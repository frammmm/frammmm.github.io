var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*
 * Third party
 */
/*!
 * jQuery JavaScript Library v2.1.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:01Z
 */

(function (global, factory) {

	if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ? factory(global, true) : function (w) {
			if (!w.document) {
				throw new Error("jQuery requires a window with a document");
			}
			return factory(w);
		};
	} else {
		factory(global);
	}

	// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//

	var arr = [];

	var _slice2 = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};

	var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,
	    version = "2.1.4",


	// Define a local copy of jQuery
	jQuery = function jQuery(selector, context) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init(selector, context);
	},


	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	    rdashAlpha = /-([\da-z])/gi,


	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function fcamelCase(all, letter) {
		return letter.toUpperCase();
	};

	jQuery.fn = jQuery.prototype = {
		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function toArray() {
			return _slice2.call(this);
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function get(num) {
			return num != null ?

			// Return just the one element from the set
			num < 0 ? this[num + this.length] : this[num] :

			// Return all the elements in a clean array
			_slice2.call(this);
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function pushStack(elems) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge(this.constructor(), elems);

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		// (You can seed the arguments with an array of args, but this is
		// only used internally.)
		each: function each(callback, args) {
			return jQuery.each(this, callback, args);
		},

		map: function map(callback) {
			return this.pushStack(jQuery.map(this, function (elem, i) {
				return callback.call(elem, i, elem);
			}));
		},

		slice: function slice() {
			return this.pushStack(_slice2.apply(this, arguments));
		},

		first: function first() {
			return this.eq(0);
		},

		last: function last() {
			return this.eq(-1);
		},

		eq: function eq(i) {
			var len = this.length,
			    j = +i + (i < 0 ? len : 0);
			return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
		},

		end: function end() {
			return this.prevObject || this.constructor(null);
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function () {
		var options,
		    name,
		    src,
		    copy,
		    copyIsArray,
		    clone,
		    target = arguments[0] || {},
		    i = 1,
		    length = arguments.length,
		    deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;

			// Skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ((typeof target === "undefined" ? "undefined" : _typeof(target)) !== "object" && !jQuery.isFunction(target)) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if (i === length) {
			target = this;
			i--;
		}

		for (; i < length; i++) {
			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];
						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = jQuery.extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function error(msg) {
			throw new Error(msg);
		},

		noop: function noop() {},

		isFunction: function isFunction(obj) {
			return jQuery.type(obj) === "function";
		},

		isArray: Array.isArray,

		isWindow: function isWindow(obj) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function isNumeric(obj) {
			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
		},

		isPlainObject: function isPlainObject(obj) {
			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
				return false;
			}

			if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
				return false;
			}

			// If the function hasn't returned already, we're confident that
			// |obj| is a plain object, created by {} or constructed with new Object
			return true;
		},

		isEmptyObject: function isEmptyObject(obj) {
			var name;
			for (name in obj) {
				return false;
			}
			return true;
		},

		type: function type(obj) {
			if (obj == null) {
				return obj + "";
			}
			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
		},

		// Evaluates a script in a global context
		globalEval: function globalEval(code) {
			var script,
			    indirect = eval;

			code = jQuery.trim(code);

			if (code) {
				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if (code.indexOf("use strict") === 1) {
					script = document.createElement("script");
					script.text = code;
					document.head.appendChild(script).parentNode.removeChild(script);
				} else {
					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval
					indirect(code);
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function camelCase(string) {
			return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
		},

		nodeName: function nodeName(elem, name) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		// args is for internal usage only
		each: function each(obj, callback, args) {
			var value,
			    i = 0,
			    length = obj.length,
			    isArray = isArraylike(obj);

			if (args) {
				if (isArray) {
					for (; i < length; i++) {
						value = callback.apply(obj[i], args);

						if (value === false) {
							break;
						}
					}
				} else {
					for (i in obj) {
						value = callback.apply(obj[i], args);

						if (value === false) {
							break;
						}
					}
				}

				// A special, fast, case for the most common use of each
			} else {
				if (isArray) {
					for (; i < length; i++) {
						value = callback.call(obj[i], i, obj[i]);

						if (value === false) {
							break;
						}
					}
				} else {
					for (i in obj) {
						value = callback.call(obj[i], i, obj[i]);

						if (value === false) {
							break;
						}
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function trim(text) {
			return text == null ? "" : (text + "").replace(rtrim, "");
		},

		// results is for internal usage only
		makeArray: function makeArray(arr, results) {
			var ret = results || [];

			if (arr != null) {
				if (isArraylike(Object(arr))) {
					jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
				} else {
					push.call(ret, arr);
				}
			}

			return ret;
		},

		inArray: function inArray(elem, arr, i) {
			return arr == null ? -1 : indexOf.call(arr, elem, i);
		},

		merge: function merge(first, second) {
			var len = +second.length,
			    j = 0,
			    i = first.length;

			for (; j < len; j++) {
				first[i++] = second[j];
			}

			first.length = i;

			return first;
		},

		grep: function grep(elems, callback, invert) {
			var callbackInverse,
			    matches = [],
			    i = 0,
			    length = elems.length,
			    callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for (; i < length; i++) {
				callbackInverse = !callback(elems[i], i);
				if (callbackInverse !== callbackExpect) {
					matches.push(elems[i]);
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function map(elems, callback, arg) {
			var value,
			    i = 0,
			    length = elems.length,
			    isArray = isArraylike(elems),
			    ret = [];

			// Go through the array, translating each of the items to their new values
			if (isArray) {
				for (; i < length; i++) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}

				// Go through every key on the object,
			} else {
				for (i in elems) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply([], ret);
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function proxy(fn, context) {
			var tmp, args, proxy;

			if (typeof context === "string") {
				tmp = fn[context];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if (!jQuery.isFunction(fn)) {
				return undefined;
			}

			// Simulated bind
			args = _slice2.call(arguments, 2);
			proxy = function proxy() {
				return fn.apply(context || this, args.concat(_slice2.call(arguments)));
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (i, name) {
		class2type["[object " + name + "]"] = name.toLowerCase();
	});

	function isArraylike(obj) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = "length" in obj && obj.length,
		    type = jQuery.type(obj);

		if (type === "function" || jQuery.isWindow(obj)) {
			return false;
		}

		if (obj.nodeType === 1 && length) {
			return true;
		}

		return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
	}
	var Sizzle =
	/*!
  * Sizzle CSS Selector Engine v2.2.0-pre
  * http://sizzlejs.com/
  *
  * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
  * Released under the MIT license
  * http://jquery.org/license
  *
  * Date: 2014-12-16
  */
	function (window) {

		var i,
		    support,
		    Expr,
		    getText,
		    isXML,
		    tokenize,
		    compile,
		    select,
		    outermostContext,
		    sortInput,
		    hasDuplicate,


		// Local document vars
		setDocument,
		    document,
		    docElem,
		    documentIsHTML,
		    rbuggyQSA,
		    rbuggyMatches,
		    matches,
		    contains,


		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		    preferredDoc = window.document,
		    dirruns = 0,
		    done = 0,
		    classCache = createCache(),
		    tokenCache = createCache(),
		    compilerCache = createCache(),
		    sortOrder = function sortOrder(a, b) {
			if (a === b) {
				hasDuplicate = true;
			}
			return 0;
		},


		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,


		// Instance methods
		hasOwn = {}.hasOwnProperty,
		    arr = [],
		    pop = arr.pop,
		    push_native = arr.push,
		    push = arr.push,
		    slice = arr.slice,

		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function indexOf(list, elem) {
			var i = 0,
			    len = list.length;
			for (; i < len; i++) {
				if (list[i] === elem) {
					return i;
				}
			}
			return -1;
		},
		    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",


		// Regular expressions

		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/css3-syntax/#characters
		characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",


		// Loosely modeled on CSS identifier characters
		// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = characterEncoding.replace("w", "w#"),


		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
		    pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" + ")\\)|)",


		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp(whitespace + "+", "g"),
		    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
		    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
		    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
		    rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
		    rpseudo = new RegExp(pseudos),
		    ridentifier = new RegExp("^" + identifier + "$"),
		    matchExpr = {
			"ID": new RegExp("^#(" + characterEncoding + ")"),
			"CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
			"TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
			"ATTR": new RegExp("^" + attributes),
			"PSEUDO": new RegExp("^" + pseudos),
			"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
			"bool": new RegExp("^(?:" + booleans + ")$", "i"),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
		},
		    rinputs = /^(?:input|select|textarea|button)$/i,
		    rheader = /^h\d$/i,
		    rnative = /^[^{]+\{\s*\[native \w/,


		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
		    rsibling = /[+~]/,
		    rescape = /'|\\/g,


		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
		    funescape = function funescape(_, escaped, escapedWhitespace) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ? escaped : high < 0 ?
			// BMP codepoint
			String.fromCharCode(high + 0x10000) :
			// Supplemental Plane codepoint (surrogate pair)
			String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
		},


		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function unloadHandler() {
			setDocument();
		};

		// Optimize for push.apply( _, NodeList )
		try {
			push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
			// Support: Android<4.0
			// Detect silently failing push.apply
			arr[preferredDoc.childNodes.length].nodeType;
		} catch (e) {
			push = { apply: arr.length ?

				// Leverage slice if possible
				function (target, els) {
					push_native.apply(target, slice.call(els));
				} :

				// Support: IE<9
				// Otherwise append directly
				function (target, els) {
					var j = target.length,
					    i = 0;
					// Can't trust NodeList.length
					while (target[j++] = els[i++]) {}
					target.length = j - 1;
				}
			};
		}

		function Sizzle(selector, context, results, seed) {
			var match, elem, m, nodeType,
			// QSA vars
			i, groups, old, nid, newContext, newSelector;

			if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
				setDocument(context);
			}

			context = context || document;
			results = results || [];
			nodeType = context.nodeType;

			if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

				return results;
			}

			if (!seed && documentIsHTML) {

				// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
				if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
					// Speed-up: Sizzle("#ID")
					if (m = match[1]) {
						if (nodeType === 9) {
							elem = context.getElementById(m);
							// Check parentNode to catch when Blackberry 4.6 returns
							// nodes that are no longer in the document (jQuery #6963)
							if (elem && elem.parentNode) {
								// Handle the case where IE, Opera, and Webkit return items
								// by name instead of ID
								if (elem.id === m) {
									results.push(elem);
									return results;
								}
							} else {
								return results;
							}
						} else {
							// Context is not a document
							if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
								results.push(elem);
								return results;
							}
						}

						// Speed-up: Sizzle("TAG")
					} else if (match[2]) {
						push.apply(results, context.getElementsByTagName(selector));
						return results;

						// Speed-up: Sizzle(".CLASS")
					} else if ((m = match[3]) && support.getElementsByClassName) {
						push.apply(results, context.getElementsByClassName(m));
						return results;
					}
				}

				// QSA path
				if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
					nid = old = expando;
					newContext = context;
					newSelector = nodeType !== 1 && selector;

					// qSA works strangely on Element-rooted queries
					// We can work around this by specifying an extra ID on the root
					// and working up from there (Thanks to Andrew Dupont for the technique)
					// IE 8 doesn't work on object elements
					if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
						groups = tokenize(selector);

						if (old = context.getAttribute("id")) {
							nid = old.replace(rescape, "\\$&");
						} else {
							context.setAttribute("id", nid);
						}
						nid = "[id='" + nid + "'] ";

						i = groups.length;
						while (i--) {
							groups[i] = nid + toSelector(groups[i]);
						}
						newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
						newSelector = groups.join(",");
					}

					if (newSelector) {
						try {
							push.apply(results, newContext.querySelectorAll(newSelector));
							return results;
						} catch (qsaError) {} finally {
							if (!old) {
								context.removeAttribute("id");
							}
						}
					}
				}
			}

			// All others
			return select(selector.replace(rtrim, "$1"), context, results, seed);
		}

		/**
   * Create key-value caches of limited size
   * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
		function createCache() {
			var keys = [];

			function cache(key, value) {
				// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
				if (keys.push(key + " ") > Expr.cacheLength) {
					// Only keep the most recent entries
					delete cache[keys.shift()];
				}
				return cache[key + " "] = value;
			}
			return cache;
		}

		/**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
		function markFunction(fn) {
			fn[expando] = true;
			return fn;
		}

		/**
   * Support testing using an element
   * @param {Function} fn Passed the created div and expects a boolean result
   */
		function assert(fn) {
			var div = document.createElement("div");

			try {
				return !!fn(div);
			} catch (e) {
				return false;
			} finally {
				// Remove from its parent by default
				if (div.parentNode) {
					div.parentNode.removeChild(div);
				}
				// release memory in IE
				div = null;
			}
		}

		/**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
		function addHandle(attrs, handler) {
			var arr = attrs.split("|"),
			    i = attrs.length;

			while (i--) {
				Expr.attrHandle[arr[i]] = handler;
			}
		}

		/**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
		function siblingCheck(a, b) {
			var cur = b && a,
			    diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);

			// Use IE sourceIndex if available on both nodes
			if (diff) {
				return diff;
			}

			// Check if b follows a
			if (cur) {
				while (cur = cur.nextSibling) {
					if (cur === b) {
						return -1;
					}
				}
			}

			return a ? 1 : -1;
		}

		/**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
		function createInputPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
		function createButtonPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return (name === "input" || name === "button") && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
		function createPositionalPseudo(fn) {
			return markFunction(function (argument) {
				argument = +argument;
				return markFunction(function (seed, matches) {
					var j,
					    matchIndexes = fn([], seed.length, argument),
					    i = matchIndexes.length;

					// Match elements found at the specified indexes
					while (i--) {
						if (seed[j = matchIndexes[i]]) {
							seed[j] = !(matches[j] = seed[j]);
						}
					}
				});
			});
		}

		/**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
		function testContext(context) {
			return context && typeof context.getElementsByTagName !== "undefined" && context;
		}

		// Expose support vars for convenience
		support = Sizzle.support = {};

		/**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
		isXML = Sizzle.isXML = function (elem) {
			// documentElement is verified for cases where it doesn't yet exist
			// (such as loading iframes in IE - #4833)
			var documentElement = elem && (elem.ownerDocument || elem).documentElement;
			return documentElement ? documentElement.nodeName !== "HTML" : false;
		};

		/**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
		setDocument = Sizzle.setDocument = function (node) {
			var hasCompare,
			    parent,
			    doc = node ? node.ownerDocument || node : preferredDoc;

			// If no document and documentElement is available, return
			if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
				return document;
			}

			// Set our document
			document = doc;
			docElem = doc.documentElement;
			parent = doc.defaultView;

			// Support: IE>8
			// If iframe document is assigned to "document" variable and if iframe has been reloaded,
			// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
			// IE6-8 do not support the defaultView property so parent will be undefined
			if (parent && parent !== parent.top) {
				// IE11 does not have attachEvent, so all must suffer
				if (parent.addEventListener) {
					parent.addEventListener("unload", unloadHandler, false);
				} else if (parent.attachEvent) {
					parent.attachEvent("onunload", unloadHandler);
				}
			}

			/* Support tests
   ---------------------------------------------------------------------- */
			documentIsHTML = !isXML(doc);

			/* Attributes
   ---------------------------------------------------------------------- */

			// Support: IE<8
			// Verify that getAttribute really returns attributes and not properties
			// (excepting IE8 booleans)
			support.attributes = assert(function (div) {
				div.className = "i";
				return !div.getAttribute("className");
			});

			/* getElement(s)By*
   ---------------------------------------------------------------------- */

			// Check if getElementsByTagName("*") returns only elements
			support.getElementsByTagName = assert(function (div) {
				div.appendChild(doc.createComment(""));
				return !div.getElementsByTagName("*").length;
			});

			// Support: IE<9
			support.getElementsByClassName = rnative.test(doc.getElementsByClassName);

			// Support: IE<10
			// Check if getElementById returns elements by name
			// The broken getElementById methods don't pick up programatically-set names,
			// so use a roundabout getElementsByName test
			support.getById = assert(function (div) {
				docElem.appendChild(div).id = expando;
				return !doc.getElementsByName || !doc.getElementsByName(expando).length;
			});

			// ID find and filter
			if (support.getById) {
				Expr.find["ID"] = function (id, context) {
					if (typeof context.getElementById !== "undefined" && documentIsHTML) {
						var m = context.getElementById(id);
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						return m && m.parentNode ? [m] : [];
					}
				};
				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						return elem.getAttribute("id") === attrId;
					};
				};
			} else {
				// Support: IE6/7
				// getElementById is not reliable as a find shortcut
				delete Expr.find["ID"];

				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
						return node && node.value === attrId;
					};
				};
			}

			// Tag
			Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
				if (typeof context.getElementsByTagName !== "undefined") {
					return context.getElementsByTagName(tag);

					// DocumentFragment nodes don't have gEBTN
				} else if (support.qsa) {
					return context.querySelectorAll(tag);
				}
			} : function (tag, context) {
				var elem,
				    tmp = [],
				    i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName(tag);

				// Filter out possible comments
				if (tag === "*") {
					while (elem = results[i++]) {
						if (elem.nodeType === 1) {
							tmp.push(elem);
						}
					}

					return tmp;
				}
				return results;
			};

			// Class
			Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
				if (documentIsHTML) {
					return context.getElementsByClassName(className);
				}
			};

			/* QSA/matchesSelector
   ---------------------------------------------------------------------- */

			// QSA and matchesSelector support

			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			rbuggyMatches = [];

			// qSa(:focus) reports false when true (Chrome 21)
			// We allow this because of a bug in IE8/9 that throws an error
			// whenever `document.activeElement` is accessed on an iframe
			// So, we allow :focus to pass through QSA all the time to avoid the IE error
			// See http://bugs.jquery.com/ticket/13378
			rbuggyQSA = [];

			if (support.qsa = rnative.test(doc.querySelectorAll)) {
				// Build QSA regex
				// Regex strategy adopted from Diego Perini
				assert(function (div) {
					// Select is set to empty string on purpose
					// This is to test IE's treatment of not explicitly
					// setting a boolean content attribute,
					// since its presence should be enough
					// http://bugs.jquery.com/ticket/12359
					docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>";

					// Support: IE8, Opera 11-12.16
					// Nothing should be selected when empty strings follow ^= or $= or *=
					// The test attribute must be unknown in Opera but "safe" for WinRT
					// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
					if (div.querySelectorAll("[msallowcapture^='']").length) {
						rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
					}

					// Support: IE8
					// Boolean attributes and "value" are not treated correctly
					if (!div.querySelectorAll("[selected]").length) {
						rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
					}

					// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
					if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
						rbuggyQSA.push("~=");
					}

					// Webkit/Opera - :checked should return selected option elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":checked").length) {
						rbuggyQSA.push(":checked");
					}

					// Support: Safari 8+, iOS 8+
					// https://bugs.webkit.org/show_bug.cgi?id=136851
					// In-page `selector#id sibing-combinator selector` fails
					if (!div.querySelectorAll("a#" + expando + "+*").length) {
						rbuggyQSA.push(".#.+[+~]");
					}
				});

				assert(function (div) {
					// Support: Windows 8 Native Apps
					// The type and name attributes are restricted during .innerHTML assignment
					var input = doc.createElement("input");
					input.setAttribute("type", "hidden");
					div.appendChild(input).setAttribute("name", "D");

					// Support: IE8
					// Enforce case-sensitivity of name attribute
					if (div.querySelectorAll("[name=d]").length) {
						rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
					}

					// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":enabled").length) {
						rbuggyQSA.push(":enabled", ":disabled");
					}

					// Opera 10-11 does not throw on post-comma invalid pseudos
					div.querySelectorAll("*,:x");
					rbuggyQSA.push(",.*:");
				});
			}

			if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {

				assert(function (div) {
					// Check to see if it's possible to do matchesSelector
					// on a disconnected node (IE 9)
					support.disconnectedMatch = matches.call(div, "div");

					// This should fail with an exception
					// Gecko does not error, returns false instead
					matches.call(div, "[s!='']:x");
					rbuggyMatches.push("!=", pseudos);
				});
			}

			rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
			rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

			/* Contains
   ---------------------------------------------------------------------- */
			hasCompare = rnative.test(docElem.compareDocumentPosition);

			// Element contains another
			// Purposefully does not implement inclusive descendent
			// As in, an element does not contain itself
			contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
				    bup = b && b.parentNode;
				return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
			} : function (a, b) {
				if (b) {
					while (b = b.parentNode) {
						if (b === a) {
							return true;
						}
					}
				}
				return false;
			};

			/* Sorting
   ---------------------------------------------------------------------- */

			// Document order sorting
			sortOrder = hasCompare ? function (a, b) {

				// Flag for duplicate removal
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				// Sort on method existence if only one input has compareDocumentPosition
				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
				if (compare) {
					return compare;
				}

				// Calculate position if both inputs belong to the same document
				compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :

				// Otherwise we know they are disconnected
				1;

				// Disconnected nodes
				if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {

					// Choose the first element that is related to our preferred document
					if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
						return -1;
					}
					if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
						return 1;
					}

					// Maintain original order
					return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
				}

				return compare & 4 ? -1 : 1;
			} : function (a, b) {
				// Exit early if the nodes are identical
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				var cur,
				    i = 0,
				    aup = a.parentNode,
				    bup = b.parentNode,
				    ap = [a],
				    bp = [b];

				// Parentless nodes are either documents or disconnected
				if (!aup || !bup) {
					return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;

					// If the nodes are siblings, we can do a quick check
				} else if (aup === bup) {
					return siblingCheck(a, b);
				}

				// Otherwise we need full lists of their ancestors for comparison
				cur = a;
				while (cur = cur.parentNode) {
					ap.unshift(cur);
				}
				cur = b;
				while (cur = cur.parentNode) {
					bp.unshift(cur);
				}

				// Walk down the tree looking for a discrepancy
				while (ap[i] === bp[i]) {
					i++;
				}

				return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck(ap[i], bp[i]) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
			};

			return doc;
		};

		Sizzle.matches = function (expr, elements) {
			return Sizzle(expr, null, null, elements);
		};

		Sizzle.matchesSelector = function (elem, expr) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			// Make sure that attribute selectors are quoted
			expr = expr.replace(rattributeQuotes, "='$1']");

			if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {

				try {
					var ret = matches.call(elem, expr);

					// IE 9's matchesSelector returns false on disconnected nodes
					if (ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11) {
						return ret;
					}
				} catch (e) {}
			}

			return Sizzle(expr, document, null, [elem]).length > 0;
		};

		Sizzle.contains = function (context, elem) {
			// Set document vars if needed
			if ((context.ownerDocument || context) !== document) {
				setDocument(context);
			}
			return contains(context, elem);
		};

		Sizzle.attr = function (elem, name) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			var fn = Expr.attrHandle[name.toLowerCase()],

			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

			return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
		};

		Sizzle.error = function (msg) {
			throw new Error("Syntax error, unrecognized expression: " + msg);
		};

		/**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
		Sizzle.uniqueSort = function (results) {
			var elem,
			    duplicates = [],
			    j = 0,
			    i = 0;

			// Unless we *know* we can detect duplicates, assume their presence
			hasDuplicate = !support.detectDuplicates;
			sortInput = !support.sortStable && results.slice(0);
			results.sort(sortOrder);

			if (hasDuplicate) {
				while (elem = results[i++]) {
					if (elem === results[i]) {
						j = duplicates.push(i);
					}
				}
				while (j--) {
					results.splice(duplicates[j], 1);
				}
			}

			// Clear input after sorting to release objects
			// See https://github.com/jquery/sizzle/pull/225
			sortInput = null;

			return results;
		};

		/**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
		getText = Sizzle.getText = function (elem) {
			var node,
			    ret = "",
			    i = 0,
			    nodeType = elem.nodeType;

			if (!nodeType) {
				// If no nodeType, this is expected to be an array
				while (node = elem[i++]) {
					// Do not traverse comment nodes
					ret += getText(node);
				}
			} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
				// Use textContent for elements
				// innerText usage removed for consistency of new lines (jQuery #11153)
				if (typeof elem.textContent === "string") {
					return elem.textContent;
				} else {
					// Traverse its children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						ret += getText(elem);
					}
				}
			} else if (nodeType === 3 || nodeType === 4) {
				return elem.nodeValue;
			}
			// Do not include comment or processing instruction nodes

			return ret;
		};

		Expr = Sizzle.selectors = {

			// Can be adjusted by the user
			cacheLength: 50,

			createPseudo: markFunction,

			match: matchExpr,

			attrHandle: {},

			find: {},

			relative: {
				">": { dir: "parentNode", first: true },
				" ": { dir: "parentNode" },
				"+": { dir: "previousSibling", first: true },
				"~": { dir: "previousSibling" }
			},

			preFilter: {
				"ATTR": function ATTR(match) {
					match[1] = match[1].replace(runescape, funescape);

					// Move the given value to match[3] whether quoted or unquoted
					match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

					if (match[2] === "~=") {
						match[3] = " " + match[3] + " ";
					}

					return match.slice(0, 4);
				},

				"CHILD": function CHILD(match) {
					/* matches from matchExpr["CHILD"]
     	1 type (only|nth|...)
     	2 what (child|of-type)
     	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
     	4 xn-component of xn+y argument ([+-]?\d*n|)
     	5 sign of xn-component
     	6 x of xn-component
     	7 sign of y-component
     	8 y of y-component
     */
					match[1] = match[1].toLowerCase();

					if (match[1].slice(0, 3) === "nth") {
						// nth-* requires argument
						if (!match[3]) {
							Sizzle.error(match[0]);
						}

						// numeric x and y parameters for Expr.filter.CHILD
						// remember that false/true cast respectively to 0/1
						match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
						match[5] = +(match[7] + match[8] || match[3] === "odd");

						// other types prohibit arguments
					} else if (match[3]) {
						Sizzle.error(match[0]);
					}

					return match;
				},

				"PSEUDO": function PSEUDO(match) {
					var excess,
					    unquoted = !match[6] && match[2];

					if (matchExpr["CHILD"].test(match[0])) {
						return null;
					}

					// Accept quoted arguments as-is
					if (match[3]) {
						match[2] = match[4] || match[5] || "";

						// Strip excess characters from unquoted arguments
					} else if (unquoted && rpseudo.test(unquoted) && (
					// Get excess from tokenize (recursively)
					excess = tokenize(unquoted, true)) && (
					// advance to the next closing parenthesis
					excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

						// excess is a negative index
						match[0] = match[0].slice(0, excess);
						match[2] = unquoted.slice(0, excess);
					}

					// Return only captures needed by the pseudo filter method (type and argument)
					return match.slice(0, 3);
				}
			},

			filter: {

				"TAG": function TAG(nodeNameSelector) {
					var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
					return nodeNameSelector === "*" ? function () {
						return true;
					} : function (elem) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
				},

				"CLASS": function CLASS(className) {
					var pattern = classCache[className + " "];

					return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
						return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
					});
				},

				"ATTR": function ATTR(name, operator, check) {
					return function (elem) {
						var result = Sizzle.attr(elem, name);

						if (result == null) {
							return operator === "!=";
						}
						if (!operator) {
							return true;
						}

						result += "";

						return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
					};
				},

				"CHILD": function CHILD(type, what, argument, first, last) {
					var simple = type.slice(0, 3) !== "nth",
					    forward = type.slice(-4) !== "last",
					    ofType = what === "of-type";

					return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function (elem) {
						return !!elem.parentNode;
					} : function (elem, context, xml) {
						var cache,
						    outerCache,
						    node,
						    diff,
						    nodeIndex,
						    start,
						    dir = simple !== forward ? "nextSibling" : "previousSibling",
						    parent = elem.parentNode,
						    name = ofType && elem.nodeName.toLowerCase(),
						    useCache = !xml && !ofType;

						if (parent) {

							// :(first|last|only)-(child|of-type)
							if (simple) {
								while (dir) {
									node = elem;
									while (node = node[dir]) {
										if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [forward ? parent.firstChild : parent.lastChild];

							// non-xml :nth-child(...) stores cache data on `parent`
							if (forward && useCache) {
								// Seek `elem` from a previously-cached index
								outerCache = parent[expando] || (parent[expando] = {});
								cache = outerCache[type] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = cache[0] === dirruns && cache[2];
								node = nodeIndex && parent.childNodes[nodeIndex];

								while (node = ++nodeIndex && node && node[dir] || (

								// Fallback to seeking `elem` from the start
								diff = nodeIndex = 0) || start.pop()) {

									// When found, cache indexes on `parent` and break
									if (node.nodeType === 1 && ++diff && node === elem) {
										outerCache[type] = [dirruns, nodeIndex, diff];
										break;
									}
								}

								// Use previously-cached element index if available
							} else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
								diff = cache[1];

								// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
							} else {
								// Use the same loop as above to seek `elem` from the start
								while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {

									if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
										// Cache the index of each encountered element
										if (useCache) {
											(node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
										}

										if (node === elem) {
											break;
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || diff % first === 0 && diff / first >= 0;
						}
					};
				},

				"PSEUDO": function PSEUDO(pseudo, argument) {
					// pseudo-class names are case-insensitive
					// http://www.w3.org/TR/selectors/#pseudo-classes
					// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
					// Remember that setFilters inherits from pseudos
					var args,
					    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

					// The user may use createPseudo to indicate that
					// arguments are needed to create the filter function
					// just as Sizzle does
					if (fn[expando]) {
						return fn(argument);
					}

					// But maintain support for old signatures
					if (fn.length > 1) {
						args = [pseudo, pseudo, "", argument];
						return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
							var idx,
							    matched = fn(seed, argument),
							    i = matched.length;
							while (i--) {
								idx = indexOf(seed, matched[i]);
								seed[idx] = !(matches[idx] = matched[i]);
							}
						}) : function (elem) {
							return fn(elem, 0, args);
						};
					}

					return fn;
				}
			},

			pseudos: {
				// Potentially complex pseudos
				"not": markFunction(function (selector) {
					// Trim the selector passed to compile
					// to avoid treating leading and trailing
					// spaces as combinators
					var input = [],
					    results = [],
					    matcher = compile(selector.replace(rtrim, "$1"));

					return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
						var elem,
						    unmatched = matcher(seed, null, xml, []),
						    i = seed.length;

						// Match elements unmatched by `matcher`
						while (i--) {
							if (elem = unmatched[i]) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) : function (elem, context, xml) {
						input[0] = elem;
						matcher(input, null, xml, results);
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
				}),

				"has": markFunction(function (selector) {
					return function (elem) {
						return Sizzle(selector, elem).length > 0;
					};
				}),

				"contains": markFunction(function (text) {
					text = text.replace(runescape, funescape);
					return function (elem) {
						return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
					};
				}),

				// "Whether an element is represented by a :lang() selector
				// is based solely on the element's language value
				// being equal to the identifier C,
				// or beginning with the identifier C immediately followed by "-".
				// The matching of C against the element's language value is performed case-insensitively.
				// The identifier C does not have to be a valid language name."
				// http://www.w3.org/TR/selectors/#lang-pseudo
				"lang": markFunction(function (lang) {
					// lang value must be a valid identifier
					if (!ridentifier.test(lang || "")) {
						Sizzle.error("unsupported lang: " + lang);
					}
					lang = lang.replace(runescape, funescape).toLowerCase();
					return function (elem) {
						var elemLang;
						do {
							if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {

								elemLang = elemLang.toLowerCase();
								return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
							}
						} while ((elem = elem.parentNode) && elem.nodeType === 1);
						return false;
					};
				}),

				// Miscellaneous
				"target": function target(elem) {
					var hash = window.location && window.location.hash;
					return hash && hash.slice(1) === elem.id;
				},

				"root": function root(elem) {
					return elem === docElem;
				},

				"focus": function focus(elem) {
					return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
				},

				// Boolean properties
				"enabled": function enabled(elem) {
					return elem.disabled === false;
				},

				"disabled": function disabled(elem) {
					return elem.disabled === true;
				},

				"checked": function checked(elem) {
					// In CSS3, :checked should return both checked and selected elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					var nodeName = elem.nodeName.toLowerCase();
					return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
				},

				"selected": function selected(elem) {
					// Accessing this property makes selected-by-default
					// options in Safari work properly
					if (elem.parentNode) {
						elem.parentNode.selectedIndex;
					}

					return elem.selected === true;
				},

				// Contents
				"empty": function empty(elem) {
					// http://www.w3.org/TR/selectors/#empty-pseudo
					// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
					//   but not by others (comment: 8; processing instruction: 7; etc.)
					// nodeType < 6 works because attributes (2) do not appear as children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						if (elem.nodeType < 6) {
							return false;
						}
					}
					return true;
				},

				"parent": function parent(elem) {
					return !Expr.pseudos["empty"](elem);
				},

				// Element/input types
				"header": function header(elem) {
					return rheader.test(elem.nodeName);
				},

				"input": function input(elem) {
					return rinputs.test(elem.nodeName);
				},

				"button": function button(elem) {
					var name = elem.nodeName.toLowerCase();
					return name === "input" && elem.type === "button" || name === "button";
				},

				"text": function text(elem) {
					var attr;
					return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					(attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
				},

				// Position-in-collection
				"first": createPositionalPseudo(function () {
					return [0];
				}),

				"last": createPositionalPseudo(function (matchIndexes, length) {
					return [length - 1];
				}),

				"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
					return [argument < 0 ? argument + length : argument];
				}),

				"even": createPositionalPseudo(function (matchIndexes, length) {
					var i = 0;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"odd": createPositionalPseudo(function (matchIndexes, length) {
					var i = 1;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; --i >= 0;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; ++i < length;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				})
			}
		};

		Expr.pseudos["nth"] = Expr.pseudos["eq"];

		// Add button/input type pseudos
		for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
			Expr.pseudos[i] = createInputPseudo(i);
		}
		for (i in { submit: true, reset: true }) {
			Expr.pseudos[i] = createButtonPseudo(i);
		}

		// Easy API for creating new setFilters
		function setFilters() {}
		setFilters.prototype = Expr.filters = Expr.pseudos;
		Expr.setFilters = new setFilters();

		tokenize = Sizzle.tokenize = function (selector, parseOnly) {
			var matched,
			    match,
			    tokens,
			    type,
			    soFar,
			    groups,
			    preFilters,
			    cached = tokenCache[selector + " "];

			if (cached) {
				return parseOnly ? 0 : cached.slice(0);
			}

			soFar = selector;
			groups = [];
			preFilters = Expr.preFilter;

			while (soFar) {

				// Comma and first run
				if (!matched || (match = rcomma.exec(soFar))) {
					if (match) {
						// Don't consume trailing commas as valid
						soFar = soFar.slice(match[0].length) || soFar;
					}
					groups.push(tokens = []);
				}

				matched = false;

				// Combinators
				if (match = rcombinators.exec(soFar)) {
					matched = match.shift();
					tokens.push({
						value: matched,
						// Cast descendant combinators to space
						type: match[0].replace(rtrim, " ")
					});
					soFar = soFar.slice(matched.length);
				}

				// Filters
				for (type in Expr.filter) {
					if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
						matched = match.shift();
						tokens.push({
							value: matched,
							type: type,
							matches: match
						});
						soFar = soFar.slice(matched.length);
					}
				}

				if (!matched) {
					break;
				}
			}

			// Return the length of the invalid excess
			// if we're just parsing
			// Otherwise, throw an error or return tokens
			return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
			// Cache the tokens
			tokenCache(selector, groups).slice(0);
		};

		function toSelector(tokens) {
			var i = 0,
			    len = tokens.length,
			    selector = "";
			for (; i < len; i++) {
				selector += tokens[i].value;
			}
			return selector;
		}

		function addCombinator(matcher, combinator, base) {
			var dir = combinator.dir,
			    checkNonElements = base && dir === "parentNode",
			    doneName = done++;

			return combinator.first ?
			// Check against closest ancestor/preceding element
			function (elem, context, xml) {
				while (elem = elem[dir]) {
					if (elem.nodeType === 1 || checkNonElements) {
						return matcher(elem, context, xml);
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function (elem, context, xml) {
				var oldCache,
				    outerCache,
				    newCache = [dirruns, doneName];

				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
				if (xml) {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							if (matcher(elem, context, xml)) {
								return true;
							}
						}
					}
				} else {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							outerCache = elem[expando] || (elem[expando] = {});
							if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {

								// Assign to newCache so results back-propagate to previous elements
								return newCache[2] = oldCache[2];
							} else {
								// Reuse newcache so results back-propagate to previous elements
								outerCache[dir] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if (newCache[2] = matcher(elem, context, xml)) {
									return true;
								}
							}
						}
					}
				}
			};
		}

		function elementMatcher(matchers) {
			return matchers.length > 1 ? function (elem, context, xml) {
				var i = matchers.length;
				while (i--) {
					if (!matchers[i](elem, context, xml)) {
						return false;
					}
				}
				return true;
			} : matchers[0];
		}

		function multipleContexts(selector, contexts, results) {
			var i = 0,
			    len = contexts.length;
			for (; i < len; i++) {
				Sizzle(selector, contexts[i], results);
			}
			return results;
		}

		function condense(unmatched, map, filter, context, xml) {
			var elem,
			    newUnmatched = [],
			    i = 0,
			    len = unmatched.length,
			    mapped = map != null;

			for (; i < len; i++) {
				if (elem = unmatched[i]) {
					if (!filter || filter(elem, context, xml)) {
						newUnmatched.push(elem);
						if (mapped) {
							map.push(i);
						}
					}
				}
			}

			return newUnmatched;
		}

		function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
			if (postFilter && !postFilter[expando]) {
				postFilter = setMatcher(postFilter);
			}
			if (postFinder && !postFinder[expando]) {
				postFinder = setMatcher(postFinder, postSelector);
			}
			return markFunction(function (seed, results, context, xml) {
				var temp,
				    i,
				    elem,
				    preMap = [],
				    postMap = [],
				    preexisting = results.length,


				// Get initial elements from seed or context
				elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),


				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
				    matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || (seed ? preFilter : preexisting || postFilter) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results : matcherIn;

				// Find primary matches
				if (matcher) {
					matcher(matcherIn, matcherOut, context, xml);
				}

				// Apply postFilter
				if (postFilter) {
					temp = condense(matcherOut, postMap);
					postFilter(temp, [], context, xml);

					// Un-match failing elements by moving them back to matcherIn
					i = temp.length;
					while (i--) {
						if (elem = temp[i]) {
							matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
						}
					}
				}

				if (seed) {
					if (postFinder || preFilter) {
						if (postFinder) {
							// Get the final matcherOut by condensing this intermediate into postFinder contexts
							temp = [];
							i = matcherOut.length;
							while (i--) {
								if (elem = matcherOut[i]) {
									// Restore matcherIn since elem is not yet a final match
									temp.push(matcherIn[i] = elem);
								}
							}
							postFinder(null, matcherOut = [], temp, xml);
						}

						// Move matched elements from seed to results to keep them synchronized
						i = matcherOut.length;
						while (i--) {
							if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

								seed[temp] = !(results[temp] = elem);
							}
						}
					}

					// Add elements to results, through postFinder if defined
				} else {
					matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
					if (postFinder) {
						postFinder(null, results, matcherOut, xml);
					} else {
						push.apply(results, matcherOut);
					}
				}
			});
		}

		function matcherFromTokens(tokens) {
			var checkContext,
			    matcher,
			    j,
			    len = tokens.length,
			    leadingRelative = Expr.relative[tokens[0].type],
			    implicitRelative = leadingRelative || Expr.relative[" "],
			    i = leadingRelative ? 1 : 0,


			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator(function (elem) {
				return elem === checkContext;
			}, implicitRelative, true),
			    matchAnyContext = addCombinator(function (elem) {
				return indexOf(checkContext, elem) > -1;
			}, implicitRelative, true),
			    matchers = [function (elem, context, xml) {
				var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			}];

			for (; i < len; i++) {
				if (matcher = Expr.relative[tokens[i].type]) {
					matchers = [addCombinator(elementMatcher(matchers), matcher)];
				} else {
					matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

					// Return special upon seeing a positional matcher
					if (matcher[expando]) {
						// Find the next relative operator (if any) for proper handling
						j = ++i;
						for (; j < len; j++) {
							if (Expr.relative[tokens[j].type]) {
								break;
							}
						}
						return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
					}
					matchers.push(matcher);
				}
			}

			return elementMatcher(matchers);
		}

		function matcherFromGroupMatchers(elementMatchers, setMatchers) {
			var bySet = setMatchers.length > 0,
			    byElement = elementMatchers.length > 0,
			    superMatcher = function superMatcher(seed, context, xml, results, outermost) {
				var elem,
				    j,
				    matcher,
				    matchedCount = 0,
				    i = "0",
				    unmatched = seed && [],
				    setMatched = [],
				    contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]("*", outermost),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
				    len = elems.length;

				if (outermost) {
					outermostContext = context !== document && context;
				}

				// Add elements passing elementMatchers directly to results
				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for (; i !== len && (elem = elems[i]) != null; i++) {
					if (byElement && elem) {
						j = 0;
						while (matcher = elementMatchers[j++]) {
							if (matcher(elem, context, xml)) {
								results.push(elem);
								break;
							}
						}
						if (outermost) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if (bySet) {
						// They will have gone through all possible matchers
						if (elem = !matcher && elem) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if (seed) {
							unmatched.push(elem);
						}
					}
				}

				// Apply set filters to unmatched elements
				matchedCount += i;
				if (bySet && i !== matchedCount) {
					j = 0;
					while (matcher = setMatchers[j++]) {
						matcher(unmatched, setMatched, context, xml);
					}

					if (seed) {
						// Reintegrate element matches to eliminate the need for sorting
						if (matchedCount > 0) {
							while (i--) {
								if (!(unmatched[i] || setMatched[i])) {
									setMatched[i] = pop.call(results);
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense(setMatched);
					}

					// Add matches to results
					push.apply(results, setMatched);

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {

						Sizzle.uniqueSort(results);
					}
				}

				// Override manipulation of globals by nested matchers
				if (outermost) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

			return bySet ? markFunction(superMatcher) : superMatcher;
		}

		compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
			var i,
			    setMatchers = [],
			    elementMatchers = [],
			    cached = compilerCache[selector + " "];

			if (!cached) {
				// Generate a function of recursive functions that can be used to check each element
				if (!match) {
					match = tokenize(selector);
				}
				i = match.length;
				while (i--) {
					cached = matcherFromTokens(match[i]);
					if (cached[expando]) {
						setMatchers.push(cached);
					} else {
						elementMatchers.push(cached);
					}
				}

				// Cache the compiled function
				cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

				// Save selector and tokenization
				cached.selector = selector;
			}
			return cached;
		};

		/**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
		select = Sizzle.select = function (selector, context, results, seed) {
			var i,
			    tokens,
			    token,
			    type,
			    find,
			    compiled = typeof selector === "function" && selector,
			    match = !seed && tokenize(selector = compiled.selector || selector);

			results = results || [];

			// Try to minimize operations if there is no seed and only one group
			if (match.length === 1) {

				// Take a shortcut and set the context if the root selector is an ID
				tokens = match[0] = match[0].slice(0);
				if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

					context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
					if (!context) {
						return results;

						// Precompiled matchers will still verify ancestry, so step up a level
					} else if (compiled) {
						context = context.parentNode;
					}

					selector = selector.slice(tokens.shift().value.length);
				}

				// Fetch a seed set for right-to-left matching
				i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
				while (i--) {
					token = tokens[i];

					// Abort if we hit a combinator
					if (Expr.relative[type = token.type]) {
						break;
					}
					if (find = Expr.find[type]) {
						// Search, expanding context for leading sibling combinators
						if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {

							// If seed is empty or no tokens remain, we can return early
							tokens.splice(i, 1);
							selector = seed.length && toSelector(tokens);
							if (!selector) {
								push.apply(results, seed);
								return results;
							}

							break;
						}
					}
				}
			}

			// Compile and execute a filtering function if one is not provided
			// Provide `match` to avoid retokenization if we modified the selector above
			(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
			return results;
		};

		// One-time assignments

		// Sort stability
		support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

		// Support: Chrome 14-35+
		// Always assume duplicates if they aren't passed to the comparison function
		support.detectDuplicates = !!hasDuplicate;

		// Initialize against the default document
		setDocument();

		// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
		// Detached nodes confoundingly follow *each other*
		support.sortDetached = assert(function (div1) {
			// Should return 1, but returns 4 (following)
			return div1.compareDocumentPosition(document.createElement("div")) & 1;
		});

		// Support: IE<8
		// Prevent attribute/property "interpolation"
		// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
		if (!assert(function (div) {
			div.innerHTML = "<a href='#'></a>";
			return div.firstChild.getAttribute("href") === "#";
		})) {
			addHandle("type|href|height|width", function (elem, name, isXML) {
				if (!isXML) {
					return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
				}
			});
		}

		// Support: IE<9
		// Use defaultValue in place of getAttribute("value")
		if (!support.attributes || !assert(function (div) {
			div.innerHTML = "<input/>";
			div.firstChild.setAttribute("value", "");
			return div.firstChild.getAttribute("value") === "";
		})) {
			addHandle("value", function (elem, name, isXML) {
				if (!isXML && elem.nodeName.toLowerCase() === "input") {
					return elem.defaultValue;
				}
			});
		}

		// Support: IE<9
		// Use getAttributeNode to fetch booleans when getAttribute lies
		if (!assert(function (div) {
			return div.getAttribute("disabled") == null;
		})) {
			addHandle(booleans, function (elem, name, isXML) {
				var val;
				if (!isXML) {
					return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
				}
			});
		}

		return Sizzle;
	}(window);

	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;

	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;

	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow(elements, qualifier, not) {
		if (jQuery.isFunction(qualifier)) {
			return jQuery.grep(elements, function (elem, i) {
				/* jshint -W018 */
				return !!qualifier.call(elem, i, elem) !== not;
			});
		}

		if (qualifier.nodeType) {
			return jQuery.grep(elements, function (elem) {
				return elem === qualifier !== not;
			});
		}

		if (typeof qualifier === "string") {
			if (risSimple.test(qualifier)) {
				return jQuery.filter(qualifier, elements, not);
			}

			qualifier = jQuery.filter(qualifier, elements);
		}

		return jQuery.grep(elements, function (elem) {
			return indexOf.call(qualifier, elem) >= 0 !== not;
		});
	}

	jQuery.filter = function (expr, elems, not) {
		var elem = elems[0];

		if (not) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
			return elem.nodeType === 1;
		}));
	};

	jQuery.fn.extend({
		find: function find(selector) {
			var i,
			    len = this.length,
			    ret = [],
			    self = this;

			if (typeof selector !== "string") {
				return this.pushStack(jQuery(selector).filter(function () {
					for (i = 0; i < len; i++) {
						if (jQuery.contains(self[i], this)) {
							return true;
						}
					}
				}));
			}

			for (i = 0; i < len; i++) {
				jQuery.find(selector, self[i], ret);
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function filter(selector) {
			return this.pushStack(winnow(this, selector || [], false));
		},
		not: function not(selector) {
			return this.pushStack(winnow(this, selector || [], true));
		},
		is: function is(selector) {
			return !!winnow(this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
		}
	});

	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,


	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	    init = jQuery.fn.init = function (selector, context) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if (!selector) {
			return this;
		}

		// Handle HTML strings
		if (typeof selector === "string") {
			if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [null, selector, null];
			} else {
				match = rquickExpr.exec(selector);
			}

			// Match html or make sure no context is specified for #id
			if (match && (match[1] || !context)) {

				// HANDLE: $(html) -> $(array)
				if (match[1]) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

					// HANDLE: $(html, props)
					if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
						for (match in context) {
							// Properties of context are called as methods if possible
							if (jQuery.isFunction(this[match])) {
								this[match](context[match]);

								// ...and otherwise set as attributes
							} else {
								this.attr(match, context[match]);
							}
						}
					}

					return this;

					// HANDLE: $(#id)
				} else {
					elem = document.getElementById(match[2]);

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if (elem && elem.parentNode) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

				// HANDLE: $(expr, $(...))
			} else if (!context || context.jquery) {
				return (context || rootjQuery).find(selector);

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor(context).find(selector);
			}

			// HANDLE: $(DOMElement)
		} else if (selector.nodeType) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

			// HANDLE: $(function)
			// Shortcut for document ready
		} else if (jQuery.isFunction(selector)) {
			return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) :
			// Execute immediately if ready is not present
			selector(jQuery);
		}

		if (selector.selector !== undefined) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray(selector, this);
	};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery(document);

	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

	jQuery.extend({
		dir: function dir(elem, _dir, until) {
			var matched = [],
			    truncate = until !== undefined;

			while ((elem = elem[_dir]) && elem.nodeType !== 9) {
				if (elem.nodeType === 1) {
					if (truncate && jQuery(elem).is(until)) {
						break;
					}
					matched.push(elem);
				}
			}
			return matched;
		},

		sibling: function sibling(n, elem) {
			var matched = [];

			for (; n; n = n.nextSibling) {
				if (n.nodeType === 1 && n !== elem) {
					matched.push(n);
				}
			}

			return matched;
		}
	});

	jQuery.fn.extend({
		has: function has(target) {
			var targets = jQuery(target, this),
			    l = targets.length;

			return this.filter(function () {
				var i = 0;
				for (; i < l; i++) {
					if (jQuery.contains(this, targets[i])) {
						return true;
					}
				}
			});
		},

		closest: function closest(selectors, context) {
			var cur,
			    i = 0,
			    l = this.length,
			    matched = [],
			    pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

			for (; i < l; i++) {
				for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
					// Always skip document fragments
					if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {

						matched.push(cur);
						break;
					}
				}
			}

			return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
		},

		// Determine the position of an element within the set
		index: function index(elem) {

			// No argument, return index in parent
			if (!elem) {
				return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if (typeof elem === "string") {
				return indexOf.call(jQuery(elem), this[0]);
			}

			// Locate the position of the desired element
			return indexOf.call(this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem);
		},

		add: function add(selector, context) {
			return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
		},

		addBack: function addBack(selector) {
			return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
		}
	});

	function sibling(cur, dir) {
		while ((cur = cur[dir]) && cur.nodeType !== 1) {}
		return cur;
	}

	jQuery.each({
		parent: function parent(elem) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function parents(elem) {
			return jQuery.dir(elem, "parentNode");
		},
		parentsUntil: function parentsUntil(elem, i, until) {
			return jQuery.dir(elem, "parentNode", until);
		},
		next: function next(elem) {
			return sibling(elem, "nextSibling");
		},
		prev: function prev(elem) {
			return sibling(elem, "previousSibling");
		},
		nextAll: function nextAll(elem) {
			return jQuery.dir(elem, "nextSibling");
		},
		prevAll: function prevAll(elem) {
			return jQuery.dir(elem, "previousSibling");
		},
		nextUntil: function nextUntil(elem, i, until) {
			return jQuery.dir(elem, "nextSibling", until);
		},
		prevUntil: function prevUntil(elem, i, until) {
			return jQuery.dir(elem, "previousSibling", until);
		},
		siblings: function siblings(elem) {
			return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
		},
		children: function children(elem) {
			return jQuery.sibling(elem.firstChild);
		},
		contents: function contents(elem) {
			return elem.contentDocument || jQuery.merge([], elem.childNodes);
		}
	}, function (name, fn) {
		jQuery.fn[name] = function (until, selector) {
			var matched = jQuery.map(this, fn, until);

			if (name.slice(-5) !== "Until") {
				selector = until;
			}

			if (selector && typeof selector === "string") {
				matched = jQuery.filter(selector, matched);
			}

			if (this.length > 1) {
				// Remove duplicates
				if (!guaranteedUnique[name]) {
					jQuery.unique(matched);
				}

				// Reverse order for parents* and prev-derivatives
				if (rparentsprev.test(name)) {
					matched.reverse();
				}
			}

			return this.pushStack(matched);
		};
	});
	var rnotwhite = /\S+/g;

	// String to Object options format cache
	var optionsCache = {};

	// Convert String-formatted options into Object-formatted ones and store in cache
	function createOptions(options) {
		var object = optionsCache[options] = {};
		jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
			object[flag] = true;
		});
		return object;
	}

	/*
  * Create a callback list using the following parameters:
  *
  *	options: an optional list of space-separated options that will change how
  *			the callback list behaves or a more traditional option object
  *
  * By default a callback list will act like an event callback list and can be
  * "fired" multiple times.
  *
  * Possible options:
  *
  *	once:			will ensure the callback list can only be fired once (like a Deferred)
  *
  *	memory:			will keep track of previous values and will call any callback added
  *					after the list has been fired right away with the latest "memorized"
  *					values (like a Deferred)
  *
  *	unique:			will ensure a callback can only be added once (no duplicate in the list)
  *
  *	stopOnFalse:	interrupt callings when a callback returns false
  *
  */
	jQuery.Callbacks = function (options) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);

		var // Last fire value (for non-forgettable lists)
		memory,

		// Flag to know if list was already fired
		_fired,

		// Flag to know if list is currently firing
		firing,

		// First callback to fire (used internally by add and fireWith)
		firingStart,

		// End of the loop when firing
		firingLength,

		// Index of currently firing callback (modified by remove if needed)
		firingIndex,

		// Actual callback list
		list = [],

		// Stack of fire calls for repeatable lists
		stack = !options.once && [],

		// Fire callbacks
		fire = function fire(data) {
			memory = options.memory && data;
			_fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for (; list && firingIndex < firingLength; firingIndex++) {
				if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if (list) {
				if (stack) {
					if (stack.length) {
						fire(stack.shift());
					}
				} else if (memory) {
					list = [];
				} else {
					self.disable();
				}
			}
		},

		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function add() {
				if (list) {
					// First, we save the current length
					var start = list.length;
					(function add(args) {
						jQuery.each(args, function (_, arg) {
							var type = jQuery.type(arg);
							if (type === "function") {
								if (!options.unique || !self.has(arg)) {
									list.push(arg);
								}
							} else if (arg && arg.length && type !== "string") {
								// Inspect recursively
								add(arg);
							}
						});
					})(arguments);
					// Do we need to add the callbacks to the
					// current firing batch?
					if (firing) {
						firingLength = list.length;
						// With memory, if we're not firing then
						// we should call right away
					} else if (memory) {
						firingStart = start;
						fire(memory);
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function remove() {
				if (list) {
					jQuery.each(arguments, function (_, arg) {
						var index;
						while ((index = jQuery.inArray(arg, list, index)) > -1) {
							list.splice(index, 1);
							// Handle firing indexes
							if (firing) {
								if (index <= firingLength) {
									firingLength--;
								}
								if (index <= firingIndex) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function has(fn) {
				return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
			},
			// Remove all callbacks from the list
			empty: function empty() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function disable() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function disabled() {
				return !list;
			},
			// Lock the list in its current state
			lock: function lock() {
				stack = undefined;
				if (!memory) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function locked() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function fireWith(context, args) {
				if (list && (!_fired || stack)) {
					args = args || [];
					args = [context, args.slice ? args.slice() : args];
					if (firing) {
						stack.push(args);
					} else {
						fire(args);
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function fire() {
				self.fireWith(this, arguments);
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function fired() {
				return !!_fired;
			}
		};

		return self;
	};

	jQuery.extend({

		Deferred: function Deferred(func) {
			var tuples = [
			// action, add listener, listener list, final state
			["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
			    _state2 = "pending",
			    _promise = {
				state: function state() {
					return _state2;
				},
				always: function always() {
					deferred.done(arguments).fail(arguments);
					return this;
				},
				then: function then() /* fnDone, fnFail, fnProgress */{
					var fns = arguments;
					return jQuery.Deferred(function (newDefer) {
						jQuery.each(tuples, function (i, tuple) {
							var fn = jQuery.isFunction(fns[i]) && fns[i];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[tuple[1]](function () {
								var returned = fn && fn.apply(this, arguments);
								if (returned && jQuery.isFunction(returned.promise)) {
									returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
								} else {
									newDefer[tuple[0] + "With"](this === _promise ? newDefer.promise() : this, fn ? [returned] : arguments);
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function promise(obj) {
					return obj != null ? jQuery.extend(obj, _promise) : _promise;
				}
			},
			    deferred = {};

			// Keep pipe for back-compat
			_promise.pipe = _promise.then;

			// Add list-specific methods
			jQuery.each(tuples, function (i, tuple) {
				var list = tuple[2],
				    stateString = tuple[3];

				// promise[ done | fail | progress ] = list.add
				_promise[tuple[1]] = list.add;

				// Handle state
				if (stateString) {
					list.add(function () {
						// state = [ resolved | rejected ]
						_state2 = stateString;

						// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
				}

				// deferred[ resolve | reject | notify ]
				deferred[tuple[0]] = function () {
					deferred[tuple[0] + "With"](this === deferred ? _promise : this, arguments);
					return this;
				};
				deferred[tuple[0] + "With"] = list.fireWith;
			});

			// Make the deferred a promise
			_promise.promise(deferred);

			// Call given func if any
			if (func) {
				func.call(deferred, deferred);
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function when(subordinate /* , ..., subordinateN */) {
			var i = 0,
			    resolveValues = _slice2.call(arguments),
			    length = resolveValues.length,


			// the count of uncompleted subordinates
			remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,


			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),


			// Update function for both resolve and progress values
			updateFunc = function updateFunc(i, contexts, values) {
				return function (value) {
					contexts[i] = this;
					values[i] = arguments.length > 1 ? _slice2.call(arguments) : value;
					if (values === progressValues) {
						deferred.notifyWith(contexts, values);
					} else if (! --remaining) {
						deferred.resolveWith(contexts, values);
					}
				};
			},
			    progressValues,
			    progressContexts,
			    resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if (length > 1) {
				progressValues = new Array(length);
				progressContexts = new Array(length);
				resolveContexts = new Array(length);
				for (; i < length; i++) {
					if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
						resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if (!remaining) {
				deferred.resolveWith(resolveContexts, resolveValues);
			}

			return deferred.promise();
		}
	});

	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function (fn) {
		// Add the callback
		jQuery.ready.promise().done(fn);

		return this;
	};

	jQuery.extend({
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function holdReady(hold) {
			if (hold) {
				jQuery.readyWait++;
			} else {
				jQuery.ready(true);
			}
		},

		// Handle when the DOM is ready
		ready: function ready(wait) {

			// Abort if there are pending holds or we're already ready
			if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if (wait !== true && --jQuery.readyWait > 0) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith(document, [jQuery]);

			// Trigger any bound ready events
			if (jQuery.fn.triggerHandler) {
				jQuery(document).triggerHandler("ready");
				jQuery(document).off("ready");
			}
		}
	});

	/**
  * The ready event handler and self cleanup method
  */
	function completed() {
		document.removeEventListener("DOMContentLoaded", completed, false);
		window.removeEventListener("load", completed, false);
		jQuery.ready();
	}

	jQuery.ready.promise = function (obj) {
		if (!readyList) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called after the browser event has already occurred.
			// We once tried to use readyState "interactive" here, but it caused issues like the one
			// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
			if (document.readyState === "complete") {
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				setTimeout(jQuery.ready);
			} else {

				// Use the handy event callback
				document.addEventListener("DOMContentLoaded", completed, false);

				// A fallback to window.onload, that will always work
				window.addEventListener("load", completed, false);
			}
		}
		return readyList.promise(obj);
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
		var i = 0,
		    len = elems.length,
		    bulk = key == null;

		// Sets many values
		if (jQuery.type(key) === "object") {
			chainable = true;
			for (i in key) {
				jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
			}

			// Sets one value
		} else if (value !== undefined) {
			chainable = true;

			if (!jQuery.isFunction(value)) {
				raw = true;
			}

			if (bulk) {
				// Bulk operations run against the entire set
				if (raw) {
					fn.call(elems, value);
					fn = null;

					// ...except when executing function values
				} else {
					bulk = fn;
					fn = function fn(elem, key, value) {
						return bulk.call(jQuery(elem), value);
					};
				}
			}

			if (fn) {
				for (; i < len; i++) {
					fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
				}
			}
		}

		return chainable ? elems :

		// Gets
		bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
	};

	/**
  * Determines whether an object can have data
  */
	jQuery.acceptData = function (owner) {
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
	};

	function Data() {
		// Support: Android<4,
		// Old WebKit does not have Object.preventExtensions/freeze method,
		// return new empty object instead with no [[set]] accessor
		Object.defineProperty(this.cache = {}, 0, {
			get: function get() {
				return {};
			}
		});

		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;
	Data.accepts = jQuery.acceptData;

	Data.prototype = {
		key: function key(owner) {
			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return the key for a frozen object.
			if (!Data.accepts(owner)) {
				return 0;
			}

			var descriptor = {},

			// Check if the owner object already has a cache key
			unlock = owner[this.expando];

			// If not, create one
			if (!unlock) {
				unlock = Data.uid++;

				// Secure it in a non-enumerable, non-writable property
				try {
					descriptor[this.expando] = { value: unlock };
					Object.defineProperties(owner, descriptor);

					// Support: Android<4
					// Fallback to a less secure definition
				} catch (e) {
					descriptor[this.expando] = unlock;
					jQuery.extend(owner, descriptor);
				}
			}

			// Ensure the cache object
			if (!this.cache[unlock]) {
				this.cache[unlock] = {};
			}

			return unlock;
		},
		set: function set(owner, data, value) {
			var prop,

			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key(owner),
			    cache = this.cache[unlock];

			// Handle: [ owner, key, value ] args
			if (typeof data === "string") {
				cache[data] = value;

				// Handle: [ owner, { properties } ] args
			} else {
				// Fresh assignments by object are shallow copied
				if (jQuery.isEmptyObject(cache)) {
					jQuery.extend(this.cache[unlock], data);
					// Otherwise, copy the properties one-by-one to the cache object
				} else {
					for (prop in data) {
						cache[prop] = data[prop];
					}
				}
			}
			return cache;
		},
		get: function get(owner, key) {
			// Either a valid cache is found, or will be created.
			// New caches will be created and the unlock returned,
			// allowing direct access to the newly created
			// empty data object. A valid owner object must be provided.
			var cache = this.cache[this.key(owner)];

			return key === undefined ? cache : cache[key];
		},
		access: function access(owner, key, value) {
			var stored;
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if (key === undefined || key && typeof key === "string" && value === undefined) {

				stored = this.get(owner, key);

				return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
			}

			// [*]When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set(owner, key, value);

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function remove(owner, key) {
			var i,
			    name,
			    camel,
			    unlock = this.key(owner),
			    cache = this.cache[unlock];

			if (key === undefined) {
				this.cache[unlock] = {};
			} else {
				// Support array or space separated string of keys
				if (jQuery.isArray(key)) {
					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat(key.map(jQuery.camelCase));
				} else {
					camel = jQuery.camelCase(key);
					// Try the string as a key before any manipulation
					if (key in cache) {
						name = [key, camel];
					} else {
						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ? [name] : name.match(rnotwhite) || [];
					}
				}

				i = name.length;
				while (i--) {
					delete cache[name[i]];
				}
			}
		},
		hasData: function hasData(owner) {
			return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
		},
		discard: function discard(owner) {
			if (owner[this.expando]) {
				delete this.cache[owner[this.expando]];
			}
		}
	};
	var data_priv = new Data();

	var data_user = new Data();

	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	    rmultiDash = /([A-Z])/g;

	function dataAttr(elem, key, data) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if (data === undefined && elem.nodeType === 1) {
			name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
			data = elem.getAttribute(name);

			if (typeof data === "string") {
				try {
					data = data === "true" ? true : data === "false" ? false : data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
				} catch (e) {}

				// Make sure we set the data so it isn't changed later
				data_user.set(elem, key, data);
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend({
		hasData: function hasData(elem) {
			return data_user.hasData(elem) || data_priv.hasData(elem);
		},

		data: function data(elem, name, _data) {
			return data_user.access(elem, name, _data);
		},

		removeData: function removeData(elem, name) {
			data_user.remove(elem, name);
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to data_priv methods, these can be deprecated.
		_data: function _data(elem, name, data) {
			return data_priv.access(elem, name, data);
		},

		_removeData: function _removeData(elem, name) {
			data_priv.remove(elem, name);
		}
	});

	jQuery.fn.extend({
		data: function data(key, value) {
			var i,
			    name,
			    data,
			    elem = this[0],
			    attrs = elem && elem.attributes;

			// Gets all values
			if (key === undefined) {
				if (this.length) {
					data = data_user.get(elem);

					if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
						i = attrs.length;
						while (i--) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if (attrs[i]) {
								name = attrs[i].name;
								if (name.indexOf("data-") === 0) {
									name = jQuery.camelCase(name.slice(5));
									dataAttr(elem, name, data[name]);
								}
							}
						}
						data_priv.set(elem, "hasDataAttrs", true);
					}
				}

				return data;
			}

			// Sets multiple values
			if ((typeof key === "undefined" ? "undefined" : _typeof(key)) === "object") {
				return this.each(function () {
					data_user.set(this, key);
				});
			}

			return access(this, function (value) {
				var data,
				    camelKey = jQuery.camelCase(key);

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if (elem && value === undefined) {
					// Attempt to get data from the cache
					// with the key as-is
					data = data_user.get(elem, key);
					if (data !== undefined) {
						return data;
					}

					// Attempt to get data from the cache
					// with the key camelized
					data = data_user.get(elem, camelKey);
					if (data !== undefined) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr(elem, camelKey, undefined);
					if (data !== undefined) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each(function () {
					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = data_user.get(this, camelKey);

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					data_user.set(this, camelKey, value);

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if (key.indexOf("-") !== -1 && data !== undefined) {
						data_user.set(this, key, value);
					}
				});
			}, null, value, arguments.length > 1, null, true);
		},

		removeData: function removeData(key) {
			return this.each(function () {
				data_user.remove(this, key);
			});
		}
	});

	jQuery.extend({
		queue: function queue(elem, type, data) {
			var queue;

			if (elem) {
				type = (type || "fx") + "queue";
				queue = data_priv.get(elem, type);

				// Speed up dequeue by getting out quickly if this is just a lookup
				if (data) {
					if (!queue || jQuery.isArray(data)) {
						queue = data_priv.access(elem, type, jQuery.makeArray(data));
					} else {
						queue.push(data);
					}
				}
				return queue || [];
			}
		},

		dequeue: function dequeue(elem, type) {
			type = type || "fx";

			var queue = jQuery.queue(elem, type),
			    startLength = queue.length,
			    fn = queue.shift(),
			    hooks = jQuery._queueHooks(elem, type),
			    next = function next() {
				jQuery.dequeue(elem, type);
			};

			// If the fx queue is dequeued, always remove the progress sentinel
			if (fn === "inprogress") {
				fn = queue.shift();
				startLength--;
			}

			if (fn) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if (type === "fx") {
					queue.unshift("inprogress");
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call(elem, next, hooks);
			}

			if (!startLength && hooks) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function _queueHooks(elem, type) {
			var key = type + "queueHooks";
			return data_priv.get(elem, key) || data_priv.access(elem, key, {
				empty: jQuery.Callbacks("once memory").add(function () {
					data_priv.remove(elem, [type + "queue", key]);
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function queue(type, data) {
			var setter = 2;

			if (typeof type !== "string") {
				data = type;
				type = "fx";
				setter--;
			}

			if (arguments.length < setter) {
				return jQuery.queue(this[0], type);
			}

			return data === undefined ? this : this.each(function () {
				var queue = jQuery.queue(this, type, data);

				// Ensure a hooks for this queue
				jQuery._queueHooks(this, type);

				if (type === "fx" && queue[0] !== "inprogress") {
					jQuery.dequeue(this, type);
				}
			});
		},
		dequeue: function dequeue(type) {
			return this.each(function () {
				jQuery.dequeue(this, type);
			});
		},
		clearQueue: function clearQueue(type) {
			return this.queue(type || "fx", []);
		},
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function promise(type, obj) {
			var tmp,
			    count = 1,
			    defer = jQuery.Deferred(),
			    elements = this,
			    i = this.length,
			    resolve = function resolve() {
				if (! --count) {
					defer.resolveWith(elements, [elements]);
				}
			};

			if (typeof type !== "string") {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while (i--) {
				tmp = data_priv.get(elements[i], type + "queueHooks");
				if (tmp && tmp.empty) {
					count++;
					tmp.empty.add(resolve);
				}
			}
			resolve();
			return defer.promise(obj);
		}
	});
	var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

	var cssExpand = ["Top", "Right", "Bottom", "Left"];

	var isHidden = function isHidden(elem, el) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
	};

	var rcheckableType = /^(?:checkbox|radio)$/i;

	(function () {
		var fragment = document.createDocumentFragment(),
		    div = fragment.appendChild(document.createElement("div")),
		    input = document.createElement("input");

		// Support: Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute("type", "radio");
		input.setAttribute("checked", "checked");
		input.setAttribute("name", "t");

		div.appendChild(input);

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
	})();
	var strundefined = typeof undefined === "undefined" ? "undefined" : _typeof(undefined);

	support.focusinBubbles = "onfocusin" in window;

	var rkeyEvent = /^key/,
	    rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	    rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch (err) {}
	}

	/*
  * Helper functions for managing events -- not part of the public interface.
  * Props to Dean Edwards' addEvent library for many of the ideas.
  */
	jQuery.event = {

		global: {},

		add: function add(elem, types, handler, data, selector) {

			var handleObjIn,
			    eventHandle,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = data_priv.get(elem);

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if (!elemData) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if (handler.handler) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if (!handler.guid) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if (!(events = elemData.events)) {
				events = elemData.events = {};
			}
			if (!(eventHandle = elemData.handle)) {
				eventHandle = elemData.handle = function (e) {
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return (typeof jQuery === "undefined" ? "undefined" : _typeof(jQuery)) !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// There *must* be a type, no attaching namespace-only handlers
				if (!type) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[type] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = (selector ? special.delegateType : special.bindType) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[type] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test(selector),
					namespace: namespaces.join(".")
				}, handleObjIn);

				// Init the event handler queue if we're the first
				if (!(handlers = events[type])) {
					handlers = events[type] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
						if (elem.addEventListener) {
							elem.addEventListener(type, eventHandle, false);
						}
					}
				}

				if (special.add) {
					special.add.call(elem, handleObj);

					if (!handleObj.handler.guid) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if (selector) {
					handlers.splice(handlers.delegateCount++, 0, handleObj);
				} else {
					handlers.push(handleObj);
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[type] = true;
			}
		},

		// Detach an event or set of events from an element
		remove: function remove(elem, types, handler, selector, mappedTypes) {

			var j,
			    origCount,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = data_priv.hasData(elem) && data_priv.get(elem);

			if (!elemData || !(events = elemData.events)) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// Unbind all events (on this namespace, if provided) for the element
				if (!type) {
					for (type in events) {
						jQuery.event.remove(elem, type + types[t], handler, selector, true);
					}
					continue;
				}

				special = jQuery.event.special[type] || {};
				type = (selector ? special.delegateType : special.bindType) || type;
				handlers = events[type] || [];
				tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

				// Remove matching events
				origCount = j = handlers.length;
				while (j--) {
					handleObj = handlers[j];

					if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
						handlers.splice(j, 1);

						if (handleObj.selector) {
							handlers.delegateCount--;
						}
						if (special.remove) {
							special.remove.call(elem, handleObj);
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if (origCount && !handlers.length) {
					if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
						jQuery.removeEvent(elem, type, elemData.handle);
					}

					delete events[type];
				}
			}

			// Remove the expando if it's no longer used
			if (jQuery.isEmptyObject(events)) {
				delete elemData.handle;
				data_priv.remove(elem, "events");
			}
		},

		trigger: function trigger(event, data, elem, onlyHandlers) {

			var i,
			    cur,
			    tmp,
			    bubbleType,
			    ontype,
			    handle,
			    special,
			    eventPath = [elem || document],
			    type = hasOwn.call(event, "type") ? event.type : event,
			    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if (elem.nodeType === 3 || elem.nodeType === 8) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if (rfocusMorph.test(type + jQuery.event.triggered)) {
				return;
			}

			if (type.indexOf(".") >= 0) {
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === "undefined" ? "undefined" : _typeof(event)) === "object" && event);

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if (!event.target) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ? [event] : jQuery.makeArray(data, [event]);

			// Allow special events to draw outside the lines
			special = jQuery.event.special[type] || {};
			if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

				bubbleType = special.delegateType || type;
				if (!rfocusMorph.test(bubbleType + type)) {
					cur = cur.parentNode;
				}
				for (; cur; cur = cur.parentNode) {
					eventPath.push(cur);
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if (tmp === (elem.ownerDocument || document)) {
					eventPath.push(tmp.defaultView || tmp.parentWindow || window);
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

				event.type = i > 1 ? bubbleType : special.bindType || type;

				// jQuery handler
				handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
				if (handle) {
					handle.apply(cur, data);
				}

				// Native handler
				handle = ontype && cur[ontype];
				if (handle && handle.apply && jQuery.acceptData(cur)) {
					event.result = handle.apply(cur, data);
					if (event.result === false) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if (!onlyHandlers && !event.isDefaultPrevented()) {

				if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ontype];

						if (tmp) {
							elem[ontype] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[type]();
						jQuery.event.triggered = undefined;

						if (tmp) {
							elem[ontype] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		dispatch: function dispatch(event) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix(event);

			var i,
			    j,
			    ret,
			    matched,
			    handleObj,
			    handlerQueue = [],
			    args = _slice2.call(arguments),
			    handlers = (data_priv.get(this, "events") || {})[event.type] || [],
			    special = jQuery.event.special[event.type] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if (special.preDispatch && special.preDispatch.call(this, event) === false) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call(this, event, handlers);

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
				event.currentTarget = matched.elem;

				j = 0;
				while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

						if (ret !== undefined) {
							if ((event.result = ret) === false) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if (special.postDispatch) {
				special.postDispatch.call(this, event);
			}

			return event.result;
		},

		handlers: function handlers(event, _handlers2) {
			var i,
			    matches,
			    sel,
			    handleObj,
			    handlerQueue = [],
			    delegateCount = _handlers2.delegateCount,
			    cur = event.target;

			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			// Avoid non-left-click bubbling in Firefox (#3861)
			if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {

				for (; cur !== this; cur = cur.parentNode || this) {

					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if (cur.disabled !== true || event.type !== "click") {
						matches = [];
						for (i = 0; i < delegateCount; i++) {
							handleObj = _handlers2[i];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if (matches[sel] === undefined) {
								matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
							}
							if (matches[sel]) {
								matches.push(handleObj);
							}
						}
						if (matches.length) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if (delegateCount < _handlers2.length) {
				handlerQueue.push({ elem: this, handlers: _handlers2.slice(delegateCount) });
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function filter(event, original) {

				// Add which for key events
				if (event.which == null) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
			filter: function filter(event, original) {
				var eventDoc,
				    doc,
				    body,
				    button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if (event.pageX == null && original.clientX != null) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
					event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if (!event.which && button !== undefined) {
					event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
				}

				return event;
			}
		},

		fix: function fix(event) {
			if (event[jQuery.expando]) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i,
			    prop,
			    copy,
			    type = event.type,
			    originalEvent = event,
			    fixHook = this.fixHooks[type];

			if (!fixHook) {
				this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
			}
			copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

			event = new jQuery.Event(originalEvent);

			i = copy.length;
			while (i--) {
				prop = copy[i];
				event[prop] = originalEvent[prop];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if (!event.target) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if (event.target.nodeType === 3) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
		},

		special: {
			load: {
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function trigger() {
					if (this !== safeActiveElement() && this.focus) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function trigger() {
					if (this === safeActiveElement() && this.blur) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
				// For checkbox, fire native event so checked state will be right
				trigger: function trigger() {
					if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function _default(event) {
					return jQuery.nodeName(event.target, "a");
				}
			},

			beforeunload: {
				postDispatch: function postDispatch(event) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if (event.result !== undefined && event.originalEvent) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		},

		simulate: function simulate(type, elem, event, bubble) {
			// Piggyback on a donor event to simulate a different one.
			// Fake originalEvent to avoid donor's stopPropagation, but if the
			// simulated event prevents default then we do the same on the donor.
			var e = jQuery.extend(new jQuery.Event(), event, {
				type: type,
				isSimulated: true,
				originalEvent: {}
			});
			if (bubble) {
				jQuery.event.trigger(e, null, elem);
			} else {
				jQuery.event.dispatch.call(elem, e);
			}
			if (e.isDefaultPrevented()) {
				event.preventDefault();
			}
		}
	};

	jQuery.removeEvent = function (elem, type, handle) {
		if (elem.removeEventListener) {
			elem.removeEventListener(type, handle, false);
		}
	};

	jQuery.Event = function (src, props) {
		// Allow instantiation without the 'new' keyword
		if (!(this instanceof jQuery.Event)) {
			return new jQuery.Event(src, props);
		}

		// Event object
		if (src && src.type) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&
			// Support: Android<4.0
			src.returnValue === false ? returnTrue : returnFalse;

			// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if (props) {
			jQuery.extend(this, props);
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[jQuery.expando] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,

		preventDefault: function preventDefault() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if (e && e.preventDefault) {
				e.preventDefault();
			}
		},
		stopPropagation: function stopPropagation() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if (e && e.stopPropagation) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function stopImmediatePropagation() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if (e && e.stopImmediatePropagation) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// Support: Chrome 15+
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function (orig, fix) {
		jQuery.event.special[orig] = {
			delegateType: fix,
			bindType: fix,

			handle: function handle(event) {
				var ret,
				    target = this,
				    related = event.relatedTarget,
				    handleObj = event.handleObj;

				// For mousenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if (!related || related !== target && !jQuery.contains(target, related)) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply(this, arguments);
					event.type = fix;
				}
				return ret;
			}
		};
	});

	// Support: Firefox, Chrome, Safari
	// Create "bubbling" focus and blur events
	if (!support.focusinBubbles) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function handler(event) {
				jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
			};

			jQuery.event.special[fix] = {
				setup: function setup() {
					var doc = this.ownerDocument || this,
					    attaches = data_priv.access(doc, fix);

					if (!attaches) {
						doc.addEventListener(orig, handler, true);
					}
					data_priv.access(doc, fix, (attaches || 0) + 1);
				},
				teardown: function teardown() {
					var doc = this.ownerDocument || this,
					    attaches = data_priv.access(doc, fix) - 1;

					if (!attaches) {
						doc.removeEventListener(orig, handler, true);
						data_priv.remove(doc, fix);
					} else {
						data_priv.access(doc, fix, attaches);
					}
				}
			};
		});
	}

	jQuery.fn.extend({

		on: function on(types, selector, data, fn, /*INTERNAL*/one) {
			var origFn, type;

			// Types can be a map of types/handlers
			if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {
				// ( types-Object, selector, data )
				if (typeof selector !== "string") {
					// ( types-Object, data )
					data = data || selector;
					selector = undefined;
				}
				for (type in types) {
					this.on(type, selector, data, types[type], one);
				}
				return this;
			}

			if (data == null && fn == null) {
				// ( types, fn )
				fn = selector;
				data = selector = undefined;
			} else if (fn == null) {
				if (typeof selector === "string") {
					// ( types, selector, fn )
					fn = data;
					data = undefined;
				} else {
					// ( types, data, fn )
					fn = data;
					data = selector;
					selector = undefined;
				}
			}
			if (fn === false) {
				fn = returnFalse;
			} else if (!fn) {
				return this;
			}

			if (one === 1) {
				origFn = fn;
				fn = function fn(event) {
					// Can use an empty set, since event contains the info
					jQuery().off(event);
					return origFn.apply(this, arguments);
				};
				// Use same guid so caller can remove using origFn
				fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
			}
			return this.each(function () {
				jQuery.event.add(this, types, fn, data, selector);
			});
		},
		one: function one(types, selector, data, fn) {
			return this.on(types, selector, data, fn, 1);
		},
		off: function off(types, selector, fn) {
			var handleObj, type;
			if (types && types.preventDefault && types.handleObj) {
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
				return this;
			}
			if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {
				// ( types-object [, selector] )
				for (type in types) {
					this.off(type, selector, types[type]);
				}
				return this;
			}
			if (selector === false || typeof selector === "function") {
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if (fn === false) {
				fn = returnFalse;
			}
			return this.each(function () {
				jQuery.event.remove(this, types, fn, selector);
			});
		},

		trigger: function trigger(type, data) {
			return this.each(function () {
				jQuery.event.trigger(type, data, this);
			});
		},
		triggerHandler: function triggerHandler(type, data) {
			var elem = this[0];
			if (elem) {
				return jQuery.event.trigger(type, data, elem, true);
			}
		}
	});

	var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	    rtagName = /<([\w:]+)/,
	    rhtml = /<|&#?\w+;/,
	    rnoInnerhtml = /<(?:script|style|link)/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	    rscriptType = /^$|\/(?:java|ecma)script/i,
	    rscriptTypeMasked = /^true\/(.*)/,
	    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,


	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [1, "<select multiple='multiple'>", "</select>"],

		thead: [1, "<table>", "</table>"],
		col: [2, "<table><colgroup>", "</colgroup></table>"],
		tr: [2, "<table><tbody>", "</tbody></table>"],
		td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

		_default: [0, "", ""]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	// Support: 1.x compatibility
	// Manipulating tables requires a tbody
	function manipulationTarget(elem, content) {
		return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript(elem) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript(elem) {
		var match = rscriptTypeMasked.exec(elem.type);

		if (match) {
			elem.type = match[1];
		} else {
			elem.removeAttribute("type");
		}

		return elem;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval(elems, refElements) {
		var i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
		}
	}

	function cloneCopyEvent(src, dest) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if (dest.nodeType !== 1) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if (data_priv.hasData(src)) {
			pdataOld = data_priv.access(src);
			pdataCur = data_priv.set(dest, pdataOld);
			events = pdataOld.events;

			if (events) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for (type in events) {
					for (i = 0, l = events[type].length; i < l; i++) {
						jQuery.event.add(dest, type, events[type][i]);
					}
				}
			}
		}

		// 2. Copy user data
		if (data_user.hasData(src)) {
			udataOld = data_user.access(src);
			udataCur = jQuery.extend({}, udataOld);

			data_user.set(dest, udataCur);
		}
	}

	function getAll(context, tag) {
		var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];

		return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
	}

	// Fix IE bugs, see support tests
	function fixInput(src, dest) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if (nodeName === "input" && rcheckableType.test(src.type)) {
			dest.checked = src.checked;

			// Fails to return the selected option to the default selected state when cloning options
		} else if (nodeName === "input" || nodeName === "textarea") {
			dest.defaultValue = src.defaultValue;
		}
	}

	jQuery.extend({
		clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
			var i,
			    l,
			    srcElements,
			    destElements,
			    clone = elem.cloneNode(true),
			    inPage = jQuery.contains(elem.ownerDocument, elem);

			// Fix IE cloning issues
			if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll(clone);
				srcElements = getAll(elem);

				for (i = 0, l = srcElements.length; i < l; i++) {
					fixInput(srcElements[i], destElements[i]);
				}
			}

			// Copy the events from the original to the clone
			if (dataAndEvents) {
				if (deepDataAndEvents) {
					srcElements = srcElements || getAll(elem);
					destElements = destElements || getAll(clone);

					for (i = 0, l = srcElements.length; i < l; i++) {
						cloneCopyEvent(srcElements[i], destElements[i]);
					}
				} else {
					cloneCopyEvent(elem, clone);
				}
			}

			// Preserve script evaluation history
			destElements = getAll(clone, "script");
			if (destElements.length > 0) {
				setGlobalEval(destElements, !inPage && getAll(elem, "script"));
			}

			// Return the cloned set
			return clone;
		},

		buildFragment: function buildFragment(elems, context, scripts, selection) {
			var elem,
			    tmp,
			    tag,
			    wrap,
			    contains,
			    j,
			    fragment = context.createDocumentFragment(),
			    nodes = [],
			    i = 0,
			    l = elems.length;

			for (; i < l; i++) {
				elem = elems[i];

				if (elem || elem === 0) {

					// Add nodes directly
					if (jQuery.type(elem) === "object") {
						// Support: QtWebKit, PhantomJS
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

						// Convert non-html into a text node
					} else if (!rhtml.test(elem)) {
						nodes.push(context.createTextNode(elem));

						// Convert html into DOM nodes
					} else {
						tmp = tmp || fragment.appendChild(context.createElement("div"));

						// Deserialize a standard representation
						tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
						wrap = wrapMap[tag] || wrapMap._default;
						tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];

						// Descend through wrappers to the right content
						j = wrap[0];
						while (j--) {
							tmp = tmp.lastChild;
						}

						// Support: QtWebKit, PhantomJS
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge(nodes, tmp.childNodes);

						// Remember the top-level container
						tmp = fragment.firstChild;

						// Ensure the created nodes are orphaned (#12392)
						tmp.textContent = "";
					}
				}
			}

			// Remove wrapper from fragment
			fragment.textContent = "";

			i = 0;
			while (elem = nodes[i++]) {

				// #4087 - If origin and destination elements are the same, and this is
				// that element, do not do anything
				if (selection && jQuery.inArray(elem, selection) !== -1) {
					continue;
				}

				contains = jQuery.contains(elem.ownerDocument, elem);

				// Append to fragment
				tmp = getAll(fragment.appendChild(elem), "script");

				// Preserve script evaluation history
				if (contains) {
					setGlobalEval(tmp);
				}

				// Capture executables
				if (scripts) {
					j = 0;
					while (elem = tmp[j++]) {
						if (rscriptType.test(elem.type || "")) {
							scripts.push(elem);
						}
					}
				}
			}

			return fragment;
		},

		cleanData: function cleanData(elems) {
			var data,
			    elem,
			    type,
			    key,
			    special = jQuery.event.special,
			    i = 0;

			for (; (elem = elems[i]) !== undefined; i++) {
				if (jQuery.acceptData(elem)) {
					key = elem[data_priv.expando];

					if (key && (data = data_priv.cache[key])) {
						if (data.events) {
							for (type in data.events) {
								if (special[type]) {
									jQuery.event.remove(elem, type);

									// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent(elem, type, data.handle);
								}
							}
						}
						if (data_priv.cache[key]) {
							// Discard any remaining `private` data
							delete data_priv.cache[key];
						}
					}
				}
				// Discard any remaining `user` data
				delete data_user.cache[elem[data_user.expando]];
			}
		}
	});

	jQuery.fn.extend({
		text: function text(value) {
			return access(this, function (value) {
				return value === undefined ? jQuery.text(this) : this.empty().each(function () {
					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						this.textContent = value;
					}
				});
			}, null, value, arguments.length);
		},

		append: function append() {
			return this.domManip(arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.appendChild(elem);
				}
			});
		},

		prepend: function prepend() {
			return this.domManip(arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.insertBefore(elem, target.firstChild);
				}
			});
		},

		before: function before() {
			return this.domManip(arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this);
				}
			});
		},

		after: function after() {
			return this.domManip(arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this.nextSibling);
				}
			});
		},

		remove: function remove(selector, keepData /* Internal Use Only */) {
			var elem,
			    elems = selector ? jQuery.filter(selector, this) : this,
			    i = 0;

			for (; (elem = elems[i]) != null; i++) {
				if (!keepData && elem.nodeType === 1) {
					jQuery.cleanData(getAll(elem));
				}

				if (elem.parentNode) {
					if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
						setGlobalEval(getAll(elem, "script"));
					}
					elem.parentNode.removeChild(elem);
				}
			}

			return this;
		},

		empty: function empty() {
			var elem,
			    i = 0;

			for (; (elem = this[i]) != null; i++) {
				if (elem.nodeType === 1) {

					// Prevent memory leaks
					jQuery.cleanData(getAll(elem, false));

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function clone(dataAndEvents, deepDataAndEvents) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map(function () {
				return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
			});
		},

		html: function html(value) {
			return access(this, function (value) {
				var elem = this[0] || {},
				    i = 0,
				    l = this.length;

				if (value === undefined && elem.nodeType === 1) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

					value = value.replace(rxhtmlTag, "<$1></$2>");

					try {
						for (; i < l; i++) {
							elem = this[i] || {};

							// Remove element nodes and prevent memory leaks
							if (elem.nodeType === 1) {
								jQuery.cleanData(getAll(elem, false));
								elem.innerHTML = value;
							}
						}

						elem = 0;

						// If using innerHTML throws an exception, use the fallback method
					} catch (e) {}
				}

				if (elem) {
					this.empty().append(value);
				}
			}, null, value, arguments.length);
		},

		replaceWith: function replaceWith() {
			var arg = arguments[0];

			// Make the changes, replacing each context element with the new content
			this.domManip(arguments, function (elem) {
				arg = this.parentNode;

				jQuery.cleanData(getAll(this));

				if (arg) {
					arg.replaceChild(elem, this);
				}
			});

			// Force removal if there was no new content (e.g., from empty arguments)
			return arg && (arg.length || arg.nodeType) ? this : this.remove();
		},

		detach: function detach(selector) {
			return this.remove(selector, true);
		},

		domManip: function domManip(args, callback) {

			// Flatten any nested arrays
			args = concat.apply([], args);

			var fragment,
			    first,
			    scripts,
			    hasScripts,
			    node,
			    doc,
			    i = 0,
			    l = this.length,
			    set = this,
			    iNoClone = l - 1,
			    value = args[0],
			    isFunction = jQuery.isFunction(value);

			// We can't cloneNode fragments that contain checked, in WebKit
			if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
				return this.each(function (index) {
					var self = set.eq(index);
					if (isFunction) {
						args[0] = value.call(this, index, self.html());
					}
					self.domManip(args, callback);
				});
			}

			if (l) {
				fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
				first = fragment.firstChild;

				if (fragment.childNodes.length === 1) {
					fragment = first;
				}

				if (first) {
					scripts = jQuery.map(getAll(fragment, "script"), disableScript);
					hasScripts = scripts.length;

					// Use the original fragment for the last item instead of the first because it can end up
					// being emptied incorrectly in certain situations (#8070).
					for (; i < l; i++) {
						node = fragment;

						if (i !== iNoClone) {
							node = jQuery.clone(node, true, true);

							// Keep references to cloned scripts for later restoration
							if (hasScripts) {
								// Support: QtWebKit
								// jQuery.merge because push.apply(_, arraylike) throws
								jQuery.merge(scripts, getAll(node, "script"));
							}
						}

						callback.call(this[i], node, i);
					}

					if (hasScripts) {
						doc = scripts[scripts.length - 1].ownerDocument;

						// Reenable scripts
						jQuery.map(scripts, restoreScript);

						// Evaluate executable scripts on first document insertion
						for (i = 0; i < hasScripts; i++) {
							node = scripts[i];
							if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {

								if (node.src) {
									// Optional AJAX dependency, but won't run scripts if not present
									if (jQuery._evalUrl) {
										jQuery._evalUrl(node.src);
									}
								} else {
									jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
								}
							}
						}
					}
				}
			}

			return this;
		}
	});

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function (name, original) {
		jQuery.fn[name] = function (selector) {
			var elems,
			    ret = [],
			    insert = jQuery(selector),
			    last = insert.length - 1,
			    i = 0;

			for (; i <= last; i++) {
				elems = i === last ? this : this.clone(true);
				jQuery(insert[i])[original](elems);

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply(ret, elems.get());
			}

			return this.pushStack(ret);
		};
	});

	var iframe,
	    elemdisplay = {};

	/**
  * Retrieve the actual display of a element
  * @param {String} name nodeName of the element
  * @param {Object} doc Document object
  */
	// Called only from within defaultDisplay
	function actualDisplay(name, doc) {
		var style,
		    elem = jQuery(doc.createElement(name)).appendTo(doc.body),


		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ?

		// Use of this method is a temporary fix (more like optimization) until something better comes along,
		// since it was removed from specification and supported only in FF
		style.display : jQuery.css(elem[0], "display");

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
  * Try to determine the default display value of an element
  * @param {String} nodeName
  */
	function defaultDisplay(nodeName) {
		var doc = document,
		    display = elemdisplay[nodeName];

		if (!display) {
			display = actualDisplay(nodeName, doc);

			// If the simple way fails, read from inside an iframe
			if (display === "none" || !display) {

				// Use the already-created iframe if possible
				iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[0].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay(nodeName, doc);
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[nodeName] = display;
		}

		return display;
	}
	var rmargin = /^margin/;

	var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

	var getStyles = function getStyles(elem) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if (elem.ownerDocument.defaultView.opener) {
			return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
		}

		return window.getComputedStyle(elem, null);
	};

	function curCSS(elem, name, computed) {
		var width,
		    minWidth,
		    maxWidth,
		    ret,
		    style = elem.style;

		computed = computed || getStyles(elem);

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if (computed) {
			ret = computed.getPropertyValue(name) || computed[name];
		}

		if (computed) {

			if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
				ret = jQuery.style(elem, name);
			}

			// Support: iOS < 6
			// A tribute to the "awesome hack by Dean Edwards"
			// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if (rnumnonpx.test(ret) && rmargin.test(name)) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" : ret;
	}

	function addGetHookIf(conditionFn, hookFn) {
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function get() {
				if (conditionFn()) {
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply(this, arguments);
			}
		};
	}

	(function () {
		var pixelPositionVal,
		    boxSizingReliableVal,
		    docElem = document.documentElement,
		    container = document.createElement("div"),
		    div = document.createElement("div");

		if (!div.style) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode(true).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
		container.appendChild(div);

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computePixelPositionAndBoxSizingReliable() {
			div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
			div.innerHTML = "";
			docElem.appendChild(container);

			var divStyle = window.getComputedStyle(div, null);
			pixelPositionVal = divStyle.top !== "1%";
			boxSizingReliableVal = divStyle.width === "4px";

			docElem.removeChild(container);
		}

		// Support: node.js jsdom
		// Don't assume that getComputedStyle is a property of the global object
		if (window.getComputedStyle) {
			jQuery.extend(support, {
				pixelPosition: function pixelPosition() {

					// This test is executed only once but we still do memoizing
					// since we can use the boxSizingReliable pre-computing.
					// No need to check if the test was already performed, though.
					computePixelPositionAndBoxSizingReliable();
					return pixelPositionVal;
				},
				boxSizingReliable: function boxSizingReliable() {
					if (boxSizingReliableVal == null) {
						computePixelPositionAndBoxSizingReliable();
					}
					return boxSizingReliableVal;
				},
				reliableMarginRight: function reliableMarginRight() {

					// Support: Android 2.3
					// Check if div with explicit width and no margin-right incorrectly
					// gets computed margin-right based on width of container. (#3333)
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
					// This support function is only executed once so no memoizing is needed.
					var ret,
					    marginDiv = div.appendChild(document.createElement("div"));

					// Reset CSS: box-sizing; display; margin; border; padding
					marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
					marginDiv.style.marginRight = marginDiv.style.width = "0";
					div.style.width = "1px";
					docElem.appendChild(container);

					ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);

					docElem.removeChild(container);
					div.removeChild(marginDiv);

					return ret;
				}
			});
		}
	})();

	// A method for quickly swapping in/out CSS properties to get correct calculations.
	jQuery.swap = function (elem, options, callback, args) {
		var ret,
		    name,
		    old = {};

		// Remember the old values, and insert the new ones
		for (name in options) {
			old[name] = elem.style[name];
			elem.style[name] = options[name];
		}

		ret = callback.apply(elem, args || []);

		// Revert the old values
		for (name in options) {
			elem.style[name] = old[name];
		}

		return ret;
	};

	var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	    rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
	    rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
	    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	    cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},
	    cssPrefixes = ["Webkit", "O", "Moz", "ms"];

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName(style, name) {

		// Shortcut for names that are not vendor prefixed
		if (name in style) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
		    origName = name,
		    i = cssPrefixes.length;

		while (i--) {
			name = cssPrefixes[i] + capName;
			if (name in style) {
				return name;
			}
		}

		return origName;
	}

	function setPositiveNumber(elem, value, subtract) {
		var matches = rnumsplit.exec(value);
		return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
	}

	function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
		var i = extra === (isBorderBox ? "border" : "content") ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,
		    val = 0;

		for (; i < 4; i += 2) {
			// Both box models exclude margin, so add it if we want it
			if (extra === "margin") {
				val += jQuery.css(elem, extra + cssExpand[i], true, styles);
			}

			if (isBorderBox) {
				// border-box includes padding, so remove it if we want content
				if (extra === "content") {
					val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
				}

				// At this point, extra isn't border nor margin, so remove border
				if (extra !== "margin") {
					val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			} else {
				// At this point, extra isn't content, so add padding
				val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

				// At this point, extra isn't content nor padding, so add border
				if (extra !== "padding") {
					val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			}
		}

		return val;
	}

	function getWidthOrHeight(elem, name, extra) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
		    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		    styles = getStyles(elem),
		    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if (val <= 0 || val == null) {
			// Fall back to computed then uncomputed css if necessary
			val = curCSS(elem, name, styles);
			if (val < 0 || val == null) {
				val = elem.style[name];
			}

			// Computed unit is not pixels. Stop here and return.
			if (rnumnonpx.test(val)) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

			// Normalize "", auto, and prepare for extra
			val = parseFloat(val) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
	}

	function showHide(elements, show) {
		var display,
		    elem,
		    hidden,
		    values = [],
		    index = 0,
		    length = elements.length;

		for (; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}

			values[index] = data_priv.get(elem, "olddisplay");
			display = elem.style.display;
			if (show) {
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if (!values[index] && display === "none") {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if (elem.style.display === "" && isHidden(elem)) {
					values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
				}
			} else {
				hidden = isHidden(elem);

				if (display !== "none" || !hidden) {
					data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for (index = 0; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}
			if (!show || elem.style.display === "none" || elem.style.display === "") {
				elem.style.display = show ? values[index] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend({

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function get(elem, computed) {
					if (computed) {

						// We should always get a number back from opacity
						var ret = curCSS(elem, "opacity");
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function style(elem, name, value, extra) {

			// Don't set styles on text and comment nodes
			if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
				return;
			}

			// Make sure that we're working with the right name
			var ret,
			    type,
			    hooks,
			    origName = jQuery.camelCase(name),
			    style = elem.style;

			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// Check if we're setting a value
			if (value !== undefined) {
				type = typeof value === "undefined" ? "undefined" : _typeof(value);

				// Convert "+=" or "-=" to relative numbers (#7345)
				if (type === "string" && (ret = rrelNum.exec(value))) {
					value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if (value == null || value !== value) {
					return;
				}

				// If a number, add 'px' to the (except for certain CSS properties)
				if (type === "number" && !jQuery.cssNumber[origName]) {
					value += "px";
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
					style[name] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
					style[name] = value;
				}
			} else {
				// If a hook was provided get the non-computed value from there
				if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
					return ret;
				}

				// Otherwise just get the value from the style object
				return style[name];
			}
		},

		css: function css(elem, name, extra, styles) {
			var val,
			    num,
			    hooks,
			    origName = jQuery.camelCase(name);

			// Make sure that we're working with the right name
			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// If a hook was provided get the computed value from there
			if (hooks && "get" in hooks) {
				val = hooks.get(elem, true, extra);
			}

			// Otherwise, if a way to get the computed value exists, use that
			if (val === undefined) {
				val = curCSS(elem, name, styles);
			}

			// Convert "normal" to computed value
			if (val === "normal" && name in cssNormalTransform) {
				val = cssNormalTransform[name];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if (extra === "" || extra) {
				num = parseFloat(val);
				return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
			}
			return val;
		}
	});

	jQuery.each(["height", "width"], function (i, name) {
		jQuery.cssHooks[name] = {
			get: function get(elem, computed, extra) {
				if (computed) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function () {
						return getWidthOrHeight(elem, name, extra);
					}) : getWidthOrHeight(elem, name, extra);
				}
			},

			set: function set(elem, value, extra) {
				var styles = extra && getStyles(elem);
				return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
			}
		};
	});

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
		if (computed) {
			return jQuery.swap(elem, { "display": "inline-block" }, curCSS, [elem, "marginRight"]);
		}
	});

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function (prefix, suffix) {
		jQuery.cssHooks[prefix + suffix] = {
			expand: function expand(value) {
				var i = 0,
				    expanded = {},


				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [value];

				for (; i < 4; i++) {
					expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
				}

				return expanded;
			}
		};

		if (!rmargin.test(prefix)) {
			jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
		}
	});

	jQuery.fn.extend({
		css: function css(name, value) {
			return access(this, function (elem, name, value) {
				var styles,
				    len,
				    map = {},
				    i = 0;

				if (jQuery.isArray(name)) {
					styles = getStyles(elem);
					len = name.length;

					for (; i < len; i++) {
						map[name[i]] = jQuery.css(elem, name[i], false, styles);
					}

					return map;
				}

				return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
			}, name, value, arguments.length > 1);
		},
		show: function show() {
			return showHide(this, true);
		},
		hide: function hide() {
			return showHide(this);
		},
		toggle: function toggle(state) {
			if (typeof state === "boolean") {
				return state ? this.show() : this.hide();
			}

			return this.each(function () {
				if (isHidden(this)) {
					jQuery(this).show();
				} else {
					jQuery(this).hide();
				}
			});
		}
	});

	function Tween(elem, options, prop, end, easing) {
		return new Tween.prototype.init(elem, options, prop, end, easing);
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function init(elem, options, prop, end, easing, unit) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || "swing";
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
		},
		cur: function cur() {
			var hooks = Tween.propHooks[this.prop];

			return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
		},
		run: function run(percent) {
			var eased,
			    hooks = Tween.propHooks[this.prop];

			if (this.options.duration) {
				this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
			} else {
				this.pos = eased = percent;
			}
			this.now = (this.end - this.start) * eased + this.start;

			if (this.options.step) {
				this.options.step.call(this.elem, this.now, this);
			}

			if (hooks && hooks.set) {
				hooks.set(this);
			} else {
				Tween.propHooks._default.set(this);
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function get(tween) {
				var result;

				if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
					return tween.elem[tween.prop];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css(tween.elem, tween.prop, "");
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function set(tween) {
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if (jQuery.fx.step[tween.prop]) {
					jQuery.fx.step[tween.prop](tween);
				} else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
					jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
				} else {
					tween.elem[tween.prop] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function set(tween) {
			if (tween.elem.nodeType && tween.elem.parentNode) {
				tween.elem[tween.prop] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function linear(p) {
			return p;
		},
		swing: function swing(p) {
			return 0.5 - Math.cos(p * Math.PI) / 2;
		}
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};

	var fxNow,
	    timerId,
	    rfxtypes = /^(?:toggle|show|hide)$/,
	    rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
	    rrun = /queueHooks$/,
	    animationPrefilters = [defaultPrefilter],
	    tweeners = {
		"*": [function (prop, value) {
			var tween = this.createTween(prop, value),
			    target = tween.cur(),
			    parts = rfxnum.exec(value),
			    unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),


			// Starting value computation is required for potential unit mismatches
			start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
			    scale = 1,
			    maxIterations = 20;

			if (start && start[3] !== unit) {
				// Trust units reported by jQuery.css
				unit = unit || start[3];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style(tween.elem, prop, start + unit);

					// Update scale, tolerating zero or NaN from tween.cur(),
					// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
			}

			// Update tween properties
			if (parts) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
			}

			return tween;
		}]
	};

	// Animations created synchronously will run synchronously
	function createFxNow() {
		setTimeout(function () {
			fxNow = undefined;
		});
		return fxNow = jQuery.now();
	}

	// Generate parameters to create a standard animation
	function genFx(type, includeWidth) {
		var which,
		    i = 0,
		    attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for (; i < 4; i += 2 - includeWidth) {
			which = cssExpand[i];
			attrs["margin" + which] = attrs["padding" + which] = type;
		}

		if (includeWidth) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween(value, prop, animation) {
		var tween,
		    collection = (tweeners[prop] || []).concat(tweeners["*"]),
		    index = 0,
		    length = collection.length;
		for (; index < length; index++) {
			if (tween = collection[index].call(animation, prop, value)) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter(elem, props, opts) {
		/* jshint validthis: true */
		var prop,
		    value,
		    toggle,
		    tween,
		    hooks,
		    oldfire,
		    display,
		    checkDisplay,
		    anim = this,
		    orig = {},
		    style = elem.style,
		    hidden = elem.nodeType && isHidden(elem),
		    dataShow = data_priv.get(elem, "fxshow");

		// Handle queue: false promises
		if (!opts.queue) {
			hooks = jQuery._queueHooks(elem, "fx");
			if (hooks.unqueued == null) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function () {
					if (!hooks.unqueued) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function () {
				// Ensure the complete handler is called before this completes
				anim.always(function () {
					hooks.unqueued--;
					if (!jQuery.queue(elem, "fx").length) {
						hooks.empty.fire();
					}
				});
			});
		}

		// Height/width overflow pass
		if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [style.overflow, style.overflowX, style.overflowY];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css(elem, "display");

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

			if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
				style.display = "inline-block";
			}
		}

		if (opts.overflow) {
			style.overflow = "hidden";
			anim.always(function () {
				style.overflow = opts.overflow[0];
				style.overflowX = opts.overflow[1];
				style.overflowY = opts.overflow[2];
			});
		}

		// show/hide pass
		for (prop in props) {
			value = props[prop];
			if (rfxtypes.exec(value)) {
				delete props[prop];
				toggle = toggle || value === "toggle";
				if (value === (hidden ? "hide" : "show")) {

					// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
					if (value === "show" && dataShow && dataShow[prop] !== undefined) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

				// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if (!jQuery.isEmptyObject(orig)) {
			if (dataShow) {
				if ("hidden" in dataShow) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = data_priv.access(elem, "fxshow", {});
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if (toggle) {
				dataShow.hidden = !hidden;
			}
			if (hidden) {
				jQuery(elem).show();
			} else {
				anim.done(function () {
					jQuery(elem).hide();
				});
			}
			anim.done(function () {
				var prop;

				data_priv.remove(elem, "fxshow");
				for (prop in orig) {
					jQuery.style(elem, prop, orig[prop]);
				}
			});
			for (prop in orig) {
				tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

				if (!(prop in dataShow)) {
					dataShow[prop] = tween.start;
					if (hidden) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

			// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
			style.display = display;
		}
	}

	function propFilter(props, specialEasing) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for (index in props) {
			name = jQuery.camelCase(index);
			easing = specialEasing[name];
			value = props[index];
			if (jQuery.isArray(value)) {
				easing = value[1];
				value = props[index] = value[0];
			}

			if (index !== name) {
				props[name] = value;
				delete props[index];
			}

			hooks = jQuery.cssHooks[name];
			if (hooks && "expand" in hooks) {
				value = hooks.expand(value);
				delete props[name];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for (index in value) {
					if (!(index in props)) {
						props[index] = value[index];
						specialEasing[index] = easing;
					}
				}
			} else {
				specialEasing[name] = easing;
			}
		}
	}

	function Animation(elem, properties, options) {
		var result,
		    stopped,
		    index = 0,
		    length = animationPrefilters.length,
		    deferred = jQuery.Deferred().always(function () {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		    tick = function tick() {
			if (stopped) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
			    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),

			// Support: Android 2.3
			// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
			temp = remaining / animation.duration || 0,
			    percent = 1 - temp,
			    index = 0,
			    length = animation.tweens.length;

			for (; index < length; index++) {
				animation.tweens[index].run(percent);
			}

			deferred.notifyWith(elem, [animation, percent, remaining]);

			if (percent < 1 && length) {
				return remaining;
			} else {
				deferred.resolveWith(elem, [animation]);
				return false;
			}
		},
		    animation = deferred.promise({
			elem: elem,
			props: jQuery.extend({}, properties),
			opts: jQuery.extend(true, { specialEasing: {} }, options),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function createTween(prop, end) {
				var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
				animation.tweens.push(tween);
				return tween;
			},
			stop: function stop(gotoEnd) {
				var index = 0,

				// If we are going to the end, we want to run all the tweens
				// otherwise we skip this part
				length = gotoEnd ? animation.tweens.length : 0;
				if (stopped) {
					return this;
				}
				stopped = true;
				for (; index < length; index++) {
					animation.tweens[index].run(1);
				}

				// Resolve when we played the last frame; otherwise, reject
				if (gotoEnd) {
					deferred.resolveWith(elem, [animation, gotoEnd]);
				} else {
					deferred.rejectWith(elem, [animation, gotoEnd]);
				}
				return this;
			}
		}),
		    props = animation.props;

		propFilter(props, animation.opts.specialEasing);

		for (; index < length; index++) {
			result = animationPrefilters[index].call(animation, elem, props, animation.opts);
			if (result) {
				return result;
			}
		}

		jQuery.map(props, createTween, animation);

		if (jQuery.isFunction(animation.opts.start)) {
			animation.opts.start.call(elem, animation);
		}

		jQuery.fx.timer(jQuery.extend(tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		}));

		// attach callbacks from options
		return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
	}

	jQuery.Animation = jQuery.extend(Animation, {

		tweener: function tweener(props, callback) {
			if (jQuery.isFunction(props)) {
				callback = props;
				props = ["*"];
			} else {
				props = props.split(" ");
			}

			var prop,
			    index = 0,
			    length = props.length;

			for (; index < length; index++) {
				prop = props[index];
				tweeners[prop] = tweeners[prop] || [];
				tweeners[prop].unshift(callback);
			}
		},

		prefilter: function prefilter(callback, prepend) {
			if (prepend) {
				animationPrefilters.unshift(callback);
			} else {
				animationPrefilters.push(callback);
			}
		}
	});

	jQuery.speed = function (speed, easing, fn) {
		var opt = speed && (typeof speed === "undefined" ? "undefined" : _typeof(speed)) === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if (opt.queue == null || opt.queue === true) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function () {
			if (jQuery.isFunction(opt.old)) {
				opt.old.call(this);
			}

			if (opt.queue) {
				jQuery.dequeue(this, opt.queue);
			}
		};

		return opt;
	};

	jQuery.fn.extend({
		fadeTo: function fadeTo(speed, to, easing, callback) {

			// Show any hidden elements after setting opacity to 0
			return this.filter(isHidden).css("opacity", 0).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback);
		},
		animate: function animate(prop, speed, easing, callback) {
			var empty = jQuery.isEmptyObject(prop),
			    optall = jQuery.speed(speed, easing, callback),
			    doAnimation = function doAnimation() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation(this, jQuery.extend({}, prop), optall);

				// Empty animations, or finishing resolves immediately
				if (empty || data_priv.get(this, "finish")) {
					anim.stop(true);
				}
			};
			doAnimation.finish = doAnimation;

			return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
		},
		stop: function stop(type, clearQueue, gotoEnd) {
			var stopQueue = function stopQueue(hooks) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop(gotoEnd);
			};

			if (typeof type !== "string") {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if (clearQueue && type !== false) {
				this.queue(type || "fx", []);
			}

			return this.each(function () {
				var dequeue = true,
				    index = type != null && type + "queueHooks",
				    timers = jQuery.timers,
				    data = data_priv.get(this);

				if (index) {
					if (data[index] && data[index].stop) {
						stopQueue(data[index]);
					}
				} else {
					for (index in data) {
						if (data[index] && data[index].stop && rrun.test(index)) {
							stopQueue(data[index]);
						}
					}
				}

				for (index = timers.length; index--;) {
					if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
						timers[index].anim.stop(gotoEnd);
						dequeue = false;
						timers.splice(index, 1);
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if (dequeue || !gotoEnd) {
					jQuery.dequeue(this, type);
				}
			});
		},
		finish: function finish(type) {
			if (type !== false) {
				type = type || "fx";
			}
			return this.each(function () {
				var index,
				    data = data_priv.get(this),
				    queue = data[type + "queue"],
				    hooks = data[type + "queueHooks"],
				    timers = jQuery.timers,
				    length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue(this, type, []);

				if (hooks && hooks.stop) {
					hooks.stop.call(this, true);
				}

				// Look for any active animations, and finish them
				for (index = timers.length; index--;) {
					if (timers[index].elem === this && timers[index].queue === type) {
						timers[index].anim.stop(true);
						timers.splice(index, 1);
					}
				}

				// Look for any animations in the old queue and finish them
				for (index = 0; index < length; index++) {
					if (queue[index] && queue[index].finish) {
						queue[index].finish.call(this);
					}
				}

				// Turn off finishing flag
				delete data.finish;
			});
		}
	});

	jQuery.each(["toggle", "show", "hide"], function (i, name) {
		var cssFn = jQuery.fn[name];
		jQuery.fn[name] = function (speed, easing, callback) {
			return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
		};
	});

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function (name, props) {
		jQuery.fn[name] = function (speed, easing, callback) {
			return this.animate(props, speed, easing, callback);
		};
	});

	jQuery.timers = [];
	jQuery.fx.tick = function () {
		var timer,
		    i = 0,
		    timers = jQuery.timers;

		fxNow = jQuery.now();

		for (; i < timers.length; i++) {
			timer = timers[i];
			// Checks the timer has not already been removed
			if (!timer() && timers[i] === timer) {
				timers.splice(i--, 1);
			}
		}

		if (!timers.length) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function (timer) {
		jQuery.timers.push(timer);
		if (timer()) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;

	jQuery.fx.start = function () {
		if (!timerId) {
			timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
		}
	};

	jQuery.fx.stop = function () {
		clearInterval(timerId);
		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	};

	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function (time, type) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue(type, function (next, hooks) {
			var timeout = setTimeout(next, time);
			hooks.stop = function () {
				clearTimeout(timeout);
			};
		});
	};

	(function () {
		var input = document.createElement("input"),
		    select = document.createElement("select"),
		    opt = select.appendChild(document.createElement("option"));

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement("input");
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();

	var nodeHook,
	    boolHook,
	    attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend({
		attr: function attr(name, value) {
			return access(this, jQuery.attr, name, value, arguments.length > 1);
		},

		removeAttr: function removeAttr(name) {
			return this.each(function () {
				jQuery.removeAttr(this, name);
			});
		}
	});

	jQuery.extend({
		attr: function attr(elem, name, value) {
			var hooks,
			    ret,
			    nType = elem.nodeType;

			// don't get/set attributes on text, comment and attribute nodes
			if (!elem || nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if (_typeof(elem.getAttribute) === strundefined) {
				return jQuery.prop(elem, name, value);
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
			}

			if (value !== undefined) {

				if (value === null) {
					jQuery.removeAttr(elem, name);
				} else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				} else {
					elem.setAttribute(name, value + "");
					return value;
				}
			} else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			} else {
				ret = jQuery.find.attr(elem, name);

				// Non-existent attributes return null, we normalize to undefined
				return ret == null ? undefined : ret;
			}
		},

		removeAttr: function removeAttr(elem, value) {
			var name,
			    propName,
			    i = 0,
			    attrNames = value && value.match(rnotwhite);

			if (attrNames && elem.nodeType === 1) {
				while (name = attrNames[i++]) {
					propName = jQuery.propFix[name] || name;

					// Boolean attributes get special treatment (#10870)
					if (jQuery.expr.match.bool.test(name)) {
						// Set corresponding property to false
						elem[propName] = false;
					}

					elem.removeAttribute(name);
				}
			}
		},

		attrHooks: {
			type: {
				set: function set(elem, value) {
					if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
						var val = elem.value;
						elem.setAttribute("type", value);
						if (val) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		}
	});

	// Hooks for boolean attributes
	boolHook = {
		set: function set(elem, value, name) {
			if (value === false) {
				// Remove boolean attributes when set to false
				jQuery.removeAttr(elem, name);
			} else {
				elem.setAttribute(name, name);
			}
			return name;
		}
	};
	jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
		var getter = attrHandle[name] || jQuery.find.attr;

		attrHandle[name] = function (elem, name, isXML) {
			var ret, handle;
			if (!isXML) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[name];
				attrHandle[name] = ret;
				ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
				attrHandle[name] = handle;
			}
			return ret;
		};
	});

	var rfocusable = /^(?:input|select|textarea|button)$/i;

	jQuery.fn.extend({
		prop: function prop(name, value) {
			return access(this, jQuery.prop, name, value, arguments.length > 1);
		},

		removeProp: function removeProp(name) {
			return this.each(function () {
				delete this[jQuery.propFix[name] || name];
			});
		}
	});

	jQuery.extend({
		propFix: {
			"for": "htmlFor",
			"class": "className"
		},

		prop: function prop(elem, name, value) {
			var ret,
			    hooks,
			    notxml,
			    nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if (!elem || nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

			if (notxml) {
				// Fix name and attach hooks
				name = jQuery.propFix[name] || name;
				hooks = jQuery.propHooks[name];
			}

			if (value !== undefined) {
				return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
			} else {
				return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
			}
		},

		propHooks: {
			tabIndex: {
				get: function get(elem) {
					return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
				}
			}
		}
	});

	if (!support.optSelected) {
		jQuery.propHooks.selected = {
			get: function get(elem) {
				var parent = elem.parentNode;
				if (parent && parent.parentNode) {
					parent.parentNode.selectedIndex;
				}
				return null;
			}
		};
	}

	jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
		jQuery.propFix[this.toLowerCase()] = this;
	});

	var rclass = /[\t\r\n\f]/g;

	jQuery.fn.extend({
		addClass: function addClass(value) {
			var classes,
			    elem,
			    cur,
			    clazz,
			    j,
			    finalValue,
			    proceed = typeof value === "string" && value,
			    i = 0,
			    len = this.length;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).addClass(value.call(this, j, this.className));
				});
			}

			if (proceed) {
				// The disjunction here is for better compressibility (see removeClass)
				classes = (value || "").match(rnotwhite) || [];

				for (; i < len; i++) {
					elem = this[i];
					cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {
							if (cur.indexOf(" " + clazz + " ") < 0) {
								cur += clazz + " ";
							}
						}

						// only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim(cur);
						if (elem.className !== finalValue) {
							elem.className = finalValue;
						}
					}
				}
			}

			return this;
		},

		removeClass: function removeClass(value) {
			var classes,
			    elem,
			    cur,
			    clazz,
			    j,
			    finalValue,
			    proceed = arguments.length === 0 || typeof value === "string" && value,
			    i = 0,
			    len = this.length;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).removeClass(value.call(this, j, this.className));
				});
			}
			if (proceed) {
				classes = (value || "").match(rnotwhite) || [];

				for (; i < len; i++) {
					elem = this[i];
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {
							// Remove *all* instances
							while (cur.indexOf(" " + clazz + " ") >= 0) {
								cur = cur.replace(" " + clazz + " ", " ");
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = value ? jQuery.trim(cur) : "";
						if (elem.className !== finalValue) {
							elem.className = finalValue;
						}
					}
				}
			}

			return this;
		},

		toggleClass: function toggleClass(value, stateVal) {
			var type = typeof value === "undefined" ? "undefined" : _typeof(value);

			if (typeof stateVal === "boolean" && type === "string") {
				return stateVal ? this.addClass(value) : this.removeClass(value);
			}

			if (jQuery.isFunction(value)) {
				return this.each(function (i) {
					jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
				});
			}

			return this.each(function () {
				if (type === "string") {
					// Toggle individual class names
					var className,
					    i = 0,
					    self = jQuery(this),
					    classNames = value.match(rnotwhite) || [];

					while (className = classNames[i++]) {
						// Check each className given, space separated list
						if (self.hasClass(className)) {
							self.removeClass(className);
						} else {
							self.addClass(className);
						}
					}

					// Toggle whole class name
				} else if (type === strundefined || type === "boolean") {
					if (this.className) {
						// store className if set
						data_priv.set(this, "__className__", this.className);
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
				}
			});
		},

		hasClass: function hasClass(selector) {
			var className = " " + selector + " ",
			    i = 0,
			    l = this.length;
			for (; i < l; i++) {
				if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
					return true;
				}
			}

			return false;
		}
	});

	var rreturn = /\r/g;

	jQuery.fn.extend({
		val: function val(value) {
			var hooks,
			    ret,
			    isFunction,
			    elem = this[0];

			if (!arguments.length) {
				if (elem) {
					hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

					if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction(value);

			return this.each(function (i) {
				var val;

				if (this.nodeType !== 1) {
					return;
				}

				if (isFunction) {
					val = value.call(this, i, jQuery(this).val());
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if (val == null) {
					val = "";
				} else if (typeof val === "number") {
					val += "";
				} else if (jQuery.isArray(val)) {
					val = jQuery.map(val, function (value) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

				// If set returns undefined, fall back to normal setting
				if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function get(elem) {
					var val = jQuery.find.attr(elem, "value");
					return val != null ? val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim(jQuery.text(elem));
				}
			},
			select: {
				get: function get(elem) {
					var value,
					    option,
					    options = elem.options,
					    index = elem.selectedIndex,
					    one = elem.type === "select-one" || index < 0,
					    values = one ? null : [],
					    max = one ? index + 1 : options.length,
					    i = index < 0 ? max : one ? index : 0;

					// Loop through all the selected options
					for (; i < max; i++) {
						option = options[i];

						// IE6-9 doesn't update selected after form reset (#2551)
						if ((option.selected || i === index) && (
						// Don't return options that are disabled or in a disabled optgroup
						support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

							// Get the specific value for the option
							value = jQuery(option).val();

							// We don't need an array for one selects
							if (one) {
								return value;
							}

							// Multi-Selects return an array
							values.push(value);
						}
					}

					return values;
				},

				set: function set(elem, value) {
					var optionSet,
					    option,
					    options = elem.options,
					    values = jQuery.makeArray(value),
					    i = options.length;

					while (i--) {
						option = options[i];
						if (option.selected = jQuery.inArray(option.value, values) >= 0) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if (!optionSet) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});

	// Radios and checkboxes getter/setter
	jQuery.each(["radio", "checkbox"], function () {
		jQuery.valHooks[this] = {
			set: function set(elem, value) {
				if (jQuery.isArray(value)) {
					return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
				}
			}
		};
		if (!support.checkOn) {
			jQuery.valHooks[this].get = function (elem) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});

	// Return jQuery for attributes-only inclusion


	jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

		// Handle event binding
		jQuery.fn[name] = function (data, fn) {
			return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
		};
	});

	jQuery.fn.extend({
		hover: function hover(fnOver, fnOut) {
			return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
		},

		bind: function bind(types, data, fn) {
			return this.on(types, null, data, fn);
		},
		unbind: function unbind(types, fn) {
			return this.off(types, null, fn);
		},

		delegate: function delegate(selector, types, data, fn) {
			return this.on(types, selector, data, fn);
		},
		undelegate: function undelegate(selector, types, fn) {
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
		}
	});

	var nonce = jQuery.now();

	var rquery = /\?/;

	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function (data) {
		return JSON.parse(data + "");
	};

	// Cross-browser xml parsing
	jQuery.parseXML = function (data) {
		var xml, tmp;
		if (!data || typeof data !== "string") {
			return null;
		}

		// Support: IE9
		try {
			tmp = new DOMParser();
			xml = tmp.parseFromString(data, "text/xml");
		} catch (e) {
			xml = undefined;
		}

		if (!xml || xml.getElementsByTagName("parsererror").length) {
			jQuery.error("Invalid XML: " + data);
		}
		return xml;
	};

	var rhash = /#.*$/,
	    rts = /([?&])_=[^&]*/,
	    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	    rnoContent = /^(?:GET|HEAD)$/,
	    rprotocol = /^\/\//,
	    rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,


	/* Prefilters
  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  * 2) These are called:
  *    - BEFORE asking for a transport
  *    - AFTER param serialization (s.data is a string if s.processData is true)
  * 3) key is the dataType
  * 4) the catchall symbol "*" can be used
  * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  */
	prefilters = {},


	/* Transports bindings
  * 1) key is the dataType
  * 2) the catchall symbol "*" can be used
  * 3) selection will start with transport dataType and THEN go to "*" if needed
  */
	transports = {},


	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*"),


	// Document location
	ajaxLocation = window.location.href,


	// Segment location into parts
	ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports(structure) {

		// dataTypeExpression is optional and defaults to "*"
		return function (dataTypeExpression, func) {

			if (typeof dataTypeExpression !== "string") {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
			    i = 0,
			    dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

			if (jQuery.isFunction(func)) {
				// For each dataType in the dataTypeExpression
				while (dataType = dataTypes[i++]) {
					// Prepend if requested
					if (dataType[0] === "+") {
						dataType = dataType.slice(1) || "*";
						(structure[dataType] = structure[dataType] || []).unshift(func);

						// Otherwise append
					} else {
						(structure[dataType] = structure[dataType] || []).push(func);
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

		var inspected = {},
		    seekingTransport = structure === transports;

		function inspect(dataType) {
			var selected;
			inspected[dataType] = true;
			jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
				var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
				if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
					options.dataTypes.unshift(dataTypeOrTransport);
					inspect(dataTypeOrTransport);
					return false;
				} else if (seekingTransport) {
					return !(selected = dataTypeOrTransport);
				}
			});
			return selected;
		}

		return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend(target, src) {
		var key,
		    deep,
		    flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for (key in src) {
			if (src[key] !== undefined) {
				(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
			}
		}
		if (deep) {
			jQuery.extend(true, target, deep);
		}

		return target;
	}

	/* Handles responses to an ajax request:
  * - finds the right dataType (mediates between content-type and expected dataType)
  * - returns the corresponding response
  */
	function ajaxHandleResponses(s, jqXHR, responses) {

		var ct,
		    type,
		    finalDataType,
		    firstDataType,
		    contents = s.contents,
		    dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while (dataTypes[0] === "*") {
			dataTypes.shift();
			if (ct === undefined) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if (ct) {
			for (type in contents) {
				if (contents[type] && contents[type].test(ct)) {
					dataTypes.unshift(type);
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if (dataTypes[0] in responses) {
			finalDataType = dataTypes[0];
		} else {
			// Try convertible dataTypes
			for (type in responses) {
				if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
					finalDataType = type;
					break;
				}
				if (!firstDataType) {
					firstDataType = type;
				}
			}
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if (finalDataType) {
			if (finalDataType !== dataTypes[0]) {
				dataTypes.unshift(finalDataType);
			}
			return responses[finalDataType];
		}
	}

	/* Chain conversions given the request and the original response
  * Also sets the responseXXX fields on the jqXHR instance
  */
	function ajaxConvert(s, response, jqXHR, isSuccess) {
		var conv2,
		    current,
		    conv,
		    tmp,
		    prev,
		    converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if (dataTypes[1]) {
			for (conv in s.converters) {
				converters[conv.toLowerCase()] = s.converters[conv];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while (current) {

			if (s.responseFields[current]) {
				jqXHR[s.responseFields[current]] = response;
			}

			// Apply the dataFilter if provided
			if (!prev && isSuccess && s.dataFilter) {
				response = s.dataFilter(response, s.dataType);
			}

			prev = current;
			current = dataTypes.shift();

			if (current) {

				// There's only work to do if current dataType is non-auto
				if (current === "*") {

					current = prev;

					// Convert response if prev dataType is non-auto and differs from current
				} else if (prev !== "*" && prev !== current) {

					// Seek a direct converter
					conv = converters[prev + " " + current] || converters["* " + current];

					// If none found, seek a pair
					if (!conv) {
						for (conv2 in converters) {

							// If conv2 outputs current
							tmp = conv2.split(" ");
							if (tmp[1] === current) {

								// If prev can be converted to accepted input
								conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
								if (conv) {
									// Condense equivalence converters
									if (conv === true) {
										conv = converters[conv2];

										// Otherwise, insert the intermediate dataType
									} else if (converters[conv2] !== true) {
										current = tmp[0];
										dataTypes.unshift(tmp[1]);
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if (conv !== true) {

						// Unless errors are allowed to bubble, catch and return them
						if (conv && s["throws"]) {
							response = conv(response);
						} else {
							try {
								response = conv(response);
							} catch (e) {
								return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: ajaxLocation,
			type: "GET",
			isLocal: rlocalProtocol.test(ajaxLocParts[1]),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
   timeout: 0,
   data: null,
   dataType: null,
   username: null,
   password: null,
   cache: null,
   throws: false,
   traditional: false,
   headers: {},
   */

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /xml/,
				html: /html/,
				json: /json/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function ajaxSetup(target, settings) {
			return settings ?

			// Building a settings object
			ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

			// Extending ajaxSettings
			ajaxExtend(jQuery.ajaxSettings, target);
		},

		ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
		ajaxTransport: addToPrefiltersOrTransports(transports),

		// Main method
		ajax: function ajax(url, options) {

			// If url is an object, simulate pre-1.5 signature
			if ((typeof url === "undefined" ? "undefined" : _typeof(url)) === "object") {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			    responseHeaders,

			// timeout handle
			timeoutTimer,

			// Cross-domain detection vars
			parts,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// Create the final options object
			s = jQuery.ajaxSetup({}, options),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			    completeDeferred = jQuery.Callbacks("once memory"),

			// Status-dependent callbacks
			_statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			    requestHeadersNames = {},

			// The jqXHR state
			state = 0,

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function getResponseHeader(key) {
					var match;
					if (state === 2) {
						if (!responseHeaders) {
							responseHeaders = {};
							while (match = rheaders.exec(responseHeadersString)) {
								responseHeaders[match[1].toLowerCase()] = match[2];
							}
						}
						match = responseHeaders[key.toLowerCase()];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function getAllResponseHeaders() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function setRequestHeader(name, value) {
					var lname = name.toLowerCase();
					if (!state) {
						name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
						requestHeaders[name] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function overrideMimeType(type) {
					if (!state) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function statusCode(map) {
					var code;
					if (map) {
						if (state < 2) {
							for (code in map) {
								// Lazy-add the new callback in a way that preserves old ones
								_statusCode[code] = [_statusCode[code], map[code]];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always(map[jqXHR.status]);
						}
					}
					return this;
				},

				// Cancel the request
				abort: function abort(statusText) {
					var finalText = statusText || strAbort;
					if (transport) {
						transport.abort(finalText);
					}
					done(0, finalText);
					return this;
				}
			};

			// Attach deferreds
			deferred.promise(jqXHR).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

			// A cross-domain request is in order when we have a protocol:host:port mismatch
			if (s.crossDomain == null) {
				parts = rurl.exec(s.url.toLowerCase());
				s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
			}

			// Convert data if not already a string
			if (s.data && s.processData && typeof s.data !== "string") {
				s.data = jQuery.param(s.data, s.traditional);
			}

			// Apply prefilters
			inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

			// If request was aborted inside a prefilter, stop there
			if (state === 2) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if (fireGlobals && jQuery.active++ === 0) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test(s.type);

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if (!s.hasContent) {

				// If data is available, append data to url
				if (s.data) {
					cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if (s.cache === false) {
					s.url = rts.test(cacheURL) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace(rts, "$1_=" + nonce++) :

					// Otherwise add one to the end
					cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if (s.ifModified) {
				if (jQuery.lastModified[cacheURL]) {
					jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
				}
				if (jQuery.etag[cacheURL]) {
					jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
				}
			}

			// Set the correct header, if data is being sent
			if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
				jqXHR.setRequestHeader("Content-Type", s.contentType);
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

			// Check for headers option
			for (i in s.headers) {
				jqXHR.setRequestHeader(i, s.headers[i]);
			}

			// Allow custom headers/mimetypes and early abort
			if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for (i in { success: 1, error: 1, complete: 1 }) {
				jqXHR[i](s[i]);
			}

			// Get transport
			transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

			// If no transport, we auto-abort
			if (!transport) {
				done(-1, "No Transport");
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if (fireGlobals) {
					globalEventContext.trigger("ajaxSend", [jqXHR, s]);
				}
				// Timeout
				if (s.async && s.timeout > 0) {
					timeoutTimer = setTimeout(function () {
						jqXHR.abort("timeout");
					}, s.timeout);
				}

				try {
					state = 1;
					transport.send(requestHeaders, done);
				} catch (e) {
					// Propagate exception as error if not done
					if (state < 2) {
						done(-1, e);
						// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done(status, nativeStatusText, responses, headers) {
				var isSuccess,
				    success,
				    error,
				    response,
				    modified,
				    statusText = nativeStatusText;

				// Called once
				if (state === 2) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if (timeoutTimer) {
					clearTimeout(timeoutTimer);
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if (responses) {
					response = ajaxHandleResponses(s, jqXHR, responses);
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert(s, response, jqXHR, isSuccess);

				// If successful, handle type chaining
				if (isSuccess) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if (s.ifModified) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if (modified) {
							jQuery.lastModified[cacheURL] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if (modified) {
							jQuery.etag[cacheURL] = modified;
						}
					}

					// if no content
					if (status === 204 || s.type === "HEAD") {
						statusText = "nocontent";

						// if not modified
					} else if (status === 304) {
						statusText = "notmodified";

						// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if (status || !statusText) {
						statusText = "error";
						if (status < 0) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = (nativeStatusText || statusText) + "";

				// Success/Error
				if (isSuccess) {
					deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
				} else {
					deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
				}

				// Status-dependent callbacks
				jqXHR.statusCode(_statusCode);
				_statusCode = undefined;

				if (fireGlobals) {
					globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
				}

				// Complete
				completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

				if (fireGlobals) {
					globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
					// Handle the global AJAX counter
					if (! --jQuery.active) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getJSON: function getJSON(url, data, callback) {
			return jQuery.get(url, data, callback, "json");
		},

		getScript: function getScript(url, callback) {
			return jQuery.get(url, undefined, callback, "script");
		}
	});

	jQuery.each(["get", "post"], function (i, method) {
		jQuery[method] = function (url, data, callback, type) {
			// Shift arguments if data argument was omitted
			if (jQuery.isFunction(data)) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			return jQuery.ajax({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			});
		};
	});

	jQuery._evalUrl = function (url) {
		return jQuery.ajax({
			url: url,
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};

	jQuery.fn.extend({
		wrapAll: function wrapAll(html) {
			var wrap;

			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapAll(html.call(this, i));
				});
			}

			if (this[0]) {

				// The elements to wrap the target around
				wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

				if (this[0].parentNode) {
					wrap.insertBefore(this[0]);
				}

				wrap.map(function () {
					var elem = this;

					while (elem.firstElementChild) {
						elem = elem.firstElementChild;
					}

					return elem;
				}).append(this);
			}

			return this;
		},

		wrapInner: function wrapInner(html) {
			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapInner(html.call(this, i));
				});
			}

			return this.each(function () {
				var self = jQuery(this),
				    contents = self.contents();

				if (contents.length) {
					contents.wrapAll(html);
				} else {
					self.append(html);
				}
			});
		},

		wrap: function wrap(html) {
			var isFunction = jQuery.isFunction(html);

			return this.each(function (i) {
				jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
			});
		},

		unwrap: function unwrap() {
			return this.parent().each(function () {
				if (!jQuery.nodeName(this, "body")) {
					jQuery(this).replaceWith(this.childNodes);
				}
			}).end();
		}
	});

	jQuery.expr.filters.hidden = function (elem) {
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
	};
	jQuery.expr.filters.visible = function (elem) {
		return !jQuery.expr.filters.hidden(elem);
	};

	var r20 = /%20/g,
	    rbracket = /\[\]$/,
	    rCRLF = /\r?\n/g,
	    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	    rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams(prefix, obj, traditional, add) {
		var name;

		if (jQuery.isArray(obj)) {
			// Serialize array item.
			jQuery.each(obj, function (i, v) {
				if (traditional || rbracket.test(prefix)) {
					// Treat each array item as a scalar.
					add(prefix, v);
				} else {
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(prefix + "[" + ((typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" ? i : "") + "]", v, traditional, add);
				}
			});
		} else if (!traditional && jQuery.type(obj) === "object") {
			// Serialize object item.
			for (name in obj) {
				buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
			}
		} else {
			// Serialize scalar item.
			add(prefix, obj);
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function (a, traditional) {
		var prefix,
		    s = [],
		    add = function add(key, value) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
			s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
		};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if (traditional === undefined) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
			// Serialize the form elements
			jQuery.each(a, function () {
				add(this.name, this.value);
			});
		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for (prefix in a) {
				buildParams(prefix, a[prefix], traditional, add);
			}
		}

		// Return the resulting serialization
		return s.join("&").replace(r20, "+");
	};

	jQuery.fn.extend({
		serialize: function serialize() {
			return jQuery.param(this.serializeArray());
		},
		serializeArray: function serializeArray() {
			return this.map(function () {
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop(this, "elements");
				return elements ? jQuery.makeArray(elements) : this;
			}).filter(function () {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
			}).map(function (i, elem) {
				var val = jQuery(this).val();

				return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
					return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
				}) : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
			}).get();
		}
	});

	jQuery.ajaxSettings.xhr = function () {
		try {
			return new XMLHttpRequest();
		} catch (e) {}
	};

	var xhrId = 0,
	    xhrCallbacks = {},
	    xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	    xhrSupported = jQuery.ajaxSettings.xhr();

	// Support: IE9
	// Open requests must be manually aborted on unload (#5280)
	// See https://support.microsoft.com/kb/2856746 for more info
	if (window.attachEvent) {
		window.attachEvent("onunload", function () {
			for (var key in xhrCallbacks) {
				xhrCallbacks[key]();
			}
		});
	}

	support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport(function (options) {
		var _callback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if (support.cors || xhrSupported && !options.crossDomain) {
			return {
				send: function send(headers, complete) {
					var i,
					    xhr = options.xhr(),
					    id = ++xhrId;

					xhr.open(options.type, options.url, options.async, options.username, options.password);

					// Apply custom fields if provided
					if (options.xhrFields) {
						for (i in options.xhrFields) {
							xhr[i] = options.xhrFields[i];
						}
					}

					// Override mime type if needed
					if (options.mimeType && xhr.overrideMimeType) {
						xhr.overrideMimeType(options.mimeType);
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if (!options.crossDomain && !headers["X-Requested-With"]) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for (i in headers) {
						xhr.setRequestHeader(i, headers[i]);
					}

					// Callback
					_callback = function callback(type) {
						return function () {
							if (_callback) {
								delete xhrCallbacks[id];
								_callback = xhr.onload = xhr.onerror = null;

								if (type === "abort") {
									xhr.abort();
								} else if (type === "error") {
									complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status, xhr.statusText);
								} else {
									complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined, xhr.getAllResponseHeaders());
								}
							}
						};
					};

					// Listen to events
					xhr.onload = _callback();
					xhr.onerror = _callback("error");

					// Create the abort callback
					_callback = xhrCallbacks[id] = _callback("abort");

					try {
						// Do send the request (this may raise an exception)
						xhr.send(options.hasContent && options.data || null);
					} catch (e) {
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if (_callback) {
							throw e;
						}
					}
				},

				abort: function abort() {
					if (_callback) {
						_callback();
					}
				}
			};
		}
	});

	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /(?:java|ecma)script/
		},
		converters: {
			"text script": function textScript(text) {
				jQuery.globalEval(text);
				return text;
			}
		}
	});

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter("script", function (s) {
		if (s.cache === undefined) {
			s.cache = false;
		}
		if (s.crossDomain) {
			s.type = "GET";
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport("script", function (s) {
		// This transport only deals with cross domain requests
		if (s.crossDomain) {
			var script, _callback2;
			return {
				send: function send(_, complete) {
					script = jQuery("<script>").prop({
						async: true,
						charset: s.scriptCharset,
						src: s.url
					}).on("load error", _callback2 = function callback(evt) {
						script.remove();
						_callback2 = null;
						if (evt) {
							complete(evt.type === "error" ? 404 : 200, evt.type);
						}
					});
					document.head.appendChild(script[0]);
				},
				abort: function abort() {
					if (_callback2) {
						_callback2();
					}
				}
			};
		}
	});

	var oldCallbacks = [],
	    rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function jsonpCallback() {
			var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
			this[callback] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

		var callbackName,
		    overwritten,
		    responseContainer,
		    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if (jsonProp || s.dataTypes[0] === "jsonp") {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

			// Insert callback into url or form data
			if (jsonProp) {
				s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
			} else if (s.jsonp !== false) {
				s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function () {
				if (!responseContainer) {
					jQuery.error(callbackName + " was not called");
				}
				return responseContainer[0];
			};

			// force json dataType
			s.dataTypes[0] = "json";

			// Install callback
			overwritten = window[callbackName];
			window[callbackName] = function () {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function () {
				// Restore preexisting value
				window[callbackName] = overwritten;

				// Save back as free
				if (s[callbackName]) {
					// make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// save the callback name for future use
					oldCallbacks.push(callbackName);
				}

				// Call if it was a function and we have a response
				if (responseContainer && jQuery.isFunction(overwritten)) {
					overwritten(responseContainer[0]);
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});

	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function (data, context, keepScripts) {
		if (!data || typeof data !== "string") {
			return null;
		}
		if (typeof context === "boolean") {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec(data),
		    scripts = !keepScripts && [];

		// Single tag
		if (parsed) {
			return [context.createElement(parsed[1])];
		}

		parsed = jQuery.buildFragment([data], context, scripts);

		if (scripts && scripts.length) {
			jQuery(scripts).remove();
		}

		return jQuery.merge([], parsed.childNodes);
	};

	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
  * Load a url into a page
  */
	jQuery.fn.load = function (url, params, callback) {
		if (typeof url !== "string" && _load) {
			return _load.apply(this, arguments);
		}

		var selector,
		    type,
		    response,
		    self = this,
		    off = url.indexOf(" ");

		if (off >= 0) {
			selector = jQuery.trim(url.slice(off));
			url = url.slice(0, off);
		}

		// If it's a function
		if (jQuery.isFunction(params)) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

			// Otherwise, build a param string
		} else if (params && (typeof params === "undefined" ? "undefined" : _typeof(params)) === "object") {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if (self.length > 0) {
			jQuery.ajax({
				url: url,

				// if "type" variable is undefined, then "GET" method will be used
				type: type,
				dataType: "html",
				data: params
			}).done(function (responseText) {

				// Save response for use in complete callback
				response = arguments;

				self.html(selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

				// Otherwise use the full result
				responseText);
			}).complete(callback && function (jqXHR, status) {
				self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
			});
		}

		return this;
	};

	// Attach a bunch of functions for handling common AJAX events
	jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
		jQuery.fn[type] = function (fn) {
			return this.on(type, fn);
		};
	});

	jQuery.expr.filters.animated = function (elem) {
		return jQuery.grep(jQuery.timers, function (fn) {
			return elem === fn.elem;
		}).length;
	};

	var docElem = window.document.documentElement;

	/**
  * Gets a window from an element
  */
	function getWindow(elem) {
		return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function setOffset(elem, options, i) {
			var curPosition,
			    curLeft,
			    curCSSTop,
			    curTop,
			    curOffset,
			    curCSSLeft,
			    calculatePosition,
			    position = jQuery.css(elem, "position"),
			    curElem = jQuery(elem),
			    props = {};

			// Set position first, in-case top/left are set even on static elem
			if (position === "static") {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css(elem, "top");
			curCSSLeft = jQuery.css(elem, "left");
			calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if (calculatePosition) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
			} else {
				curTop = parseFloat(curCSSTop) || 0;
				curLeft = parseFloat(curCSSLeft) || 0;
			}

			if (jQuery.isFunction(options)) {
				options = options.call(elem, i, curOffset);
			}

			if (options.top != null) {
				props.top = options.top - curOffset.top + curTop;
			}
			if (options.left != null) {
				props.left = options.left - curOffset.left + curLeft;
			}

			if ("using" in options) {
				options.using.call(elem, props);
			} else {
				curElem.css(props);
			}
		}
	};

	jQuery.fn.extend({
		offset: function offset(options) {
			if (arguments.length) {
				return options === undefined ? this : this.each(function (i) {
					jQuery.offset.setOffset(this, options, i);
				});
			}

			var docElem,
			    win,
			    elem = this[0],
			    box = { top: 0, left: 0 },
			    doc = elem && elem.ownerDocument;

			if (!doc) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if (!jQuery.contains(docElem, elem)) {
				return box;
			}

			// Support: BlackBerry 5, iOS 3 (original iPhone)
			// If we don't have gBCR, just use 0,0 rather than error
			if (_typeof(elem.getBoundingClientRect) !== strundefined) {
				box = elem.getBoundingClientRect();
			}
			win = getWindow(doc);
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function position() {
			if (!this[0]) {
				return;
			}

			var offsetParent,
			    offset,
			    elem = this[0],
			    parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
			if (jQuery.css(elem, "position") === "fixed") {
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
			} else {
				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if (!jQuery.nodeName(offsetParent[0], "html")) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
				parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
				left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
			};
		},

		offsetParent: function offsetParent() {
			return this.map(function () {
				var offsetParent = this.offsetParent || docElem;

				while (offsetParent && !jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static") {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || docElem;
			});
		}
	});

	// Create scrollLeft and scrollTop methods
	jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
		var top = "pageYOffset" === prop;

		jQuery.fn[method] = function (val) {
			return access(this, function (elem, method, val) {
				var win = getWindow(elem);

				if (val === undefined) {
					return win ? win[prop] : elem[method];
				}

				if (win) {
					win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
				} else {
					elem[method] = val;
				}
			}, method, val, arguments.length, null);
		};
	});

	// Support: Safari<7+, Chrome<37+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each(["top", "left"], function (i, prop) {
		jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
			if (computed) {
				computed = curCSS(elem, prop);
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
			}
		});
	});

	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
		jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[funcName] = function (margin, value) {
				var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
				    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

				return access(this, function (elem, type, value) {
					var doc;

					if (jQuery.isWindow(elem)) {
						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement["client" + name];
					}

					// Get document width or height
					if (elem.nodeType === 9) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
					}

					return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css(elem, type, extra) :

					// Set width or height on the element
					jQuery.style(elem, type, value, extra);
				}, type, chainable ? margin : undefined, chainable, null);
			};
		});
	});

	// The number of elements contained in the matched element set
	jQuery.fn.size = function () {
		return this.length;
	};

	jQuery.fn.andSelf = jQuery.fn.addBack;

	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if (typeof define === "function" && define.amd) {
		define("jquery", [], function () {
			return jQuery;
		});
	}

	var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,


	// Map over the $ in case of overwrite
	_$ = window.$;

	jQuery.noConflict = function (deep) {
		if (window.$ === jQuery) {
			window.$ = _$;
		}

		if (deep && window.jQuery === jQuery) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ((typeof noGlobal === "undefined" ? "undefined" : _typeof(noGlobal)) === strundefined) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
});
/*!
 * Bootstrap v3.3.7 (http://getbootstrap.com)
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under the MIT license
 */

if (typeof jQuery === 'undefined') {
	throw new Error('Bootstrap\'s JavaScript requires jQuery');
}

+function ($) {
	'use strict';

	var version = $.fn.jquery.split(' ')[0].split('.');
	if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1 || version[0] > 3) {
		throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4');
	}
}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.7
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
	'use strict';

	// CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
	// ============================================================

	function transitionEnd() {
		var el = document.createElement('bootstrap');

		var transEndEventNames = {
			WebkitTransition: 'webkitTransitionEnd',
			MozTransition: 'transitionend',
			OTransition: 'oTransitionEnd otransitionend',
			transition: 'transitionend'
		};

		for (var name in transEndEventNames) {
			if (el.style[name] !== undefined) {
				return { end: transEndEventNames[name] };
			}
		}

		return false; // explicit for ie8 (  ._.)
	}

	// http://blog.alexmaccaw.com/css-transitions
	$.fn.emulateTransitionEnd = function (duration) {
		var called = false;
		var $el = this;
		$(this).one('bsTransitionEnd', function () {
			called = true;
		});
		var callback = function callback() {
			if (!called) $($el).trigger($.support.transition.end);
		};
		setTimeout(callback, duration);
		return this;
	};

	$(function () {
		$.support.transition = transitionEnd();

		if (!$.support.transition) return;

		$.event.special.bsTransitionEnd = {
			bindType: $.support.transition.end,
			delegateType: $.support.transition.end,
			handle: function handle(e) {
				if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
			}
		};
	});
}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.3.7
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
	'use strict';

	// ALERT CLASS DEFINITION
	// ======================

	var dismiss = '[data-dismiss="alert"]';
	var Alert = function Alert(el) {
		$(el).on('click', dismiss, this.close);
	};

	Alert.VERSION = '3.3.7';

	Alert.TRANSITION_DURATION = 150;

	Alert.prototype.close = function (e) {
		var $this = $(this);
		var selector = $this.attr('data-target');

		if (!selector) {
			selector = $this.attr('href');
			selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
		}

		var $parent = $(selector === '#' ? [] : selector);

		if (e) e.preventDefault();

		if (!$parent.length) {
			$parent = $this.closest('.alert');
		}

		$parent.trigger(e = $.Event('close.bs.alert'));

		if (e.isDefaultPrevented()) return;

		$parent.removeClass('in');

		function removeElement() {
			// detach from parent, fire event then clean up data
			$parent.detach().trigger('closed.bs.alert').remove();
		}

		$.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
	};

	// ALERT PLUGIN DEFINITION
	// =======================

	function Plugin(option) {
		return this.each(function () {
			var $this = $(this);
			var data = $this.data('bs.alert');

			if (!data) $this.data('bs.alert', data = new Alert(this));
			if (typeof option == 'string') data[option].call($this);
		});
	}

	var old = $.fn.alert;

	$.fn.alert = Plugin;
	$.fn.alert.Constructor = Alert;

	// ALERT NO CONFLICT
	// =================

	$.fn.alert.noConflict = function () {
		$.fn.alert = old;
		return this;
	};

	// ALERT DATA-API
	// ==============

	$(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);
}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.3.7
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
	'use strict';

	// BUTTON PUBLIC CLASS DEFINITION
	// ==============================

	var Button = function Button(element, options) {
		this.$element = $(element);
		this.options = $.extend({}, Button.DEFAULTS, options);
		this.isLoading = false;
	};

	Button.VERSION = '3.3.7';

	Button.DEFAULTS = {
		loadingText: 'loading...'
	};

	Button.prototype.setState = function (state) {
		var d = 'disabled';
		var $el = this.$element;
		var val = $el.is('input') ? 'val' : 'html';
		var data = $el.data();

		state += 'Text';

		if (data.resetText == null) $el.data('resetText', $el[val]());

		// push to event loop to allow forms to submit
		setTimeout($.proxy(function () {
			$el[val](data[state] == null ? this.options[state] : data[state]);

			if (state == 'loadingText') {
				this.isLoading = true;
				$el.addClass(d).attr(d, d).prop(d, true);
			} else if (this.isLoading) {
				this.isLoading = false;
				$el.removeClass(d).removeAttr(d).prop(d, false);
			}
		}, this), 0);
	};

	Button.prototype.toggle = function () {
		var changed = true;
		var $parent = this.$element.closest('[data-toggle="buttons"]');

		if ($parent.length) {
			var $input = this.$element.find('input');
			if ($input.prop('type') == 'radio') {
				if ($input.prop('checked')) changed = false;
				$parent.find('.active').removeClass('active');
				this.$element.addClass('active');
			} else if ($input.prop('type') == 'checkbox') {
				if ($input.prop('checked') !== this.$element.hasClass('active')) changed = false;
				this.$element.toggleClass('active');
			}
			$input.prop('checked', this.$element.hasClass('active'));
			if (changed) $input.trigger('change');
		} else {
			this.$element.attr('aria-pressed', !this.$element.hasClass('active'));
			this.$element.toggleClass('active');
		}
	};

	// BUTTON PLUGIN DEFINITION
	// ========================

	function Plugin(option) {
		return this.each(function () {
			var $this = $(this);
			var data = $this.data('bs.button');
			var options = (typeof option === "undefined" ? "undefined" : _typeof(option)) == 'object' && option;

			if (!data) $this.data('bs.button', data = new Button(this, options));

			if (option == 'toggle') data.toggle();else if (option) data.setState(option);
		});
	}

	var old = $.fn.button;

	$.fn.button = Plugin;
	$.fn.button.Constructor = Button;

	// BUTTON NO CONFLICT
	// ==================

	$.fn.button.noConflict = function () {
		$.fn.button = old;
		return this;
	};

	// BUTTON DATA-API
	// ===============

	$(document).on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
		var $btn = $(e.target).closest('.btn');
		Plugin.call($btn, 'toggle');
		if (!$(e.target).is('input[type="radio"], input[type="checkbox"]')) {
			// Prevent double click on radios, and the double selections (so cancellation) on checkboxes
			e.preventDefault();
			// The target component still receive the focus
			if ($btn.is('input,button')) $btn.trigger('focus');else $btn.find('input:visible,button:visible').first().trigger('focus');
		}
	}).on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
		$(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type));
	});
}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.3.7
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
	'use strict';

	// CAROUSEL CLASS DEFINITION
	// =========================

	var Carousel = function Carousel(element, options) {
		this.$element = $(element);
		this.$indicators = this.$element.find('.carousel-indicators');
		this.options = options;
		this.paused = null;
		this.sliding = null;
		this.interval = null;
		this.$active = null;
		this.$items = null;

		this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this));

		this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element.on('mouseenter.bs.carousel', $.proxy(this.pause, this)).on('mouseleave.bs.carousel', $.proxy(this.cycle, this));
	};

	Carousel.VERSION = '3.3.7';

	Carousel.TRANSITION_DURATION = 600;

	Carousel.DEFAULTS = {
		interval: 5000,
		pause: 'hover',
		wrap: true,
		keyboard: true
	};

	Carousel.prototype.keydown = function (e) {
		if (/input|textarea/i.test(e.target.tagName)) return;
		switch (e.which) {
			case 37:
				this.prev();break;
			case 39:
				this.next();break;
			default:
				return;
		}

		e.preventDefault();
	};

	Carousel.prototype.cycle = function (e) {
		e || (this.paused = false);

		this.interval && clearInterval(this.interval);

		this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));

		return this;
	};

	Carousel.prototype.getItemIndex = function (item) {
		this.$items = item.parent().children('.item');
		return this.$items.index(item || this.$active);
	};

	Carousel.prototype.getItemForDirection = function (direction, active) {
		var activeIndex = this.getItemIndex(active);
		var willWrap = direction == 'prev' && activeIndex === 0 || direction == 'next' && activeIndex == this.$items.length - 1;
		if (willWrap && !this.options.wrap) return active;
		var delta = direction == 'prev' ? -1 : 1;
		var itemIndex = (activeIndex + delta) % this.$items.length;
		return this.$items.eq(itemIndex);
	};

	Carousel.prototype.to = function (pos) {
		var that = this;
		var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'));

		if (pos > this.$items.length - 1 || pos < 0) return;

		if (this.sliding) return this.$element.one('slid.bs.carousel', function () {
			that.to(pos);
		}); // yes, "slid"
		if (activeIndex == pos) return this.pause().cycle();

		return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos));
	};

	Carousel.prototype.pause = function (e) {
		e || (this.paused = true);

		if (this.$element.find('.next, .prev').length && $.support.transition) {
			this.$element.trigger($.support.transition.end);
			this.cycle(true);
		}

		this.interval = clearInterval(this.interval);

		return this;
	};

	Carousel.prototype.next = function () {
		if (this.sliding) return;
		return this.slide('next');
	};

	Carousel.prototype.prev = function () {
		if (this.sliding) return;
		return this.slide('prev');
	};

	Carousel.prototype.slide = function (type, next) {
		var $active = this.$element.find('.item.active');
		var $next = next || this.getItemForDirection(type, $active);
		var isCycling = this.interval;
		var direction = type == 'next' ? 'left' : 'right';
		var that = this;

		if ($next.hasClass('active')) return this.sliding = false;

		var relatedTarget = $next[0];
		var slideEvent = $.Event('slide.bs.carousel', {
			relatedTarget: relatedTarget,
			direction: direction
		});
		this.$element.trigger(slideEvent);
		if (slideEvent.isDefaultPrevented()) return;

		this.sliding = true;

		isCycling && this.pause();

		if (this.$indicators.length) {
			this.$indicators.find('.active').removeClass('active');
			var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
			$nextIndicator && $nextIndicator.addClass('active');
		}

		var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }); // yes, "slid"
		if ($.support.transition && this.$element.hasClass('slide')) {
			$next.addClass(type);
			$next[0].offsetWidth; // force reflow
			$active.addClass(direction);
			$next.addClass(direction);
			$active.one('bsTransitionEnd', function () {
				$next.removeClass([type, direction].join(' ')).addClass('active');
				$active.removeClass(['active', direction].join(' '));
				that.sliding = false;
				setTimeout(function () {
					that.$element.trigger(slidEvent);
				}, 0);
			}).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
		} else {
			$active.removeClass('active');
			$next.addClass('active');
			this.sliding = false;
			this.$element.trigger(slidEvent);
		}

		isCycling && this.cycle();

		return this;
	};

	// CAROUSEL PLUGIN DEFINITION
	// ==========================

	function Plugin(option) {
		return this.each(function () {
			var $this = $(this);
			var data = $this.data('bs.carousel');
			var options = $.extend({}, Carousel.DEFAULTS, $this.data(), (typeof option === "undefined" ? "undefined" : _typeof(option)) == 'object' && option);
			var action = typeof option == 'string' ? option : options.slide;

			if (!data) $this.data('bs.carousel', data = new Carousel(this, options));
			if (typeof option == 'number') data.to(option);else if (action) data[action]();else if (options.interval) data.pause().cycle();
		});
	}

	var old = $.fn.carousel;

	$.fn.carousel = Plugin;
	$.fn.carousel.Constructor = Carousel;

	// CAROUSEL NO CONFLICT
	// ====================

	$.fn.carousel.noConflict = function () {
		$.fn.carousel = old;
		return this;
	};

	// CAROUSEL DATA-API
	// =================

	var clickHandler = function clickHandler(e) {
		var href;
		var $this = $(this);
		var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7
		if (!$target.hasClass('carousel')) return;
		var options = $.extend({}, $target.data(), $this.data());
		var slideIndex = $this.attr('data-slide-to');
		if (slideIndex) options.interval = false;

		Plugin.call($target, options);

		if (slideIndex) {
			$target.data('bs.carousel').to(slideIndex);
		}

		e.preventDefault();
	};

	$(document).on('click.bs.carousel.data-api', '[data-slide]', clickHandler).on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler);

	$(window).on('load', function () {
		$('[data-ride="carousel"]').each(function () {
			var $carousel = $(this);
			Plugin.call($carousel, $carousel.data());
		});
	});
}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.3.7
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

/* jshint latedef: false */

+function ($) {
	'use strict';

	// COLLAPSE PUBLIC CLASS DEFINITION
	// ================================

	var Collapse = function Collapse(element, options) {
		this.$element = $(element);
		this.options = $.extend({}, Collapse.DEFAULTS, options);
		this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
		this.transitioning = null;

		if (this.options.parent) {
			this.$parent = this.getParent();
		} else {
			this.addAriaAndCollapsedClass(this.$element, this.$trigger);
		}

		if (this.options.toggle) this.toggle();
	};

	Collapse.VERSION = '3.3.7';

	Collapse.TRANSITION_DURATION = 350;

	Collapse.DEFAULTS = {
		toggle: true
	};

	Collapse.prototype.dimension = function () {
		var hasWidth = this.$element.hasClass('width');
		return hasWidth ? 'width' : 'height';
	};

	Collapse.prototype.show = function () {
		if (this.transitioning || this.$element.hasClass('in')) return;

		var activesData;
		var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing');

		if (actives && actives.length) {
			activesData = actives.data('bs.collapse');
			if (activesData && activesData.transitioning) return;
		}

		var startEvent = $.Event('show.bs.collapse');
		this.$element.trigger(startEvent);
		if (startEvent.isDefaultPrevented()) return;

		if (actives && actives.length) {
			Plugin.call(actives, 'hide');
			activesData || actives.data('bs.collapse', null);
		}

		var dimension = this.dimension();

		this.$element.removeClass('collapse').addClass('collapsing')[dimension](0).attr('aria-expanded', true);

		this.$trigger.removeClass('collapsed').attr('aria-expanded', true);

		this.transitioning = 1;

		var complete = function complete() {
			this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('');
			this.transitioning = 0;
			this.$element.trigger('shown.bs.collapse');
		};

		if (!$.support.transition) return complete.call(this);

		var scrollSize = $.camelCase(['scroll', dimension].join('-'));

		this.$element.one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
	};

	Collapse.prototype.hide = function () {
		if (this.transitioning || !this.$element.hasClass('in')) return;

		var startEvent = $.Event('hide.bs.collapse');
		this.$element.trigger(startEvent);
		if (startEvent.isDefaultPrevented()) return;

		var dimension = this.dimension();

		this.$element[dimension](this.$element[dimension]())[0].offsetHeight;

		this.$element.addClass('collapsing').removeClass('collapse in').attr('aria-expanded', false);

		this.$trigger.addClass('collapsed').attr('aria-expanded', false);

		this.transitioning = 1;

		var complete = function complete() {
			this.transitioning = 0;
			this.$element.removeClass('collapsing').addClass('collapse').trigger('hidden.bs.collapse');
		};

		if (!$.support.transition) return complete.call(this);

		this.$element[dimension](0).one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
	};

	Collapse.prototype.toggle = function () {
		this[this.$element.hasClass('in') ? 'hide' : 'show']();
	};

	Collapse.prototype.getParent = function () {
		return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function (i, element) {
			var $element = $(element);
			this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
		}, this)).end();
	};

	Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
		var isOpen = $element.hasClass('in');

		$element.attr('aria-expanded', isOpen);
		$trigger.toggleClass('collapsed', !isOpen).attr('aria-expanded', isOpen);
	};

	function getTargetFromTrigger($trigger) {
		var href;
		var target = $trigger.attr('data-target') || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''); // strip for ie7

		return $(target);
	}

	// COLLAPSE PLUGIN DEFINITION
	// ==========================

	function Plugin(option) {
		return this.each(function () {
			var $this = $(this);
			var data = $this.data('bs.collapse');
			var options = $.extend({}, Collapse.DEFAULTS, $this.data(), (typeof option === "undefined" ? "undefined" : _typeof(option)) == 'object' && option);

			if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false;
			if (!data) $this.data('bs.collapse', data = new Collapse(this, options));
			if (typeof option == 'string') data[option]();
		});
	}

	var old = $.fn.collapse;

	$.fn.collapse = Plugin;
	$.fn.collapse.Constructor = Collapse;

	// COLLAPSE NO CONFLICT
	// ====================

	$.fn.collapse.noConflict = function () {
		$.fn.collapse = old;
		return this;
	};

	// COLLAPSE DATA-API
	// =================

	$(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
		var $this = $(this);

		if (!$this.attr('data-target')) e.preventDefault();

		var $target = getTargetFromTrigger($this);
		var data = $target.data('bs.collapse');
		var option = data ? 'toggle' : $this.data();

		Plugin.call($target, option);
	});
}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.7
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
	'use strict';

	// DROPDOWN CLASS DEFINITION
	// =========================

	var backdrop = '.dropdown-backdrop';
	var toggle = '[data-toggle="dropdown"]';
	var Dropdown = function Dropdown(element) {
		$(element).on('click.bs.dropdown', this.toggle);
	};

	Dropdown.VERSION = '3.3.7';

	function getParent($this) {
		var selector = $this.attr('data-target');

		if (!selector) {
			selector = $this.attr('href');
			selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
		}

		var $parent = selector && $(selector);

		return $parent && $parent.length ? $parent : $this.parent();
	}

	function clearMenus(e) {
		if (e && e.which === 3) return;
		$(backdrop).remove();
		$(toggle).each(function () {
			var $this = $(this);
			var $parent = getParent($this);
			var relatedTarget = { relatedTarget: this };

			if (!$parent.hasClass('open')) return;

			if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return;

			$parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));

			if (e.isDefaultPrevented()) return;

			$this.attr('aria-expanded', 'false');
			$parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget));
		});
	}

	Dropdown.prototype.toggle = function (e) {
		var $this = $(this);

		if ($this.is('.disabled, :disabled')) return;

		var $parent = getParent($this);
		var isActive = $parent.hasClass('open');

		clearMenus();

		if (!isActive) {
			if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
				// if mobile we use a backdrop because click events don't delegate
				$(document.createElement('div')).addClass('dropdown-backdrop').insertAfter($(this)).on('click', clearMenus);
			}

			var relatedTarget = { relatedTarget: this };
			$parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));

			if (e.isDefaultPrevented()) return;

			$this.trigger('focus').attr('aria-expanded', 'true');

			$parent.toggleClass('open').trigger($.Event('shown.bs.dropdown', relatedTarget));
		}

		return false;
	};

	Dropdown.prototype.keydown = function (e) {
		if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return;

		var $this = $(this);

		e.preventDefault();
		e.stopPropagation();

		if ($this.is('.disabled, :disabled')) return;

		var $parent = getParent($this);
		var isActive = $parent.hasClass('open');

		if (!isActive && e.which != 27 || isActive && e.which == 27) {
			if (e.which == 27) $parent.find(toggle).trigger('focus');
			return $this.trigger('click');
		}

		var desc = ' li:not(.disabled):visible a';
		var $items = $parent.find('.dropdown-menu' + desc);

		if (!$items.length) return;

		var index = $items.index(e.target);

		if (e.which == 38 && index > 0) index--; // up
		if (e.which == 40 && index < $items.length - 1) index++; // down
		if (!~index) index = 0;

		$items.eq(index).trigger('focus');
	};

	// DROPDOWN PLUGIN DEFINITION
	// ==========================

	function Plugin(option) {
		return this.each(function () {
			var $this = $(this);
			var data = $this.data('bs.dropdown');

			if (!data) $this.data('bs.dropdown', data = new Dropdown(this));
			if (typeof option == 'string') data[option].call($this);
		});
	}

	var old = $.fn.dropdown;

	$.fn.dropdown = Plugin;
	$.fn.dropdown.Constructor = Dropdown;

	// DROPDOWN NO CONFLICT
	// ====================

	$.fn.dropdown.noConflict = function () {
		$.fn.dropdown = old;
		return this;
	};

	// APPLY TO STANDARD DROPDOWN ELEMENTS
	// ===================================

	$(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function (e) {
		e.stopPropagation();
	}).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown).on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown);
}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.7
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
	'use strict';

	// MODAL CLASS DEFINITION
	// ======================

	var Modal = function Modal(element, options) {
		this.options = options;
		this.$body = $(document.body);
		this.$element = $(element);
		this.$dialog = this.$element.find('.modal-dialog');
		this.$backdrop = null;
		this.isShown = null;
		this.originalBodyPad = null;
		this.scrollbarWidth = 0;
		this.ignoreBackdropClick = false;

		if (this.options.remote) {
			this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {
				this.$element.trigger('loaded.bs.modal');
			}, this));
		}
	};

	Modal.VERSION = '3.3.7';

	Modal.TRANSITION_DURATION = 300;
	Modal.BACKDROP_TRANSITION_DURATION = 150;

	Modal.DEFAULTS = {
		backdrop: true,
		keyboard: true,
		show: true
	};

	Modal.prototype.toggle = function (_relatedTarget) {
		return this.isShown ? this.hide() : this.show(_relatedTarget);
	};

	Modal.prototype.show = function (_relatedTarget) {
		var that = this;
		var e = $.Event('show.bs.modal', { relatedTarget: _relatedTarget });

		this.$element.trigger(e);

		if (this.isShown || e.isDefaultPrevented()) return;

		this.isShown = true;

		this.checkScrollbar();
		this.setScrollbar();
		this.$body.addClass('modal-open');

		this.escape();
		this.resize();

		this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));

		this.$dialog.on('mousedown.dismiss.bs.modal', function () {
			that.$element.one('mouseup.dismiss.bs.modal', function (e) {
				if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
			});
		});

		this.backdrop(function () {
			var transition = $.support.transition && that.$element.hasClass('fade');

			if (!that.$element.parent().length) {
				that.$element.appendTo(that.$body); // don't move modals dom position
			}

			that.$element.show().scrollTop(0);

			that.adjustDialog();

			if (transition) {
				that.$element[0].offsetWidth; // force reflow
			}

			that.$element.addClass('in');

			that.enforceFocus();

			var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget });

			transition ? that.$dialog // wait for modal to slide in
			.one('bsTransitionEnd', function () {
				that.$element.trigger('focus').trigger(e);
			}).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
		});
	};

	Modal.prototype.hide = function (e) {
		if (e) e.preventDefault();

		e = $.Event('hide.bs.modal');

		this.$element.trigger(e);

		if (!this.isShown || e.isDefaultPrevented()) return;

		this.isShown = false;

		this.escape();
		this.resize();

		$(document).off('focusin.bs.modal');

		this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');

		this.$dialog.off('mousedown.dismiss.bs.modal');

		$.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
	};

	Modal.prototype.enforceFocus = function () {
		$(document).off('focusin.bs.modal') // guard against infinite focus loop
		.on('focusin.bs.modal', $.proxy(function (e) {
			if (document !== e.target && this.$element[0] !== e.target && !this.$element.has(e.target).length) {
				this.$element.trigger('focus');
			}
		}, this));
	};

	Modal.prototype.escape = function () {
		if (this.isShown && this.options.keyboard) {
			this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
				e.which == 27 && this.hide();
			}, this));
		} else if (!this.isShown) {
			this.$element.off('keydown.dismiss.bs.modal');
		}
	};

	Modal.prototype.resize = function () {
		if (this.isShown) {
			$(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
		} else {
			$(window).off('resize.bs.modal');
		}
	};

	Modal.prototype.hideModal = function () {
		var that = this;
		this.$element.hide();
		this.backdrop(function () {
			that.$body.removeClass('modal-open');
			that.resetAdjustments();
			that.resetScrollbar();
			that.$element.trigger('hidden.bs.modal');
		});
	};

	Modal.prototype.removeBackdrop = function () {
		this.$backdrop && this.$backdrop.remove();
		this.$backdrop = null;
	};

	Modal.prototype.backdrop = function (callback) {
		var that = this;
		var animate = this.$element.hasClass('fade') ? 'fade' : '';

		if (this.isShown && this.options.backdrop) {
			var doAnimate = $.support.transition && animate;

			this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);

			this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
				if (this.ignoreBackdropClick) {
					this.ignoreBackdropClick = false;
					return;
				}
				if (e.target !== e.currentTarget) return;
				this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
			}, this));

			if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow

			this.$backdrop.addClass('in');

			if (!callback) return;

			doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
		} else if (!this.isShown && this.$backdrop) {
			this.$backdrop.removeClass('in');

			var callbackRemove = function callbackRemove() {
				that.removeBackdrop();
				callback && callback();
			};
			$.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
		} else if (callback) {
			callback();
		}
	};

	// these following methods are used to handle overflowing modals

	Modal.prototype.handleUpdate = function () {
		this.adjustDialog();
	};

	Modal.prototype.adjustDialog = function () {
		var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;

		this.$element.css({
			paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
			paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
		});
	};

	Modal.prototype.resetAdjustments = function () {
		this.$element.css({
			paddingLeft: '',
			paddingRight: ''
		});
	};

	Modal.prototype.checkScrollbar = function () {
		var fullWindowWidth = window.innerWidth;
		if (!fullWindowWidth) {
			// workaround for missing window.innerWidth in IE8
			var documentElementRect = document.documentElement.getBoundingClientRect();
			fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
		}
		this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
		this.scrollbarWidth = this.measureScrollbar();
	};

	Modal.prototype.setScrollbar = function () {
		var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);
		this.originalBodyPad = document.body.style.paddingRight || '';
		if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
	};

	Modal.prototype.resetScrollbar = function () {
		this.$body.css('padding-right', this.originalBodyPad);
	};

	Modal.prototype.measureScrollbar = function () {
		// thx walsh
		var scrollDiv = document.createElement('div');
		scrollDiv.className = 'modal-scrollbar-measure';
		this.$body.append(scrollDiv);
		var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
		this.$body[0].removeChild(scrollDiv);
		return scrollbarWidth;
	};

	// MODAL PLUGIN DEFINITION
	// =======================

	function Plugin(option, _relatedTarget) {
		return this.each(function () {
			var $this = $(this);
			var data = $this.data('bs.modal');
			var options = $.extend({}, Modal.DEFAULTS, $this.data(), (typeof option === "undefined" ? "undefined" : _typeof(option)) == 'object' && option);

			if (!data) $this.data('bs.modal', data = new Modal(this, options));
			if (typeof option == 'string') data[option](_relatedTarget);else if (options.show) data.show(_relatedTarget);
		});
	}

	var old = $.fn.modal;

	$.fn.modal = Plugin;
	$.fn.modal.Constructor = Modal;

	// MODAL NO CONFLICT
	// =================

	$.fn.modal.noConflict = function () {
		$.fn.modal = old;
		return this;
	};

	// MODAL DATA-API
	// ==============

	$(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
		var $this = $(this);
		var href = $this.attr('href');
		var $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7
		var option = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());

		if ($this.is('a')) e.preventDefault();

		$target.one('show.bs.modal', function (showEvent) {
			if (showEvent.isDefaultPrevented()) return; // only register focus restorer if modal will actually get shown
			$target.one('hidden.bs.modal', function () {
				$this.is(':visible') && $this.trigger('focus');
			});
		});
		Plugin.call($target, option, this);
	});
}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.3.7
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
	'use strict';

	// TOOLTIP PUBLIC CLASS DEFINITION
	// ===============================

	var Tooltip = function Tooltip(element, options) {
		this.type = null;
		this.options = null;
		this.enabled = null;
		this.timeout = null;
		this.hoverState = null;
		this.$element = null;
		this.inState = null;

		this.init('tooltip', element, options);
	};

	Tooltip.VERSION = '3.3.7';

	Tooltip.TRANSITION_DURATION = 150;

	Tooltip.DEFAULTS = {
		animation: true,
		placement: 'top',
		selector: false,
		template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
		trigger: 'hover focus',
		title: '',
		delay: 0,
		html: false,
		container: false,
		viewport: {
			selector: 'body',
			padding: 0
		}
	};

	Tooltip.prototype.init = function (type, element, options) {
		this.enabled = true;
		this.type = type;
		this.$element = $(element);
		this.options = this.getOptions(options);
		this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport);
		this.inState = { click: false, hover: false, focus: false };

		if (this.$element[0] instanceof document.constructor && !this.options.selector) {
			throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!');
		}

		var triggers = this.options.trigger.split(' ');

		for (var i = triggers.length; i--;) {
			var trigger = triggers[i];

			if (trigger == 'click') {
				this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
			} else if (trigger != 'manual') {
				var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
				var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';

				this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
				this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
			}
		}

		this.options.selector ? this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' }) : this.fixTitle();
	};

	Tooltip.prototype.getDefaults = function () {
		return Tooltip.DEFAULTS;
	};

	Tooltip.prototype.getOptions = function (options) {
		options = $.extend({}, this.getDefaults(), this.$element.data(), options);

		if (options.delay && typeof options.delay == 'number') {
			options.delay = {
				show: options.delay,
				hide: options.delay
			};
		}

		return options;
	};

	Tooltip.prototype.getDelegateOptions = function () {
		var options = {};
		var defaults = this.getDefaults();

		this._options && $.each(this._options, function (key, value) {
			if (defaults[key] != value) options[key] = value;
		});

		return options;
	};

	Tooltip.prototype.enter = function (obj) {
		var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

		if (!self) {
			self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
			$(obj.currentTarget).data('bs.' + this.type, self);
		}

		if (obj instanceof $.Event) {
			self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true;
		}

		if (self.tip().hasClass('in') || self.hoverState == 'in') {
			self.hoverState = 'in';
			return;
		}

		clearTimeout(self.timeout);

		self.hoverState = 'in';

		if (!self.options.delay || !self.options.delay.show) return self.show();

		self.timeout = setTimeout(function () {
			if (self.hoverState == 'in') self.show();
		}, self.options.delay.show);
	};

	Tooltip.prototype.isInStateTrue = function () {
		for (var key in this.inState) {
			if (this.inState[key]) return true;
		}

		return false;
	};

	Tooltip.prototype.leave = function (obj) {
		var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

		if (!self) {
			self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
			$(obj.currentTarget).data('bs.' + this.type, self);
		}

		if (obj instanceof $.Event) {
			self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false;
		}

		if (self.isInStateTrue()) return;

		clearTimeout(self.timeout);

		self.hoverState = 'out';

		if (!self.options.delay || !self.options.delay.hide) return self.hide();

		self.timeout = setTimeout(function () {
			if (self.hoverState == 'out') self.hide();
		}, self.options.delay.hide);
	};

	Tooltip.prototype.show = function () {
		var e = $.Event('show.bs.' + this.type);

		if (this.hasContent() && this.enabled) {
			this.$element.trigger(e);

			var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
			if (e.isDefaultPrevented() || !inDom) return;
			var that = this;

			var $tip = this.tip();

			var tipId = this.getUID(this.type);

			this.setContent();
			$tip.attr('id', tipId);
			this.$element.attr('aria-describedby', tipId);

			if (this.options.animation) $tip.addClass('fade');

			var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;

			var autoToken = /\s?auto?\s?/i;
			var autoPlace = autoToken.test(placement);
			if (autoPlace) placement = placement.replace(autoToken, '') || 'top';

			$tip.detach().css({ top: 0, left: 0, display: 'block' }).addClass(placement).data('bs.' + this.type, this);

			this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
			this.$element.trigger('inserted.bs.' + this.type);

			var pos = this.getPosition();
			var actualWidth = $tip[0].offsetWidth;
			var actualHeight = $tip[0].offsetHeight;

			if (autoPlace) {
				var orgPlacement = placement;
				var viewportDim = this.getPosition(this.$viewport);

				placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' : placement;

				$tip.removeClass(orgPlacement).addClass(placement);
			}

			var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);

			this.applyPlacement(calculatedOffset, placement);

			var complete = function complete() {
				var prevHoverState = that.hoverState;
				that.$element.trigger('shown.bs.' + that.type);
				that.hoverState = null;

				if (prevHoverState == 'out') that.leave(that);
			};

			$.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
		}
	};

	Tooltip.prototype.applyPlacement = function (offset, placement) {
		var $tip = this.tip();
		var width = $tip[0].offsetWidth;
		var height = $tip[0].offsetHeight;

		// manually read margins because getBoundingClientRect includes difference
		var marginTop = parseInt($tip.css('margin-top'), 10);
		var marginLeft = parseInt($tip.css('margin-left'), 10);

		// we must check for NaN for ie 8/9
		if (isNaN(marginTop)) marginTop = 0;
		if (isNaN(marginLeft)) marginLeft = 0;

		offset.top += marginTop;
		offset.left += marginLeft;

		// $.fn.offset doesn't round pixel values
		// so we use setOffset directly with our own function B-0
		$.offset.setOffset($tip[0], $.extend({
			using: function using(props) {
				$tip.css({
					top: Math.round(props.top),
					left: Math.round(props.left)
				});
			}
		}, offset), 0);

		$tip.addClass('in');

		// check to see if placing tip in new offset caused the tip to resize itself
		var actualWidth = $tip[0].offsetWidth;
		var actualHeight = $tip[0].offsetHeight;

		if (placement == 'top' && actualHeight != height) {
			offset.top = offset.top + height - actualHeight;
		}

		var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);

		if (delta.left) offset.left += delta.left;else offset.top += delta.top;

		var isVertical = /top|bottom/.test(placement);
		var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
		var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';

		$tip.offset(offset);
		this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
	};

	Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
		this.arrow().css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isVertical ? 'top' : 'left', '');
	};

	Tooltip.prototype.setContent = function () {
		var $tip = this.tip();
		var title = this.getTitle();

		$tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
		$tip.removeClass('fade in top bottom left right');
	};

	Tooltip.prototype.hide = function (callback) {
		var that = this;
		var $tip = $(this.$tip);
		var e = $.Event('hide.bs.' + this.type);

		function complete() {
			if (that.hoverState != 'in') $tip.detach();
			if (that.$element) {
				// TODO: Check whether guarding this code with this `if` is really necessary.
				that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type);
			}
			callback && callback();
		}

		this.$element.trigger(e);

		if (e.isDefaultPrevented()) return;

		$tip.removeClass('in');

		$.support.transition && $tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();

		this.hoverState = null;

		return this;
	};

	Tooltip.prototype.fixTitle = function () {
		var $e = this.$element;
		if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
			$e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
		}
	};

	Tooltip.prototype.hasContent = function () {
		return this.getTitle();
	};

	Tooltip.prototype.getPosition = function ($element) {
		$element = $element || this.$element;

		var el = $element[0];
		var isBody = el.tagName == 'BODY';

		var elRect = el.getBoundingClientRect();
		if (elRect.width == null) {
			// width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
			elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });
		}
		var isSvg = window.SVGElement && el instanceof window.SVGElement;
		// Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
		// See https://github.com/twbs/bootstrap/issues/20280
		var elOffset = isBody ? { top: 0, left: 0 } : isSvg ? null : $element.offset();
		var scroll = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() };
		var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null;

		return $.extend({}, elRect, scroll, outerDims, elOffset);
	};

	Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
		return placement == 'bottom' ? { top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == 'top' ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == 'left' ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
		/* placement == 'right' */{ top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width };
	};

	Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
		var delta = { top: 0, left: 0 };
		if (!this.$viewport) return delta;

		var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
		var viewportDimensions = this.getPosition(this.$viewport);

		if (/right|left/.test(placement)) {
			var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
			var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
			if (topEdgeOffset < viewportDimensions.top) {
				// top overflow
				delta.top = viewportDimensions.top - topEdgeOffset;
			} else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
				// bottom overflow
				delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
			}
		} else {
			var leftEdgeOffset = pos.left - viewportPadding;
			var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
			if (leftEdgeOffset < viewportDimensions.left) {
				// left overflow
				delta.left = viewportDimensions.left - leftEdgeOffset;
			} else if (rightEdgeOffset > viewportDimensions.right) {
				// right overflow
				delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
			}
		}

		return delta;
	};

	Tooltip.prototype.getTitle = function () {
		var title;
		var $e = this.$element;
		var o = this.options;

		title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);

		return title;
	};

	Tooltip.prototype.getUID = function (prefix) {
		do {
			prefix += ~~(Math.random() * 1000000);
		} while (document.getElementById(prefix));
		return prefix;
	};

	Tooltip.prototype.tip = function () {
		if (!this.$tip) {
			this.$tip = $(this.options.template);
			if (this.$tip.length != 1) {
				throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!');
			}
		}
		return this.$tip;
	};

	Tooltip.prototype.arrow = function () {
		return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow');
	};

	Tooltip.prototype.enable = function () {
		this.enabled = true;
	};

	Tooltip.prototype.disable = function () {
		this.enabled = false;
	};

	Tooltip.prototype.toggleEnabled = function () {
		this.enabled = !this.enabled;
	};

	Tooltip.prototype.toggle = function (e) {
		var self = this;
		if (e) {
			self = $(e.currentTarget).data('bs.' + this.type);
			if (!self) {
				self = new this.constructor(e.currentTarget, this.getDelegateOptions());
				$(e.currentTarget).data('bs.' + this.type, self);
			}
		}

		if (e) {
			self.inState.click = !self.inState.click;
			if (self.isInStateTrue()) self.enter(self);else self.leave(self);
		} else {
			self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
		}
	};

	Tooltip.prototype.destroy = function () {
		var that = this;
		clearTimeout(this.timeout);
		this.hide(function () {
			that.$element.off('.' + that.type).removeData('bs.' + that.type);
			if (that.$tip) {
				that.$tip.detach();
			}
			that.$tip = null;
			that.$arrow = null;
			that.$viewport = null;
			that.$element = null;
		});
	};

	// TOOLTIP PLUGIN DEFINITION
	// =========================

	function Plugin(option) {
		return this.each(function () {
			var $this = $(this);
			var data = $this.data('bs.tooltip');
			var options = (typeof option === "undefined" ? "undefined" : _typeof(option)) == 'object' && option;

			if (!data && /destroy|hide/.test(option)) return;
			if (!data) $this.data('bs.tooltip', data = new Tooltip(this, options));
			if (typeof option == 'string') data[option]();
		});
	}

	var old = $.fn.tooltip;

	$.fn.tooltip = Plugin;
	$.fn.tooltip.Constructor = Tooltip;

	// TOOLTIP NO CONFLICT
	// ===================

	$.fn.tooltip.noConflict = function () {
		$.fn.tooltip = old;
		return this;
	};
}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.7
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
	'use strict';

	// POPOVER PUBLIC CLASS DEFINITION
	// ===============================

	var Popover = function Popover(element, options) {
		this.init('popover', element, options);
	};

	if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js');

	Popover.VERSION = '3.3.7';

	Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
		placement: 'right',
		trigger: 'click',
		content: '',
		template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
	});

	// NOTE: POPOVER EXTENDS tooltip.js
	// ================================

	Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);

	Popover.prototype.constructor = Popover;

	Popover.prototype.getDefaults = function () {
		return Popover.DEFAULTS;
	};

	Popover.prototype.setContent = function () {
		var $tip = this.tip();
		var title = this.getTitle();
		var content = this.getContent();

		$tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
		$tip.find('.popover-content').children().detach().end()[// we use append for html objects to maintain js events
		this.options.html ? typeof content == 'string' ? 'html' : 'append' : 'text'](content);

		$tip.removeClass('fade top bottom left right in');

		// IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
		// this manually by checking the contents.
		if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide();
	};

	Popover.prototype.hasContent = function () {
		return this.getTitle() || this.getContent();
	};

	Popover.prototype.getContent = function () {
		var $e = this.$element;
		var o = this.options;

		return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);
	};

	Popover.prototype.arrow = function () {
		return this.$arrow = this.$arrow || this.tip().find('.arrow');
	};

	// POPOVER PLUGIN DEFINITION
	// =========================

	function Plugin(option) {
		return this.each(function () {
			var $this = $(this);
			var data = $this.data('bs.popover');
			var options = (typeof option === "undefined" ? "undefined" : _typeof(option)) == 'object' && option;

			if (!data && /destroy|hide/.test(option)) return;
			if (!data) $this.data('bs.popover', data = new Popover(this, options));
			if (typeof option == 'string') data[option]();
		});
	}

	var old = $.fn.popover;

	$.fn.popover = Plugin;
	$.fn.popover.Constructor = Popover;

	// POPOVER NO CONFLICT
	// ===================

	$.fn.popover.noConflict = function () {
		$.fn.popover = old;
		return this;
	};
}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.7
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
	'use strict';

	// SCROLLSPY CLASS DEFINITION
	// ==========================

	function ScrollSpy(element, options) {
		this.$body = $(document.body);
		this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
		this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
		this.selector = (this.options.target || '') + ' .nav li > a';
		this.offsets = [];
		this.targets = [];
		this.activeTarget = null;
		this.scrollHeight = 0;

		this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this));
		this.refresh();
		this.process();
	}

	ScrollSpy.VERSION = '3.3.7';

	ScrollSpy.DEFAULTS = {
		offset: 10
	};

	ScrollSpy.prototype.getScrollHeight = function () {
		return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
	};

	ScrollSpy.prototype.refresh = function () {
		var that = this;
		var offsetMethod = 'offset';
		var offsetBase = 0;

		this.offsets = [];
		this.targets = [];
		this.scrollHeight = this.getScrollHeight();

		if (!$.isWindow(this.$scrollElement[0])) {
			offsetMethod = 'position';
			offsetBase = this.$scrollElement.scrollTop();
		}

		this.$body.find(this.selector).map(function () {
			var $el = $(this);
			var href = $el.data('target') || $el.attr('href');
			var $href = /^#./.test(href) && $(href);

			return $href && $href.length && $href.is(':visible') && [[$href[offsetMethod]().top + offsetBase, href]] || null;
		}).sort(function (a, b) {
			return a[0] - b[0];
		}).each(function () {
			that.offsets.push(this[0]);
			that.targets.push(this[1]);
		});
	};

	ScrollSpy.prototype.process = function () {
		var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
		var scrollHeight = this.getScrollHeight();
		var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
		var offsets = this.offsets;
		var targets = this.targets;
		var activeTarget = this.activeTarget;
		var i;

		if (this.scrollHeight != scrollHeight) {
			this.refresh();
		}

		if (scrollTop >= maxScroll) {
			return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
		}

		if (activeTarget && scrollTop < offsets[0]) {
			this.activeTarget = null;
			return this.clear();
		}

		for (i = offsets.length; i--;) {
			activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
		}
	};

	ScrollSpy.prototype.activate = function (target) {
		this.activeTarget = target;

		this.clear();

		var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';

		var active = $(selector).parents('li').addClass('active');

		if (active.parent('.dropdown-menu').length) {
			active = active.closest('li.dropdown').addClass('active');
		}

		active.trigger('activate.bs.scrollspy');
	};

	ScrollSpy.prototype.clear = function () {
		$(this.selector).parentsUntil(this.options.target, '.active').removeClass('active');
	};

	// SCROLLSPY PLUGIN DEFINITION
	// ===========================

	function Plugin(option) {
		return this.each(function () {
			var $this = $(this);
			var data = $this.data('bs.scrollspy');
			var options = (typeof option === "undefined" ? "undefined" : _typeof(option)) == 'object' && option;

			if (!data) $this.data('bs.scrollspy', data = new ScrollSpy(this, options));
			if (typeof option == 'string') data[option]();
		});
	}

	var old = $.fn.scrollspy;

	$.fn.scrollspy = Plugin;
	$.fn.scrollspy.Constructor = ScrollSpy;

	// SCROLLSPY NO CONFLICT
	// =====================

	$.fn.scrollspy.noConflict = function () {
		$.fn.scrollspy = old;
		return this;
	};

	// SCROLLSPY DATA-API
	// ==================

	$(window).on('load.bs.scrollspy.data-api', function () {
		$('[data-spy="scroll"]').each(function () {
			var $spy = $(this);
			Plugin.call($spy, $spy.data());
		});
	});
}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.3.7
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
	'use strict';

	// TAB CLASS DEFINITION
	// ====================

	var Tab = function Tab(element) {
		// jscs:disable requireDollarBeforejQueryAssignment
		this.element = $(element);
		// jscs:enable requireDollarBeforejQueryAssignment
	};

	Tab.VERSION = '3.3.7';

	Tab.TRANSITION_DURATION = 150;

	Tab.prototype.show = function () {
		var $this = this.element;
		var $ul = $this.closest('ul:not(.dropdown-menu)');
		var selector = $this.data('target');

		if (!selector) {
			selector = $this.attr('href');
			selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
		}

		if ($this.parent('li').hasClass('active')) return;

		var $previous = $ul.find('.active:last a');
		var hideEvent = $.Event('hide.bs.tab', {
			relatedTarget: $this[0]
		});
		var showEvent = $.Event('show.bs.tab', {
			relatedTarget: $previous[0]
		});

		$previous.trigger(hideEvent);
		$this.trigger(showEvent);

		if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;

		var $target = $(selector);

		this.activate($this.closest('li'), $ul);
		this.activate($target, $target.parent(), function () {
			$previous.trigger({
				type: 'hidden.bs.tab',
				relatedTarget: $this[0]
			});
			$this.trigger({
				type: 'shown.bs.tab',
				relatedTarget: $previous[0]
			});
		});
	};

	Tab.prototype.activate = function (element, container, callback) {
		var $active = container.find('> .active');
		var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length);

		function next() {
			$active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', false);

			element.addClass('active').find('[data-toggle="tab"]').attr('aria-expanded', true);

			if (transition) {
				element[0].offsetWidth; // reflow for transition
				element.addClass('in');
			} else {
				element.removeClass('fade');
			}

			if (element.parent('.dropdown-menu').length) {
				element.closest('li.dropdown').addClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', true);
			}

			callback && callback();
		}

		$active.length && transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();

		$active.removeClass('in');
	};

	// TAB PLUGIN DEFINITION
	// =====================

	function Plugin(option) {
		return this.each(function () {
			var $this = $(this);
			var data = $this.data('bs.tab');

			if (!data) $this.data('bs.tab', data = new Tab(this));
			if (typeof option == 'string') data[option]();
		});
	}

	var old = $.fn.tab;

	$.fn.tab = Plugin;
	$.fn.tab.Constructor = Tab;

	// TAB NO CONFLICT
	// ===============

	$.fn.tab.noConflict = function () {
		$.fn.tab = old;
		return this;
	};

	// TAB DATA-API
	// ============

	var clickHandler = function clickHandler(e) {
		e.preventDefault();
		Plugin.call($(this), 'show');
	};

	$(document).on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler).on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler);
}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.7
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
	'use strict';

	// AFFIX CLASS DEFINITION
	// ======================

	var Affix = function Affix(element, options) {
		this.options = $.extend({}, Affix.DEFAULTS, options);

		this.$target = $(this.options.target).on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this));

		this.$element = $(element);
		this.affixed = null;
		this.unpin = null;
		this.pinnedOffset = null;

		this.checkPosition();
	};

	Affix.VERSION = '3.3.7';

	Affix.RESET = 'affix affix-top affix-bottom';

	Affix.DEFAULTS = {
		offset: 0,
		target: window
	};

	Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
		var scrollTop = this.$target.scrollTop();
		var position = this.$element.offset();
		var targetHeight = this.$target.height();

		if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false;

		if (this.affixed == 'bottom') {
			if (offsetTop != null) return scrollTop + this.unpin <= position.top ? false : 'bottom';
			return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : 'bottom';
		}

		var initializing = this.affixed == null;
		var colliderTop = initializing ? scrollTop : position.top;
		var colliderHeight = initializing ? targetHeight : height;

		if (offsetTop != null && scrollTop <= offsetTop) return 'top';
		if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom) return 'bottom';

		return false;
	};

	Affix.prototype.getPinnedOffset = function () {
		if (this.pinnedOffset) return this.pinnedOffset;
		this.$element.removeClass(Affix.RESET).addClass('affix');
		var scrollTop = this.$target.scrollTop();
		var position = this.$element.offset();
		return this.pinnedOffset = position.top - scrollTop;
	};

	Affix.prototype.checkPositionWithEventLoop = function () {
		setTimeout($.proxy(this.checkPosition, this), 1);
	};

	Affix.prototype.checkPosition = function () {
		if (!this.$element.is(':visible')) return;

		var height = this.$element.height();
		var offset = this.options.offset;
		var offsetTop = offset.top;
		var offsetBottom = offset.bottom;
		var scrollHeight = Math.max($(document).height(), $(document.body).height());

		if ((typeof offset === "undefined" ? "undefined" : _typeof(offset)) != 'object') offsetBottom = offsetTop = offset;
		if (typeof offsetTop == 'function') offsetTop = offset.top(this.$element);
		if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element);

		var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);

		if (this.affixed != affix) {
			if (this.unpin != null) this.$element.css('top', '');

			var affixType = 'affix' + (affix ? '-' + affix : '');
			var e = $.Event(affixType + '.bs.affix');

			this.$element.trigger(e);

			if (e.isDefaultPrevented()) return;

			this.affixed = affix;
			this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null;

			this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace('affix', 'affixed') + '.bs.affix');
		}

		if (affix == 'bottom') {
			this.$element.offset({
				top: scrollHeight - height - offsetBottom
			});
		}
	};

	// AFFIX PLUGIN DEFINITION
	// =======================

	function Plugin(option) {
		return this.each(function () {
			var $this = $(this);
			var data = $this.data('bs.affix');
			var options = (typeof option === "undefined" ? "undefined" : _typeof(option)) == 'object' && option;

			if (!data) $this.data('bs.affix', data = new Affix(this, options));
			if (typeof option == 'string') data[option]();
		});
	}

	var old = $.fn.affix;

	$.fn.affix = Plugin;
	$.fn.affix.Constructor = Affix;

	// AFFIX NO CONFLICT
	// =================

	$.fn.affix.noConflict = function () {
		$.fn.affix = old;
		return this;
	};

	// AFFIX DATA-API
	// ==============

	$(window).on('load', function () {
		$('[data-spy="affix"]').each(function () {
			var $spy = $(this);
			var data = $spy.data();

			data.offset = data.offset || {};

			if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom;
			if (data.offsetTop != null) data.offset.top = data.offsetTop;

			Plugin.call($spy, data);
		});
	});
}(jQuery);
/*!
 * jQuery Mousewheel 3.1.12
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['jquery'], factory);
	} else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
		// Node/CommonJS style for Browserify
		module.exports = factory;
	} else {
		// Browser globals
		factory(jQuery);
	}
})(function ($) {

	var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
	    toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
	    slice = Array.prototype.slice,
	    nullLowestDeltaTimeout,
	    lowestDelta;

	if ($.event.fixHooks) {
		for (var i = toFix.length; i;) {
			$.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
		}
	}

	var special = $.event.special.mousewheel = {
		version: '3.1.12',

		setup: function setup() {
			if (this.addEventListener) {
				for (var i = toBind.length; i;) {
					this.addEventListener(toBind[--i], handler, false);
				}
			} else {
				this.onmousewheel = handler;
			}
			// Store the line height and page height for this particular element
			$.data(this, 'mousewheel-line-height', special.getLineHeight(this));
			$.data(this, 'mousewheel-page-height', special.getPageHeight(this));
		},

		teardown: function teardown() {
			if (this.removeEventListener) {
				for (var i = toBind.length; i;) {
					this.removeEventListener(toBind[--i], handler, false);
				}
			} else {
				this.onmousewheel = null;
			}
			// Clean up the data we added to the element
			$.removeData(this, 'mousewheel-line-height');
			$.removeData(this, 'mousewheel-page-height');
		},

		getLineHeight: function getLineHeight(elem) {
			var $elem = $(elem),
			    $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
			if (!$parent.length) {
				$parent = $('body');
			}
			return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
		},

		getPageHeight: function getPageHeight(elem) {
			return $(elem).height();
		},

		settings: {
			adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
			normalizeOffset: true // calls getBoundingClientRect for each event
		}
	};

	$.fn.extend({
		mousewheel: function mousewheel(fn) {
			return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
		},

		unmousewheel: function unmousewheel(fn) {
			return this.unbind('mousewheel', fn);
		}
	});

	function handler(event) {
		var orgEvent = event || window.event,
		    args = slice.call(arguments, 1),
		    delta = 0,
		    deltaX = 0,
		    deltaY = 0,
		    absDelta = 0,
		    offsetX = 0,
		    offsetY = 0;
		event = $.event.fix(orgEvent);
		event.type = 'mousewheel';

		// Old school scrollwheel delta
		if ('detail' in orgEvent) {
			deltaY = orgEvent.detail * -1;
		}
		if ('wheelDelta' in orgEvent) {
			deltaY = orgEvent.wheelDelta;
		}
		if ('wheelDeltaY' in orgEvent) {
			deltaY = orgEvent.wheelDeltaY;
		}
		if ('wheelDeltaX' in orgEvent) {
			deltaX = orgEvent.wheelDeltaX * -1;
		}

		// Firefox < 17 horizontal scrolling related to DOMMouseScroll event
		if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
			deltaX = deltaY * -1;
			deltaY = 0;
		}

		// Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
		delta = deltaY === 0 ? deltaX : deltaY;

		// New school wheel delta (wheel event)
		if ('deltaY' in orgEvent) {
			deltaY = orgEvent.deltaY * -1;
			delta = deltaY;
		}
		if ('deltaX' in orgEvent) {
			deltaX = orgEvent.deltaX;
			if (deltaY === 0) {
				delta = deltaX * -1;
			}
		}

		// No change actually happened, no reason to go any further
		if (deltaY === 0 && deltaX === 0) {
			return;
		}

		// Need to convert lines and pages to pixels if we aren't already in pixels
		// There are three delta modes:
		//   * deltaMode 0 is by pixels, nothing to do
		//   * deltaMode 1 is by lines
		//   * deltaMode 2 is by pages
		if (orgEvent.deltaMode === 1) {
			var lineHeight = $.data(this, 'mousewheel-line-height');
			delta *= lineHeight;
			deltaY *= lineHeight;
			deltaX *= lineHeight;
		} else if (orgEvent.deltaMode === 2) {
			var pageHeight = $.data(this, 'mousewheel-page-height');
			delta *= pageHeight;
			deltaY *= pageHeight;
			deltaX *= pageHeight;
		}

		// Store lowest absolute delta to normalize the delta values
		absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));

		if (!lowestDelta || absDelta < lowestDelta) {
			lowestDelta = absDelta;

			// Adjust older deltas if necessary
			if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
				lowestDelta /= 40;
			}
		}

		// Adjust older deltas if necessary
		if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
			// Divide all the things by 40!
			delta /= 40;
			deltaX /= 40;
			deltaY /= 40;
		}

		// Get a whole, normalized value for the deltas
		delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
		deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
		deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta);

		// Normalise offsetX and offsetY properties
		if (special.settings.normalizeOffset && this.getBoundingClientRect) {
			var boundingRect = this.getBoundingClientRect();
			offsetX = event.clientX - boundingRect.left;
			offsetY = event.clientY - boundingRect.top;
		}

		// Add information to the event object
		event.deltaX = deltaX;
		event.deltaY = deltaY;
		event.deltaFactor = lowestDelta;
		event.offsetX = offsetX;
		event.offsetY = offsetY;
		// Go ahead and set deltaMode to 0 since we converted to pixels
		// Although this is a little odd since we overwrite the deltaX/Y
		// properties with normalized deltas.
		event.deltaMode = 0;

		// Add event and delta to the front of the arguments
		args.unshift(event, delta, deltaX, deltaY);

		// Clearout lowestDelta after sometime to better
		// handle multiple device types that give different
		// a different lowestDelta
		// Ex: trackpad = 3 and mouse wheel = 120
		if (nullLowestDeltaTimeout) {
			clearTimeout(nullLowestDeltaTimeout);
		}
		nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

		return ($.event.dispatch || $.event.handle).apply(this, args);
	}

	function nullLowestDelta() {
		lowestDelta = null;
	}

	function shouldAdjustOldDeltas(orgEvent, absDelta) {
		// If this is an older event and the delta is divisable by 120,
		// then we are assuming that the browser is treating this as an
		// older mouse wheel event and that we should divide the deltas
		// by 40 to try and get a more usable deltaFactor.
		// Side note, this actually impacts the reported scroll distance
		// in older browsers and can cause scrolling to be slower than native.
		// Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
		return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
	}
});
/* jQuery Form Styler v1.7.8 | (c) Dimox | https://github.com/Dimox/jQueryFormStyler */
!function (e) {
	"function" == typeof define && define.amd ? define(["jquery"], e) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? module.exports = e($ || require("jquery")) : e(jQuery);
}(function (e) {
	"use strict";
	function t(t, s) {
		this.element = t, this.options = e.extend({}, l, s);var i = this.options.locale;void 0 !== this.options.locales[i] && e.extend(this.options, this.options.locales[i]), this.init();
	}function s(t) {
		if (!e(t.target).parents().hasClass("jq-selectbox") && "OPTION" != t.target.nodeName && e("div.jq-selectbox.opened").length) {
			var s = e("div.jq-selectbox.opened"),
			    l = e("div.jq-selectbox__search input", s),
			    o = e("div.jq-selectbox__dropdown", s),
			    a = s.find("select").data("_" + i).options;a.onSelectClosed.call(s), l.length && l.val("").keyup(), o.hide().find("li.sel").addClass("selected"), s.removeClass("focused opened dropup dropdown");
		}
	}var i = "styler",
	    l = { idSuffix: "-styler", filePlaceholder: "  ", fileBrowse: "...", fileNumber: " : %s", selectPlaceholder: "...", selectSearch: !1, selectSearchLimit: 10, selectSearchNotFound: "  ", selectSearchPlaceholder: "...", selectVisibleOptions: 0, singleSelectzIndex: "100", selectSmartPositioning: !0, locale: "ru", locales: { en: { filePlaceholder: "No file selected", fileBrowse: "Browse...", fileNumber: "Selected files: %s", selectPlaceholder: "Select...", selectSearchNotFound: "No matches found", selectSearchPlaceholder: "Search..." } }, onSelectOpened: function onSelectOpened() {}, onSelectClosed: function onSelectClosed() {}, onFormStyled: function onFormStyled() {} };t.prototype = { init: function init() {
			function t() {
				void 0 !== i.attr("id") && "" !== i.attr("id") && (this.id = i.attr("id") + l.idSuffix), this.title = i.attr("title"), this.classes = i.attr("class"), this.data = i.data();
			}var i = e(this.element),
			    l = this.options,
			    o = !(!navigator.userAgent.match(/(iPad|iPhone|iPod)/i) || navigator.userAgent.match(/(Windows\sPhone)/i)),
			    a = !(!navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/(Windows\sPhone)/i));if (i.is(":checkbox")) {
				var d = function d() {
					var s = new t(),
					    l = e('<div class="jq-checkbox"><div class="jq-checkbox__div"></div></div>').attr({ id: s.id, title: s.title }).addClass(s.classes).data(s.data);i.css({ position: "absolute", zIndex: "-1", opacity: 0, margin: 0, padding: 0 }).after(l).prependTo(l), l.attr("unselectable", "on").css({ "-webkit-user-select": "none", "-moz-user-select": "none", "-ms-user-select": "none", "-o-user-select": "none", "user-select": "none", display: "inline-block", position: "relative", overflow: "hidden" }), i.is(":checked") && l.addClass("checked"), i.is(":disabled") && l.addClass("disabled"), l.click(function (e) {
						e.preventDefault(), l.is(".disabled") || (i.is(":checked") ? (i.prop("checked", !1), l.removeClass("checked")) : (i.prop("checked", !0), l.addClass("checked")), i.focus().change());
					}), i.closest("label").add('label[for="' + i.attr("id") + '"]').on("click.styler", function (t) {
						e(t.target).is("a") || e(t.target).closest(l).length || (l.triggerHandler("click"), t.preventDefault());
					}), i.on("change.styler", function () {
						i.is(":checked") ? l.addClass("checked") : l.removeClass("checked");
					}).on("keydown.styler", function (e) {
						32 == e.which && l.click();
					}).on("focus.styler", function () {
						l.is(".disabled") || l.addClass("focused");
					}).on("blur.styler", function () {
						l.removeClass("focused");
					});
				};d(), i.on("refresh", function () {
					i.closest("label").add('label[for="' + i.attr("id") + '"]').off(".styler"), i.off(".styler").parent().before(i).remove(), d();
				});
			} else if (i.is(":radio")) {
				var r = function r() {
					var s = new t(),
					    l = e('<div class="jq-radio"><div class="jq-radio__div"></div></div>').attr({ id: s.id, title: s.title }).addClass(s.classes).data(s.data);i.css({ position: "absolute", zIndex: "-1", opacity: 0, margin: 0, padding: 0 }).after(l).prependTo(l), l.attr("unselectable", "on").css({ "-webkit-user-select": "none", "-moz-user-select": "none", "-ms-user-select": "none", "-o-user-select": "none", "user-select": "none", display: "inline-block", position: "relative" }), i.is(":checked") && l.addClass("checked"), i.is(":disabled") && l.addClass("disabled"), e.fn.commonParents = function () {
						var t = this;return t.first().parents().filter(function () {
							return e(this).find(t).length === t.length;
						});
					}, e.fn.commonParent = function () {
						return e(this).commonParents().first();
					}, l.click(function (t) {
						if (t.preventDefault(), !l.is(".disabled")) {
							var s = e('input[name="' + i.attr("name") + '"]');s.commonParent().find(s).prop("checked", !1).parent().removeClass("checked"), i.prop("checked", !0).parent().addClass("checked"), i.focus().change();
						}
					}), i.closest("label").add('label[for="' + i.attr("id") + '"]').on("click.styler", function (t) {
						e(t.target).is("a") || e(t.target).closest(l).length || (l.triggerHandler("click"), t.preventDefault());
					}), i.on("change.styler", function () {
						i.parent().addClass("checked");
					}).on("focus.styler", function () {
						l.is(".disabled") || l.addClass("focused");
					}).on("blur.styler", function () {
						l.removeClass("focused");
					});
				};r(), i.on("refresh", function () {
					i.closest("label").add('label[for="' + i.attr("id") + '"]').off(".styler"), i.off(".styler").parent().before(i).remove(), r();
				});
			} else if (i.is(":file")) {
				i.css({ position: "absolute", top: 0, right: 0, margin: 0, padding: 0, opacity: 0, fontSize: "100px" });var n = function n() {
					var s = new t(),
					    o = i.data("placeholder");void 0 === o && (o = l.filePlaceholder);var a = i.data("browse");void 0 !== a && "" !== a || (a = l.fileBrowse);var d = e('<div class="jq-file"><div class="jq-file__name">' + o + '</div><div class="jq-file__browse">' + a + "</div></div>").css({ display: "inline-block", position: "relative", overflow: "hidden" }).attr({ id: s.id, title: s.title }).addClass(s.classes).data(s.data);i.after(d).appendTo(d), i.is(":disabled") && d.addClass("disabled"), i.on("change.styler", function () {
						var t = i.val(),
						    s = e("div.jq-file__name", d);if (i.is("[multiple]")) {
							t = "";var a = i[0].files.length;if (a > 0) {
								var r = i.data("number");void 0 === r && (r = l.fileNumber), r = r.replace("%s", a), t = r;
							}
						}s.text(t.replace(/.+[\\\/]/, "")), "" === t ? (s.text(o), d.removeClass("changed")) : d.addClass("changed");
					}).on("focus.styler", function () {
						d.addClass("focused");
					}).on("blur.styler", function () {
						d.removeClass("focused");
					}).on("click.styler", function () {
						d.removeClass("focused");
					});
				};n(), i.on("refresh", function () {
					i.off(".styler").parent().before(i).remove(), n();
				});
			} else if (i.is('input[type="number"]')) {
				var c = function c() {
					var s = new t(),
					    l = e('<div class="jq-number"><div class="jq-number__spin minus"></div><div class="jq-number__spin plus"></div></div>').attr({ id: s.id, title: s.title }).addClass(s.classes).data(s.data);i.after(l).prependTo(l).wrap('<div class="jq-number__field"></div>'), i.is(":disabled") && l.addClass("disabled");var o,
					    a,
					    d,
					    r = null,
					    n = null;void 0 !== i.attr("min") && (o = i.attr("min")), void 0 !== i.attr("max") && (a = i.attr("max")), d = void 0 !== i.attr("step") && e.isNumeric(i.attr("step")) ? Number(i.attr("step")) : Number(1);var c = function c(t) {
						var s,
						    l = i.val();e.isNumeric(l) || (l = 0, i.val("0")), t.is(".minus") ? s = Number(l) - d : t.is(".plus") && (s = Number(l) + d);var r = (d.toString().split(".")[1] || []).length;if (r > 0) {
							for (var n = "1"; n.length <= r;) {
								n += "0";
							}s = Math.round(s * n) / n;
						}e.isNumeric(o) && e.isNumeric(a) ? s >= o && a >= s && i.val(s) : e.isNumeric(o) && !e.isNumeric(a) ? s >= o && i.val(s) : !e.isNumeric(o) && e.isNumeric(a) ? a >= s && i.val(s) : i.val(s);
					};l.is(".disabled") || (l.on("mousedown", "div.jq-number__spin", function () {
						var t = e(this);c(t), r = setTimeout(function () {
							n = setInterval(function () {
								c(t);
							}, 40);
						}, 350);
					}).on("mouseup mouseout", "div.jq-number__spin", function () {
						clearTimeout(r), clearInterval(n);
					}).on("mouseup", "div.jq-number__spin", function () {
						i.change();
					}), i.on("focus.styler", function () {
						l.addClass("focused");
					}).on("blur.styler", function () {
						l.removeClass("focused");
					}));
				};c(), i.on("refresh", function () {
					i.off(".styler").closest(".jq-number").before(i).remove(), c();
				});
			} else if (i.is("select")) {
				var f = function f() {
					function d(t) {
						t.off("mousewheel DOMMouseScroll").on("mousewheel DOMMouseScroll", function (t) {
							var s = null;"mousewheel" == t.type ? s = -1 * t.originalEvent.wheelDelta : "DOMMouseScroll" == t.type && (s = 40 * t.originalEvent.detail), s && (t.stopPropagation(), t.preventDefault(), e(this).scrollTop(s + e(this).scrollTop()));
						});
					}function r() {
						for (var e = 0; e < f.length; e++) {
							var t = f.eq(e),
							    s = "",
							    i = "",
							    o = "",
							    a = "",
							    d = "",
							    r = "",
							    n = "",
							    c = "",
							    u = "",
							    p = "disabled",
							    v = "selected sel disabled";t.prop("selected") && (i = "selected sel"), t.is(":disabled") && (i = p), t.is(":selected:disabled") && (i = v), void 0 !== t.attr("id") && "" !== t.attr("id") && (a = ' id="' + t.attr("id") + l.idSuffix + '"'), void 0 !== t.attr("title") && "" !== f.attr("title") && (d = ' title="' + t.attr("title") + '"'), void 0 !== t.attr("class") && (n = " " + t.attr("class"), u = ' data-jqfs-class="' + t.attr("class") + '"');var m = t.data();for (var g in m) {
								"" !== m[g] && (r += " data-" + g + '="' + m[g] + '"');
							}i + n !== "" && (o = ' class="' + i + n + '"'), s = "<li" + u + r + o + d + a + ">" + t.html() + "</li>", t.parent().is("optgroup") && (void 0 !== t.parent().attr("class") && (c = " " + t.parent().attr("class")), s = "<li" + u + r + ' class="' + i + n + " option" + c + '"' + d + a + ">" + t.html() + "</li>", t.is(":first-child") && (s = '<li class="optgroup' + c + '">' + t.parent().attr("label") + "</li>" + s)), h += s;
						}
					}function n() {
						var a = new t(),
						    n = "",
						    c = i.data("placeholder"),
						    u = i.data("search"),
						    p = i.data("search-limit"),
						    v = i.data("search-not-found"),
						    m = i.data("search-placeholder"),
						    g = i.data("z-index"),
						    b = i.data("smart-positioning");void 0 === c && (c = l.selectPlaceholder), void 0 !== u && "" !== u || (u = l.selectSearch), void 0 !== p && "" !== p || (p = l.selectSearchLimit), void 0 !== v && "" !== v || (v = l.selectSearchNotFound), void 0 === m && (m = l.selectSearchPlaceholder), void 0 !== g && "" !== g || (g = l.singleSelectzIndex), void 0 !== b && "" !== b || (b = l.selectSmartPositioning);var y = e('<div class="jq-selectbox jqselect"><div class="jq-selectbox__select" style="position: relative"><div class="jq-selectbox__select-text"></div><div class="jq-selectbox__trigger"><div class="jq-selectbox__trigger-arrow"></div></div></div></div>').css({ display: "inline-block", position: "relative", zIndex: g }).attr({ id: a.id, title: a.title }).addClass(a.classes).data(a.data);i.css({ margin: 0, padding: 0 }).after(y).prependTo(y);var C = e("div.jq-selectbox__select", y),
						    x = e("div.jq-selectbox__select-text", y),
						    w = f.filter(":selected");r(), u && (n = '<div class="jq-selectbox__search"><input type="search" autocomplete="off" placeholder="' + m + '"></div><div class="jq-selectbox__not-found">' + v + "</div>");var q = e('<div class="jq-selectbox__dropdown" style="position: absolute">' + n + '<ul style="position: relative; list-style: none; overflow: auto; overflow-x: hidden">' + h + "</ul></div>");y.append(q);var _ = e("ul", q),
						    j = e("li", q),
						    k = e("input", q),
						    S = e("div.jq-selectbox__not-found", q).hide();j.length < p && k.parent().hide(), "" === f.first().text() && f.first().is(":selected") && c !== !1 ? x.text(c).addClass("placeholder") : x.text(w.text());var T = 0,
						    N = 0;if (j.css({ display: "inline-block" }), j.each(function () {
							var t = e(this);t.innerWidth() > T && (T = t.innerWidth(), N = t.width());
						}), j.css({ display: "" }), x.is(".placeholder") && x.width() > T) x.width(x.width());else {
							var P = y.clone().appendTo("body").width("auto"),
							    A = P.outerWidth();P.remove(), A == y.outerWidth() && x.width(N);
						}T > y.width() && q.width(T), "" === f.first().text() && "" !== i.data("placeholder") && j.first().hide(), i.css({ position: "absolute", left: 0, top: 0, width: "100%", height: "100%", opacity: 0 });var D = y.outerHeight(!0),
						    H = k.parent().outerHeight(!0) || 0,
						    I = _.css("max-height"),
						    z = j.filter(".selected");if (z.length < 1 && j.first().addClass("selected sel"), void 0 === j.data("li-height")) {
							var K = j.outerHeight();c !== !1 && (K = j.eq(1).outerHeight()), j.data("li-height", K);
						}var M = q.css("top");if ("auto" == q.css("left") && q.css({ left: 0 }), "auto" == q.css("top") && (q.css({ top: D }), M = D), q.hide(), z.length && (f.first().text() != w.text() && y.addClass("changed"), y.data("jqfs-class", z.data("jqfs-class")), y.addClass(z.data("jqfs-class"))), i.is(":disabled")) return y.addClass("disabled"), !1;C.click(function () {
							if (e("div.jq-selectbox").filter(".opened").length && l.onSelectClosed.call(e("div.jq-selectbox").filter(".opened")), i.focus(), !o) {
								var t = e(window),
								    s = j.data("li-height"),
								    a = y.offset().top,
								    r = t.height() - D - (a - t.scrollTop()),
								    n = i.data("visible-options");void 0 !== n && "" !== n || (n = l.selectVisibleOptions);var c = 5 * s,
								    h = s * n;n > 0 && 6 > n && (c = h), 0 === n && (h = "auto");var u = function u() {
									q.height("auto").css({ bottom: "auto", top: M });var e = function e() {
										_.css("max-height", Math.floor((r - 20 - H) / s) * s);
									};e(), _.css("max-height", h), "none" != I && _.css("max-height", I), r < q.outerHeight() + 20 && e();
								},
								    p = function p() {
									q.height("auto").css({ top: "auto", bottom: M });var e = function e() {
										_.css("max-height", Math.floor((a - t.scrollTop() - 20 - H) / s) * s);
									};e(), _.css("max-height", h), "none" != I && _.css("max-height", I), a - t.scrollTop() - 20 < q.outerHeight() + 20 && e();
								};b === !0 || 1 === b ? r > c + H + 20 ? (u(), y.removeClass("dropup").addClass("dropdown")) : (p(), y.removeClass("dropdown").addClass("dropup")) : b === !1 || 0 === b ? r > c + H + 20 && (u(), y.removeClass("dropup").addClass("dropdown")) : (q.height("auto").css({ bottom: "auto", top: M }), _.css("max-height", h), "none" != I && _.css("max-height", I)), y.offset().left + q.outerWidth() > t.width() && q.css({ left: "auto", right: 0 }), e("div.jqselect").css({ zIndex: g - 1 }).removeClass("opened"), y.css({ zIndex: g }), q.is(":hidden") ? (e("div.jq-selectbox__dropdown:visible").hide(), q.show(), y.addClass("opened focused"), l.onSelectOpened.call(y)) : (q.hide(), y.removeClass("opened dropup dropdown"), e("div.jq-selectbox").filter(".opened").length && l.onSelectClosed.call(y)), k.length && (k.val("").keyup(), S.hide(), k.keyup(function () {
									var t = e(this).val();j.each(function () {
										e(this).html().match(new RegExp(".*?" + t + ".*?", "i")) ? e(this).show() : e(this).hide();
									}), "" === f.first().text() && "" !== i.data("placeholder") && j.first().hide(), j.filter(":visible").length < 1 ? S.show() : S.hide();
								})), j.filter(".selected").length && ("" === i.val() ? _.scrollTop(0) : (_.innerHeight() / s % 2 !== 0 && (s /= 2), _.scrollTop(_.scrollTop() + j.filter(".selected").position().top - _.innerHeight() / 2 + s))), d(_);
							}
						}), j.hover(function () {
							e(this).siblings().removeClass("selected");
						});var O = j.filter(".selected").text();j.filter(":not(.disabled):not(.optgroup)").click(function () {
							i.focus();var t = e(this),
							    s = t.text();if (!t.is(".selected")) {
								var o = t.index();o -= t.prevAll(".optgroup").length, t.addClass("selected sel").siblings().removeClass("selected sel"), f.prop("selected", !1).eq(o).prop("selected", !0), O = s, x.text(s), y.data("jqfs-class") && y.removeClass(y.data("jqfs-class")), y.data("jqfs-class", t.data("jqfs-class")), y.addClass(t.data("jqfs-class")), i.change();
							}q.hide(), y.removeClass("opened dropup dropdown"), l.onSelectClosed.call(y);
						}), q.mouseout(function () {
							e("li.sel", q).addClass("selected");
						}), i.on("change.styler", function () {
							x.text(f.filter(":selected").text()).removeClass("placeholder"), j.removeClass("selected sel").not(".optgroup").eq(i[0].selectedIndex).addClass("selected sel"), f.first().text() != j.filter(".selected").text() ? y.addClass("changed") : y.removeClass("changed");
						}).on("focus.styler", function () {
							y.addClass("focused"), e("div.jqselect").not(".focused").removeClass("opened dropup dropdown").find("div.jq-selectbox__dropdown").hide();
						}).on("blur.styler", function () {
							y.removeClass("focused");
						}).on("keydown.styler keyup.styler", function (e) {
							var t = j.data("li-height");"" === i.val() ? x.text(c).addClass("placeholder") : x.text(f.filter(":selected").text()), j.removeClass("selected sel").not(".optgroup").eq(i[0].selectedIndex).addClass("selected sel"), 38 != e.which && 37 != e.which && 33 != e.which && 36 != e.which || ("" === i.val() ? _.scrollTop(0) : _.scrollTop(_.scrollTop() + j.filter(".selected").position().top)), 40 != e.which && 39 != e.which && 34 != e.which && 35 != e.which || _.scrollTop(_.scrollTop() + j.filter(".selected").position().top - _.innerHeight() + t), 13 == e.which && (e.preventDefault(), q.hide(), y.removeClass("opened dropup dropdown"), l.onSelectClosed.call(y));
						}).on("keydown.styler", function (e) {
							32 == e.which && (e.preventDefault(), C.click());
						}), s.registered || (e(document).on("click", s), s.registered = !0);
					}function c() {
						var s = new t(),
						    l = e('<div class="jq-select-multiple jqselect"></div>').css({ display: "inline-block", position: "relative" }).attr({ id: s.id, title: s.title }).addClass(s.classes).data(s.data);i.css({ margin: 0, padding: 0 }).after(l), r(), l.append("<ul>" + h + "</ul>");var o = e("ul", l).css({ position: "relative", "overflow-x": "hidden", "-webkit-overflow-scrolling": "touch" }),
						    a = e("li", l).attr("unselectable", "on"),
						    n = i.attr("size"),
						    c = o.outerHeight(),
						    u = a.outerHeight();void 0 !== n && n > 0 ? o.css({ height: u * n }) : o.css({ height: 4 * u }), c > l.height() && (o.css("overflowY", "scroll"), d(o), a.filter(".selected").length && o.scrollTop(o.scrollTop() + a.filter(".selected").position().top)), i.prependTo(l).css({ position: "absolute", left: 0, top: 0, width: "100%", height: "100%", opacity: 0 }), i.is(":disabled") ? (l.addClass("disabled"), f.each(function () {
							e(this).is(":selected") && a.eq(e(this).index()).addClass("selected");
						})) : (a.filter(":not(.disabled):not(.optgroup)").click(function (t) {
							i.focus();var s = e(this);if (t.ctrlKey || t.metaKey || s.addClass("selected"), t.shiftKey || s.addClass("first"), t.ctrlKey || t.metaKey || t.shiftKey || s.siblings().removeClass("selected first"), (t.ctrlKey || t.metaKey) && (s.is(".selected") ? s.removeClass("selected first") : s.addClass("selected first"), s.siblings().removeClass("first")), t.shiftKey) {
								var l = !1,
								    o = !1;s.siblings().removeClass("selected").siblings(".first").addClass("selected"), s.prevAll().each(function () {
									e(this).is(".first") && (l = !0);
								}), s.nextAll().each(function () {
									e(this).is(".first") && (o = !0);
								}), l && s.prevAll().each(function () {
									return e(this).is(".selected") ? !1 : void e(this).not(".disabled, .optgroup").addClass("selected");
								}), o && s.nextAll().each(function () {
									return e(this).is(".selected") ? !1 : void e(this).not(".disabled, .optgroup").addClass("selected");
								}), 1 == a.filter(".selected").length && s.addClass("first");
							}f.prop("selected", !1), a.filter(".selected").each(function () {
								var t = e(this),
								    s = t.index();t.is(".option") && (s -= t.prevAll(".optgroup").length), f.eq(s).prop("selected", !0);
							}), i.change();
						}), f.each(function (t) {
							e(this).data("optionIndex", t);
						}), i.on("change.styler", function () {
							a.removeClass("selected");var t = [];f.filter(":selected").each(function () {
								t.push(e(this).data("optionIndex"));
							}), a.not(".optgroup").filter(function (s) {
								return e.inArray(s, t) > -1;
							}).addClass("selected");
						}).on("focus.styler", function () {
							l.addClass("focused");
						}).on("blur.styler", function () {
							l.removeClass("focused");
						}), c > l.height() && i.on("keydown.styler", function (e) {
							38 != e.which && 37 != e.which && 33 != e.which || o.scrollTop(o.scrollTop() + a.filter(".selected").position().top - u), 40 != e.which && 39 != e.which && 34 != e.which || o.scrollTop(o.scrollTop() + a.filter(".selected:last").position().top - o.innerHeight() + 2 * u);
						}));
					}var f = e("option", i),
					    h = "";if (i.is("[multiple]")) {
						if (a || o) return;c();
					} else n();
				};f(), i.on("refresh", function () {
					i.off(".styler").parent().before(i).remove(), f();
				});
			} else i.is(":reset") && i.on("click", function () {
				setTimeout(function () {
					i.closest("form").find("input, select").trigger("refresh");
				}, 1);
			});
		}, destroy: function destroy() {
			var t = e(this.element);t.is(":checkbox") || t.is(":radio") ? (t.removeData("_" + i).off(".styler refresh").removeAttr("style").parent().before(t).remove(), t.closest("label").add('label[for="' + t.attr("id") + '"]').off(".styler")) : t.is('input[type="number"]') ? t.removeData("_" + i).off(".styler refresh").closest(".jq-number").before(t).remove() : (t.is(":file") || t.is("select")) && t.removeData("_" + i).off(".styler refresh").removeAttr("style").parent().before(t).remove();
		} }, e.fn[i] = function (s) {
		var l = arguments;if (void 0 === s || "object" == (typeof s === "undefined" ? "undefined" : _typeof(s))) return this.each(function () {
			e.data(this, "_" + i) || e.data(this, "_" + i, new t(this, s));
		}).promise().done(function () {
			var t = e(this[0]).data("_" + i);t && t.options.onFormStyled.call();
		}), this;if ("string" == typeof s && "_" !== s[0] && "init" !== s) {
			var o;return this.each(function () {
				var a = e.data(this, "_" + i);a instanceof t && "function" == typeof a[s] && (o = a[s].apply(a, Array.prototype.slice.call(l, 1)));
			}), void 0 !== o ? o : this;
		}
	}, s.registered = !1;
});
/*!
 * VERSION: 1.18.5
 * DATE: 2016-05-24
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {

	"use strict";

	_gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {

		var _slice = function _slice(a) {
			//don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
			var b = [],
			    l = a.length,
			    i;
			for (i = 0; i !== l; b.push(a[i++])) {}
			return b;
		},
		    _applyCycle = function _applyCycle(vars, targets, i) {
			var alt = vars.cycle,
			    p,
			    val;
			for (p in alt) {
				val = alt[p];
				vars[p] = typeof val === "function" ? val.call(targets[i], i) : val[i % val.length];
			}
			delete vars.cycle;
		},
		    TweenMax = function TweenMax(target, duration, vars) {
			TweenLite.call(this, target, duration, vars);
			this._cycle = 0;
			this._yoyo = this.vars.yoyo === true;
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
			this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
		},
		    _tinyNum = 0.0000000001,
		    TweenLiteInternals = TweenLite._internals,
		    _isSelector = TweenLiteInternals.isSelector,
		    _isArray = TweenLiteInternals.isArray,
		    p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
		    _blankArray = [];

		TweenMax.version = "1.18.5";
		p.constructor = TweenMax;
		p.kill()._gc = false;
		TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
		TweenMax.getTweensOf = TweenLite.getTweensOf;
		TweenMax.lagSmoothing = TweenLite.lagSmoothing;
		TweenMax.ticker = TweenLite.ticker;
		TweenMax.render = TweenLite.render;

		p.invalidate = function () {
			this._yoyo = this.vars.yoyo === true;
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TweenLite.prototype.invalidate.call(this);
		};

		p.updateTo = function (vars, resetDuration) {
			var curRatio = this.ratio,
			    immediate = this.vars.immediateRender || vars.immediateRender,
			    p;
			if (resetDuration && this._startTime < this._timeline._time) {
				this._startTime = this._timeline._time;
				this._uncache(false);
				if (this._gc) {
					this._enabled(true, false);
				} else {
					this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			for (p in vars) {
				this.vars[p] = vars[p];
			}
			if (this._initted || immediate) {
				if (resetDuration) {
					this._initted = false;
					if (immediate) {
						this.render(0, true, true);
					}
				} else {
					if (this._gc) {
						this._enabled(true, false);
					}
					if (this._notifyPluginsOfEnabled && this._firstPT) {
						TweenLite._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks
					}
					if (this._time / this._duration > 0.998) {
						//if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards. 
						var prevTime = this._totalTime;
						this.render(0, true, false);
						this._initted = false;
						this.render(prevTime, true, false);
					} else {
						this._initted = false;
						this._init();
						if (this._time > 0 || immediate) {
							var inv = 1 / (1 - curRatio),
							    pt = this._firstPT,
							    endValue;
							while (pt) {
								endValue = pt.s + pt.c;
								pt.c *= inv;
								pt.s = endValue - pt.c;
								pt = pt._next;
							}
						}
					}
				}
			}
			return this;
		};

		p.render = function (time, suppressEvents, force) {
			if (!this._initted) if (this._duration === 0 && this.vars.repeat) {
				//zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
				this.invalidate();
			}
			var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
			    prevTime = this._time,
			    prevTotalTime = this._totalTime,
			    prevCycle = this._cycle,
			    duration = this._duration,
			    prevRawPrevTime = this._rawPrevTime,
			    isComplete,
			    callback,
			    pt,
			    cycleDuration,
			    r,
			    type,
			    pow,
			    rawPrevTime;
			if (time >= totalDur - 0.0000001) {
				//to work around occasional floating point math artifacts.
				this._totalTime = totalDur;
				this._cycle = this._repeat;
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = 0;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				} else {
					this._time = duration;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				}
				if (!this._reversed) {
					isComplete = true;
					callback = "onComplete";
					force = force || this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) {
					//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) {
						//if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime < 0 || time <= 0 && time >= -0.0000001 || prevRawPrevTime === _tinyNum && this.data !== "isPause") if (prevRawPrevTime !== time) {
						//note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}
			} else if (time < 0.0000001) {
				//to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = this._cycle = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTotalTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) {
						//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) {
					//if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;
				if (this._repeat !== 0) {
					cycleDuration = duration + this._repeatDelay;
					this._cycle = this._totalTime / cycleDuration >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
					if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
						this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
					}
					this._time = this._totalTime - this._cycle * cycleDuration;
					if (this._yoyo) if ((this._cycle & 1) !== 0) {
						this._time = duration - this._time;
					}
					if (this._time > duration) {
						this._time = duration;
					} else if (this._time < 0) {
						this._time = 0;
					}
				}

				if (this._easeType) {
					r = this._time / duration;
					type = this._easeType;
					pow = this._easePower;
					if (type === 1 || type === 3 && r >= 0.5) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (this._time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - r / 2;
					}
				} else {
					this.ratio = this._ease.getRatio(this._time / duration);
				}
			}

			if (prevTime === this._time && !force && prevCycle === this._cycle) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) {
					//so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) {
					//immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
					//we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
					this._time = prevTime;
					this._totalTime = prevTotalTime;
					this._rawPrevTime = prevRawPrevTime;
					this._cycle = prevCycle;
					TweenLiteInternals.lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
				}
			}
			if (this._lazy !== false) {
				this._lazy = false;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTotalTime === 0) {
				if (this._initted === 2 && time > 0) {
					//this.invalidate();
					this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
				}
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {
					this._callback("onStart");
				}
			}

			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && this._startTime) {
					//if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._totalTime !== prevTotalTime || callback) {
					this._callback("onUpdate");
				}
			}
			if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {
				this._callback("onRepeat");
			}
			if (callback) if (!this._gc || force) {
				//check gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && this._startTime) {
					//if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
					//the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

		//---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------

		TweenMax.to = function (target, duration, vars) {
			return new TweenMax(target, duration, vars);
		};

		TweenMax.from = function (target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = vars.immediateRender != false;
			return new TweenMax(target, duration, vars);
		};

		TweenMax.fromTo = function (target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
			return new TweenMax(target, duration, toVars);
		};

		TweenMax.staggerTo = TweenMax.allTo = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = 0,
			    a = [],
			    finalComplete = function finalComplete() {
				if (vars.onComplete) {
					vars.onComplete.apply(vars.onCompleteScope || this, arguments);
				}
				onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
			},
			    cycle = vars.cycle,
			    fromCycle = vars.startAt && vars.startAt.cycle,
			    l,
			    copy,
			    i,
			    p;
			if (!_isArray(targets)) {
				if (typeof targets === "string") {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i <= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				if (fromCycle) {
					fromCycle = copy.startAt = {};
					for (p in vars.startAt) {
						fromCycle[p] = vars.startAt[p];
					}
					_applyCycle(copy.startAt, targets, i);
				}
				copy.delay = delay + (copy.delay || 0);
				if (i === l && onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		};

		TweenMax.staggerFrom = TweenMax.allFrom = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = vars.immediateRender != false;
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		TweenMax.staggerFromTo = TweenMax.allFromTo = function (targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		TweenMax.delayedCall = function (delay, callback, params, scope, useFrames) {
			return new TweenMax(callback, 0, { delay: delay, onComplete: callback, onCompleteParams: params, callbackScope: scope, onReverseComplete: callback, onReverseCompleteParams: params, immediateRender: false, useFrames: useFrames, overwrite: 0 });
		};

		TweenMax.set = function (target, vars) {
			return new TweenMax(target, 0, vars);
		};

		TweenMax.isTweening = function (target) {
			return TweenLite.getTweensOf(target, true).length > 0;
		};

		var _getChildrenOf = function _getChildrenOf(timeline, includeTimelines) {
			var a = [],
			    cnt = 0,
			    tween = timeline._first;
			while (tween) {
				if (tween instanceof TweenLite) {
					a[cnt++] = tween;
				} else {
					if (includeTimelines) {
						a[cnt++] = tween;
					}
					a = a.concat(_getChildrenOf(tween, includeTimelines));
					cnt = a.length;
				}
				tween = tween._next;
			}
			return a;
		},
		    getAllTweens = TweenMax.getAllTweens = function (includeTimelines) {
			return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat(_getChildrenOf(Animation._rootFramesTimeline, includeTimelines));
		};

		TweenMax.killAll = function (complete, tweens, delayedCalls, timelines) {
			if (tweens == null) {
				tweens = true;
			}
			if (delayedCalls == null) {
				delayedCalls = true;
			}
			var a = getAllTweens(timelines != false),
			    l = a.length,
			    allTrue = tweens && delayedCalls && timelines,
			    isDC,
			    tween,
			    i;
			for (i = 0; i < l; i++) {
				tween = a[i];
				if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
					if (complete) {
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
					} else {
						tween._enabled(false, false);
					}
				}
			}
		};

		TweenMax.killChildTweensOf = function (parent, complete) {
			if (parent == null) {
				return;
			}
			var tl = TweenLiteInternals.tweenLookup,
			    a,
			    curParent,
			    p,
			    i,
			    l;
			if (typeof parent === "string") {
				parent = TweenLite.selector(parent) || parent;
			}
			if (_isSelector(parent)) {
				parent = _slice(parent);
			}
			if (_isArray(parent)) {
				i = parent.length;
				while (--i > -1) {
					TweenMax.killChildTweensOf(parent[i], complete);
				}
				return;
			}
			a = [];
			for (p in tl) {
				curParent = tl[p].target.parentNode;
				while (curParent) {
					if (curParent === parent) {
						a = a.concat(tl[p].tweens);
					}
					curParent = curParent.parentNode;
				}
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				if (complete) {
					a[i].totalTime(a[i].totalDuration());
				}
				a[i]._enabled(false, false);
			}
		};

		var _changePause = function _changePause(pause, tweens, delayedCalls, timelines) {
			tweens = tweens !== false;
			delayedCalls = delayedCalls !== false;
			timelines = timelines !== false;
			var a = getAllTweens(timelines),
			    allTrue = tweens && delayedCalls && timelines,
			    i = a.length,
			    isDC,
			    tween;
			while (--i > -1) {
				tween = a[i];
				if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
					tween.paused(pause);
				}
			}
		};

		TweenMax.pauseAll = function (tweens, delayedCalls, timelines) {
			_changePause(true, tweens, delayedCalls, timelines);
		};

		TweenMax.resumeAll = function (tweens, delayedCalls, timelines) {
			_changePause(false, tweens, delayedCalls, timelines);
		};

		TweenMax.globalTimeScale = function (value) {
			var tl = Animation._rootTimeline,
			    t = TweenLite.ticker.time;
			if (!arguments.length) {
				return tl._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
			tl = Animation._rootFramesTimeline;
			t = TweenLite.ticker.frame;
			tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
			tl._timeScale = Animation._rootTimeline._timeScale = value;
			return value;
		};

		//---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------

		p.progress = function (value, suppressEvents) {
			return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);
		};

		p.totalProgress = function (value, suppressEvents) {
			return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
		};

		p.time = function (value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.duration = function (value) {
			if (!arguments.length) {
				return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
			}
			return Animation.prototype.duration.call(this, value);
		};

		p.totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					//instead of Infinity, we use 999999999999 so that we can accommodate reverses
					this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return this._repeat === -1 ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1));
		};

		p.repeat = function (value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function (value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function (value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		return TweenMax;
	}, true);

	/*
  * ----------------------------------------------------------------
  * TimelineLite
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {

		var TimelineLite = function TimelineLite(vars) {
			SimpleTimeline.call(this, vars);
			this._labels = {};
			this.autoRemoveChildren = this.vars.autoRemoveChildren === true;
			this.smoothChildTiming = this.vars.smoothChildTiming === true;
			this._sortChildren = true;
			this._onUpdate = this.vars.onUpdate;
			var v = this.vars,
			    val,
			    p;
			for (p in v) {
				val = v[p];
				if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
					v[p] = this._swapSelfInParams(val);
				}
			}
			if (_isArray(v.tweens)) {
				this.add(v.tweens, 0, v.align, v.stagger);
			}
		},
		    _tinyNum = 0.0000000001,
		    TweenLiteInternals = TweenLite._internals,
		    _internals = TimelineLite._internals = {},
		    _isSelector = TweenLiteInternals.isSelector,
		    _isArray = TweenLiteInternals.isArray,
		    _lazyTweens = TweenLiteInternals.lazyTweens,
		    _lazyRender = TweenLiteInternals.lazyRender,
		    _globals = _gsScope._gsDefine.globals,
		    _copy = function _copy(vars) {
			var copy = {},
			    p;
			for (p in vars) {
				copy[p] = vars[p];
			}
			return copy;
		},
		    _applyCycle = function _applyCycle(vars, targets, i) {
			var alt = vars.cycle,
			    p,
			    val;
			for (p in alt) {
				val = alt[p];
				vars[p] = typeof val === "function" ? val.call(targets[i], i) : val[i % val.length];
			}
			delete vars.cycle;
		},
		    _pauseCallback = _internals.pauseCallback = function () {},
		    _slice = function _slice(a) {
			//don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
			var b = [],
			    l = a.length,
			    i;
			for (i = 0; i !== l; b.push(a[i++])) {}
			return b;
		},
		    p = TimelineLite.prototype = new SimpleTimeline();

		TimelineLite.version = "1.18.5";
		p.constructor = TimelineLite;
		p.kill()._gc = p._forcingPlayhead = p._hasPause = false;

		/* might use later...
  //translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
  function localToGlobal(time, animation) {
  	while (animation) {
  		time = (time / animation._timeScale) + animation._startTime;
  		animation = animation.timeline;
  	}
  	return time;
  }
  		//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
  function globalToLocal(time, animation) {
  	var scale = 1;
  	time -= localToGlobal(0, animation);
  	while (animation) {
  		scale *= animation._timeScale;
  		animation = animation.timeline;
  	}
  	return time * scale;
  }
  */

		p.to = function (target, duration, vars, position) {
			var Engine = vars.repeat && _globals.TweenMax || TweenLite;
			return duration ? this.add(new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function (target, duration, vars, position) {
			return this.add((vars.repeat && _globals.TweenMax || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function (target, duration, fromVars, toVars, position) {
			var Engine = toVars.repeat && _globals.TweenMax || TweenLite;
			return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};

		p.staggerTo = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({ onComplete: onCompleteAll, onCompleteParams: onCompleteAllParams, callbackScope: onCompleteAllScope, smoothChildTiming: this.smoothChildTiming }),
			    cycle = vars.cycle,
			    copy,
			    i;
			if (typeof targets === "string") {
				targets = TweenLite.selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) {
				//senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i < targets.length; i++) {
				copy = _copy(vars);
				if (copy.startAt) {
					copy.startAt = _copy(copy.startAt);
					if (copy.startAt.cycle) {
						_applyCycle(copy.startAt, targets, i);
					}
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				tl.to(targets[i], duration, copy, i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = vars.immediateRender != false;
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.staggerFromTo = function (targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function (callback, params, scope, position) {
			return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.set = function (target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = position === this._time && !this._paused;
			}
			return this.add(new TweenLite(target, 0, vars), position);
		};

		TimelineLite.exportRoot = function (vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
			    root = tl._timeline,
			    tween,
			    next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
					tl.add(tween, tween._startTime - tween._delay);
				}
				tween = next;
			}
			root.add(tl, 0);
			return tl;
		};

		p.add = function (value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof position !== "number") {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof Animation)) {
				if (value instanceof Array || value && value.push && _isArray(value)) {
					align = align || "normal";
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i < l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({ tweens: child });
						}
						this.add(child, curTime);
						if (typeof child !== "string" && typeof child !== "function") {
							if (align === "sequence") {
								curTime = child._startTime + child.totalDuration() / child._timeScale;
							} else if (align === "start") {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof value === "string") {
					return this.addLabel(value, position);
				} else if (typeof value === "function") {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw "Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.";
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = tl.rawTime() > value._startTime; //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime && tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};

		p.remove = function (value) {
			if (value instanceof Animation) {
				this._remove(value, false);
				var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline; //now that it's removed, default it to the root timeline so that if it gets played again, it doesn't jump back into this timeline.
				value._startTime = (value._paused ? value._pauseTime : tl._time) - (!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale; //ensure that if it gets played again, the timing is correct.
				return this;
			} else if (value instanceof Array || value && value.push && _isArray(value)) {
				var i = value.length;
				while (--i > -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof value === "string") {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};

		p._remove = function (tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time > last._startTime + last._totalDuration / last._timeScale) {
				this._time = this.duration();
				this._totalTime = this._totalDuration;
			}
			return this;
		};

		p.append = function (value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		};

		p.insert = p.insertMultiple = function (value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		};

		p.appendMultiple = function (tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		};

		p.addLabel = function (label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		};

		p.addPause = function (position, callback, params, scope) {
			var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
			t.vars.onComplete = t.vars.onReverseComplete = callback;
			t.data = "isPause";
			this._hasPause = true;
			return this.add(t, position);
		};

		p.removeLabel = function (label) {
			delete this._labels[label];
			return this;
		};

		p.getLabelTime = function (label) {
			return this._labels[label] != null ? this._labels[label] : -1;
		};

		p._parseTimeOrLabel = function (timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var i;
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof Animation && ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore && (ignore instanceof Array || ignore.push && _isArray(ignore))) {
				i = ignore.length;
				while (--i > -1) {
					if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			if (typeof offsetOrLabel === "string") {
				return this._parseTimeOrLabel(offsetOrLabel, appendIfAbsent && typeof timeOrLabel === "number" && this._labels[offsetOrLabel] == null ? timeOrLabel - this.duration() : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof timeOrLabel === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) {
				//if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? this._labels[timeOrLabel] = this.duration() + offsetOrLabel : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1));
				timeOrLabel = i > 1 ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : this.duration();
			} else if (timeOrLabel == null) {
				timeOrLabel = this.duration();
			}
			return Number(timeOrLabel) + offsetOrLabel;
		};

		p.seek = function (position, suppressEvents) {
			return this.totalTime(typeof position === "number" ? position : this._parseTimeOrLabel(position), suppressEvents !== false);
		};

		p.stop = function () {
			return this.paused(true);
		};

		p.gotoAndPlay = function (position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function (position, suppressEvents) {
			return this.pause(position, suppressEvents);
		};

		p.render = function (time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
			    prevTime = this._time,
			    prevStart = this._startTime,
			    prevTimeScale = this._timeScale,
			    prevPaused = this._paused,
			    tween,
			    isComplete,
			    next,
			    callback,
			    internalForce,
			    pauseTween,
			    curTime;
			if (time >= totalDur - 0.0000001) {
				//to work around occasional floating point math artifacts.
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if (time <= 0 && time >= -0.0000001 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;
						if (this._rawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.
			} else if (time < 0.0000001) {
				//to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || time < 0 && this._rawPrevTime >= 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) {
						//ensures proper GC if a timeline is resumed after it's finished reversing.
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (this._rawPrevTime >= 0 && this._first) {
						//when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) {
						//if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}
			} else {

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
					if (time >= prevTime) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
					}
				}

				this._totalTime = this._time = this._rawPrevTime = time;
			}
			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
				this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0 || !this._duration) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= curTime && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) {
					//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}

			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) {
				//if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) {
						//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p._hasPausedChild = function () {
			var tween = this._first;
			while (tween) {
				if (tween._paused || tween instanceof TimelineLite && tween._hasPausedChild()) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		};

		p.getChildren = function (nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
			    tween = this._first,
			    cnt = 0;
			while (tween) {
				if (tween._startTime < ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof TweenLite) {
					if (tweens !== false) {
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.getChildren(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		};

		p.getTweensOf = function (target, nested) {
			var disabled = this._gc,
			    a = [],
			    cnt = 0,
			    tweens,
			    i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i > -1) {
				if (tweens[i].timeline === this || nested && this._contains(tweens[i])) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		};

		p.recent = function () {
			return this._recent;
		};

		p._contains = function (tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		};

		p.shiftChildren = function (amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
			    labels = this._labels,
			    p;
			while (tween) {
				if (tween._startTime >= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		};

		p._kill = function (vars, target) {
			if (!vars && !target) {
				return this._enabled(false, false);
			}
			var tweens = !target ? this.getChildren(true, true, false) : this.getTweensOf(target),
			    i = tweens.length,
			    changed = false;
			while (--i > -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function (labels) {
			var tweens = this.getChildren(false, true, true),
			    i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i > -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		};

		p.invalidate = function () {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function (enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
		};

		p.totalTime = function (time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = Animation.prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		};

		p.duration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 && value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		};

		p.totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
					    tween = this._last,
					    prevStart = 999999999999,
					    prev,
					    end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused) {
							//in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this.add(tween, tween._startTime - tween._delay);
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime < 0 && !tween._paused) {
							//children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + tween._totalDuration / tween._timeScale;
						if (end > max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return value && this.totalDuration() ? this.timeScale(this._totalDuration / value) : this;
		};

		p.paused = function (value) {
			if (!value) {
				//if there's a pause directly at the spot from where we're unpausing, skip it.
				var tween = this._first,
				    time = this._time;
				while (tween) {
					if (tween._startTime === time && tween.data === "isPause") {
						tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}
					tween = tween._next;
				}
			}
			return Animation.prototype.paused.apply(this, arguments);
		};

		p.usesFrames = function () {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return tl === Animation._rootFramesTimeline;
		};

		p.rawTime = function () {
			return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
		};

		return TimelineLite;
	}, true);

	/*
  * ----------------------------------------------------------------
  * TimelineMax
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (TimelineLite, TweenLite, Ease) {

		var TimelineMax = function TimelineMax(vars) {
			TimelineLite.call(this, vars);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._cycle = 0;
			this._yoyo = this.vars.yoyo === true;
			this._dirty = true;
		},
		    _tinyNum = 0.0000000001,
		    TweenLiteInternals = TweenLite._internals,
		    _lazyTweens = TweenLiteInternals.lazyTweens,
		    _lazyRender = TweenLiteInternals.lazyRender,
		    _easeNone = new Ease(null, null, 1, 0),
		    p = TimelineMax.prototype = new TimelineLite();

		p.constructor = TimelineMax;
		p.kill()._gc = false;
		TimelineMax.version = "1.18.5";

		p.invalidate = function () {
			this._yoyo = this.vars.yoyo === true;
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TimelineLite.prototype.invalidate.call(this);
		};

		p.addCallback = function (callback, position, params, scope) {
			return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.removeCallback = function (callback, position) {
			if (callback) {
				if (position == null) {
					this._kill(null, callback);
				} else {
					var a = this.getTweensOf(callback, false),
					    i = a.length,
					    time = this._parseTimeOrLabel(position);
					while (--i > -1) {
						if (a[i]._startTime === time) {
							a[i]._enabled(false, false);
						}
					}
				}
			}
			return this;
		};

		p.removePause = function (position) {
			return this.removeCallback(TimelineLite._internals.pauseCallback, position);
		};

		p.tweenTo = function (position, vars) {
			vars = vars || {};
			var copy = { ease: _easeNone, useFrames: this.usesFrames(), immediateRender: false },
			    duration,
			    p,
			    t;
			for (p in vars) {
				copy[p] = vars[p];
			}
			copy.time = this._parseTimeOrLabel(position);
			duration = Math.abs(Number(copy.time) - this._time) / this._timeScale || 0.001;
			t = new TweenLite(this, duration, copy);
			copy.onStart = function () {
				t.target.paused(true);
				if (t.vars.time !== t.target.time() && duration === t.duration()) {
					//don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
					t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale);
				}
				if (vars.onStart) {
					//in case the user had an onStart in the vars - we don't want to overwrite it.
					t._callback("onStart");
				}
			};
			return t;
		};

		p.tweenFromTo = function (fromPosition, toPosition, vars) {
			vars = vars || {};
			fromPosition = this._parseTimeOrLabel(fromPosition);
			vars.startAt = { onComplete: this.seek, onCompleteParams: [fromPosition], callbackScope: this };
			vars.immediateRender = vars.immediateRender !== false;
			var t = this.tweenTo(toPosition, vars);
			return t.duration(Math.abs(t.vars.time - fromPosition) / this._timeScale || 0.001);
		};

		p.render = function (time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
			    dur = this._duration,
			    prevTime = this._time,
			    prevTotalTime = this._totalTime,
			    prevStart = this._startTime,
			    prevTimeScale = this._timeScale,
			    prevRawPrevTime = this._rawPrevTime,
			    prevPaused = this._paused,
			    prevCycle = this._cycle,
			    tween,
			    isComplete,
			    next,
			    callback,
			    internalForce,
			    cycleDuration,
			    pauseTween,
			    curTime;
			if (time >= totalDur - 0.0000001) {
				//to work around occasional floating point math artifacts.
				if (!this._locked) {
					this._totalTime = totalDur;
					this._cycle = this._repeat;
				}
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if (time <= 0 && time >= -0.0000001 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
						internalForce = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = time = 0;
				} else {
					this._time = dur;
					time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
				}
			} else if (time < 0.0000001) {
				//to work around occasional floating point math artifacts, round super small values to 0.
				if (!this._locked) {
					this._totalTime = this._cycle = 0;
				}
				this._time = 0;
				if (prevTime !== 0 || dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || time < 0 && prevRawPrevTime >= 0) && !this._locked) {
					//edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) {
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (prevRawPrevTime >= 0 && this._first) {
						//when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = dur || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) {
						//if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}
			} else {
				if (dur === 0 && prevRawPrevTime < 0) {
					//without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
					internalForce = true;
				}
				this._time = this._rawPrevTime = time;
				if (!this._locked) {
					this._totalTime = time;
					if (this._repeat !== 0) {
						cycleDuration = dur + this._repeatDelay;
						this._cycle = this._totalTime / cycleDuration >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
						if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
							this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
						}
						this._time = this._totalTime - this._cycle * cycleDuration;
						if (this._yoyo) if ((this._cycle & 1) !== 0) {
							this._time = dur - this._time;
						}
						if (this._time > dur) {
							this._time = dur;
							time = dur + 0.0001; //to avoid occasional floating point rounding error
						} else if (this._time < 0) {
							this._time = time = 0;
						} else {
							time = this._time;
						}
					}
				}

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
					time = this._time;
					if (time >= prevTime) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
					}
				}
			}

			if (this._cycle !== prevCycle) if (!this._locked) {
				/*
    make sure children at the end/beginning of the timeline are rendered properly. If, for example,
    a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
    would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
    could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
    we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
    ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.
    */
				var backwards = this._yoyo && (prevCycle & 1) !== 0,
				    wrap = backwards === (this._yoyo && (this._cycle & 1) !== 0),
				    recTotalTime = this._totalTime,
				    recCycle = this._cycle,
				    recRawPrevTime = this._rawPrevTime,
				    recTime = this._time;

				this._totalTime = prevCycle * dur;
				if (this._cycle < prevCycle) {
					backwards = !backwards;
				} else {
					this._totalTime += dur;
				}
				this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

				this._rawPrevTime = dur === 0 ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
				this._cycle = prevCycle;
				this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
				prevTime = backwards ? 0 : dur;
				this.render(prevTime, suppressEvents, dur === 0);
				if (!suppressEvents) if (!this._gc) {
					if (this.vars.onRepeat) {
						this._callback("onRepeat");
					}
				}
				if (prevTime !== this._time) {
					//in case there's a callback like onComplete in a nested tween/timeline that changes the playhead position, like via seek(), we should just abort.
					return;
				}
				if (wrap) {
					prevTime = backwards ? dur + 0.0001 : -0.0001;
					this.render(prevTime, true, false);
				}
				this._locked = false;
				if (this._paused && !prevPaused) {
					//if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
					return;
				}
				this._time = recTime;
				this._totalTime = recTotalTime;
				this._cycle = recCycle;
				this._rawPrevTime = recRawPrevTime;
			}

			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) {
					//so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
				this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0 || !this._totalDuration) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) {
					//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}
			if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) {
				//if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) {
						//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p.getActive = function (nested, tweens, timelines) {
			if (nested == null) {
				nested = true;
			}
			if (tweens == null) {
				tweens = true;
			}
			if (timelines == null) {
				timelines = false;
			}
			var a = [],
			    all = this.getChildren(nested, tweens, timelines),
			    cnt = 0,
			    l = all.length,
			    i,
			    tween;
			for (i = 0; i < l; i++) {
				tween = all[i];
				if (tween.isActive()) {
					a[cnt++] = tween;
				}
			}
			return a;
		};

		p.getLabelAfter = function (time) {
			if (!time) if (time !== 0) {
				//faster than isNan()
				time = this._time;
			}
			var labels = this.getLabelsArray(),
			    l = labels.length,
			    i;
			for (i = 0; i < l; i++) {
				if (labels[i].time > time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelBefore = function (time) {
			if (time == null) {
				time = this._time;
			}
			var labels = this.getLabelsArray(),
			    i = labels.length;
			while (--i > -1) {
				if (labels[i].time < time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelsArray = function () {
			var a = [],
			    cnt = 0,
			    p;
			for (p in this._labels) {
				a[cnt++] = { time: this._labels[p], name: p };
			}
			a.sort(function (a, b) {
				return a.time - b.time;
			});
			return a;
		};

		//---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------

		p.progress = function (value, suppressEvents) {
			return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);
		};

		p.totalProgress = function (value, suppressEvents) {
			return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
		};

		p.totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					TimelineLite.prototype.totalDuration.call(this); //just forces refresh
					//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
					this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
				}
				return this._totalDuration;
			}
			return this._repeat === -1 || !value ? this : this.timeScale(this.totalDuration() / value);
		};

		p.time = function (value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.repeat = function (value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function (value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function (value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		p.currentLabel = function (value) {
			if (!arguments.length) {
				return this.getLabelBefore(this._time + 0.00000001);
			}
			return this.seek(value, true);
		};

		return TimelineMax;
	}, true);

	/*
  * ----------------------------------------------------------------
  * BezierPlugin
  * ----------------------------------------------------------------
  */
	(function () {

		var _RAD2DEG = 180 / Math.PI,
		    _r1 = [],
		    _r2 = [],
		    _r3 = [],
		    _corProps = {},
		    _globals = _gsScope._gsDefine.globals,
		    Segment = function Segment(a, b, c, d) {
			if (c === d) {
				//if c and d match, the final autoRotate value could lock at -90 degrees, so differentiate them slightly.
				c = d - (d - b) / 1000000;
			}
			if (a === b) {
				//if a and b match, the starting autoRotate value could lock at -90 degrees, so differentiate them slightly.
				b = a + (c - a) / 1000000;
			}
			this.a = a;
			this.b = b;
			this.c = c;
			this.d = d;
			this.da = d - a;
			this.ca = c - a;
			this.ba = b - a;
		},
		    _correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
		    cubicToQuadratic = function cubicToQuadratic(a, b, c, d) {
			var q1 = { a: a },
			    q2 = {},
			    q3 = {},
			    q4 = { c: d },
			    mab = (a + b) / 2,
			    mbc = (b + c) / 2,
			    mcd = (c + d) / 2,
			    mabc = (mab + mbc) / 2,
			    mbcd = (mbc + mcd) / 2,
			    m8 = (mbcd - mabc) / 8;
			q1.b = mab + (a - mab) / 4;
			q2.b = mabc + m8;
			q1.c = q2.a = (q1.b + q2.b) / 2;
			q2.c = q3.a = (mabc + mbcd) / 2;
			q3.b = mbcd - m8;
			q4.b = mcd + (d - mcd) / 4;
			q3.c = q4.a = (q3.b + q4.b) / 2;
			return [q1, q2, q3, q4];
		},
		    _calculateControlPoints = function _calculateControlPoints(a, curviness, quad, basic, correlate) {
			var l = a.length - 1,
			    ii = 0,
			    cp1 = a[0].a,
			    i,
			    p1,
			    p2,
			    p3,
			    seg,
			    m1,
			    m2,
			    mm,
			    cp2,
			    qb,
			    r1,
			    r2,
			    tl;
			for (i = 0; i < l; i++) {
				seg = a[ii];
				p1 = seg.a;
				p2 = seg.d;
				p3 = a[ii + 1].d;

				if (correlate) {
					r1 = _r1[i];
					r2 = _r2[i];
					tl = (r2 + r1) * curviness * 0.25 / (basic ? 0.5 : _r3[i] || 0.5);
					m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : r1 !== 0 ? tl / r1 : 0);
					m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : r2 !== 0 ? tl / r2 : 0);
					mm = p2 - (m1 + ((m2 - m1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));
				} else {
					m1 = p2 - (p2 - p1) * curviness * 0.5;
					m2 = p2 + (p3 - p2) * curviness * 0.5;
					mm = p2 - (m1 + m2) / 2;
				}
				m1 += mm;
				m2 += mm;

				seg.c = cp2 = m1;
				if (i !== 0) {
					seg.b = cp1;
				} else {
					seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
				}

				seg.da = p2 - p1;
				seg.ca = cp2 - p1;
				seg.ba = cp1 - p1;

				if (quad) {
					qb = cubicToQuadratic(p1, cp1, cp2, p2);
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
					ii += 4;
				} else {
					ii++;
				}

				cp1 = m2;
			}
			seg = a[ii];
			seg.b = cp1;
			seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
			seg.da = seg.d - seg.a;
			seg.ca = seg.c - seg.a;
			seg.ba = cp1 - seg.a;
			if (quad) {
				qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
				a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
			}
		},
		    _parseAnchors = function _parseAnchors(values, p, correlate, prepend) {
			var a = [],
			    l,
			    i,
			    p1,
			    p2,
			    p3,
			    tmp;
			if (prepend) {
				values = [prepend].concat(values);
				i = values.length;
				while (--i > -1) {
					if (typeof (tmp = values[i][p]) === "string") if (tmp.charAt(1) === "=") {
						values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
					}
				}
			}
			l = values.length - 2;
			if (l < 0) {
				a[0] = new Segment(values[0][p], 0, 0, values[l < -1 ? 0 : 1][p]);
				return a;
			}
			for (i = 0; i < l; i++) {
				p1 = values[i][p];
				p2 = values[i + 1][p];
				a[i] = new Segment(p1, 0, 0, p2);
				if (correlate) {
					p3 = values[i + 2][p];
					_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
					_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
				}
			}
			a[i] = new Segment(values[i][p], 0, 0, values[i + 1][p]);
			return a;
		},
		    bezierThrough = function bezierThrough(values, curviness, quadratic, basic, correlate, prepend) {
			var obj = {},
			    props = [],
			    first = prepend || values[0],
			    i,
			    p,
			    a,
			    j,
			    r,
			    l,
			    seamless,
			    last;
			correlate = typeof correlate === "string" ? "," + correlate + "," : _correlate;
			if (curviness == null) {
				curviness = 1;
			}
			for (p in values[0]) {
				props.push(p);
			}
			//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
			if (values.length > 1) {
				last = values[values.length - 1];
				seamless = true;
				i = props.length;
				while (--i > -1) {
					p = props[i];
					if (Math.abs(first[p] - last[p]) > 0.05) {
						//build in a tolerance of +/-0.05 to accommodate rounding errors.
						seamless = false;
						break;
					}
				}
				if (seamless) {
					values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
					if (prepend) {
						values.unshift(prepend);
					}
					values.push(values[1]);
					prepend = values[values.length - 3];
				}
			}
			_r1.length = _r2.length = _r3.length = 0;
			i = props.length;
			while (--i > -1) {
				p = props[i];
				_corProps[p] = correlate.indexOf("," + p + ",") !== -1;
				obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
			}
			i = _r1.length;
			while (--i > -1) {
				_r1[i] = Math.sqrt(_r1[i]);
				_r2[i] = Math.sqrt(_r2[i]);
			}
			if (!basic) {
				i = props.length;
				while (--i > -1) {
					if (_corProps[p]) {
						a = obj[props[i]];
						l = a.length - 1;
						for (j = 0; j < l; j++) {
							r = a[j + 1].da / _r2[j] + a[j].da / _r1[j] || 0;
							_r3[j] = (_r3[j] || 0) + r * r;
						}
					}
				}
				i = _r3.length;
				while (--i > -1) {
					_r3[i] = Math.sqrt(_r3[i]);
				}
			}
			i = props.length;
			j = quadratic ? 4 : 1;
			while (--i > -1) {
				p = props[i];
				a = obj[p];
				_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
				if (seamless) {
					a.splice(0, j);
					a.splice(a.length - j, j);
				}
			}
			return obj;
		},
		    _parseBezierData = function _parseBezierData(values, type, prepend) {
			type = type || "soft";
			var obj = {},
			    inc = type === "cubic" ? 3 : 2,
			    soft = type === "soft",
			    props = [],
			    a,
			    b,
			    c,
			    d,
			    cur,
			    i,
			    j,
			    l,
			    p,
			    cnt,
			    tmp;
			if (soft && prepend) {
				values = [prepend].concat(values);
			}
			if (values == null || values.length < inc + 1) {
				throw "invalid Bezier data";
			}
			for (p in values[0]) {
				props.push(p);
			}
			i = props.length;
			while (--i > -1) {
				p = props[i];
				obj[p] = cur = [];
				cnt = 0;
				l = values.length;
				for (j = 0; j < l; j++) {
					a = prepend == null ? values[j][p] : typeof (tmp = values[j][p]) === "string" && tmp.charAt(1) === "=" ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
					if (soft) if (j > 1) if (j < l - 1) {
						cur[cnt++] = (a + cur[cnt - 2]) / 2;
					}
					cur[cnt++] = a;
				}
				l = cnt - inc + 1;
				cnt = 0;
				for (j = 0; j < l; j += inc) {
					a = cur[j];
					b = cur[j + 1];
					c = cur[j + 2];
					d = inc === 2 ? 0 : cur[j + 3];
					cur[cnt++] = tmp = inc === 3 ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
				}
				cur.length = cnt;
			}
			return obj;
		},
		    _addCubicLengths = function _addCubicLengths(a, steps, resolution) {
			var inc = 1 / resolution,
			    j = a.length,
			    d,
			    d1,
			    s,
			    da,
			    ca,
			    ba,
			    p,
			    i,
			    inv,
			    bez,
			    index;
			while (--j > -1) {
				bez = a[j];
				s = bez.a;
				da = bez.d - s;
				ca = bez.c - s;
				ba = bez.b - s;
				d = d1 = 0;
				for (i = 1; i <= resolution; i++) {
					p = inc * i;
					inv = 1 - p;
					d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
					index = j * resolution + i - 1;
					steps[index] = (steps[index] || 0) + d * d;
				}
			}
		},
		    _parseLengthData = function _parseLengthData(obj, resolution) {
			resolution = resolution >> 0 || 6;
			var a = [],
			    lengths = [],
			    d = 0,
			    total = 0,
			    threshold = resolution - 1,
			    segments = [],
			    curLS = [],
			    //current length segments array
			p,
			    i,
			    l,
			    index;
			for (p in obj) {
				_addCubicLengths(obj[p], a, resolution);
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				d += Math.sqrt(a[i]);
				index = i % resolution;
				curLS[index] = d;
				if (index === threshold) {
					total += d;
					index = i / resolution >> 0;
					segments[index] = curLS;
					lengths[index] = total;
					d = 0;
					curLS = [];
				}
			}
			return { length: total, lengths: lengths, segments: segments };
		},
		    BezierPlugin = _gsScope._gsDefine.plugin({
			propName: "bezier",
			priority: -1,
			version: "1.3.6",
			API: 2,
			global: true,

			//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function init(target, vars, tween) {
				this._target = target;
				if (vars instanceof Array) {
					vars = { values: vars };
				}
				this._func = {};
				this._round = {};
				this._props = [];
				this._timeRes = vars.timeResolution == null ? 6 : parseInt(vars.timeResolution, 10);
				var values = vars.values || [],
				    first = {},
				    second = values[0],
				    autoRotate = vars.autoRotate || tween.vars.orientToBezier,
				    p,
				    isFunc,
				    i,
				    j,
				    prepend;

				this._autoRotate = autoRotate ? autoRotate instanceof Array ? autoRotate : [["x", "y", "rotation", autoRotate === true ? 0 : Number(autoRotate) || 0]] : null;
				for (p in second) {
					this._props.push(p);
				}

				i = this._props.length;
				while (--i > -1) {
					p = this._props[i];

					this._overwriteProps.push(p);
					isFunc = this._func[p] = typeof target[p] === "function";
					first[p] = !isFunc ? parseFloat(target[p]) : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]();
					if (!prepend) if (first[p] !== values[0][p]) {
						prepend = first;
					}
				}
				this._beziers = vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft" ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, vars.type === "thruBasic", vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
				this._segCount = this._beziers[p].length;

				if (this._timeRes) {
					var ld = _parseLengthData(this._beziers, this._timeRes);
					this._length = ld.length;
					this._lengths = ld.lengths;
					this._segments = ld.segments;
					this._l1 = this._li = this._s1 = this._si = 0;
					this._l2 = this._lengths[0];
					this._curSeg = this._segments[0];
					this._s2 = this._curSeg[0];
					this._prec = 1 / this._curSeg.length;
				}

				if (autoRotate = this._autoRotate) {
					this._initialRotations = [];
					if (!(autoRotate[0] instanceof Array)) {
						this._autoRotate = autoRotate = [autoRotate];
					}
					i = autoRotate.length;
					while (--i > -1) {
						for (j = 0; j < 3; j++) {
							p = autoRotate[i][j];
							this._func[p] = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)] : false;
						}
						p = autoRotate[i][2];
						this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
					}
				}
				this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
				return true;
			},

			//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
			set: function set(v) {
				var segments = this._segCount,
				    func = this._func,
				    target = this._target,
				    notStart = v !== this._startRatio,
				    curIndex,
				    inv,
				    i,
				    p,
				    b,
				    t,
				    val,
				    l,
				    lengths,
				    curSeg;
				if (!this._timeRes) {
					curIndex = v < 0 ? 0 : v >= 1 ? segments - 1 : segments * v >> 0;
					t = (v - curIndex * (1 / segments)) * segments;
				} else {
					lengths = this._lengths;
					curSeg = this._curSeg;
					v *= this._length;
					i = this._li;
					//find the appropriate segment (if the currently cached one isn't correct)
					if (v > this._l2 && i < segments - 1) {
						l = segments - 1;
						while (i < l && (this._l2 = lengths[++i]) <= v) {}
						this._l1 = lengths[i - 1];
						this._li = i;
						this._curSeg = curSeg = this._segments[i];
						this._s2 = curSeg[this._s1 = this._si = 0];
					} else if (v < this._l1 && i > 0) {
						while (i > 0 && (this._l1 = lengths[--i]) >= v) {}
						if (i === 0 && v < this._l1) {
							this._l1 = 0;
						} else {
							i++;
						}
						this._l2 = lengths[i];
						this._li = i;
						this._curSeg = curSeg = this._segments[i];
						this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
						this._s2 = curSeg[this._si];
					}
					curIndex = i;
					//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
					v -= this._l1;
					i = this._si;
					if (v > this._s2 && i < curSeg.length - 1) {
						l = curSeg.length - 1;
						while (i < l && (this._s2 = curSeg[++i]) <= v) {}
						this._s1 = curSeg[i - 1];
						this._si = i;
					} else if (v < this._s1 && i > 0) {
						while (i > 0 && (this._s1 = curSeg[--i]) >= v) {}
						if (i === 0 && v < this._s1) {
							this._s1 = 0;
						} else {
							i++;
						}
						this._s2 = curSeg[i];
						this._si = i;
					}
					t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec || 0;
				}
				inv = 1 - t;

				i = this._props.length;
				while (--i > -1) {
					p = this._props[i];
					b = this._beziers[p][curIndex];
					val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
					if (this._round[p]) {
						val = Math.round(val);
					}
					if (func[p]) {
						target[p](val);
					} else {
						target[p] = val;
					}
				}

				if (this._autoRotate) {
					var ar = this._autoRotate,
					    b2,
					    x1,
					    y1,
					    x2,
					    y2,
					    add,
					    conv;
					i = ar.length;
					while (--i > -1) {
						p = ar[i][2];
						add = ar[i][3] || 0;
						conv = ar[i][4] === true ? 1 : _RAD2DEG;
						b = this._beziers[ar[i][0]];
						b2 = this._beziers[ar[i][1]];

						if (b && b2) {
							//in case one of the properties got overwritten.
							b = b[curIndex];
							b2 = b2[curIndex];

							x1 = b.a + (b.b - b.a) * t;
							x2 = b.b + (b.c - b.b) * t;
							x1 += (x2 - x1) * t;
							x2 += (b.c + (b.d - b.c) * t - x2) * t;

							y1 = b2.a + (b2.b - b2.a) * t;
							y2 = b2.b + (b2.c - b2.b) * t;
							y1 += (y2 - y1) * t;
							y2 += (b2.c + (b2.d - b2.c) * t - y2) * t;

							val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}
					}
				}
			}
		}),
		    p = BezierPlugin.prototype;

		BezierPlugin.bezierThrough = bezierThrough;
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function (a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		};

		BezierPlugin._cssRegister = function () {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
			    _parseToProxy = _internals._parseToProxy,
			    _setPluginRatio = _internals._setPluginRatio,
			    CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("bezier", { parser: function parser(t, e, prop, cssp, pt, plugin) {
					if (e instanceof Array) {
						e = { values: e };
					}
					plugin = new BezierPlugin();
					var values = e.values,
					    l = values.length - 1,
					    pluginValues = [],
					    v = {},
					    i,
					    p,
					    data;
					if (l < 0) {
						return pt;
					}
					for (i = 0; i <= l; i++) {
						data = _parseToProxy(t, values[i], cssp, pt, plugin, l !== i);
						pluginValues[i] = data.end;
					}
					for (p in e) {
						v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
					}
					v.values = pluginValues;
					pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
					pt.data = data;
					pt.plugin = plugin;
					pt.setRatio = _setPluginRatio;
					if (v.autoRotate === 0) {
						v.autoRotate = true;
					}
					if (v.autoRotate && !(v.autoRotate instanceof Array)) {
						i = v.autoRotate === true ? 0 : Number(v.autoRotate);
						v.autoRotate = data.end.left != null ? [["left", "top", "rotation", i, false]] : data.end.x != null ? [["x", "y", "rotation", i, false]] : false;
					}
					if (v.autoRotate) {
						if (!cssp._transform) {
							cssp._enableTransforms(false);
						}
						data.autoRotate = cssp._target._gsTransform;
						data.proxy.rotation = data.autoRotate.rotation || 0;
					}
					plugin._onInitTween(data.proxy, v, cssp._tween);
					return pt;
				} });
		};

		p._roundProps = function (lookup, value) {
			var op = this._overwriteProps,
			    i = op.length;
			while (--i > -1) {
				if (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) {
					this._round[op[i]] = value;
				}
			}
		};

		p._kill = function (lookup) {
			var a = this._props,
			    p,
			    i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i > -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			return this._super._kill.call(this, lookup);
		};
	})();

	/*
  * ----------------------------------------------------------------
  * CSSPlugin
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (TweenPlugin, TweenLite) {

		/** @constructor **/
		var CSSPlugin = function CSSPlugin() {
			TweenPlugin.call(this, "css");
			this._overwriteProps.length = 0;
			this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
		},
		    _globals = _gsScope._gsDefine.globals,
		    _hasPriority,
		    //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
		_suffixMap,
		    //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
		_cs,
		    //computed style (we store this in a shared variable to conserve memory and make minification tighter
		_overwriteProps,
		    //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
		_specialProps = {},
		    p = CSSPlugin.prototype = new TweenPlugin("css");

		p.constructor = CSSPlugin;
		CSSPlugin.version = "1.18.5";
		CSSPlugin.API = 2;
		CSSPlugin.defaultTransformPerspective = 0;
		CSSPlugin.defaultSkewType = "compensated";
		CSSPlugin.defaultSmoothOrigin = true;
		p = "px"; //we'll reuse the "p" variable to keep file size down
		CSSPlugin.suffixMap = { top: p, right: p, bottom: p, left: p, width: p, height: p, fontSize: p, padding: p, margin: p, perspective: p, lineHeight: "" };

		var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
		    _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
		    _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
		    //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
		_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
		    //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
		_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
		    _opacityExp = /opacity *= *([^)]*)/i,
		    _opacityValExp = /opacity:([^;]*)/i,
		    _alphaFilterExp = /alpha\(opacity *=.+?\)/i,
		    _rgbhslExp = /^(rgb|hsl)/,
		    _capsExp = /([A-Z])/g,
		    _camelExp = /-([a-z])/gi,
		    _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
		    //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
		_camelFunc = function _camelFunc(s, g) {
			return g.toUpperCase();
		},
		    _horizExp = /(?:Left|Right|Width)/i,
		    _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
		    _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
		    _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi,
		    //finds any commas that are not within parenthesis
		_complexExp = /[\s,\(]/i,
		    //for testing a string to find if it has a space, comma, or open parenthesis (clues that it's a complex value)
		_DEG2RAD = Math.PI / 180,
		    _RAD2DEG = 180 / Math.PI,
		    _forcePT = {},
		    _doc = document,
		    _createElement = function _createElement(type) {
			return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
		},
		    _tempDiv = _createElement("div"),
		    _tempImg = _createElement("img"),
		    _internals = CSSPlugin._internals = { _specialProps: _specialProps },
		    //provides a hook to a few internal methods that we need to access from inside other plugins
		_agent = navigator.userAgent,
		    _autoRound,
		    _reqSafariFix,
		    //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

		_isSafari,
		    _isFirefox,
		    //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
		_isSafariLT6,
		    //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
		_ieVers,
		    _supportsOpacity = function () {
			//we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
			var i = _agent.indexOf("Android"),
			    a = _createElement("a");
			_isSafari = _agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i + 8, 1)) > 3);
			_isSafariLT6 = _isSafari && Number(_agent.substr(_agent.indexOf("Version/") + 8, 1)) < 6;
			_isFirefox = _agent.indexOf("Firefox") !== -1;
			if (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(_agent) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(_agent)) {
				_ieVers = parseFloat(RegExp.$1);
			}
			if (!a) {
				return false;
			}
			a.style.cssText = "top:1px;opacity:.55;";
			return (/^0.55/.test(a.style.opacity)
			);
		}(),
		    _getIEOpacity = function _getIEOpacity(v) {
			return _opacityExp.test(typeof v === "string" ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1;
		},
		    _log = function _log(s) {
			//for logging messages, but in a way that won't throw errors in old versions of IE.
			if (window.console) {
				console.log(s);
			}
		},
		    _prefixCSS = "",
		    //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
		_prefix = "",
		    //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

		// @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
		_checkPropPrefix = function _checkPropPrefix(p, e) {
			e = e || _tempDiv;
			var s = e.style,
			    a,
			    i;
			if (s[p] !== undefined) {
				return p;
			}
			p = p.charAt(0).toUpperCase() + p.substr(1);
			a = ["O", "Moz", "ms", "Ms", "Webkit"];
			i = 5;
			while (--i > -1 && s[a[i] + p] === undefined) {}
			if (i >= 0) {
				_prefix = i === 3 ? "ms" : a[i];
				_prefixCSS = "-" + _prefix.toLowerCase() + "-";
				return _prefix + p;
			}
			return null;
		},
		    _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function () {},


		/**
   * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
   * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
   *
   * @param {!Object} t Target element whose style property you want to query
   * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
   * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
   * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
   * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
   * @return {?string} The current property value
   */
		_getStyle = CSSPlugin.getStyle = function (t, p, cs, calc, dflt) {
			var rv;
			if (!_supportsOpacity) if (p === "opacity") {
				//several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
				return _getIEOpacity(t);
			}
			if (!calc && t.style[p]) {
				rv = t.style[p];
			} else if (cs = cs || _getComputedStyle(t)) {
				rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
			} else if (t.currentStyle) {
				rv = t.currentStyle[p];
			}
			return dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto") ? dflt : rv;
		},


		/**
   * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
   * @param {!Object} t Target element
   * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
   * @param {!number} v Value
   * @param {string=} sfx Suffix (like "px" or "%" or "em")
   * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
   * @return {number} value in pixels
   */
		_convertToPixels = _internals.convertToPixels = function (t, p, v, sfx, recurse) {
			if (sfx === "px" || !sfx) {
				return v;
			}
			if (sfx === "auto" || !v) {
				return 0;
			}
			var horiz = _horizExp.test(p),
			    node = t,
			    style = _tempDiv.style,
			    neg = v < 0,
			    precise = v === 1,
			    pix,
			    cache,
			    time;
			if (neg) {
				v = -v;
			}
			if (precise) {
				v *= 100;
			}
			if (sfx === "%" && p.indexOf("border") !== -1) {
				pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight);
			} else {
				style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
				if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
					node = t.parentNode || _doc.body;
					cache = node._gsCache;
					time = TweenLite.ticker.frame;
					if (cache && horiz && cache.time === time) {
						//performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
						return cache.width * v / 100;
					}
					style[horiz ? "width" : "height"] = v + sfx;
				} else {
					style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx;
				}
				node.appendChild(_tempDiv);
				pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"]);
				node.removeChild(_tempDiv);
				if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
					cache = node._gsCache = node._gsCache || {};
					cache.time = time;
					cache.width = pix / v * 100;
				}
				if (pix === 0 && !recurse) {
					pix = _convertToPixels(t, p, v, sfx, true);
				}
			}
			if (precise) {
				pix /= 100;
			}
			return neg ? -pix : pix;
		},
		    _calculateOffset = _internals.calculateOffset = function (t, p, cs) {
			//for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
			if (_getStyle(t, "position", cs) !== "absolute") {
				return 0;
			}
			var dim = p === "left" ? "Left" : "Top",
			    v = _getStyle(t, "margin" + dim, cs);
			return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
		},


		// @private returns at object containing ALL of the style properties in camelCase and their associated values.
		_getAllStyles = function _getAllStyles(t, cs) {
			var s = {},
			    i,
			    tr,
			    p;
			if (cs = cs || _getComputedStyle(t, null)) {
				if (i = cs.length) {
					while (--i > -1) {
						p = cs[i];
						if (p.indexOf("-transform") === -1 || _transformPropCSS === p) {
							//Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
							s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
						}
					}
				} else {
					//some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
					for (i in cs) {
						if (i.indexOf("Transform") === -1 || _transformProp === i) {
							//Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
							s[i] = cs[i];
						}
					}
				}
			} else if (cs = t.currentStyle || t.style) {
				for (i in cs) {
					if (typeof i === "string" && s[i] === undefined) {
						s[i.replace(_camelExp, _camelFunc)] = cs[i];
					}
				}
			}
			if (!_supportsOpacity) {
				s.opacity = _getIEOpacity(t);
			}
			tr = _getTransform(t, cs, false);
			s.rotation = tr.rotation;
			s.skewX = tr.skewX;
			s.scaleX = tr.scaleX;
			s.scaleY = tr.scaleY;
			s.x = tr.x;
			s.y = tr.y;
			if (_supports3D) {
				s.z = tr.z;
				s.rotationX = tr.rotationX;
				s.rotationY = tr.rotationY;
				s.scaleZ = tr.scaleZ;
			}
			if (s.filters) {
				delete s.filters;
			}
			return s;
		},


		// @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
		_cssDif = function _cssDif(t, s1, s2, vars, forceLookup) {
			var difs = {},
			    style = t.style,
			    val,
			    p,
			    mpt;
			for (p in s2) {
				if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || forceLookup && forceLookup[p]) if (p.indexOf("Origin") === -1) if (typeof val === "number" || typeof val === "string") {
					difs[p] = val === "auto" && (p === "left" || p === "top") ? _calculateOffset(t, p) : (val === "" || val === "auto" || val === "none") && typeof s1[p] === "string" && s1[p].replace(_NaNExp, "") !== "" ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
					if (style[p] !== undefined) {
						//for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
						mpt = new MiniPropTween(style, p, style[p], mpt);
					}
				}
			}
			if (vars) {
				for (p in vars) {
					//copy properties (except className)
					if (p !== "className") {
						difs[p] = vars[p];
					}
				}
			}
			return { difs: difs, firstMPT: mpt };
		},
		    _dimensions = { width: ["Left", "Right"], height: ["Top", "Bottom"] },
		    _margins = ["marginLeft", "marginRight", "marginTop", "marginBottom"],


		/**
   * @private Gets the width or height of an element
   * @param {!Object} t Target element
   * @param {!string} p Property name ("width" or "height")
   * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
   * @return {number} Dimension (in pixels)
   */
		_getDimension = function _getDimension(t, p, cs) {
			if ((t.nodeName + "").toLowerCase() === "svg") {
				//Chrome no longer supports offsetWidth/offsetHeight on SVG elements.
				return (cs || _getComputedStyle(t))[p] || 0;
			} else if (t.getBBox && _isSVG(t)) {
				return t.getBBox()[p] || 0;
			}
			var v = parseFloat(p === "width" ? t.offsetWidth : t.offsetHeight),
			    a = _dimensions[p],
			    i = a.length;
			cs = cs || _getComputedStyle(t, null);
			while (--i > -1) {
				v -= parseFloat(_getStyle(t, "padding" + a[i], cs, true)) || 0;
				v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, true)) || 0;
			}
			return v;
		},


		// @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
		_parsePosition = function _parsePosition(v, recObj) {
			if (v === "contain" || v === "auto" || v === "auto auto") {
				return v + " ";
			}
			if (v == null || v === "") {
				//note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
				v = "0 0";
			}
			var a = v.split(" "),
			    x = v.indexOf("left") !== -1 ? "0%" : v.indexOf("right") !== -1 ? "100%" : a[0],
			    y = v.indexOf("top") !== -1 ? "0%" : v.indexOf("bottom") !== -1 ? "100%" : a[1],
			    i;
			if (a.length > 3 && !recObj) {
				//multiple positions
				a = v.split(", ").join(",").split(",");
				v = [];
				for (i = 0; i < a.length; i++) {
					v.push(_parsePosition(a[i]));
				}
				return v.join(",");
			}
			if (y == null) {
				y = x === "center" ? "50%" : "0";
			} else if (y === "center") {
				y = "50%";
			}
			if (x === "center" || isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1) {
				//remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
				x = "50%";
			}
			v = x + " " + y + (a.length > 2 ? " " + a[2] : "");
			if (recObj) {
				recObj.oxp = x.indexOf("%") !== -1;
				recObj.oyp = y.indexOf("%") !== -1;
				recObj.oxr = x.charAt(1) === "=";
				recObj.oyr = y.charAt(1) === "=";
				recObj.ox = parseFloat(x.replace(_NaNExp, ""));
				recObj.oy = parseFloat(y.replace(_NaNExp, ""));
				recObj.v = v;
			}
			return recObj || v;
		},


		/**
   * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
   * @param {(number|string)} e End value which is typically a string, but could be a number
   * @param {(number|string)} b Beginning value which is typically a string but could be a number
   * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
   */
		_parseChange = function _parseChange(e, b) {
			return typeof e === "string" && e.charAt(1) === "=" ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b) || 0;
		},


		/**
   * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
   * @param {Object} v Value to be parsed
   * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
   * @return {number} Parsed value
   */
		_parseVal = function _parseVal(v, d) {
			return v == null ? d : typeof v === "string" && v.charAt(1) === "=" ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0;
		},


		/**
   * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
   * @param {Object} v Value to be parsed
   * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
   * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
   * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
   * @return {number} parsed angle in radians
   */
		_parseAngle = function _parseAngle(v, d, p, directionalEnd) {
			var min = 0.000001,
			    cap,
			    split,
			    dif,
			    result,
			    isRelative;
			if (v == null) {
				result = d;
			} else if (typeof v === "number") {
				result = v;
			} else {
				cap = 360;
				split = v.split("_");
				isRelative = v.charAt(1) === "=";
				dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * (v.indexOf("rad") === -1 ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
				if (split.length) {
					if (directionalEnd) {
						directionalEnd[p] = d + dif;
					}
					if (v.indexOf("short") !== -1) {
						dif = dif % cap;
						if (dif !== dif % (cap / 2)) {
							dif = dif < 0 ? dif + cap : dif - cap;
						}
					}
					if (v.indexOf("_cw") !== -1 && dif < 0) {
						dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
					} else if (v.indexOf("ccw") !== -1 && dif > 0) {
						dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
					}
				}
				result = d + dif;
			}
			if (result < min && result > -min) {
				result = 0;
			}
			return result;
		},
		    _colorLookup = { aqua: [0, 255, 255],
			lime: [0, 255, 0],
			silver: [192, 192, 192],
			black: [0, 0, 0],
			maroon: [128, 0, 0],
			teal: [0, 128, 128],
			blue: [0, 0, 255],
			navy: [0, 0, 128],
			white: [255, 255, 255],
			fuchsia: [255, 0, 255],
			olive: [128, 128, 0],
			yellow: [255, 255, 0],
			orange: [255, 165, 0],
			gray: [128, 128, 128],
			purple: [128, 0, 128],
			green: [0, 128, 0],
			red: [255, 0, 0],
			pink: [255, 192, 203],
			cyan: [0, 255, 255],
			transparent: [255, 255, 255, 0] },
		    _hue = function _hue(h, m1, m2) {
			h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
			return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255 + 0.5 | 0;
		},


		/**
   * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if toHSL parameter is true, it will populate the array with hue, saturation, and lightness values. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
   * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
   * @param {(boolean)} toHSL If true, an hsl() or hsla() value will be returned instead of rgb() or rgba()
   * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order, or if the toHSL parameter was true, the array will contain hue, saturation and lightness (and optionally alpha) in that order. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and toHSL is true.
   */
		_parseColor = CSSPlugin.parseColor = function (v, toHSL) {
			var a, r, g, b, h, s, l, max, min, d, wasHSL;
			if (!v) {
				a = _colorLookup.black;
			} else if (typeof v === "number") {
				a = [v >> 16, v >> 8 & 255, v & 255];
			} else {
				if (v.charAt(v.length - 1) === ",") {
					//sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
					v = v.substr(0, v.length - 1);
				}
				if (_colorLookup[v]) {
					a = _colorLookup[v];
				} else if (v.charAt(0) === "#") {
					if (v.length === 4) {
						//for shorthand like #9F0
						r = v.charAt(1);
						g = v.charAt(2);
						b = v.charAt(3);
						v = "#" + r + r + g + g + b + b;
					}
					v = parseInt(v.substr(1), 16);
					a = [v >> 16, v >> 8 & 255, v & 255];
				} else if (v.substr(0, 3) === "hsl") {
					a = wasHSL = v.match(_numExp);
					if (!toHSL) {
						h = Number(a[0]) % 360 / 360;
						s = Number(a[1]) / 100;
						l = Number(a[2]) / 100;
						g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
						r = l * 2 - g;
						if (a.length > 3) {
							a[3] = Number(v[3]);
						}
						a[0] = _hue(h + 1 / 3, r, g);
						a[1] = _hue(h, r, g);
						a[2] = _hue(h - 1 / 3, r, g);
					} else if (v.indexOf("=") !== -1) {
						//if relative values are found, just return the raw strings with the relative prefixes in place.
						return v.match(_relNumExp);
					}
				} else {
					a = v.match(_numExp) || _colorLookup.transparent;
				}
				a[0] = Number(a[0]);
				a[1] = Number(a[1]);
				a[2] = Number(a[2]);
				if (a.length > 3) {
					a[3] = Number(a[3]);
				}
			}
			if (toHSL && !wasHSL) {
				r = a[0] / 255;
				g = a[1] / 255;
				b = a[2] / 255;
				max = Math.max(r, g, b);
				min = Math.min(r, g, b);
				l = (max + min) / 2;
				if (max === min) {
					h = s = 0;
				} else {
					d = max - min;
					s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
					h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
					h *= 60;
				}
				a[0] = h + 0.5 | 0;
				a[1] = s * 100 + 0.5 | 0;
				a[2] = l * 100 + 0.5 | 0;
			}
			return a;
		},
		    _formatColors = function _formatColors(s, toHSL) {
			var colors = s.match(_colorExp) || [],
			    charIndex = 0,
			    parsed = colors.length ? "" : s,
			    i,
			    color,
			    temp;
			for (i = 0; i < colors.length; i++) {
				color = colors[i];
				temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
				charIndex += temp.length + color.length;
				color = _parseColor(color, toHSL);
				if (color.length === 3) {
					color.push(1);
				}
				parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
			}
			return parsed + s.substr(charIndex);
		},
		    _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

		for (p in _colorLookup) {
			_colorExp += "|" + p + "\\b";
		}
		_colorExp = new RegExp(_colorExp + ")", "gi");

		CSSPlugin.colorStringFilter = function (a) {
			var combined = a[0] + a[1],
			    toHSL;
			if (_colorExp.test(combined)) {
				toHSL = combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1;
				a[0] = _formatColors(a[0], toHSL);
				a[1] = _formatColors(a[1], toHSL);
			}
			_colorExp.lastIndex = 0;
		};

		if (!TweenLite.defaultStringFilter) {
			TweenLite.defaultStringFilter = CSSPlugin.colorStringFilter;
		}

		/**
   * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
   * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
   * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
   * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
   * @return {Function} formatter function
   */
		var _getFormatter = function _getFormatter(dflt, clr, collapsible, multi) {
			if (dflt == null) {
				return function (v) {
					return v;
				};
			}
			var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
			    dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
			    pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
			    sfx = dflt.charAt(dflt.length - 1) === ")" ? ")" : "",
			    delim = dflt.indexOf(" ") !== -1 ? " " : ",",
			    numVals = dVals.length,
			    dSfx = numVals > 0 ? dVals[0].replace(_numExp, "") : "",
			    _formatter2;
			if (!numVals) {
				return function (v) {
					return v;
				};
			}
			if (clr) {
				_formatter2 = function formatter(v) {
					var color, vals, i, a;
					if (typeof v === "number") {
						v += dSfx;
					} else if (multi && _commasOutsideParenExp.test(v)) {
						a = v.replace(_commasOutsideParenExp, "|").split("|");
						for (i = 0; i < a.length; i++) {
							a[i] = _formatter2(a[i]);
						}
						return a.join(",");
					}
					color = (v.match(_colorExp) || [dColor])[0];
					vals = v.split(color).join("").match(_valuesExp) || [];
					i = vals.length;
					if (numVals > i--) {
						while (++i < numVals) {
							vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
						}
					}
					return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
				};
				return _formatter2;
			}
			_formatter2 = function _formatter(v) {
				var vals, a, i;
				if (typeof v === "number") {
					v += dSfx;
				} else if (multi && _commasOutsideParenExp.test(v)) {
					a = v.replace(_commasOutsideParenExp, "|").split("|");
					for (i = 0; i < a.length; i++) {
						a[i] = _formatter2(a[i]);
					}
					return a.join(",");
				}
				vals = v.match(_valuesExp) || [];
				i = vals.length;
				if (numVals > i--) {
					while (++i < numVals) {
						vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
					}
				}
				return pfx + vals.join(delim) + sfx;
			};
			return _formatter2;
		},


		/**
   * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
   * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
   * @return {Function} a formatter function
   */
		_getEdgeParser = function _getEdgeParser(props) {
			props = props.split(",");
			return function (t, e, p, cssp, pt, plugin, vars) {
				var a = (e + "").split(" "),
				    i;
				vars = {};
				for (i = 0; i < 4; i++) {
					vars[props[i]] = a[i] = a[i] || a[(i - 1) / 2 >> 0];
				}
				return cssp.parse(t, vars, pt, plugin);
			};
		},


		// @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens  which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
		_setPluginRatio = _internals._setPluginRatio = function (v) {
			this.plugin.setRatio(v);
			var d = this.data,
			    proxy = d.proxy,
			    mpt = d.firstMPT,
			    min = 0.000001,
			    val,
			    pt,
			    i,
			    str,
			    p;
			while (mpt) {
				val = proxy[mpt.v];
				if (mpt.r) {
					val = Math.round(val);
				} else if (val < min && val > -min) {
					val = 0;
				}
				mpt.t[mpt.p] = val;
				mpt = mpt._next;
			}
			if (d.autoRotate) {
				d.autoRotate.rotation = proxy.rotation;
			}
			//at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method. Same for "b" at the beginning.
			if (v === 1 || v === 0) {
				mpt = d.firstMPT;
				p = v === 1 ? "e" : "b";
				while (mpt) {
					pt = mpt.t;
					if (!pt.type) {
						pt[p] = pt.s + pt.xs0;
					} else if (pt.type === 1) {
						str = pt.xs0 + pt.s + pt.xs1;
						for (i = 1; i < pt.l; i++) {
							str += pt["xn" + i] + pt["xs" + (i + 1)];
						}
						pt[p] = str;
					}
					mpt = mpt._next;
				}
			}
		},


		/**
   * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
   * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
   * @param {!string} p property name
   * @param {(number|string|object)} v value
   * @param {MiniPropTween=} next next MiniPropTween in the linked list
   * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
   */
		MiniPropTween = function MiniPropTween(t, p, v, next, r) {
			this.t = t;
			this.p = p;
			this.v = v;
			this.r = r;
			if (next) {
				next._prev = this;
				this._next = next;
			}
		},


		/**
   * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
   * This method returns an object that has the following properties:
   *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
   *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
   *  - firstMPT: the first MiniPropTween in the linked list
   *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
   * @param {!Object} t target object to be tweened
   * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
   * @param {!CSSPlugin} cssp The CSSPlugin instance
   * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
   * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
   * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
   * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
   */
		_parseToProxy = _internals._parseToProxy = function (t, vars, cssp, pt, plugin, shallow) {
			var bpt = pt,
			    start = {},
			    end = {},
			    transform = cssp._transform,
			    oldForce = _forcePT,
			    i,
			    p,
			    xp,
			    mpt,
			    firstPT;
			cssp._transform = null;
			_forcePT = vars;
			pt = firstPT = cssp.parse(t, vars, pt, plugin);
			_forcePT = oldForce;
			//break off from the linked list so the new ones are isolated.
			if (shallow) {
				cssp._transform = transform;
				if (bpt) {
					bpt._prev = null;
					if (bpt._prev) {
						bpt._prev._next = null;
					}
				}
			}
			while (pt && pt !== bpt) {
				if (pt.type <= 1) {
					p = pt.p;
					end[p] = pt.s + pt.c;
					start[p] = pt.s;
					if (!shallow) {
						mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
						pt.c = 0;
					}
					if (pt.type === 1) {
						i = pt.l;
						while (--i > 0) {
							xp = "xn" + i;
							p = pt.p + "_" + xp;
							end[p] = pt.data[xp];
							start[p] = pt[xp];
							if (!shallow) {
								mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
							}
						}
					}
				}
				pt = pt._next;
			}
			return { proxy: start, end: end, firstMPT: mpt, pt: firstPT };
		},


		/**
   * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
   * CSSPropTweens have the following optional properties as well (not defined through the constructor):
   *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
   *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
   *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
   *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
   *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
   * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
   * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
   * @param {number} s Starting numeric value
   * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
   * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
   * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
   * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
   * @param {boolean=} r If true, the value(s) should be rounded
   * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
   * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
   * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
   */
		CSSPropTween = _internals.CSSPropTween = function (t, p, s, c, next, type, n, r, pr, b, e) {
			this.t = t; //target
			this.p = p; //property
			this.s = s; //starting value
			this.c = c; //change value
			this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
			if (!(t instanceof CSSPropTween)) {
				_overwriteProps.push(this.n);
			}
			this.r = r; //round (boolean)
			this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
			if (pr) {
				this.pr = pr;
				_hasPriority = true;
			}
			this.b = b === undefined ? s : b;
			this.e = e === undefined ? s + c : e;
			if (next) {
				this._next = next;
				next._prev = this;
			}
		},
		    _addNonTweeningNumericPT = function _addNonTweeningNumericPT(target, prop, start, end, next, overwriteProp) {
			//cleans up some code redundancies and helps minification. Just a fast way to add a NUMERIC non-tweening CSSPropTween
			var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
			pt.b = start;
			pt.e = pt.xs0 = end;
			return pt;
		},


		/**
   * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
   * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
   * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
   * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
   *
   * @param {!Object} t Target whose property will be tweened
   * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
   * @param {string} b Beginning value
   * @param {string} e Ending value
   * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
   * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
   * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
   * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
   * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
   * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
   * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
   */
		_parseComplex = CSSPlugin.parseComplex = function (t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
			//DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
			b = b || dflt || "";
			pt = new CSSPropTween(t, p, 0, 0, pt, setRatio ? 2 : 1, null, false, pr, b, e);
			e += ""; //ensures it's a string
			if (clrs && _colorExp.test(e + b)) {
				//if colors are found, normalize the formatting to rgba() or hsla().
				e = [b, e];
				CSSPlugin.colorStringFilter(e);
				b = e[0];
				e = e[1];
			}
			var ba = b.split(", ").join(",").split(" "),
			    //beginning array
			ea = e.split(", ").join(",").split(" "),
			    //ending array
			l = ba.length,
			    autoRound = _autoRound !== false,
			    i,
			    xi,
			    ni,
			    bv,
			    ev,
			    bnums,
			    enums,
			    bn,
			    hasAlpha,
			    temp,
			    cv,
			    str,
			    useHSL;
			if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
				ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
				ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
				l = ba.length;
			}
			if (l !== ea.length) {
				//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
				ba = (dflt || "").split(" ");
				l = ba.length;
			}
			pt.plugin = plugin;
			pt.setRatio = setRatio;
			_colorExp.lastIndex = 0;
			for (i = 0; i < l; i++) {
				bv = ba[i];
				ev = ea[i];
				bn = parseFloat(bv);
				//if the value begins with a number (most common). It's fine if it has a suffix like px
				if (bn || bn === 0) {
					pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), autoRound && ev.indexOf("px") !== -1, true);

					//if the value is a color
				} else if (clrs && _colorExp.test(bv)) {
					str = ev.indexOf(")") + 1;
					str = ")" + (str ? ev.substr(str) : ""); //if there's a comma or ) at the end, retain it.
					useHSL = ev.indexOf("hsl") !== -1 && _supportsOpacity;
					bv = _parseColor(bv, useHSL);
					ev = _parseColor(ev, useHSL);
					hasAlpha = bv.length + ev.length > 6;
					if (hasAlpha && !_supportsOpacity && ev[3] === 0) {
						//older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
						pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
						pt.e = pt.e.split(ea[i]).join("transparent");
					} else {
						if (!_supportsOpacity) {
							//old versions of IE don't support rgba().
							hasAlpha = false;
						}
						if (useHSL) {
							pt.appendXtra(hasAlpha ? "hsla(" : "hsl(", bv[0], _parseChange(ev[0], bv[0]), ",", false, true).appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false).appendXtra("", bv[2], _parseChange(ev[2], bv[2]), hasAlpha ? "%," : "%" + str, false);
						} else {
							pt.appendXtra(hasAlpha ? "rgba(" : "rgb(", bv[0], ev[0] - bv[0], ",", true, true).appendXtra("", bv[1], ev[1] - bv[1], ",", true).appendXtra("", bv[2], ev[2] - bv[2], hasAlpha ? "," : str, true);
						}

						if (hasAlpha) {
							bv = bv.length < 4 ? 1 : bv[3];
							pt.appendXtra("", bv, (ev.length < 4 ? 1 : ev[3]) - bv, str, false);
						}
					}
					_colorExp.lastIndex = 0; //otherwise the test() on the RegExp could move the lastIndex and taint future results.
				} else {
					bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

					//if no number is found, treat it as a non-tweening value and just append the string to the current xs.
					if (!bnums) {
						pt["xs" + pt.l] += pt.l || pt["xs" + pt.l] ? " " + ev : ev;

						//loop through all the numbers that are found and construct the extra values on the pt.
					} else {
						enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
						if (!enums || enums.length !== bnums.length) {
							//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
							return pt;
						}
						ni = 0;
						for (xi = 0; xi < bnums.length; xi++) {
							cv = bnums[xi];
							temp = bv.indexOf(cv, ni);
							pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", autoRound && bv.substr(temp + cv.length, 2) === "px", xi === 0);
							ni = temp + cv.length;
						}
						pt["xs" + pt.l] += bv.substr(ni);
					}
				}
			}
			//if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
			if (e.indexOf("=") !== -1) if (pt.data) {
				str = pt.xs0 + pt.data.s;
				for (i = 1; i < pt.l; i++) {
					str += pt["xs" + i] + pt.data["xn" + i];
				}
				pt.e = str + pt["xs" + i];
			}
			if (!pt.l) {
				pt.type = -1;
				pt.xs0 = pt.e;
			}
			return pt.xfirst || pt;
		},
		    i = 9;

		p = CSSPropTween.prototype;
		p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
		while (--i > 0) {
			p["xn" + i] = 0;
			p["xs" + i] = "";
		}
		p.xs0 = "";
		p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;

		/**
   * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
   * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
   * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
   * @param {string=} pfx Prefix (if any)
   * @param {!number} s Starting value
   * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
   * @param {string=} sfx Suffix (if any)
   * @param {boolean=} r Round (if true).
   * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
   * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
   */
		p.appendXtra = function (pfx, s, c, sfx, r, pad) {
			var pt = this,
			    l = pt.l;
			pt["xs" + l] += pad && (l || pt["xs" + l]) ? " " + pfx : pfx || "";
			if (!c) if (l !== 0 && !pt.plugin) {
				//typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
				pt["xs" + l] += s + (sfx || "");
				return pt;
			}
			pt.l++;
			pt.type = pt.setRatio ? 2 : 1;
			pt["xs" + pt.l] = sfx || "";
			if (l > 0) {
				pt.data["xn" + l] = s + c;
				pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
				pt["xn" + l] = s;
				if (!pt.plugin) {
					pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
					pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
				}
				return pt;
			}
			pt.data = { s: s + c };
			pt.rxp = {};
			pt.s = s;
			pt.c = c;
			pt.r = r;
			return pt;
		};

		/**
   * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
   * @param {!string} p Property name (like "boxShadow" or "throwProps")
   * @param {Object=} options An object containing any of the following configuration options:
   *                      - defaultValue: the default value
   *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
   *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
   *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
   *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
   *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
   *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
   *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
   *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
   */
		var SpecialProp = function SpecialProp(p, options) {
			options = options || {};
			this.p = options.prefix ? _checkPropPrefix(p) || p : p;
			_specialProps[p] = _specialProps[this.p] = this;
			this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
			if (options.parser) {
				this.parse = options.parser;
			}
			this.clrs = options.color;
			this.multi = options.multi;
			this.keyword = options.keyword;
			this.dflt = options.defaultValue;
			this.pr = options.priority || 0;
		},


		//shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
		_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function (p, options, defaults) {
			if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== "object") {
				options = { parser: defaults }; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
			}
			var a = p.split(","),
			    d = options.defaultValue,
			    i,
			    temp;
			defaults = defaults || [d];
			for (i = 0; i < a.length; i++) {
				options.prefix = i === 0 && options.prefix;
				options.defaultValue = defaults[i] || d;
				temp = new SpecialProp(a[i], options);
			}
		},


		//creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
		_registerPluginProp = function _registerPluginProp(p) {
			if (!_specialProps[p]) {
				var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
				_registerComplexSpecialProp(p, { parser: function parser(t, e, p, cssp, pt, plugin, vars) {
						var pluginClass = _globals.com.greensock.plugins[pluginName];
						if (!pluginClass) {
							_log("Error: " + pluginName + " js file not loaded.");
							return pt;
						}
						pluginClass._cssRegister();
						return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
					} });
			}
		};

		p = SpecialProp.prototype;

		/**
   * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
   * @param {!Object} t target element
   * @param {(string|number|object)} b beginning value
   * @param {(string|number|object)} e ending (destination) value
   * @param {CSSPropTween=} pt next CSSPropTween in the linked list
   * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
   * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
   * @return {CSSPropTween=} First CSSPropTween in the linked list
   */
		p.parseComplex = function (t, b, e, pt, plugin, setRatio) {
			var kwd = this.keyword,
			    i,
			    ba,
			    ea,
			    l,
			    bi,
			    ei;
			//if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
			if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
				ba = b.replace(_commasOutsideParenExp, "|").split("|");
				ea = e.replace(_commasOutsideParenExp, "|").split("|");
			} else if (kwd) {
				ba = [b];
				ea = [e];
			}
			if (ea) {
				l = ea.length > ba.length ? ea.length : ba.length;
				for (i = 0; i < l; i++) {
					b = ba[i] = ba[i] || this.dflt;
					e = ea[i] = ea[i] || this.dflt;
					if (kwd) {
						bi = b.indexOf(kwd);
						ei = e.indexOf(kwd);
						if (bi !== ei) {
							if (ei === -1) {
								//if the keyword isn't in the end value, remove it from the beginning one.
								ba[i] = ba[i].split(kwd).join("");
							} else if (bi === -1) {
								//if the keyword isn't in the beginning, add it.
								ba[i] += " " + kwd;
							}
						}
					}
				}
				b = ba.join(", ");
				e = ea.join(", ");
			}
			return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
		};

		/**
   * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
   * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
   * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
   * @param {!Object} t Target object whose property is being tweened
   * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
   * @param {!string} p Property name
   * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
   * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
   * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
   * @param {Object=} vars Original vars object that contains the data for parsing.
   * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
   */
		p.parse = function (t, e, p, cssp, pt, plugin, vars) {
			return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
		};

		/**
   * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
   *  1) Target object whose property should be tweened (typically a DOM element)
   *  2) The end/destination value (could be a string, number, object, or whatever you want)
   *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
   *
   * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
   *
   * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
   *      var start = target.style.width;
   *      return function(ratio) {
   *              target.style.width = (start + value * ratio) + "px";
   *              console.log("set width to " + target.style.width);
   *          }
   * }, 0);
   *
   * Then, when I do this tween, it will trigger my special property:
   *
   * TweenLite.to(element, 1, {css:{myCustomProp:100}});
   *
   * In the example, of course, we're just changing the width, but you can do anything you want.
   *
   * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
   * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
   * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
   */
		CSSPlugin.registerSpecialProp = function (name, onInitTween, priority) {
			_registerComplexSpecialProp(name, { parser: function parser(t, e, p, cssp, pt, plugin, vars) {
					var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
					rv.plugin = plugin;
					rv.setRatio = onInitTween(t, e, cssp._tween, p);
					return rv;
				}, priority: priority });
		};

		//transform-related methods and properties
		CSSPlugin.useSVGTransformAttr = _isSafari || _isFirefox; //Safari and Firefox both have some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead (users can override this).
		var _transformProps = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
		    _transformProp = _checkPropPrefix("transform"),
		    //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
		_transformPropCSS = _prefixCSS + "transform",
		    _transformOriginProp = _checkPropPrefix("transformOrigin"),
		    _supports3D = _checkPropPrefix("perspective") !== null,
		    Transform = _internals.Transform = function () {
			this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
			this.force3D = CSSPlugin.defaultForce3D === false || !_supports3D ? false : CSSPlugin.defaultForce3D || "auto";
		},
		    _SVGElement = window.SVGElement,
		    _useSVGTransformAttr,

		//Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.

		_createSVG = function _createSVG(type, container, attributes) {
			var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
			    reg = /([a-z])([A-Z])/g,
			    p;
			for (p in attributes) {
				element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
			}
			container.appendChild(element);
			return element;
		},
		    _docElement = _doc.documentElement,
		    _forceSVGTransformAttr = function () {
			//IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
			var force = _ieVers || /Android/i.test(_agent) && !window.chrome,
			    svg,
			    rect,
			    width;
			if (_doc.createElementNS && !force) {
				//IE8 and earlier doesn't support SVG anyway
				svg = _createSVG("svg", _docElement);
				rect = _createSVG("rect", svg, { width: 100, height: 50, x: 100 });
				width = rect.getBoundingClientRect().width;
				rect.style[_transformOriginProp] = "50% 50%";
				rect.style[_transformProp] = "scaleX(0.5)";
				force = width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
				_docElement.removeChild(svg);
			}
			return force;
		}(),
		    _parseSVGOrigin = function _parseSVGOrigin(e, local, decoratee, absolute, smoothOrigin, skipRecord) {
			var tm = e._gsTransform,
			    m = _getMatrix(e, true),
			    v,
			    x,
			    y,
			    xOrigin,
			    yOrigin,
			    a,
			    b,
			    c,
			    d,
			    tx,
			    ty,
			    determinant,
			    xOriginOld,
			    yOriginOld;
			if (tm) {
				xOriginOld = tm.xOrigin; //record the original values before we alter them.
				yOriginOld = tm.yOrigin;
			}
			if (!absolute || (v = absolute.split(" ")).length < 2) {
				b = e.getBBox();
				local = _parsePosition(local).split(" ");
				v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x, (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y];
			}
			decoratee.xOrigin = xOrigin = parseFloat(v[0]);
			decoratee.yOrigin = yOrigin = parseFloat(v[1]);
			if (absolute && m !== _identity2DMatrix) {
				//if svgOrigin is being set, we must invert the matrix and determine where the absolute point is, factoring in the current transforms. Otherwise, the svgOrigin would be based on the element's non-transformed position on the canvas.
				a = m[0];
				b = m[1];
				c = m[2];
				d = m[3];
				tx = m[4];
				ty = m[5];
				determinant = a * d - b * c;
				x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
				y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
				xOrigin = decoratee.xOrigin = v[0] = x;
				yOrigin = decoratee.yOrigin = v[1] = y;
			}
			if (tm) {
				//avoid jump when transformOrigin is changed - adjust the x/y values accordingly
				if (skipRecord) {
					decoratee.xOffset = tm.xOffset;
					decoratee.yOffset = tm.yOffset;
					tm = decoratee;
				}
				if (smoothOrigin || smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false) {
					x = xOrigin - xOriginOld;
					y = yOrigin - yOriginOld;
					//originally, we simply adjusted the x and y values, but that would cause problems if, for example, you created a rotational tween part-way through an x/y tween. Managing the offset in a separate variable gives us ultimate flexibility.
					//tm.x -= x - (x * m[0] + y * m[2]);
					//tm.y -= y - (x * m[1] + y * m[3]);
					tm.xOffset += x * m[0] + y * m[2] - x;
					tm.yOffset += x * m[1] + y * m[3] - y;
				} else {
					tm.xOffset = tm.yOffset = 0;
				}
			}
			if (!skipRecord) {
				e.setAttribute("data-svg-origin", v.join(" "));
			}
		},
		    _canGetBBox = function _canGetBBox(e) {
			try {
				return e.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
			} catch (e) {}
		},
		    _isSVG = function _isSVG(e) {
			//reports if the element is an SVG on which getBBox() actually works
			return !!(_SVGElement && e.getBBox && e.getCTM && _canGetBBox(e) && (!e.parentNode || e.parentNode.getBBox && e.parentNode.getCTM));
		},
		    _identity2DMatrix = [1, 0, 0, 1, 0, 0],
		    _getMatrix = function _getMatrix(e, force2D) {
			var tm = e._gsTransform || new Transform(),
			    rnd = 100000,
			    style = e.style,
			    isDefault,
			    s,
			    m,
			    n,
			    dec,
			    none;
			if (_transformProp) {
				s = _getStyle(e, _transformPropCSS, null, true);
			} else if (e.currentStyle) {
				//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
				s = e.currentStyle.filter.match(_ieGetMatrixExp);
				s = s && s.length === 4 ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), tm.x || 0, tm.y || 0].join(",") : "";
			}
			isDefault = !s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)";
			if (isDefault && _transformProp && ((none = _getComputedStyle(e).display === "none") || !e.parentNode)) {
				if (none) {
					//browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none".
					n = style.display;
					style.display = "block";
				}
				if (!e.parentNode) {
					dec = 1; //flag
					_docElement.appendChild(e);
				}
				s = _getStyle(e, _transformPropCSS, null, true);
				isDefault = !s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)";
				if (n) {
					style.display = n;
				} else if (none) {
					_removeProp(style, "display");
				}
				if (dec) {
					_docElement.removeChild(e);
				}
			}
			if (tm.svg || e.getBBox && _isSVG(e)) {
				if (isDefault && (style[_transformProp] + "").indexOf("matrix") !== -1) {
					//some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
					s = style[_transformProp];
					isDefault = 0;
				}
				m = e.getAttribute("transform");
				if (isDefault && m) {
					if (m.indexOf("matrix") !== -1) {
						//just in case there's a "transform" value specified as an attribute instead of CSS style. Accept either a matrix() or simple translate() value though.
						s = m;
						isDefault = 0;
					} else if (m.indexOf("translate") !== -1) {
						s = "matrix(1,0,0,1," + m.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")";
						isDefault = 0;
					}
				}
			}
			if (isDefault) {
				return _identity2DMatrix;
			}
			//split the matrix values out into an array (m for matrix)
			m = (s || "").match(_numExp) || [];
			i = m.length;
			while (--i > -1) {
				n = Number(m[i]);
				m[i] = (dec = n - (n |= 0)) ? (dec * rnd + (dec < 0 ? -0.5 : 0.5) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
			}
			return force2D && m.length > 6 ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
		},


		/**
   * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
   * @param {!Object} t target element
   * @param {Object=} cs computed style object (optional)
   * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
   * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
   * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
   */
		_getTransform = _internals.getTransform = function (t, cs, rec, parse) {
			if (t._gsTransform && rec && !parse) {
				return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
			}
			var tm = rec ? t._gsTransform || new Transform() : new Transform(),
			    invX = tm.scaleX < 0,
			    //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
			min = 0.00002,
			    rnd = 100000,
			    zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0,
			    defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
			    m,
			    i,
			    scaleX,
			    scaleY,
			    rotation,
			    skewX;

			tm.svg = !!(t.getBBox && _isSVG(t));
			if (tm.svg) {
				_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
				_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
			}
			m = _getMatrix(t);
			if (m !== _identity2DMatrix) {

				if (m.length === 16) {
					//we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
					var a11 = m[0],
					    a21 = m[1],
					    a31 = m[2],
					    a41 = m[3],
					    a12 = m[4],
					    a22 = m[5],
					    a32 = m[6],
					    a42 = m[7],
					    a13 = m[8],
					    a23 = m[9],
					    a33 = m[10],
					    a14 = m[12],
					    a24 = m[13],
					    a34 = m[14],
					    a43 = m[11],
					    angle = Math.atan2(a32, a33),
					    t1,
					    t2,
					    t3,
					    t4,
					    cos,
					    sin;

					//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
					if (tm.zOrigin) {
						a34 = -tm.zOrigin;
						a14 = a13 * a34 - m[12];
						a24 = a23 * a34 - m[13];
						a34 = a33 * a34 + tm.zOrigin - m[14];
					}
					tm.rotationX = angle * _RAD2DEG;
					//rotationX
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						t1 = a12 * cos + a13 * sin;
						t2 = a22 * cos + a23 * sin;
						t3 = a32 * cos + a33 * sin;
						a13 = a12 * -sin + a13 * cos;
						a23 = a22 * -sin + a23 * cos;
						a33 = a32 * -sin + a33 * cos;
						a43 = a42 * -sin + a43 * cos;
						a12 = t1;
						a22 = t2;
						a32 = t3;
					}
					//rotationY
					angle = Math.atan2(-a31, a33);
					tm.rotationY = angle * _RAD2DEG;
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						t1 = a11 * cos - a13 * sin;
						t2 = a21 * cos - a23 * sin;
						t3 = a31 * cos - a33 * sin;
						a23 = a21 * sin + a23 * cos;
						a33 = a31 * sin + a33 * cos;
						a43 = a41 * sin + a43 * cos;
						a11 = t1;
						a21 = t2;
						a31 = t3;
					}
					//rotationZ
					angle = Math.atan2(a21, a11);
					tm.rotation = angle * _RAD2DEG;
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						a11 = a11 * cos + a12 * sin;
						t2 = a21 * cos + a22 * sin;
						a22 = a21 * -sin + a22 * cos;
						a32 = a31 * -sin + a32 * cos;
						a21 = t2;
					}

					if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) {
						//when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
						tm.rotationX = tm.rotation = 0;
						tm.rotationY = 180 - tm.rotationY;
					}

					tm.scaleX = (Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5 | 0) / rnd;
					tm.scaleY = (Math.sqrt(a22 * a22 + a23 * a23) * rnd + 0.5 | 0) / rnd;
					tm.scaleZ = (Math.sqrt(a32 * a32 + a33 * a33) * rnd + 0.5 | 0) / rnd;
					if (tm.rotationX || tm.rotationY) {
						tm.skewX = 0;
					} else {
						tm.skewX = a12 || a22 ? Math.atan2(a12, a22) * _RAD2DEG + tm.rotation : tm.skewX || 0;
						if (Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
							if (invX) {
								tm.scaleX *= -1;
								tm.skewX += tm.rotation <= 0 ? 180 : -180;
								tm.rotation += tm.rotation <= 0 ? 180 : -180;
							} else {
								tm.scaleY *= -1;
								tm.skewX += tm.skewX <= 0 ? 180 : -180;
							}
						}
					}
					tm.perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
					tm.x = a14;
					tm.y = a24;
					tm.z = a34;
					if (tm.svg) {
						tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
						tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
					}
				} else if (!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || !tm.rotationX && !tm.rotationY) {
					//sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
					var k = m.length >= 6,
					    a = k ? m[0] : 1,
					    b = m[1] || 0,
					    c = m[2] || 0,
					    d = k ? m[3] : 1;
					tm.x = m[4] || 0;
					tm.y = m[5] || 0;
					scaleX = Math.sqrt(a * a + b * b);
					scaleY = Math.sqrt(d * d + c * c);
					rotation = a || b ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
					skewX = c || d ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
					if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
						if (invX) {
							scaleX *= -1;
							skewX += rotation <= 0 ? 180 : -180;
							rotation += rotation <= 0 ? 180 : -180;
						} else {
							scaleY *= -1;
							skewX += skewX <= 0 ? 180 : -180;
						}
					}
					tm.scaleX = scaleX;
					tm.scaleY = scaleY;
					tm.rotation = rotation;
					tm.skewX = skewX;
					if (_supports3D) {
						tm.rotationX = tm.rotationY = tm.z = 0;
						tm.perspective = defaultTransformPerspective;
						tm.scaleZ = 1;
					}
					if (tm.svg) {
						tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
						tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
					}
				}
				tm.zOrigin = zOrigin;
				//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
				for (i in tm) {
					if (tm[i] < min) if (tm[i] > -min) {
						tm[i] = 0;
					}
				}
			}
			//DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective+ ", origin: "+ tm.xOrigin+ ","+ tm.yOrigin);
			if (rec) {
				t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
				if (tm.svg) {
					//if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
					if (_useSVGTransformAttr && t.style[_transformProp]) {
						TweenLite.delayedCall(0.001, function () {
							//if we apply this right away (before anything has rendered), we risk there being no transforms for a brief moment and it also interferes with adjusting the transformOrigin in a tween with immediateRender:true (it'd try reading the matrix and it wouldn't have the appropriate data in place because we just removed it).
							_removeProp(t.style, _transformProp);
						});
					} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
						TweenLite.delayedCall(0.001, function () {
							t.removeAttribute("transform");
						});
					}
				}
			}
			return tm;
		},


		//for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
		_setIETransformRatio = function _setIETransformRatio(v) {
			var t = this.data,
			    //refers to the element's _gsTransform object
			ang = -t.rotation * _DEG2RAD,
			    skew = ang + t.skewX * _DEG2RAD,
			    rnd = 100000,
			    a = (Math.cos(ang) * t.scaleX * rnd | 0) / rnd,
			    b = (Math.sin(ang) * t.scaleX * rnd | 0) / rnd,
			    c = (Math.sin(skew) * -t.scaleY * rnd | 0) / rnd,
			    d = (Math.cos(skew) * t.scaleY * rnd | 0) / rnd,
			    style = this.t.style,
			    cs = this.t.currentStyle,
			    filters,
			    val;
			if (!cs) {
				return;
			}
			val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
			b = -c;
			c = -val;
			filters = cs.filter;
			style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
			var w = this.t.offsetWidth,
			    h = this.t.offsetHeight,
			    clip = cs.position !== "absolute",
			    m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
			    ox = t.x + w * t.xPercent / 100,
			    oy = t.y + h * t.yPercent / 100,
			    dx,
			    dy;

			//if transformOrigin is being used, adjust the offset x and y
			if (t.ox != null) {
				dx = (t.oxp ? w * t.ox * 0.01 : t.ox) - w / 2;
				dy = (t.oyp ? h * t.oy * 0.01 : t.oy) - h / 2;
				ox += dx - (dx * a + dy * b);
				oy += dy - (dx * c + dy * d);
			}

			if (!clip) {
				m += ", sizingMethod='auto expand')";
			} else {
				dx = w / 2;
				dy = h / 2;
				//translate to ensure that transformations occur around the correct origin (default is center).
				m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
			}
			if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
				style.filter = filters.replace(_ieSetMatrixExp, m);
			} else {
				style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
			}

			//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
			if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
				style.removeAttribute("filter");
			}

			//we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
			if (!clip) {
				var mult = _ieVers < 8 ? 1 : -1,
				    //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
				marg,
				    prop,
				    dif;
				dx = t.ieOffsetX || 0;
				dy = t.ieOffsetY || 0;
				t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
				t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
				for (i = 0; i < 4; i++) {
					prop = _margins[i];
					marg = cs[prop];
					//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
					val = marg.indexOf("px") !== -1 ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
					if (val !== t[prop]) {
						dif = i < 2 ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
					} else {
						dif = i < 2 ? dx - t.ieOffsetX : dy - t.ieOffsetY;
					}
					style[prop] = (t[prop] = Math.round(val - dif * (i === 0 || i === 2 ? 1 : mult))) + "px";
				}
			}
		},


		/* translates a super small decimal to a string WITHOUT scientific notation
  _safeDecimal = function(n) {
  	var s = (n < 0 ? -n : n) + "",
  		a = s.split("e-");
  	return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
  },
  */

		_setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function (v) {
			var t = this.data,
			    //refers to the element's _gsTransform object
			style = this.t.style,
			    angle = t.rotation,
			    rotationX = t.rotationX,
			    rotationY = t.rotationY,
			    sx = t.scaleX,
			    sy = t.scaleY,
			    sz = t.scaleZ,
			    x = t.x,
			    y = t.y,
			    z = t.z,
			    isSVG = t.svg,
			    perspective = t.perspective,
			    force3D = t.force3D,
			    a11,
			    a12,
			    a13,
			    a21,
			    a22,
			    a23,
			    a31,
			    a32,
			    a33,
			    a41,
			    a42,
			    a43,
			    zOrigin,
			    min,
			    cos,
			    sin,
			    t1,
			    t2,
			    transform,
			    comma,
			    zero,
			    skew,
			    rnd;
			//check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
			if (((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1 || _useSVGTransformAttr && isSVG || !_supports3D) {
				//on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.

				//2D
				if (angle || t.skewX || isSVG) {
					angle *= _DEG2RAD;
					skew = t.skewX * _DEG2RAD;
					rnd = 100000;
					a11 = Math.cos(angle) * sx;
					a21 = Math.sin(angle) * sx;
					a12 = Math.sin(angle - skew) * -sy;
					a22 = Math.cos(angle - skew) * sy;
					if (skew && t.skewType === "simple") {
						//by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
						t1 = Math.tan(skew);
						t1 = Math.sqrt(1 + t1 * t1);
						a12 *= t1;
						a22 *= t1;
						if (t.skewY) {
							a11 *= t1;
							a21 *= t1;
						}
					}
					if (isSVG) {
						x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
						y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
						if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) {
							//The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the matrix to simulate it.
							min = this.t.getBBox();
							x += t.xPercent * 0.01 * min.width;
							y += t.yPercent * 0.01 * min.height;
						}
						min = 0.000001;
						if (x < min) if (x > -min) {
							x = 0;
						}
						if (y < min) if (y > -min) {
							y = 0;
						}
					}
					transform = (a11 * rnd | 0) / rnd + "," + (a21 * rnd | 0) / rnd + "," + (a12 * rnd | 0) / rnd + "," + (a22 * rnd | 0) / rnd + "," + x + "," + y + ")";
					if (isSVG && _useSVGTransformAttr) {
						this.t.setAttribute("transform", "matrix(" + transform);
					} else {
						//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
						style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
					}
				} else {
					style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
				}
				return;
			}
			if (_isFirefox) {
				//Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
				min = 0.0001;
				if (sx < min && sx > -min) {
					sx = sz = 0.00002;
				}
				if (sy < min && sy > -min) {
					sy = sz = 0.00002;
				}
				if (perspective && !t.z && !t.rotationX && !t.rotationY) {
					//Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
					perspective = 0;
				}
			}
			if (angle || t.skewX) {
				angle *= _DEG2RAD;
				cos = a11 = Math.cos(angle);
				sin = a21 = Math.sin(angle);
				if (t.skewX) {
					angle -= t.skewX * _DEG2RAD;
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					if (t.skewType === "simple") {
						//by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
						t1 = Math.tan(t.skewX * _DEG2RAD);
						t1 = Math.sqrt(1 + t1 * t1);
						cos *= t1;
						sin *= t1;
						if (t.skewY) {
							a11 *= t1;
							a21 *= t1;
						}
					}
				}
				a12 = -sin;
				a22 = cos;
			} else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) {
				//if we're only translating and/or 2D scaling, this is faster...
				style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + (sx !== 1 || sy !== 1 ? " scale(" + sx + "," + sy + ")" : "");
				return;
			} else {
				a11 = a22 = 1;
				a12 = a21 = 0;
			}
			// KEY  INDEX   AFFECTS
			// a11  0       rotation, rotationY, scaleX
			// a21  1       rotation, rotationY, scaleX
			// a31  2       rotationY, scaleX
			// a41  3       rotationY, scaleX
			// a12  4       rotation, skewX, rotationX, scaleY
			// a22  5       rotation, skewX, rotationX, scaleY
			// a32  6       rotationX, scaleY
			// a42  7       rotationX, scaleY
			// a13  8       rotationY, rotationX, scaleZ
			// a23  9       rotationY, rotationX, scaleZ
			// a33  10      rotationY, rotationX, scaleZ
			// a43  11      rotationY, rotationX, perspective, scaleZ
			// a14  12      x, zOrigin, svgOrigin
			// a24  13      y, zOrigin, svgOrigin
			// a34  14      z, zOrigin
			// a44  15
			// rotation: Math.atan2(a21, a11)
			// rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
			// rotationX: Math.atan2(a32, a33)
			a33 = 1;
			a13 = a23 = a31 = a32 = a41 = a42 = 0;
			a43 = perspective ? -1 / perspective : 0;
			zOrigin = t.zOrigin;
			min = 0.000001; //threshold below which browsers use scientific notation which won't work.
			comma = ",";
			zero = "0";
			angle = rotationY * _DEG2RAD;
			if (angle) {
				cos = Math.cos(angle);
				sin = Math.sin(angle);
				a31 = -sin;
				a41 = a43 * -sin;
				a13 = a11 * sin;
				a23 = a21 * sin;
				a33 = cos;
				a43 *= cos;
				a11 *= cos;
				a21 *= cos;
			}
			angle = rotationX * _DEG2RAD;
			if (angle) {
				cos = Math.cos(angle);
				sin = Math.sin(angle);
				t1 = a12 * cos + a13 * sin;
				t2 = a22 * cos + a23 * sin;
				a32 = a33 * sin;
				a42 = a43 * sin;
				a13 = a12 * -sin + a13 * cos;
				a23 = a22 * -sin + a23 * cos;
				a33 = a33 * cos;
				a43 = a43 * cos;
				a12 = t1;
				a22 = t2;
			}
			if (sz !== 1) {
				a13 *= sz;
				a23 *= sz;
				a33 *= sz;
				a43 *= sz;
			}
			if (sy !== 1) {
				a12 *= sy;
				a22 *= sy;
				a32 *= sy;
				a42 *= sy;
			}
			if (sx !== 1) {
				a11 *= sx;
				a21 *= sx;
				a31 *= sx;
				a41 *= sx;
			}

			if (zOrigin || isSVG) {
				if (zOrigin) {
					x += a13 * -zOrigin;
					y += a23 * -zOrigin;
					z += a33 * -zOrigin + zOrigin;
				}
				if (isSVG) {
					//due to bugs in some browsers, we need to manage the transform-origin of SVG manually
					x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
					y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
				}
				if (x < min && x > -min) {
					x = zero;
				}
				if (y < min && y > -min) {
					y = zero;
				}
				if (z < min && z > -min) {
					z = 0; //don't use string because we calculate perspective later and need the number.
				}
			}

			//optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
			transform = t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(";
			transform += (a11 < min && a11 > -min ? zero : a11) + comma + (a21 < min && a21 > -min ? zero : a21) + comma + (a31 < min && a31 > -min ? zero : a31);
			transform += comma + (a41 < min && a41 > -min ? zero : a41) + comma + (a12 < min && a12 > -min ? zero : a12) + comma + (a22 < min && a22 > -min ? zero : a22);
			if (rotationX || rotationY || sz !== 1) {
				//performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
				transform += comma + (a32 < min && a32 > -min ? zero : a32) + comma + (a42 < min && a42 > -min ? zero : a42) + comma + (a13 < min && a13 > -min ? zero : a13);
				transform += comma + (a23 < min && a23 > -min ? zero : a23) + comma + (a33 < min && a33 > -min ? zero : a33) + comma + (a43 < min && a43 > -min ? zero : a43) + comma;
			} else {
				transform += ",0,0,0,0,1,0,";
			}
			transform += x + comma + y + comma + z + comma + (perspective ? 1 + -z / perspective : 1) + ")";

			style[_transformProp] = transform;
		};

		p = Transform.prototype;
		p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
		p.scaleX = p.scaleY = p.scaleZ = 1;

		_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", { parser: function parser(t, e, p, cssp, pt, plugin, vars) {
				if (cssp._lastParsedTransform === vars) {
					return pt;
				} //only need to parse the transform once, and only if the browser supports it.
				cssp._lastParsedTransform = vars;
				var originalGSTransform = t._gsTransform,
				    style = t.style,
				    min = 0.000001,
				    i = _transformProps.length,
				    v = vars,
				    endRotations = {},
				    transformOriginString = "transformOrigin",
				    m1 = _getTransform(t, _cs, true, vars.parseTransform),
				    m2,
				    copy,
				    orig,
				    has3D,
				    hasChange,
				    dr,
				    x,
				    y,
				    matrix;
				cssp._transform = m1;
				if (typeof v.transform === "string" && _transformProp) {
					//for values like transform:"rotate(60deg) scale(0.5, 0.8)"
					copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
					copy[_transformProp] = v.transform;
					copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
					copy.position = "absolute";
					_doc.body.appendChild(_tempDiv);
					m2 = _getTransform(_tempDiv, null, false);
					if (m1.svg) {
						//if it's an SVG element, x/y part of the matrix will be affected by whatever we use as the origin and the offsets, so compensate here...
						x = m1.xOrigin;
						y = m1.yOrigin;
						m2.x -= m1.xOffset;
						m2.y -= m1.yOffset;
						if (v.transformOrigin || v.svgOrigin) {
							//if this tween is altering the origin, we must factor that in here. The actual work of recording the transformOrigin values and setting up the PropTween is done later (still inside this function) so we cannot leave the changes intact here - we only want to update the x/y accordingly.
							orig = {};
							_parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);
							x = orig.xOrigin;
							y = orig.yOrigin;
							m2.x -= orig.xOffset - m1.xOffset;
							m2.y -= orig.yOffset - m1.yOffset;
						}
						if (x || y) {
							matrix = _getMatrix(_tempDiv, true);
							m2.x -= x - (x * matrix[0] + y * matrix[2]);
							m2.y -= y - (x * matrix[1] + y * matrix[3]);
						}
					}
					_doc.body.removeChild(_tempDiv);
					if (!m2.perspective) {
						m2.perspective = m1.perspective; //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
					}
					if (v.xPercent != null) {
						m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
					}
					if (v.yPercent != null) {
						m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
					}
				} else if ((typeof v === "undefined" ? "undefined" : _typeof(v)) === "object") {
					//for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
					m2 = { scaleX: _parseVal(v.scaleX != null ? v.scaleX : v.scale, m1.scaleX),
						scaleY: _parseVal(v.scaleY != null ? v.scaleY : v.scale, m1.scaleY),
						scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
						x: _parseVal(v.x, m1.x),
						y: _parseVal(v.y, m1.y),
						z: _parseVal(v.z, m1.z),
						xPercent: _parseVal(v.xPercent, m1.xPercent),
						yPercent: _parseVal(v.yPercent, m1.yPercent),
						perspective: _parseVal(v.transformPerspective, m1.perspective) };
					dr = v.directionalRotation;
					if (dr != null) {
						if ((typeof dr === "undefined" ? "undefined" : _typeof(dr)) === "object") {
							for (copy in dr) {
								v[copy] = dr[copy];
							}
						} else {
							v.rotation = dr;
						}
					}
					if (typeof v.x === "string" && v.x.indexOf("%") !== -1) {
						m2.x = 0;
						m2.xPercent = _parseVal(v.x, m1.xPercent);
					}
					if (typeof v.y === "string" && v.y.indexOf("%") !== -1) {
						m2.y = 0;
						m2.yPercent = _parseVal(v.y, m1.yPercent);
					}

					m2.rotation = _parseAngle("rotation" in v ? v.rotation : "shortRotation" in v ? v.shortRotation + "_short" : "rotationZ" in v ? v.rotationZ : m1.rotation - m1.skewY, m1.rotation - m1.skewY, "rotation", endRotations); //see notes below about skewY for why we subtract it from rotation here
					if (_supports3D) {
						m2.rotationX = _parseAngle("rotationX" in v ? v.rotationX : "shortRotationX" in v ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
						m2.rotationY = _parseAngle("rotationY" in v ? v.rotationY : "shortRotationY" in v ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
					}
					m2.skewX = _parseAngle(v.skewX, m1.skewX - m1.skewY); //see notes below about skewY and why we subtract it from skewX here

					//note: for performance reasons, we combine all skewing into the skewX and rotation values, ignoring skewY but we must still record it so that we can discern how much of the overall skew is attributed to skewX vs. skewY. Otherwise, if the skewY would always act relative (tween skewY to 10deg, for example, multiple times and if we always combine things into skewX, we can't remember that skewY was 10 from last time). Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of -10 degrees.
					if (m2.skewY = _parseAngle(v.skewY, m1.skewY)) {
						m2.skewX += m2.skewY;
						m2.rotation += m2.skewY;
					}
				}
				if (_supports3D && v.force3D != null) {
					m1.force3D = v.force3D;
					hasChange = true;
				}

				m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;

				has3D = m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective;
				if (!has3D && v.scale != null) {
					m2.scaleZ = 1; //no need to tween scaleZ.
				}

				while (--i > -1) {
					p = _transformProps[i];
					orig = m2[p] - m1[p];
					if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
						hasChange = true;
						pt = new CSSPropTween(m1, p, m1[p], orig, pt);
						if (p in endRotations) {
							pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
						}
						pt.xs0 = 0; //ensures the value stays numeric in setRatio()
						pt.plugin = plugin;
						cssp._overwriteProps.push(pt.n);
					}
				}

				orig = v.transformOrigin;
				if (m1.svg && (orig || v.svgOrigin)) {
					x = m1.xOffset; //when we change the origin, in order to prevent things from jumping we adjust the x/y so we must record those here so that we can create PropTweens for them and flip them at the same time as the origin
					y = m1.yOffset;
					_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
					pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString); //note: if there wasn't a transformOrigin defined yet, just start with the destination one; it's wasteful otherwise, and it causes problems with fromTo() tweens. For example, TweenLite.to("#wheel", 3, {rotation:180, transformOrigin:"50% 50%", delay:1}); TweenLite.fromTo("#wheel", 3, {scale:0.5, transformOrigin:"50% 50%"}, {scale:1, delay:2}); would cause a jump when the from values revert at the beginning of the 2nd tween.
					pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
					if (x !== m1.xOffset || y !== m1.yOffset) {
						pt = _addNonTweeningNumericPT(m1, "xOffset", originalGSTransform ? x : m1.xOffset, m1.xOffset, pt, transformOriginString);
						pt = _addNonTweeningNumericPT(m1, "yOffset", originalGSTransform ? y : m1.yOffset, m1.yOffset, pt, transformOriginString);
					}
					orig = _useSVGTransformAttr ? null : "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
				}
				if (orig || _supports3D && has3D && m1.zOrigin) {
					//if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
					if (_transformProp) {
						hasChange = true;
						p = _transformOriginProp;
						orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors
						pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
						pt.b = style[p];
						pt.plugin = plugin;
						if (_supports3D) {
							copy = m1.zOrigin;
							orig = orig.split(" ");
							m1.zOrigin = (orig.length > 2 && !(copy !== 0 && orig[2] === "0px") ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
							pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
							pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
							pt.b = copy;
							pt.xs0 = pt.e = m1.zOrigin;
						} else {
							pt.xs0 = pt.e = orig;
						}

						//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
					} else {
						_parsePosition(orig + "", m1);
					}
				}
				if (hasChange) {
					cssp._transformType = !(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3) ? 3 : 2; //quicker than calling cssp._enableTransforms();
				}
				return pt;
			}, prefix: true });

		_registerComplexSpecialProp("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: true, color: true, multi: true, keyword: "inset" });

		_registerComplexSpecialProp("borderRadius", { defaultValue: "0px", parser: function parser(t, e, p, cssp, pt, plugin) {
				e = this.format(e);
				var props = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
				    style = t.style,
				    ea1,
				    i,
				    es2,
				    bs2,
				    bs,
				    es,
				    bn,
				    en,
				    w,
				    h,
				    esfx,
				    bsfx,
				    rel,
				    hn,
				    vn,
				    em;
				w = parseFloat(t.offsetWidth);
				h = parseFloat(t.offsetHeight);
				ea1 = e.split(" ");
				for (i = 0; i < props.length; i++) {
					//if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
					if (this.p.indexOf("border")) {
						//older browsers used a prefix
						props[i] = _checkPropPrefix(props[i]);
					}
					bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
					if (bs.indexOf(" ") !== -1) {
						bs2 = bs.split(" ");
						bs = bs2[0];
						bs2 = bs2[1];
					}
					es = es2 = ea1[i];
					bn = parseFloat(bs);
					bsfx = bs.substr((bn + "").length);
					rel = es.charAt(1) === "=";
					if (rel) {
						en = parseInt(es.charAt(0) + "1", 10);
						es = es.substr(2);
						en *= parseFloat(es);
						esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
					} else {
						en = parseFloat(es);
						esfx = es.substr((en + "").length);
					}
					if (esfx === "") {
						esfx = _suffixMap[p] || bsfx;
					}
					if (esfx !== bsfx) {
						hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
						vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
						if (esfx === "%") {
							bs = hn / w * 100 + "%";
							bs2 = vn / h * 100 + "%";
						} else if (esfx === "em") {
							em = _convertToPixels(t, "borderLeft", 1, "em");
							bs = hn / em + "em";
							bs2 = vn / em + "em";
						} else {
							bs = hn + "px";
							bs2 = vn + "px";
						}
						if (rel) {
							es = parseFloat(bs) + en + esfx;
							es2 = parseFloat(bs2) + en + esfx;
						}
					}
					pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
				}
				return pt;
			}, prefix: true, formatter: _getFormatter("0px 0px 0px 0px", false, true) });
		_registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", { defaultValue: "0px", parser: function parser(t, e, p, cssp, pt, plugin) {
				return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt);
			}, prefix: true, formatter: _getFormatter("0px 0px", false, true) });
		_registerComplexSpecialProp("backgroundPosition", { defaultValue: "0 0", parser: function parser(t, e, p, cssp, pt, plugin) {
				var bp = "background-position",
				    cs = _cs || _getComputedStyle(t, null),
				    bs = this.format((cs ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
				    //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
				es = this.format(e),
				    ba,
				    ea,
				    i,
				    pct,
				    overlap,
				    src;
				if (bs.indexOf("%") !== -1 !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
					src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
					if (src && src !== "none") {
						ba = bs.split(" ");
						ea = es.split(" ");
						_tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
						i = 2;
						while (--i > -1) {
							bs = ba[i];
							pct = bs.indexOf("%") !== -1;
							if (pct !== (ea[i].indexOf("%") !== -1)) {
								overlap = i === 0 ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
								ba[i] = pct ? parseFloat(bs) / 100 * overlap + "px" : parseFloat(bs) / overlap * 100 + "%";
							}
						}
						bs = ba.join(" ");
					}
				}
				return this.parseComplex(t.style, bs, es, pt, plugin);
			}, formatter: _parsePosition });
		_registerComplexSpecialProp("backgroundSize", { defaultValue: "0 0", formatter: _parsePosition });
		_registerComplexSpecialProp("perspective", { defaultValue: "0px", prefix: true });
		_registerComplexSpecialProp("perspectiveOrigin", { defaultValue: "50% 50%", prefix: true });
		_registerComplexSpecialProp("transformStyle", { prefix: true });
		_registerComplexSpecialProp("backfaceVisibility", { prefix: true });
		_registerComplexSpecialProp("userSelect", { prefix: true });
		_registerComplexSpecialProp("margin", { parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft") });
		_registerComplexSpecialProp("padding", { parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft") });
		_registerComplexSpecialProp("clip", { defaultValue: "rect(0px,0px,0px,0px)", parser: function parser(t, e, p, cssp, pt, plugin) {
				var b, cs, delim;
				if (_ieVers < 9) {
					//IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
					cs = t.currentStyle;
					delim = _ieVers < 8 ? " " : ",";
					b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
					e = this.format(e).split(",").join(delim);
				} else {
					b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
					e = this.format(e);
				}
				return this.parseComplex(t.style, b, e, pt, plugin);
			} });
		_registerComplexSpecialProp("textShadow", { defaultValue: "0px 0px 0px #999", color: true, multi: true });
		_registerComplexSpecialProp("autoRound,strictUnits", { parser: function parser(t, e, p, cssp, pt) {
				return pt;
			} }); //just so that we can ignore these properties (not tween them)
		_registerComplexSpecialProp("border", { defaultValue: "0px solid #000", parser: function parser(t, e, p, cssp, pt, plugin) {
				var bw = _getStyle(t, "borderTopWidth", _cs, false, "0px"),
				    end = this.format(e).split(" "),
				    esfx = end[0].replace(_suffixExp, "");
				if (esfx !== "px") {
					//if we're animating to a non-px value, we need to convert the beginning width to that unit.
					bw = parseFloat(bw) / _convertToPixels(t, "borderTopWidth", 1, esfx) + esfx;
				}
				return this.parseComplex(t.style, this.format(bw + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), end.join(" "), pt, plugin);
			}, color: true, formatter: function formatter(v) {
				var a = v.split(" ");
				return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
			} });
		_registerComplexSpecialProp("borderWidth", { parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth") }); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
		_registerComplexSpecialProp("float,cssFloat,styleFloat", { parser: function parser(t, e, p, cssp, pt, plugin) {
				var s = t.style,
				    prop = "cssFloat" in s ? "cssFloat" : "styleFloat";
				return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
			} });

		//opacity-related
		var _setIEOpacityRatio = function _setIEOpacityRatio(v) {
			var t = this.t,
			    //refers to the element's style property
			filters = t.filter || _getStyle(this.data, "filter") || "",
			    val = this.s + this.c * v | 0,
			    skip;
			if (val === 100) {
				//for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
				if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
					t.removeAttribute("filter");
					skip = !_getStyle(this.data, "filter"); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
				} else {
					t.filter = filters.replace(_alphaFilterExp, "");
					skip = true;
				}
			}
			if (!skip) {
				if (this.xn1) {
					t.filter = filters = filters || "alpha(opacity=" + val + ")"; //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
				}
				if (filters.indexOf("pacity") === -1) {
					//only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
					if (val !== 0 || !this.xn1) {
						//bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
						t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
					}
				} else {
					t.filter = filters.replace(_opacityExp, "opacity=" + val);
				}
			}
		};
		_registerComplexSpecialProp("opacity,alpha,autoAlpha", { defaultValue: "1", parser: function parser(t, e, p, cssp, pt, plugin) {
				var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
				    style = t.style,
				    isAutoAlpha = p === "autoAlpha";
				if (typeof e === "string" && e.charAt(1) === "=") {
					e = (e.charAt(0) === "-" ? -1 : 1) * parseFloat(e.substr(2)) + b;
				}
				if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) {
					//if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
					b = 0;
				}
				if (_supportsOpacity) {
					pt = new CSSPropTween(style, "opacity", b, e - b, pt);
				} else {
					pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
					pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
					style.zoom = 1; //helps correct an IE issue.
					pt.type = 2;
					pt.b = "alpha(opacity=" + pt.s + ")";
					pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
					pt.data = t;
					pt.plugin = plugin;
					pt.setRatio = _setIEOpacityRatio;
				}
				if (isAutoAlpha) {
					//we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
					pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, b !== 0 ? "inherit" : "hidden", e === 0 ? "hidden" : "inherit");
					pt.xs0 = "inherit";
					cssp._overwriteProps.push(pt.n);
					cssp._overwriteProps.push(p);
				}
				return pt;
			} });

		var _removeProp = function _removeProp(s, p) {
			if (p) {
				if (s.removeProperty) {
					if (p.substr(0, 2) === "ms" || p.substr(0, 6) === "webkit") {
						//Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
						p = "-" + p;
					}
					s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
				} else {
					//note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
					s.removeAttribute(p);
				}
			}
		},
		    _setClassNameRatio = function _setClassNameRatio(v) {
			this.t._gsClassPT = this;
			if (v === 1 || v === 0) {
				this.t.setAttribute("class", v === 0 ? this.b : this.e);
				var mpt = this.data,
				    //first MiniPropTween
				s = this.t.style;
				while (mpt) {
					if (!mpt.v) {
						_removeProp(s, mpt.p);
					} else {
						s[mpt.p] = mpt.v;
					}
					mpt = mpt._next;
				}
				if (v === 1 && this.t._gsClassPT === this) {
					this.t._gsClassPT = null;
				}
			} else if (this.t.getAttribute("class") !== this.e) {
				this.t.setAttribute("class", this.e);
			}
		};
		_registerComplexSpecialProp("className", { parser: function parser(t, e, p, cssp, pt, plugin, vars) {
				var b = t.getAttribute("class") || "",
				    //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
				cssText = t.style.cssText,
				    difData,
				    bs,
				    cnpt,
				    cnptLookup,
				    mpt;
				pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
				pt.setRatio = _setClassNameRatio;
				pt.pr = -11;
				_hasPriority = true;
				pt.b = b;
				bs = _getAllStyles(t, _cs);
				//if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
				cnpt = t._gsClassPT;
				if (cnpt) {
					cnptLookup = {};
					mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
					while (mpt) {
						cnptLookup[mpt.p] = 1;
						mpt = mpt._next;
					}
					cnpt.setRatio(1);
				}
				t._gsClassPT = pt;
				pt.e = e.charAt(1) !== "=" ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + (e.charAt(0) === "+" ? " " + e.substr(2) : "");
				t.setAttribute("class", pt.e);
				difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
				t.setAttribute("class", b);
				pt.data = difData.firstMPT;
				t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
				pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
				return pt;
			} });

		var _setClearPropsRatio = function _setClearPropsRatio(v) {
			if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
				//this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
				var s = this.t.style,
				    transformParse = _specialProps.transform.parse,
				    a,
				    p,
				    i,
				    clearTransform,
				    transform;
				if (this.e === "all") {
					s.cssText = "";
					clearTransform = true;
				} else {
					a = this.e.split(" ").join("").split(",");
					i = a.length;
					while (--i > -1) {
						p = a[i];
						if (_specialProps[p]) {
							if (_specialProps[p].parse === transformParse) {
								clearTransform = true;
							} else {
								p = p === "transformOrigin" ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
							}
						}
						_removeProp(s, p);
					}
				}
				if (clearTransform) {
					_removeProp(s, _transformProp);
					transform = this.t._gsTransform;
					if (transform) {
						if (transform.svg) {
							this.t.removeAttribute("data-svg-origin");
							this.t.removeAttribute("transform");
						}
						delete this.t._gsTransform;
					}
				}
			}
		};
		_registerComplexSpecialProp("clearProps", { parser: function parser(t, e, p, cssp, pt) {
				pt = new CSSPropTween(t, p, 0, 0, pt, 2);
				pt.setRatio = _setClearPropsRatio;
				pt.e = e;
				pt.pr = -10;
				pt.data = cssp._tween;
				_hasPriority = true;
				return pt;
			} });

		p = "bezier,throwProps,physicsProps,physics2D".split(",");
		i = p.length;
		while (i--) {
			_registerPluginProp(p[i]);
		}

		p = CSSPlugin.prototype;
		p._firstPT = p._lastParsedTransform = p._transform = null;

		//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
		p._onInitTween = function (target, vars, tween) {
			if (!target.nodeType) {
				//css is only for dom elements
				return false;
			}
			this._target = target;
			this._tween = tween;
			this._vars = vars;
			_autoRound = vars.autoRound;
			_hasPriority = false;
			_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
			_cs = _getComputedStyle(target, "");
			_overwriteProps = this._overwriteProps;
			var style = target.style,
			    v,
			    pt,
			    pt2,
			    first,
			    last,
			    next,
			    zIndex,
			    tpt,
			    threeD;
			if (_reqSafariFix) if (style.zIndex === "") {
				v = _getStyle(target, "zIndex", _cs);
				if (v === "auto" || v === "") {
					//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
					this._addLazySet(style, "zIndex", 0);
				}
			}

			if (typeof vars === "string") {
				first = style.cssText;
				v = _getAllStyles(target, _cs);
				style.cssText = first + ";" + vars;
				v = _cssDif(target, v, _getAllStyles(target)).difs;
				if (!_supportsOpacity && _opacityValExp.test(vars)) {
					v.opacity = parseFloat(RegExp.$1);
				}
				vars = v;
				style.cssText = first;
			}

			if (vars.className) {
				//className tweens will combine any differences they find in the css with the vars that are passed in, so {className:"myClass", scale:0.5, left:20} would work.
				this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
			} else {
				this._firstPT = pt = this.parse(target, vars, null);
			}

			if (this._transformType) {
				threeD = this._transformType === 3;
				if (!_transformProp) {
					style.zoom = 1; //helps correct an IE issue.
				} else if (_isSafari) {
					_reqSafariFix = true;
					//if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
					if (style.zIndex === "") {
						zIndex = _getStyle(target, "zIndex", _cs);
						if (zIndex === "auto" || zIndex === "") {
							this._addLazySet(style, "zIndex", 0);
						}
					}
					//Setting WebkitBackfaceVisibility corrects 3 bugs:
					// 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
					// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
					// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
					//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
					if (_isSafariLT6) {
						this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
					}
				}
				pt2 = pt;
				while (pt2 && pt2._next) {
					pt2 = pt2._next;
				}
				tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
				this._linkCSSP(tpt, null, pt2);
				tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
				tpt.data = this._transform || _getTransform(target, _cs, true);
				tpt.tween = tween;
				tpt.pr = -1; //ensures that the transforms get applied after the components are updated.
				_overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
			}

			if (_hasPriority) {
				//reorders the linked list in order of pr (priority)
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if (pt._prev = pt2 ? pt2._prev : last) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if (pt._next = pt2) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				this._firstPT = first;
			}
			return true;
		};

		p.parse = function (target, vars, pt, plugin) {
			var style = target.style,
			    p,
			    sp,
			    bn,
			    en,
			    bs,
			    es,
			    bsfx,
			    esfx,
			    isStr,
			    rel;
			for (p in vars) {
				es = vars[p]; //ending value string
				sp = _specialProps[p]; //SpecialProp lookup.
				if (sp) {
					pt = sp.parse(target, es, p, this, pt, plugin, vars);
				} else {
					bs = _getStyle(target, p, _cs) + "";
					isStr = typeof es === "string";
					if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || isStr && _rgbhslExp.test(es)) {
						//Opera uses background: to define color sometimes in addition to backgroundColor:
						if (!isStr) {
							es = _parseColor(es);
							es = (es.length > 3 ? "rgba(" : "rgb(") + es.join(",") + ")";
						}
						pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);
					} else if (isStr && _complexExp.test(es)) {
						pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);
					} else {
						bn = parseFloat(bs);
						bsfx = bn || bn === 0 ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

						if (bs === "" || bs === "auto") {
							if (p === "width" || p === "height") {
								bn = _getDimension(target, p, _cs);
								bsfx = "px";
							} else if (p === "left" || p === "top") {
								bn = _calculateOffset(target, p, _cs);
								bsfx = "px";
							} else {
								bn = p !== "opacity" ? 0 : 1;
								bsfx = "";
							}
						}

						rel = isStr && es.charAt(1) === "=";
						if (rel) {
							en = parseInt(es.charAt(0) + "1", 10);
							es = es.substr(2);
							en *= parseFloat(es);
							esfx = es.replace(_suffixExp, "");
						} else {
							en = parseFloat(es);
							esfx = isStr ? es.replace(_suffixExp, "") : "";
						}

						if (esfx === "") {
							esfx = p in _suffixMap ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
						}

						es = en || en === 0 ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.

						//if the beginning/ending suffixes don't match, normalize them...
						if (bsfx !== esfx) if (esfx !== "") if (en || en === 0) if (bn) {
							//note: if the beginning value (bn) is 0, we don't need to convert units!
							bn = _convertToPixels(target, p, bn, bsfx);
							if (esfx === "%") {
								bn /= _convertToPixels(target, p, 100, "%") / 100;
								if (vars.strictUnits !== true) {
									//some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
									bs = bn + "%";
								}
							} else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
								bn /= _convertToPixels(target, p, 1, esfx);

								//otherwise convert to pixels.
							} else if (esfx !== "px") {
								en = _convertToPixels(target, p, en, esfx);
								esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
							}
							if (rel) if (en || en === 0) {
								es = en + bn + esfx; //the changes we made affect relative calculations, so adjust the end value here.
							}
						}

						if (rel) {
							en += bn;
						}

						if ((bn || bn === 0) && (en || en === 0)) {
							//faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
							pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, _autoRound !== false && (esfx === "px" || p === "zIndex"), 0, bs, es);
							pt.xs0 = esfx;
							//DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
						} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
							_log("invalid " + p + " tween value: " + vars[p]);
						} else {
							pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
							pt.xs0 = es === "none" && (p === "display" || p.indexOf("Style") !== -1) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
							//DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
						}
					}
				}
				if (plugin) if (pt && !pt.plugin) {
					pt.plugin = plugin;
				}
			}
			return pt;
		};

		//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
		p.setRatio = function (v) {
			var pt = this._firstPT,
			    min = 0.000001,
			    val,
			    str,
			    i;
			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
			if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
				while (pt) {
					if (pt.type !== 2) {
						if (pt.r && pt.type !== -1) {
							val = Math.round(pt.s + pt.c);
							if (!pt.type) {
								pt.t[pt.p] = val + pt.xs0;
							} else if (pt.type === 1) {
								//complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
								i = pt.l;
								str = pt.xs0 + val + pt.xs1;
								for (i = 1; i < pt.l; i++) {
									str += pt["xn" + i] + pt["xs" + (i + 1)];
								}
								pt.t[pt.p] = str;
							}
						} else {
							pt.t[pt.p] = pt.e;
						}
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
				while (pt) {
					val = pt.c * v + pt.s;
					if (pt.r) {
						val = Math.round(val);
					} else if (val < min) if (val > -min) {
						val = 0;
					}
					if (!pt.type) {
						pt.t[pt.p] = val + pt.xs0;
					} else if (pt.type === 1) {
						//complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
						i = pt.l;
						if (i === 2) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
						} else if (i === 3) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
						} else if (i === 4) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
						} else if (i === 5) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
						} else {
							str = pt.xs0 + val + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn" + i] + pt["xs" + (i + 1)];
							}
							pt.t[pt.p] = str;
						}
					} else if (pt.type === -1) {
						//non-tweening value
						pt.t[pt.p] = pt.xs0;
					} else if (pt.setRatio) {
						//custom setRatio() for things like SpecialProps, external plugins, etc.
						pt.setRatio(v);
					}
					pt = pt._next;
				}

				//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
			} else {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.b;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			}
		};

		/**
   * @private
   * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
   * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
   * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
   * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
   * doesn't have any transform-related properties of its own. You can call this method as many times as you
   * want and it won't create duplicate CSSPropTweens.
   *
   * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
   */
		p._enableTransforms = function (threeD) {
			this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
			this._transformType = !(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3) ? 3 : 2;
		};

		var lazySet = function lazySet(v) {
			this.t[this.p] = this.e;
			this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
		};
		/** @private Gives us a way to set a value on the first render (and only the first render). **/
		p._addLazySet = function (t, p, v) {
			var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
			pt.e = v;
			pt.setRatio = lazySet;
			pt.data = this;
		};

		/** @private **/
		p._linkCSSP = function (pt, next, prev, remove) {
			if (pt) {
				if (next) {
					next._prev = pt;
				}
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
					remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
				}
				if (prev) {
					prev._next = pt;
				} else if (!remove && this._firstPT === null) {
					this._firstPT = pt;
				}
				pt._next = next;
				pt._prev = prev;
			}
			return pt;
		};

		//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
		p._kill = function (lookup) {
			var copy = lookup,
			    pt,
			    p,
			    xfirst;
			if (lookup.autoAlpha || lookup.alpha) {
				copy = {};
				for (p in lookup) {
					//copy the lookup so that we're not changing the original which may be passed elsewhere.
					copy[p] = lookup[p];
				}
				copy.opacity = 1;
				if (copy.autoAlpha) {
					copy.visibility = 1;
				}
			}
			if (lookup.className && (pt = this._classNamePT)) {
				//for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
				xfirst = pt.xfirst;
				if (xfirst && xfirst._prev) {
					this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
				} else if (xfirst === this._firstPT) {
					this._firstPT = pt._next;
				}
				if (pt._next) {
					this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
				}
				this._classNamePT = null;
			}
			return TweenPlugin.prototype._kill.call(this, copy);
		};

		//used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
		var _getChildStyles = function _getChildStyles(e, props, targets) {
			var children, i, child, type;
			if (e.slice) {
				i = e.length;
				while (--i > -1) {
					_getChildStyles(e[i], props, targets);
				}
				return;
			}
			children = e.childNodes;
			i = children.length;
			while (--i > -1) {
				child = children[i];
				type = child.type;
				if (child.style) {
					props.push(_getAllStyles(child));
					if (targets) {
						targets.push(child);
					}
				}
				if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
					_getChildStyles(child, props, targets);
				}
			}
		};

		/**
   * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
   * and then compares the style properties of all the target's child elements at the tween's start and end, and
   * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
   * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
   * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
   * is because it creates entirely new tweens that may have completely different targets than the original tween,
   * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
   * and it would create other problems. For example:
   *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
   *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
   *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
   *
   * @param {Object} target object to be tweened
   * @param {number} Duration in seconds (or frames for frames-based tweens)
   * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
   * @return {Array} An array of TweenLite instances
   */
		CSSPlugin.cascadeTo = function (target, duration, vars) {
			var tween = TweenLite.to(target, duration, vars),
			    results = [tween],
			    b = [],
			    e = [],
			    targets = [],
			    _reservedProps = TweenLite._internals.reservedProps,
			    i,
			    difs,
			    p,
			    from;
			target = tween._targets || tween.target;
			_getChildStyles(target, b, targets);
			tween.render(duration, true, true);
			_getChildStyles(target, e);
			tween.render(0, true, true);
			tween._enabled(true);
			i = targets.length;
			while (--i > -1) {
				difs = _cssDif(targets[i], b[i], e[i]);
				if (difs.firstMPT) {
					difs = difs.difs;
					for (p in vars) {
						if (_reservedProps[p]) {
							difs[p] = vars[p];
						}
					}
					from = {};
					for (p in difs) {
						from[p] = b[i][p];
					}
					results.push(TweenLite.fromTo(targets[i], duration, from, difs));
				}
			}
			return results;
		};

		TweenPlugin.activate([CSSPlugin]);
		return CSSPlugin;
	}, true);

	/*
  * ----------------------------------------------------------------
  * RoundPropsPlugin
  * ----------------------------------------------------------------
  */
	(function () {

		var RoundPropsPlugin = _gsScope._gsDefine.plugin({
			propName: "roundProps",
			version: "1.5",
			priority: -1,
			API: 2,

			//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function init(target, value, tween) {
				this._tween = tween;
				return true;
			}

		}),
		    _roundLinkedList = function _roundLinkedList(node) {
			while (node) {
				if (!node.f && !node.blob) {
					node.r = 1;
				}
				node = node._next;
			}
		},
		    p = RoundPropsPlugin.prototype;

		p._onInitAllProps = function () {
			var tween = this._tween,
			    rp = tween.vars.roundProps.join ? tween.vars.roundProps : tween.vars.roundProps.split(","),
			    i = rp.length,
			    lookup = {},
			    rpt = tween._propLookup.roundProps,
			    prop,
			    pt,
			    next;
			while (--i > -1) {
				lookup[rp[i]] = 1;
			}
			i = rp.length;
			while (--i > -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._roundProps(lookup, true);
					} else if (pt.n === prop) {
						if (pt.f === 2 && pt.t) {
							//a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this._add(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
								next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = next;
							} else if (tween._firstPT === pt) {
								tween._firstPT = next;
							}
							pt._next = pt._prev = null;
							tween._propLookup[prop] = rpt;
						}
					}
					pt = next;
				}
			}
			return false;
		};

		p._add = function (target, p, s, c) {
			this._addTween(target, p, s, s + c, p, true);
			this._overwriteProps.push(p);
		};
	})();

	/*
  * ----------------------------------------------------------------
  * AttrPlugin
  * ----------------------------------------------------------------
  */

	(function () {

		_gsScope._gsDefine.plugin({
			propName: "attr",
			API: 2,
			version: "0.5.0",

			//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function init(target, value, tween) {
				var p;
				if (typeof target.setAttribute !== "function") {
					return false;
				}
				for (p in value) {
					this._addTween(target, "setAttribute", target.getAttribute(p) + "", value[p] + "", p, false, p);
					this._overwriteProps.push(p);
				}
				return true;
			}

		});
	})();

	/*
  * ----------------------------------------------------------------
  * DirectionalRotationPlugin
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine.plugin({
		propName: "directionalRotation",
		version: "0.2.1",
		API: 2,

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function init(target, value, tween) {
			if ((typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object") {
				value = { rotation: value };
			}
			this.finals = {};
			var cap = value.useRadians === true ? Math.PI * 2 : 360,
			    min = 0.000001,
			    p,
			    v,
			    start,
			    end,
			    dif,
			    split;
			for (p in value) {
				if (p !== "useRadians") {
					split = (value[p] + "").split("_");
					v = split[0];
					start = parseFloat(typeof target[p] !== "function" ? target[p] : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]());
					end = this.finals[p] = typeof v === "string" && v.charAt(1) === "=" ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join("_");
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = dif < 0 ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
						}
					}
					if (dif > min || dif < -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function set(ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}

	})._autoCSS = true;

	/*
  * ----------------------------------------------------------------
  * EasePack
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("easing.Back", ["easing.Ease"], function (Ease) {

		var w = _gsScope.GreenSockGlobals || _gsScope,
		    gs = w.com.greensock,
		    _2PI = Math.PI * 2,
		    _HALF_PI = Math.PI / 2,
		    _class = gs._class,
		    _create = function _create(n, f) {
			var C = _class("easing." + n, function () {}, true),
			    p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			return C;
		},
		    _easeReg = Ease.register || function () {},
		    //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
		_wrap = function _wrap(name, EaseOut, EaseIn, EaseInOut, aliases) {
			var C = _class("easing." + name, {
				easeOut: new EaseOut(),
				easeIn: new EaseIn(),
				easeInOut: new EaseInOut()
			}, true);
			_easeReg(C, name);
			return C;
		},
		    EasePoint = function EasePoint(time, value, next) {
			this.t = time;
			this.v = value;
			if (next) {
				this.next = next;
				next.prev = this;
				this.c = next.v - value;
				this.gap = next.t - time;
			}
		},


		//Back
		_createBack = function _createBack(n, f) {
			var C = _class("easing." + n, function (overshoot) {
				this._p1 = overshoot || overshoot === 0 ? overshoot : 1.70158;
				this._p2 = this._p1 * 1.525;
			}, true),
			    p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function (overshoot) {
				return new C(overshoot);
			};
			return C;
		},
		    Back = _wrap("Back", _createBack("BackOut", function (p) {
			return (p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1;
		}), _createBack("BackIn", function (p) {
			return p * p * ((this._p1 + 1) * p - this._p1);
		}), _createBack("BackInOut", function (p) {
			return (p *= 2) < 1 ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
		})),


		//SlowMo
		SlowMo = _class("easing.SlowMo", function (linearRatio, power, yoyoMode) {
			power = power || power === 0 ? power : 0.7;
			if (linearRatio == null) {
				linearRatio = 0.7;
			} else if (linearRatio > 1) {
				linearRatio = 1;
			}
			this._p = linearRatio !== 1 ? power : 0;
			this._p1 = (1 - linearRatio) / 2;
			this._p2 = linearRatio;
			this._p3 = this._p1 + this._p2;
			this._calcEnd = yoyoMode === true;
		}, true),
		    p = SlowMo.prototype = new Ease(),
		    SteppedEase,
		    RoughEase,
		    _createElastic;

		p.constructor = SlowMo;
		p.getRatio = function (p) {
			var r = p + (0.5 - p) * this._p;
			if (p < this._p1) {
				return this._calcEnd ? 1 - (p = 1 - p / this._p1) * p : r - (p = 1 - p / this._p1) * p * p * p * r;
			} else if (p > this._p3) {
				return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + (p - r) * (p = (p - this._p3) / this._p1) * p * p * p;
			}
			return this._calcEnd ? 1 : r;
		};
		SlowMo.ease = new SlowMo(0.7, 0.7);

		p.config = SlowMo.config = function (linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		};

		//SteppedEase
		SteppedEase = _class("easing.SteppedEase", function (steps) {
			steps = steps || 1;
			this._p1 = 1 / steps;
			this._p2 = steps + 1;
		}, true);
		p = SteppedEase.prototype = new Ease();
		p.constructor = SteppedEase;
		p.getRatio = function (p) {
			if (p < 0) {
				p = 0;
			} else if (p >= 1) {
				p = 0.999999999;
			}
			return (this._p2 * p >> 0) * this._p1;
		};
		p.config = SteppedEase.config = function (steps) {
			return new SteppedEase(steps);
		};

		//RoughEase
		RoughEase = _class("easing.RoughEase", function (vars) {
			vars = vars || {};
			var taper = vars.taper || "none",
			    a = [],
			    cnt = 0,
			    points = (vars.points || 20) | 0,
			    i = points,
			    randomize = vars.randomize !== false,
			    clamp = vars.clamp === true,
			    template = vars.template instanceof Ease ? vars.template : null,
			    strength = typeof vars.strength === "number" ? vars.strength * 0.4 : 0.4,
			    x,
			    y,
			    bump,
			    invX,
			    obj,
			    pnt;
			while (--i > -1) {
				x = randomize ? Math.random() : 1 / points * i;
				y = template ? template.getRatio(x) : x;
				if (taper === "none") {
					bump = strength;
				} else if (taper === "out") {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === "in") {
					bump = x * x * strength;
				} else if (x < 0.5) {
					//"both" (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {
					//"both" (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += Math.random() * bump - bump * 0.5;
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y > 1) {
						y = 1;
					} else if (y < 0) {
						y = 0;
					}
				}
				a[cnt++] = { x: x, y: y };
			}
			a.sort(function (a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i > -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, pnt.t !== 0 ? pnt : pnt.next);
		}, true);
		p = RoughEase.prototype = new Ease();
		p.constructor = RoughEase;
		p.getRatio = function (p) {
			var pnt = this._prev;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return pnt.v + (p - pnt.t) / pnt.gap * pnt.c;
		};
		p.config = function (vars) {
			return new RoughEase(vars);
		};
		RoughEase.ease = new RoughEase();

		//Bounce
		_wrap("Bounce", _create("BounceOut", function (p) {
			if (p < 1 / 2.75) {
				return 7.5625 * p * p;
			} else if (p < 2 / 2.75) {
				return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
			} else if (p < 2.5 / 2.75) {
				return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
			}
			return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
		}), _create("BounceIn", function (p) {
			if ((p = 1 - p) < 1 / 2.75) {
				return 1 - 7.5625 * p * p;
			} else if (p < 2 / 2.75) {
				return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
			} else if (p < 2.5 / 2.75) {
				return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
			}
			return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
		}), _create("BounceInOut", function (p) {
			var invert = p < 0.5;
			if (invert) {
				p = 1 - p * 2;
			} else {
				p = p * 2 - 1;
			}
			if (p < 1 / 2.75) {
				p = 7.5625 * p * p;
			} else if (p < 2 / 2.75) {
				p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
			} else if (p < 2.5 / 2.75) {
				p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
			} else {
				p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}
			return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
		}));

		//CIRC
		_wrap("Circ", _create("CircOut", function (p) {
			return Math.sqrt(1 - (p = p - 1) * p);
		}), _create("CircIn", function (p) {
			return -(Math.sqrt(1 - p * p) - 1);
		}), _create("CircInOut", function (p) {
			return (p *= 2) < 1 ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
		}));

		//Elastic
		_createElastic = function _createElastic(n, f, def) {
			var C = _class("easing." + n, function (amplitude, period) {
				this._p1 = amplitude >= 1 ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
				this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
				this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
				this._p2 = _2PI / this._p2; //precalculate to optimize
			}, true),
			    p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function (amplitude, period) {
				return new C(amplitude, period);
			};
			return C;
		};
		_wrap("Elastic", _createElastic("ElasticOut", function (p) {
			return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * this._p2) + 1;
		}, 0.3), _createElastic("ElasticIn", function (p) {
			return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2));
		}, 0.3), _createElastic("ElasticInOut", function (p) {
			return (p *= 2) < 1 ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2) * 0.5 + 1;
		}, 0.45));

		//Expo
		_wrap("Expo", _create("ExpoOut", function (p) {
			return 1 - Math.pow(2, -10 * p);
		}), _create("ExpoIn", function (p) {
			return Math.pow(2, 10 * (p - 1)) - 0.001;
		}), _create("ExpoInOut", function (p) {
			return (p *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
		}));

		//Sine
		_wrap("Sine", _create("SineOut", function (p) {
			return Math.sin(p * _HALF_PI);
		}), _create("SineIn", function (p) {
			return -Math.cos(p * _HALF_PI) + 1;
		}), _create("SineInOut", function (p) {
			return -0.5 * (Math.cos(Math.PI * p) - 1);
		}));

		_class("easing.EaseLookup", {
			find: function find(s) {
				return Ease.map[s];
			}
		}, true);

		//register the non-standard eases
		_easeReg(w.SlowMo, "SlowMo", "ease,");
		_easeReg(RoughEase, "RoughEase", "ease,");
		_easeReg(SteppedEase, "SteppedEase", "ease,");

		return Back;
	}, true);
});

if (_gsScope._gsDefine) {
	_gsScope._gsQueue.pop()();
} //necessary in case TweenLite was already loaded separately.


/*
 * ----------------------------------------------------------------
 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.
 * ----------------------------------------------------------------
 */
(function (window, moduleName) {

	"use strict";

	var _exports = {},
	    _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
	if (_globals.TweenLite) {
		return; //in case the core set of classes is already loaded, don't instantiate twice.
	}
	var _namespace = function _namespace(ns) {
		var a = ns.split("."),
		    p = _globals,
		    i;
		for (i = 0; i < a.length; i++) {
			p[a[i]] = p = p[a[i]] || {};
		}
		return p;
	},
	    gs = _namespace("com.greensock"),
	    _tinyNum = 0.0000000001,
	    _slice = function _slice(a) {
		//don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
		var b = [],
		    l = a.length,
		    i;
		for (i = 0; i !== l; b.push(a[i++])) {}
		return b;
	},
	    _emptyFunc = function _emptyFunc() {},
	    _isArray = function () {
		//works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
		var toString = Object.prototype.toString,
		    array = toString.call([]);
		return function (obj) {
			return obj != null && (obj instanceof Array || (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" && !!obj.push && toString.call(obj) === array);
		};
	}(),
	    a,
	    i,
	    p,
	    _ticker,
	    _tickerActive,
	    _defLookup = {},


	/**
  * @constructor
  * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
  * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
  * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
  * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
  *
  * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
  * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
  * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
  * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
  * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
  * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
  * sandbox the banner one like:
  *
  * <script>
  *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
  * </script>
  * <script src="js/greensock/v1.7/TweenMax.js"></script>
  * <script>
  *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
  * </script>
  * <script src="js/greensock/v1.6/TweenMax.js"></script>
  * <script>
  *     gs.TweenLite.to(...); //would use v1.7
  *     TweenLite.to(...); //would use v1.6
  * </script>
  *
  * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
  * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
  * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
  * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
  */
	Definition = function Definition(ns, dependencies, func, global) {
		this.sc = _defLookup[ns] ? _defLookup[ns].sc : []; //subclasses
		_defLookup[ns] = this;
		this.gsClass = null;
		this.func = func;
		var _classes = [];
		this.check = function (init) {
			var i = dependencies.length,
			    missing = i,
			    cur,
			    a,
			    n,
			    cl,
			    hasModule;
			while (--i > -1) {
				if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
					_classes[i] = cur.gsClass;
					missing--;
				} else if (init) {
					cur.sc.push(this);
				}
			}
			if (missing === 0 && func) {
				a = ("com.greensock." + ns).split(".");
				n = a.pop();
				cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

				//exports to multiple environments
				if (global) {
					_globals[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
					hasModule = typeof module !== "undefined" && module.exports;
					if (!hasModule && typeof define === "function" && define.amd) {
						//AMD
						define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function () {
							return cl;
						});
					} else if (hasModule) {
						//node
						if (ns === moduleName) {
							module.exports = _exports[moduleName] = cl;
							for (i in _exports) {
								cl[i] = _exports[i];
							}
						} else if (_exports[moduleName]) {
							_exports[moduleName][n] = cl;
						}
					}
				}
				for (i = 0; i < this.sc.length; i++) {
					this.sc[i].check();
				}
			}
		};
		this.check(true);
	},


	//used to create Definition instances (which basically registers a class that has dependencies).
	_gsDefine = window._gsDefine = function (ns, dependencies, func, global) {
		return new Definition(ns, dependencies, func, global);
	},


	//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
	_class = gs._class = function (ns, func, global) {
		func = func || function () {};
		_gsDefine(ns, [], function () {
			return func;
		}, global);
		return func;
	};

	_gsDefine.globals = _globals;

	/*
  * ----------------------------------------------------------------
  * Ease
  * ----------------------------------------------------------------
  */
	var _baseParams = [0, 0, 1, 1],
	    _blankArray = [],
	    Ease = _class("easing.Ease", function (func, extraParams, type, power) {
		this._func = func;
		this._type = type || 0;
		this._power = power || 0;
		this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
	}, true),
	    _easeMap = Ease.map = {},
	    _easeReg = Ease.register = function (ease, names, types, create) {
		var na = names.split(","),
		    i = na.length,
		    ta = (types || "easeIn,easeOut,easeInOut").split(","),
		    e,
		    name,
		    j,
		    type;
		while (--i > -1) {
			name = na[i];
			e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
			j = ta.length;
			while (--j > -1) {
				type = ta[j];
				_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
			}
		}
	};

	p = Ease.prototype;
	p._calcEnd = false;
	p.getRatio = function (p) {
		if (this._func) {
			this._params[0] = p;
			return this._func.apply(null, this._params);
		}
		var t = this._type,
		    pw = this._power,
		    r = t === 1 ? 1 - p : t === 2 ? p : p < 0.5 ? p * 2 : (1 - p) * 2;
		if (pw === 1) {
			r *= r;
		} else if (pw === 2) {
			r *= r * r;
		} else if (pw === 3) {
			r *= r * r * r;
		} else if (pw === 4) {
			r *= r * r * r * r;
		}
		return t === 1 ? 1 - r : t === 2 ? r : p < 0.5 ? r / 2 : 1 - r / 2;
	};

	//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
	a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
	i = a.length;
	while (--i > -1) {
		p = a[i] + ",Power" + i;
		_easeReg(new Ease(null, null, 1, i), p, "easeOut", true);
		_easeReg(new Ease(null, null, 2, i), p, "easeIn" + (i === 0 ? ",easeNone" : ""));
		_easeReg(new Ease(null, null, 3, i), p, "easeInOut");
	}
	_easeMap.linear = gs.easing.Linear.easeIn;
	_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


	/*
  * ----------------------------------------------------------------
  * EventDispatcher
  * ----------------------------------------------------------------
  */
	var EventDispatcher = _class("events.EventDispatcher", function (target) {
		this._listeners = {};
		this._eventTarget = target || this;
	});
	p = EventDispatcher.prototype;

	p.addEventListener = function (type, callback, scope, useParam, priority) {
		priority = priority || 0;
		var list = this._listeners[type],
		    index = 0,
		    listener,
		    i;
		if (this === _ticker && !_tickerActive) {
			_ticker.wake();
		}
		if (list == null) {
			this._listeners[type] = list = [];
		}
		i = list.length;
		while (--i > -1) {
			listener = list[i];
			if (listener.c === callback && listener.s === scope) {
				list.splice(i, 1);
			} else if (index === 0 && listener.pr < priority) {
				index = i + 1;
			}
		}
		list.splice(index, 0, { c: callback, s: scope, up: useParam, pr: priority });
	};

	p.removeEventListener = function (type, callback) {
		var list = this._listeners[type],
		    i;
		if (list) {
			i = list.length;
			while (--i > -1) {
				if (list[i].c === callback) {
					list.splice(i, 1);
					return;
				}
			}
		}
	};

	p.dispatchEvent = function (type) {
		var list = this._listeners[type],
		    i,
		    t,
		    listener;
		if (list) {
			i = list.length;
			t = this._eventTarget;
			while (--i > -1) {
				listener = list[i];
				if (listener) {
					if (listener.up) {
						listener.c.call(listener.s || t, { type: type, target: t });
					} else {
						listener.c.call(listener.s || t);
					}
				}
			}
		}
	};

	/*
  * ----------------------------------------------------------------
  * Ticker
  * ----------------------------------------------------------------
  */
	var _reqAnimFrame = window.requestAnimationFrame,
	    _cancelAnimFrame = window.cancelAnimationFrame,
	    _getTime = Date.now || function () {
		return new Date().getTime();
	},
	    _lastUpdate = _getTime();

	//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
	a = ["ms", "moz", "webkit", "o"];
	i = a.length;
	while (--i > -1 && !_reqAnimFrame) {
		_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
		_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
	}

	_class("Ticker", function (fps, useRAF) {
		var _self = this,
		    _startTime = _getTime(),
		    _useRAF = useRAF !== false && _reqAnimFrame ? "auto" : false,
		    _lagThreshold = 500,
		    _adjustedLag = 33,
		    _tickWord = "tick",
		    //helps reduce gc burden
		_fps,
		    _req,
		    _id,
		    _gap,
		    _nextTime,
		    _tick = function _tick(manual) {
			var elapsed = _getTime() - _lastUpdate,
			    overlap,
			    dispatch;
			if (elapsed > _lagThreshold) {
				_startTime += elapsed - _adjustedLag;
			}
			_lastUpdate += elapsed;
			_self.time = (_lastUpdate - _startTime) / 1000;
			overlap = _self.time - _nextTime;
			if (!_fps || overlap > 0 || manual === true) {
				_self.frame++;
				_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
				dispatch = true;
			}
			if (manual !== true) {
				//make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
				_id = _req(_tick);
			}
			if (dispatch) {
				_self.dispatchEvent(_tickWord);
			}
		};

		EventDispatcher.call(_self);
		_self.time = _self.frame = 0;
		_self.tick = function () {
			_tick(true);
		};

		_self.lagSmoothing = function (threshold, adjustedLag) {
			_lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited
			_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
		};

		_self.sleep = function () {
			if (_id == null) {
				return;
			}
			if (!_useRAF || !_cancelAnimFrame) {
				clearTimeout(_id);
			} else {
				_cancelAnimFrame(_id);
			}
			_req = _emptyFunc;
			_id = null;
			if (_self === _ticker) {
				_tickerActive = false;
			}
		};

		_self.wake = function (seamless) {
			if (_id !== null) {
				_self.sleep();
			} else if (seamless) {
				_startTime += -_lastUpdate + (_lastUpdate = _getTime());
			} else if (_self.frame > 10) {
				//don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
				_lastUpdate = _getTime() - _lagThreshold + 5;
			}
			_req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function (f) {
				return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
			} : _reqAnimFrame;
			if (_self === _ticker) {
				_tickerActive = true;
			}
			_tick(2);
		};

		_self.fps = function (value) {
			if (!arguments.length) {
				return _fps;
			}
			_fps = value;
			_gap = 1 / (_fps || 60);
			_nextTime = this.time + _gap;
			_self.wake();
		};

		_self.useRAF = function (value) {
			if (!arguments.length) {
				return _useRAF;
			}
			_self.sleep();
			_useRAF = value;
			_self.fps(_fps);
		};
		_self.fps(fps);

		//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
		setTimeout(function () {
			if (_useRAF === "auto" && _self.frame < 5 && document.visibilityState !== "hidden") {
				_self.useRAF(false);
			}
		}, 1500);
	});

	p = gs.Ticker.prototype = new gs.events.EventDispatcher();
	p.constructor = gs.Ticker;

	/*
  * ----------------------------------------------------------------
  * Animation
  * ----------------------------------------------------------------
  */
	var Animation = _class("core.Animation", function (duration, vars) {
		this.vars = vars = vars || {};
		this._duration = this._totalDuration = duration || 0;
		this._delay = Number(vars.delay) || 0;
		this._timeScale = 1;
		this._active = vars.immediateRender === true;
		this.data = vars.data;
		this._reversed = vars.reversed === true;

		if (!_rootTimeline) {
			return;
		}
		if (!_tickerActive) {
			//some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
			_ticker.wake();
		}

		var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
		tl.add(this, tl._time);

		if (this.vars.paused) {
			this.paused(true);
		}
	});

	_ticker = Animation.ticker = new gs.Ticker();
	p = Animation.prototype;
	p._dirty = p._gc = p._initted = p._paused = false;
	p._totalTime = p._time = 0;
	p._rawPrevTime = -1;
	p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
	p._paused = false;

	//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
	var _checkTimeout = function _checkTimeout() {
		if (_tickerActive && _getTime() - _lastUpdate > 2000) {
			_ticker.wake();
		}
		setTimeout(_checkTimeout, 2000);
	};
	_checkTimeout();

	p.play = function (from, suppressEvents) {
		if (from != null) {
			this.seek(from, suppressEvents);
		}
		return this.reversed(false).paused(false);
	};

	p.pause = function (atTime, suppressEvents) {
		if (atTime != null) {
			this.seek(atTime, suppressEvents);
		}
		return this.paused(true);
	};

	p.resume = function (from, suppressEvents) {
		if (from != null) {
			this.seek(from, suppressEvents);
		}
		return this.paused(false);
	};

	p.seek = function (time, suppressEvents) {
		return this.totalTime(Number(time), suppressEvents !== false);
	};

	p.restart = function (includeDelay, suppressEvents) {
		return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true);
	};

	p.reverse = function (from, suppressEvents) {
		if (from != null) {
			this.seek(from || this.totalDuration(), suppressEvents);
		}
		return this.reversed(true).paused(false);
	};

	p.render = function (time, suppressEvents, force) {
		//stub - we override this method in subclasses.
	};

	p.invalidate = function () {
		this._time = this._totalTime = 0;
		this._initted = this._gc = false;
		this._rawPrevTime = -1;
		if (this._gc || !this.timeline) {
			this._enabled(true);
		}
		return this;
	};

	p.isActive = function () {
		var tl = this._timeline,
		    //the 2 root timelines won't have a _timeline; they're always active.
		startTime = this._startTime,
		    rawTime;
		return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale;
	};

	p._enabled = function (enabled, ignoreTimeline) {
		if (!_tickerActive) {
			_ticker.wake();
		}
		this._gc = !enabled;
		this._active = this.isActive();
		if (ignoreTimeline !== true) {
			if (enabled && !this.timeline) {
				this._timeline.add(this, this._startTime - this._delay);
			} else if (!enabled && this.timeline) {
				this._timeline._remove(this, true);
			}
		}
		return false;
	};

	p._kill = function (vars, target) {
		return this._enabled(false, false);
	};

	p.kill = function (vars, target) {
		this._kill(vars, target);
		return this;
	};

	p._uncache = function (includeSelf) {
		var tween = includeSelf ? this : this.timeline;
		while (tween) {
			tween._dirty = true;
			tween = tween.timeline;
		}
		return this;
	};

	p._swapSelfInParams = function (params) {
		var i = params.length,
		    copy = params.concat();
		while (--i > -1) {
			if (params[i] === "{self}") {
				copy[i] = this;
			}
		}
		return copy;
	};

	p._callback = function (type) {
		var v = this.vars;
		v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
	};

	//----Animation getters/setters --------------------------------------------------------

	p.eventCallback = function (type, callback, params, scope) {
		if ((type || "").substr(0, 2) === "on") {
			var v = this.vars;
			if (arguments.length === 1) {
				return v[type];
			}
			if (callback == null) {
				delete v[type];
			} else {
				v[type] = callback;
				v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params;
				v[type + "Scope"] = scope;
			}
			if (type === "onUpdate") {
				this._onUpdate = callback;
			}
		}
		return this;
	};

	p.delay = function (value) {
		if (!arguments.length) {
			return this._delay;
		}
		if (this._timeline.smoothChildTiming) {
			this.startTime(this._startTime + value - this._delay);
		}
		this._delay = value;
		return this;
	};

	p.duration = function (value) {
		if (!arguments.length) {
			this._dirty = false;
			return this._duration;
		}
		this._duration = this._totalDuration = value;
		this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
		if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
			this.totalTime(this._totalTime * (value / this._duration), true);
		}
		return this;
	};

	p.totalDuration = function (value) {
		this._dirty = false;
		return !arguments.length ? this._totalDuration : this.duration(value);
	};

	p.time = function (value, suppressEvents) {
		if (!arguments.length) {
			return this._time;
		}
		if (this._dirty) {
			this.totalDuration();
		}
		return this.totalTime(value > this._duration ? this._duration : value, suppressEvents);
	};

	p.totalTime = function (time, suppressEvents, uncapped) {
		if (!_tickerActive) {
			_ticker.wake();
		}
		if (!arguments.length) {
			return this._totalTime;
		}
		if (this._timeline) {
			if (time < 0 && !uncapped) {
				time += this.totalDuration();
			}
			if (this._timeline.smoothChildTiming) {
				if (this._dirty) {
					this.totalDuration();
				}
				var totalDuration = this._totalDuration,
				    tl = this._timeline;
				if (time > totalDuration && !uncapped) {
					time = totalDuration;
				}
				this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale;
				if (!tl._dirty) {
					//for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
					this._uncache(false);
				}
				//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
				if (tl._timeline) {
					while (tl._timeline) {
						if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
							tl.totalTime(tl._totalTime, true);
						}
						tl = tl._timeline;
					}
				}
			}
			if (this._gc) {
				this._enabled(true, false);
			}
			if (this._totalTime !== time || this._duration === 0) {
				if (_lazyTweens.length) {
					_lazyRender();
				}
				this.render(time, suppressEvents, false);
				if (_lazyTweens.length) {
					//in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
					_lazyRender();
				}
			}
		}
		return this;
	};

	p.progress = p.totalProgress = function (value, suppressEvents) {
		var duration = this.duration();
		return !arguments.length ? duration ? this._time / duration : this.ratio : this.totalTime(duration * value, suppressEvents);
	};

	p.startTime = function (value) {
		if (!arguments.length) {
			return this._startTime;
		}
		if (value !== this._startTime) {
			this._startTime = value;
			if (this.timeline) if (this.timeline._sortChildren) {
				this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
			}
		}
		return this;
	};

	p.endTime = function (includeRepeats) {
		return this._startTime + (includeRepeats != false ? this.totalDuration() : this.duration()) / this._timeScale;
	};

	p.timeScale = function (value) {
		if (!arguments.length) {
			return this._timeScale;
		}
		value = value || _tinyNum; //can't allow zero because it'll throw the math off
		if (this._timeline && this._timeline.smoothChildTiming) {
			var pauseTime = this._pauseTime,
			    t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime();
			this._startTime = t - (t - this._startTime) * this._timeScale / value;
		}
		this._timeScale = value;
		return this._uncache(false);
	};

	p.reversed = function (value) {
		if (!arguments.length) {
			return this._reversed;
		}
		if (value != this._reversed) {
			this._reversed = value;
			this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, true);
		}
		return this;
	};

	p.paused = function (value) {
		if (!arguments.length) {
			return this._paused;
		}
		var tl = this._timeline,
		    raw,
		    elapsed;
		if (value != this._paused) if (tl) {
			if (!_tickerActive && !value) {
				_ticker.wake();
			}
			raw = tl.rawTime();
			elapsed = raw - this._pauseTime;
			if (!value && tl.smoothChildTiming) {
				this._startTime += elapsed;
				this._uncache(false);
			}
			this._pauseTime = value ? raw : null;
			this._paused = value;
			this._active = this.isActive();
			if (!value && elapsed !== 0 && this._initted && this.duration()) {
				raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
				this.render(raw, raw === this._totalTime, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
			}
		}
		if (this._gc && !value) {
			this._enabled(true, false);
		}
		return this;
	};

	/*
  * ----------------------------------------------------------------
  * SimpleTimeline
  * ----------------------------------------------------------------
  */
	var SimpleTimeline = _class("core.SimpleTimeline", function (vars) {
		Animation.call(this, 0, vars);
		this.autoRemoveChildren = this.smoothChildTiming = true;
	});

	p = SimpleTimeline.prototype = new Animation();
	p.constructor = SimpleTimeline;
	p.kill()._gc = false;
	p._first = p._last = p._recent = null;
	p._sortChildren = false;

	p.add = p.insert = function (child, position, align, stagger) {
		var prevTween, st;
		child._startTime = Number(position || 0) + child._delay;
		if (child._paused) if (this !== child._timeline) {
			//we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
			child._pauseTime = child._startTime + (this.rawTime() - child._startTime) / child._timeScale;
		}
		if (child.timeline) {
			child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
		}
		child.timeline = child._timeline = this;
		if (child._gc) {
			child._enabled(true, true);
		}
		prevTween = this._last;
		if (this._sortChildren) {
			st = child._startTime;
			while (prevTween && prevTween._startTime > st) {
				prevTween = prevTween._prev;
			}
		}
		if (prevTween) {
			child._next = prevTween._next;
			prevTween._next = child;
		} else {
			child._next = this._first;
			this._first = child;
		}
		if (child._next) {
			child._next._prev = child;
		} else {
			this._last = child;
		}
		child._prev = prevTween;
		this._recent = child;
		if (this._timeline) {
			this._uncache(true);
		}
		return this;
	};

	p._remove = function (tween, skipDisable) {
		if (tween.timeline === this) {
			if (!skipDisable) {
				tween._enabled(false, true);
			}

			if (tween._prev) {
				tween._prev._next = tween._next;
			} else if (this._first === tween) {
				this._first = tween._next;
			}
			if (tween._next) {
				tween._next._prev = tween._prev;
			} else if (this._last === tween) {
				this._last = tween._prev;
			}
			tween._next = tween._prev = tween.timeline = null;
			if (tween === this._recent) {
				this._recent = this._last;
			}

			if (this._timeline) {
				this._uncache(true);
			}
		}
		return this;
	};

	p.render = function (time, suppressEvents, force) {
		var tween = this._first,
		    next;
		this._totalTime = this._time = this._rawPrevTime = time;
		while (tween) {
			next = tween._next; //record it here because the value could change after rendering...
			if (tween._active || time >= tween._startTime && !tween._paused) {
				if (!tween._reversed) {
					tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
				} else {
					tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
				}
			}
			tween = next;
		}
	};

	p.rawTime = function () {
		if (!_tickerActive) {
			_ticker.wake();
		}
		return this._totalTime;
	};

	/*
  * ----------------------------------------------------------------
  * TweenLite
  * ----------------------------------------------------------------
  */
	var TweenLite = _class("TweenLite", function (target, duration, vars) {
		Animation.call(this, duration, vars);
		this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

		if (target == null) {
			throw "Cannot tween a null target.";
		}

		this.target = target = typeof target !== "string" ? target : TweenLite.selector(target) || target;

		var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),
		    overwrite = this.vars.overwrite,
		    i,
		    targ,
		    targets;

		this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === "number" ? overwrite >> 0 : _overwriteLookup[overwrite];

		if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== "number") {
			this._targets = targets = _slice(target); //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
			this._propLookup = [];
			this._siblings = [];
			for (i = 0; i < targets.length; i++) {
				targ = targets[i];
				if (!targ) {
					targets.splice(i--, 1);
					continue;
				} else if (typeof targ === "string") {
					targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
					if (typeof targ === "string") {
						targets.splice(i + 1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
					}
					continue;
				} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {
					//in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
					targets.splice(i--, 1);
					this._targets = targets = targets.concat(_slice(targ));
					continue;
				}
				this._siblings[i] = _register(targ, this, false);
				if (overwrite === 1) if (this._siblings[i].length > 1) {
					_applyOverwrite(targ, this, null, 1, this._siblings[i]);
				}
			}
		} else {
			this._propLookup = {};
			this._siblings = _register(target, this, false);
			if (overwrite === 1) if (this._siblings.length > 1) {
				_applyOverwrite(target, this, null, 1, this._siblings);
			}
		}
		if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {
			this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
			this.render(Math.min(0, -this._delay)); //in case delay is negative
		}
	}, true),
	    _isSelector = function _isSelector(v) {
		return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
	},
	    _autoCSS = function _autoCSS(vars, target) {
		var css = {},
		    p;
		for (p in vars) {
			if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {
				//note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
				css[p] = vars[p];
				delete vars[p];
			}
		}
		vars.css = css;
	};

	p = TweenLite.prototype = new Animation();
	p.constructor = TweenLite;
	p.kill()._gc = false;

	//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

	p.ratio = 0;
	p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
	p._notifyPluginsOfEnabled = p._lazy = false;

	TweenLite.version = "1.18.5";
	TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
	TweenLite.defaultOverwrite = "auto";
	TweenLite.ticker = _ticker;
	TweenLite.autoSleep = 120;
	TweenLite.lagSmoothing = function (threshold, adjustedLag) {
		_ticker.lagSmoothing(threshold, adjustedLag);
	};

	TweenLite.selector = window.$ || window.jQuery || function (e) {
		var selector = window.$ || window.jQuery;
		if (selector) {
			TweenLite.selector = selector;
			return selector(e);
		}
		return typeof document === "undefined" ? e : document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById(e.charAt(0) === "#" ? e.substr(1) : e);
	};

	var _lazyTweens = [],
	    _lazyLookup = {},
	    _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,

	//_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
	_setRatio = function _setRatio(v) {
		var pt = this._firstPT,
		    min = 0.000001,
		    val;
		while (pt) {
			val = !pt.blob ? pt.c * v + pt.s : v ? this.join("") : this.start;
			if (pt.r) {
				val = Math.round(val);
			} else if (val < min) if (val > -min) {
				//prevents issues with converting very small numbers to strings in the browser
				val = 0;
			}
			if (!pt.f) {
				pt.t[pt.p] = val;
			} else if (pt.fp) {
				pt.t[pt.p](pt.fp, val);
			} else {
				pt.t[pt.p](val);
			}
			pt = pt._next;
		}
	},

	//compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
	_blobDif = function _blobDif(start, end, filter, pt) {
		var a = [start, end],
		    charIndex = 0,
		    s = "",
		    color = 0,
		    startNums,
		    endNums,
		    num,
		    i,
		    l,
		    nonNumbers,
		    currentNum;
		a.start = start;
		if (filter) {
			filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
			start = a[0];
			end = a[1];
		}
		a.length = 0;
		startNums = start.match(_numbersExp) || [];
		endNums = end.match(_numbersExp) || [];
		if (pt) {
			pt._next = null;
			pt.blob = 1;
			a._firstPT = pt; //apply last in the linked list (which means inserting it first)
		}
		l = endNums.length;
		for (i = 0; i < l; i++) {
			currentNum = endNums[i];
			nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
			s += nonNumbers || !i ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
			charIndex += nonNumbers.length;
			if (color) {
				//sense rgba() values and round them.
				color = (color + 1) % 5;
			} else if (nonNumbers.substr(-5) === "rgba(") {
				color = 1;
			}
			if (currentNum === startNums[i] || startNums.length <= i) {
				s += currentNum;
			} else {
				if (s) {
					a.push(s);
					s = "";
				}
				num = parseFloat(startNums[i]);
				a.push(num);
				a._firstPT = { _next: a._firstPT, t: a, p: a.length - 1, s: num, c: (currentNum.charAt(1) === "=" ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : parseFloat(currentNum) - num) || 0, f: 0, r: color && color < 4 };
				//note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
			}
			charIndex += currentNum.length;
		}
		s += end.substr(charIndex);
		if (s) {
			a.push(s);
		}
		a.setRatio = _setRatio;
		return a;
	},

	//note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
	_addPropTween = function _addPropTween(target, prop, start, end, overwriteProp, round, funcParam, stringFilter) {
		var s = start === "get" ? target[prop] : start,
		    type = _typeof(target[prop]),
		    isRelative = typeof end === "string" && end.charAt(1) === "=",
		    pt = { t: target, p: prop, s: s, f: type === "function", pg: 0, n: overwriteProp || prop, r: round, pr: 0, c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : parseFloat(end) - s || 0 },
		    blob,
		    getterName;
		if (type !== "number") {
			if (type === "function" && start === "get") {
				getterName = prop.indexOf("set") || typeof target["get" + prop.substr(3)] !== "function" ? prop : "get" + prop.substr(3);
				pt.s = s = funcParam ? target[getterName](funcParam) : target[getterName]();
			}
			if (typeof s === "string" && (funcParam || isNaN(s))) {
				//a blob (string that has multiple numbers in it)
				pt.fp = funcParam;
				blob = _blobDif(s, end, stringFilter || TweenLite.defaultStringFilter, pt);
				pt = { t: blob, p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: overwriteProp || prop, pr: 0 }; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
			} else if (!isRelative) {
				pt.s = parseFloat(s);
				pt.c = parseFloat(end) - pt.s || 0;
			}
		}
		if (pt.c) {
			//only add it to the linked list if there's a change.
			if (pt._next = this._firstPT) {
				pt._next._prev = pt;
			}
			this._firstPT = pt;
			return pt;
		}
	},
	    _internals = TweenLite._internals = { isArray: _isArray, isSelector: _isSelector, lazyTweens: _lazyTweens, blobDif: _blobDif },
	    //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
	_plugins = TweenLite._plugins = {},
	    _tweenLookup = _internals.tweenLookup = {},
	    _tweenLookupNum = 0,
	    _reservedProps = _internals.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1, lazy: 1, onOverwrite: 1, callbackScope: 1, stringFilter: 1, id: 1 },
	    _overwriteLookup = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, "true": 1, "false": 0 },
	    _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
	    _rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
	    _nextGCFrame = 30,
	    _lazyRender = _internals.lazyRender = function () {
		var i = _lazyTweens.length,
		    tween;
		_lazyLookup = {};
		while (--i > -1) {
			tween = _lazyTweens[i];
			if (tween && tween._lazy !== false) {
				tween.render(tween._lazy[0], tween._lazy[1], true);
				tween._lazy = false;
			}
		}
		_lazyTweens.length = 0;
	};

	_rootTimeline._startTime = _ticker.time;
	_rootFramesTimeline._startTime = _ticker.frame;
	_rootTimeline._active = _rootFramesTimeline._active = true;
	setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

	Animation._updateRoot = TweenLite.render = function () {
		var i, a, p;
		if (_lazyTweens.length) {
			//if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
			_lazyRender();
		}
		_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
		_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
		if (_lazyTweens.length) {
			_lazyRender();
		}
		if (_ticker.frame >= _nextGCFrame) {
			//dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
			_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
			for (p in _tweenLookup) {
				a = _tweenLookup[p].tweens;
				i = a.length;
				while (--i > -1) {
					if (a[i]._gc) {
						a.splice(i, 1);
					}
				}
				if (a.length === 0) {
					delete _tweenLookup[p];
				}
			}
			//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
			p = _rootTimeline._first;
			if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
				while (p && p._paused) {
					p = p._next;
				}
				if (!p) {
					_ticker.sleep();
				}
			}
		}
	};

	_ticker.addEventListener("tick", Animation._updateRoot);

	var _register = function _register(target, tween, scrub) {
		var id = target._gsTweenID,
		    a,
		    i;
		if (!_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)]) {
			_tweenLookup[id] = { target: target, tweens: [] };
		}
		if (tween) {
			a = _tweenLookup[id].tweens;
			a[i = a.length] = tween;
			if (scrub) {
				while (--i > -1) {
					if (a[i] === tween) {
						a.splice(i, 1);
					}
				}
			}
		}
		return _tweenLookup[id].tweens;
	},
	    _onOverwrite = function _onOverwrite(overwrittenTween, overwritingTween, target, killedProps) {
		var func = overwrittenTween.vars.onOverwrite,
		    r1,
		    r2;
		if (func) {
			r1 = func(overwrittenTween, overwritingTween, target, killedProps);
		}
		func = TweenLite.onOverwrite;
		if (func) {
			r2 = func(overwrittenTween, overwritingTween, target, killedProps);
		}
		return r1 !== false && r2 !== false;
	},
	    _applyOverwrite = function _applyOverwrite(target, tween, props, mode, siblings) {
		var i, changed, curTween, l;
		if (mode === 1 || mode >= 4) {
			l = siblings.length;
			for (i = 0; i < l; i++) {
				if ((curTween = siblings[i]) !== tween) {
					if (!curTween._gc) {
						if (curTween._kill(null, target, tween)) {
							changed = true;
						}
					}
				} else if (mode === 5) {
					break;
				}
			}
			return changed;
		}
		//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
		var startTime = tween._startTime + _tinyNum,
		    overlaps = [],
		    oCount = 0,
		    zeroDur = tween._duration === 0,
		    globalStart;
		i = siblings.length;
		while (--i > -1) {
			if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
				//ignore
			} else if (curTween._timeline !== tween._timeline) {
				globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
				if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
					overlaps[oCount++] = curTween;
				}
			} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
				overlaps[oCount++] = curTween;
			}
		}

		i = oCount;
		while (--i > -1) {
			curTween = overlaps[i];
			if (mode === 2) if (curTween._kill(props, target, tween)) {
				changed = true;
			}
			if (mode !== 2 || !curTween._firstPT && curTween._initted) {
				if (mode !== 2 && !_onOverwrite(curTween, tween)) {
					continue;
				}
				if (curTween._enabled(false, false)) {
					//if all property tweens have been overwritten, kill the tween.
					changed = true;
				}
			}
		}
		return changed;
	},
	    _checkOverlap = function _checkOverlap(tween, reference, zeroDur) {
		var tl = tween._timeline,
		    ts = tl._timeScale,
		    t = tween._startTime;
		while (tl._timeline) {
			t += tl._startTime;
			ts *= tl._timeScale;
			if (tl._paused) {
				return -100;
			}
			tl = tl._timeline;
		}
		t /= ts;
		return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum;
	};

	//---- TweenLite instance methods -----------------------------------------------------------------------------

	p._init = function () {
		var v = this.vars,
		    op = this._overwrittenProps,
		    dur = this._duration,
		    immediate = !!v.immediateRender,
		    ease = v.ease,
		    i,
		    initPlugins,
		    pt,
		    p,
		    startVars;
		if (v.startAt) {
			if (this._startAt) {
				this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
				this._startAt.kill();
			}
			startVars = {};
			for (p in v.startAt) {
				//copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
				startVars[p] = v.startAt[p];
			}
			startVars.overwrite = false;
			startVars.immediateRender = true;
			startVars.lazy = immediate && v.lazy !== false;
			startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
			this._startAt = TweenLite.to(this.target, 0, startVars);
			if (immediate) {
				if (this._time > 0) {
					this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
				} else if (dur !== 0) {
					return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
				}
			}
		} else if (v.runBackwards && dur !== 0) {
			//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
			if (this._startAt) {
				this._startAt.render(-1, true);
				this._startAt.kill();
				this._startAt = null;
			} else {
				if (this._time !== 0) {
					//in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
					immediate = false;
				}
				pt = {};
				for (p in v) {
					//copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
					if (!_reservedProps[p] || p === "autoCSS") {
						pt[p] = v[p];
					}
				}
				pt.overwrite = 0;
				pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
				pt.lazy = immediate && v.lazy !== false;
				pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
				this._startAt = TweenLite.to(this.target, 0, pt);
				if (!immediate) {
					this._startAt._init(); //ensures that the initial values are recorded
					this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
					if (this.vars.immediateRender) {
						this._startAt = null;
					}
				} else if (this._time === 0) {
					return;
				}
			}
		}
		this._ease = ease = !ease ? TweenLite.defaultEase : ease instanceof Ease ? ease : typeof ease === "function" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
		if (v.easeParams instanceof Array && ease.config) {
			this._ease = ease.config.apply(ease, v.easeParams);
		}
		this._easeType = this._ease._type;
		this._easePower = this._ease._power;
		this._firstPT = null;

		if (this._targets) {
			i = this._targets.length;
			while (--i > -1) {
				if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null)) {
					initPlugins = true;
				}
			}
		} else {
			initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op);
		}

		if (initPlugins) {
			TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
		}
		if (op) if (!this._firstPT) if (typeof this.target !== "function") {
			//if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
			this._enabled(false, false);
		}
		if (v.runBackwards) {
			pt = this._firstPT;
			while (pt) {
				pt.s += pt.c;
				pt.c = -pt.c;
				pt = pt._next;
			}
		}
		this._onUpdate = v.onUpdate;
		this._initted = true;
	};

	p._initProps = function (target, propLookup, siblings, overwrittenProps) {
		var p, i, initPlugins, plugin, pt, v;
		if (target == null) {
			return false;
		}

		if (_lazyLookup[target._gsTweenID]) {
			_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
		}

		if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) {
			//it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
			_autoCSS(this.vars, target);
		}
		for (p in this.vars) {
			v = this.vars[p];
			if (_reservedProps[p]) {
				if (v) if (v instanceof Array || v.push && _isArray(v)) if (v.join("").indexOf("{self}") !== -1) {
					this.vars[p] = v = this._swapSelfInParams(v, this);
				}
			} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {

				//t - target 		[object]
				//p - property 		[string]
				//s - start			[number]
				//c - change		[number]
				//f - isFunction	[boolean]
				//n - name			[string]
				//pg - isPlugin 	[boolean]
				//pr - priority		[number]
				this._firstPT = pt = { _next: this._firstPT, t: plugin, p: "setRatio", s: 0, c: 1, f: 1, n: p, pg: 1, pr: plugin._priority };
				i = plugin._overwriteProps.length;
				while (--i > -1) {
					propLookup[plugin._overwriteProps[i]] = this._firstPT;
				}
				if (plugin._priority || plugin._onInitAllProps) {
					initPlugins = true;
				}
				if (plugin._onDisable || plugin._onEnable) {
					this._notifyPluginsOfEnabled = true;
				}
				if (pt._next) {
					pt._next._prev = pt;
				}
			} else {
				propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter);
			}
		}

		if (overwrittenProps) if (this._kill(overwrittenProps, target)) {
			//another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
			return this._initProps(target, propLookup, siblings, overwrittenProps);
		}
		if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
			this._kill(propLookup, target);
			return this._initProps(target, propLookup, siblings, overwrittenProps);
		}
		if (this._firstPT) if (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration) {
			//zero duration tweens don't lazy render by default; everything else does.
			_lazyLookup[target._gsTweenID] = true;
		}
		return initPlugins;
	};

	p.render = function (time, suppressEvents, force) {
		var prevTime = this._time,
		    duration = this._duration,
		    prevRawPrevTime = this._rawPrevTime,
		    isComplete,
		    callback,
		    pt,
		    rawPrevTime;
		if (time >= duration - 0.0000001) {
			//to work around occasional floating point math artifacts.
			this._totalTime = this._time = duration;
			this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
			if (!this._reversed) {
				isComplete = true;
				callback = "onComplete";
				force = force || this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
			}
			if (duration === 0) if (this._initted || !this.vars.lazy || force) {
				//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
				if (this._startTime === this._timeline._duration) {
					//if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
					time = 0;
				}
				if (prevRawPrevTime < 0 || time <= 0 && time >= -0.0000001 || prevRawPrevTime === _tinyNum && this.data !== "isPause") if (prevRawPrevTime !== time) {
					//note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
					force = true;
					if (prevRawPrevTime > _tinyNum) {
						callback = "onReverseComplete";
					}
				}
				this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
			}
		} else if (time < 0.0000001) {
			//to work around occasional floating point math artifacts, round super small values to 0.
			this._totalTime = this._time = 0;
			this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
			if (prevTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
				callback = "onReverseComplete";
				isComplete = this._reversed;
			}
			if (time < 0) {
				this._active = false;
				if (duration === 0) if (this._initted || !this.vars.lazy || force) {
					//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
						force = true;
					}
					this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}
			}
			if (!this._initted) {
				//if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
				force = true;
			}
		} else {
			this._totalTime = this._time = time;

			if (this._easeType) {
				var r = time / duration,
				    type = this._easeType,
				    pow = this._easePower;
				if (type === 1 || type === 3 && r >= 0.5) {
					r = 1 - r;
				}
				if (type === 3) {
					r *= 2;
				}
				if (pow === 1) {
					r *= r;
				} else if (pow === 2) {
					r *= r * r;
				} else if (pow === 3) {
					r *= r * r * r;
				} else if (pow === 4) {
					r *= r * r * r * r;
				}

				if (type === 1) {
					this.ratio = 1 - r;
				} else if (type === 2) {
					this.ratio = r;
				} else if (time / duration < 0.5) {
					this.ratio = r / 2;
				} else {
					this.ratio = 1 - r / 2;
				}
			} else {
				this.ratio = this._ease.getRatio(time / duration);
			}
		}

		if (this._time === prevTime && !force) {
			return;
		} else if (!this._initted) {
			this._init();
			if (!this._initted || this._gc) {
				//immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
				return;
			} else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
				this._time = this._totalTime = prevTime;
				this._rawPrevTime = prevRawPrevTime;
				_lazyTweens.push(this);
				this._lazy = [time, suppressEvents];
				return;
			}
			//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
			if (this._time && !isComplete) {
				this.ratio = this._ease.getRatio(this._time / duration);
			} else if (isComplete && this._ease._calcEnd) {
				this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
			}
		}
		if (this._lazy !== false) {
			//in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
			this._lazy = false;
		}
		if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
			this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
		}
		if (prevTime === 0) {
			if (this._startAt) {
				if (time >= 0) {
					this._startAt.render(time, suppressEvents, force);
				} else if (!callback) {
					callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
				}
			}
			if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
				this._callback("onStart");
			}
		}
		pt = this._firstPT;
		while (pt) {
			if (pt.f) {
				pt.t[pt.p](pt.c * this.ratio + pt.s);
			} else {
				pt.t[pt.p] = pt.c * this.ratio + pt.s;
			}
			pt = pt._next;
		}

		if (this._onUpdate) {
			if (time < 0) if (this._startAt && time !== -0.0001) {
				//if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
				this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
			}
			if (!suppressEvents) if (this._time !== prevTime || isComplete || force) {
				this._callback("onUpdate");
			}
		}
		if (callback) if (!this._gc || force) {
			//check _gc because there's a chance that kill() could be called in an onUpdate
			if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) {
				//-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
				this._startAt.render(time, suppressEvents, force);
			}
			if (isComplete) {
				if (this._timeline.autoRemoveChildren) {
					this._enabled(false, false);
				}
				this._active = false;
			}
			if (!suppressEvents && this.vars[callback]) {
				this._callback(callback);
			}
			if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
				//the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
				this._rawPrevTime = 0;
			}
		}
	};

	p._kill = function (vars, target, overwritingTween) {
		if (vars === "all") {
			vars = null;
		}
		if (vars == null) if (target == null || target === this.target) {
			this._lazy = false;
			return this._enabled(false, false);
		}
		target = typeof target !== "string" ? target || this._targets || this.target : TweenLite.selector(target) || target;
		var simultaneousOverwrite = overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline,
		    i,
		    overwrittenProps,
		    p,
		    pt,
		    propLookup,
		    changed,
		    killProps,
		    record,
		    killed;
		if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
			i = target.length;
			while (--i > -1) {
				if (this._kill(vars, target[i], overwritingTween)) {
					changed = true;
				}
			}
		} else {
			if (this._targets) {
				i = this._targets.length;
				while (--i > -1) {
					if (target === this._targets[i]) {
						propLookup = this._propLookup[i] || {};
						this._overwrittenProps = this._overwrittenProps || [];
						overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
						break;
					}
				}
			} else if (target !== this.target) {
				return false;
			} else {
				propLookup = this._propLookup;
				overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
			}

			if (propLookup) {
				killProps = vars || propLookup;
				record = vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && ((typeof vars === "undefined" ? "undefined" : _typeof(vars)) !== "object" || !vars._tempKill); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
				if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
					for (p in killProps) {
						if (propLookup[p]) {
							if (!killed) {
								killed = [];
							}
							killed.push(p);
						}
					}
					if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {
						//if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
						return false;
					}
				}

				for (p in killProps) {
					if (pt = propLookup[p]) {
						if (simultaneousOverwrite) {
							//if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
							if (pt.f) {
								pt.t[pt.p](pt.s);
							} else {
								pt.t[pt.p] = pt.s;
							}
							changed = true;
						}
						if (pt.pg && pt.t._kill(killProps)) {
							changed = true; //some plugins need to be notified so they can perform cleanup tasks first
						}
						if (!pt.pg || pt.t._overwriteProps.length === 0) {
							if (pt._prev) {
								pt._prev._next = pt._next;
							} else if (pt === this._firstPT) {
								this._firstPT = pt._next;
							}
							if (pt._next) {
								pt._next._prev = pt._prev;
							}
							pt._next = pt._prev = null;
						}
						delete propLookup[p];
					}
					if (record) {
						overwrittenProps[p] = 1;
					}
				}
				if (!this._firstPT && this._initted) {
					//if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
					this._enabled(false, false);
				}
			}
		}
		return changed;
	};

	p.invalidate = function () {
		if (this._notifyPluginsOfEnabled) {
			TweenLite._onPluginEvent("_onDisable", this);
		}
		this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
		this._notifyPluginsOfEnabled = this._active = this._lazy = false;
		this._propLookup = this._targets ? {} : [];
		Animation.prototype.invalidate.call(this);
		if (this.vars.immediateRender) {
			this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
			this.render(Math.min(0, -this._delay)); //in case delay is negative.
		}
		return this;
	};

	p._enabled = function (enabled, ignoreTimeline) {
		if (!_tickerActive) {
			_ticker.wake();
		}
		if (enabled && this._gc) {
			var targets = this._targets,
			    i;
			if (targets) {
				i = targets.length;
				while (--i > -1) {
					this._siblings[i] = _register(targets[i], this, true);
				}
			} else {
				this._siblings = _register(this.target, this, true);
			}
		}
		Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
		if (this._notifyPluginsOfEnabled) if (this._firstPT) {
			return TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this);
		}
		return false;
	};

	//----TweenLite static methods -----------------------------------------------------

	TweenLite.to = function (target, duration, vars) {
		return new TweenLite(target, duration, vars);
	};

	TweenLite.from = function (target, duration, vars) {
		vars.runBackwards = true;
		vars.immediateRender = vars.immediateRender != false;
		return new TweenLite(target, duration, vars);
	};

	TweenLite.fromTo = function (target, duration, fromVars, toVars) {
		toVars.startAt = fromVars;
		toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
		return new TweenLite(target, duration, toVars);
	};

	TweenLite.delayedCall = function (delay, callback, params, scope, useFrames) {
		return new TweenLite(callback, 0, { delay: delay, onComplete: callback, onCompleteParams: params, callbackScope: scope, onReverseComplete: callback, onReverseCompleteParams: params, immediateRender: false, lazy: false, useFrames: useFrames, overwrite: 0 });
	};

	TweenLite.set = function (target, vars) {
		return new TweenLite(target, 0, vars);
	};

	TweenLite.getTweensOf = function (target, onlyActive) {
		if (target == null) {
			return [];
		}
		target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
		var i, a, j, t;
		if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
			i = target.length;
			a = [];
			while (--i > -1) {
				a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
			}
			i = a.length;
			//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
			while (--i > -1) {
				t = a[i];
				j = i;
				while (--j > -1) {
					if (t === a[j]) {
						a.splice(i, 1);
					}
				}
			}
		} else {
			a = _register(target).concat();
			i = a.length;
			while (--i > -1) {
				if (a[i]._gc || onlyActive && !a[i].isActive()) {
					a.splice(i, 1);
				}
			}
		}
		return a;
	};

	TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (target, onlyActive, vars) {
		if ((typeof onlyActive === "undefined" ? "undefined" : _typeof(onlyActive)) === "object") {
			vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
			onlyActive = false;
		}
		var a = TweenLite.getTweensOf(target, onlyActive),
		    i = a.length;
		while (--i > -1) {
			a[i]._kill(vars, target);
		}
	};

	/*
  * ----------------------------------------------------------------
  * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
  * ----------------------------------------------------------------
  */
	var TweenPlugin = _class("plugins.TweenPlugin", function (props, priority) {
		this._overwriteProps = (props || "").split(",");
		this._propName = this._overwriteProps[0];
		this._priority = priority || 0;
		this._super = TweenPlugin.prototype;
	}, true);

	p = TweenPlugin.prototype;
	TweenPlugin.version = "1.18.0";
	TweenPlugin.API = 2;
	p._firstPT = null;
	p._addTween = _addPropTween;
	p.setRatio = _setRatio;

	p._kill = function (lookup) {
		var a = this._overwriteProps,
		    pt = this._firstPT,
		    i;
		if (lookup[this._propName] != null) {
			this._overwriteProps = [];
		} else {
			i = a.length;
			while (--i > -1) {
				if (lookup[a[i]] != null) {
					a.splice(i, 1);
				}
			}
		}
		while (pt) {
			if (lookup[pt.n] != null) {
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
					pt._prev = null;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
				}
			}
			pt = pt._next;
		}
		return false;
	};

	p._roundProps = function (lookup, value) {
		var pt = this._firstPT;
		while (pt) {
			if (lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + "_").join("")]) {
				//some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
				pt.r = value;
			}
			pt = pt._next;
		}
	};

	TweenLite._onPluginEvent = function (type, tween) {
		var pt = tween._firstPT,
		    changed,
		    pt2,
		    first,
		    last,
		    next;
		if (type === "_onInitAllProps") {
			//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
			while (pt) {
				next = pt._next;
				pt2 = first;
				while (pt2 && pt2.pr > pt.pr) {
					pt2 = pt2._next;
				}
				if (pt._prev = pt2 ? pt2._prev : last) {
					pt._prev._next = pt;
				} else {
					first = pt;
				}
				if (pt._next = pt2) {
					pt2._prev = pt;
				} else {
					last = pt;
				}
				pt = next;
			}
			pt = tween._firstPT = first;
		}
		while (pt) {
			if (pt.pg) if (typeof pt.t[type] === "function") if (pt.t[type]()) {
				changed = true;
			}
			pt = pt._next;
		}
		return changed;
	};

	TweenPlugin.activate = function (plugins) {
		var i = plugins.length;
		while (--i > -1) {
			if (plugins[i].API === TweenPlugin.API) {
				_plugins[new plugins[i]()._propName] = plugins[i];
			}
		}
		return true;
	};

	//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
	_gsDefine.plugin = function (config) {
		if (!config || !config.propName || !config.init || !config.API) {
			throw "illegal plugin definition.";
		}
		var propName = config.propName,
		    priority = config.priority || 0,
		    overwriteProps = config.overwriteProps,
		    map = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_roundProps", initAll: "_onInitAllProps" },
		    Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function () {
			TweenPlugin.call(this, propName, priority);
			this._overwriteProps = overwriteProps || [];
		}, config.global === true),
		    p = Plugin.prototype = new TweenPlugin(propName),
		    prop;
		p.constructor = Plugin;
		Plugin.API = config.API;
		for (prop in map) {
			if (typeof config[prop] === "function") {
				p[map[prop]] = config[prop];
			}
		}
		Plugin.version = config.version;
		TweenPlugin.activate([Plugin]);
		return Plugin;
	};

	//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
	a = window._gsQueue;
	if (a) {
		for (i = 0; i < a.length; i++) {
			a[i]();
		}
		for (p in _defLookup) {
			if (!_defLookup[p].func) {
				window.console.log("GSAP encountered missing dependency: com.greensock." + p);
			}
		}
	}

	_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated
})(typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : this || window, "TweenMax");
/*!
 * VERSION: 1.7.6
 * DATE: 2015-12-10
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
	"use strict";
	var a = document.documentElement,
	    b = window,
	    c = function c(_c, d) {
		var e = "x" === d ? "Width" : "Height",
		    f = "scroll" + e,
		    g = "client" + e,
		    h = document.body;return _c === b || _c === a || _c === h ? Math.max(a[f], h[f]) - (b["inner" + e] || a[g] || h[g]) : _c[f] - _c["offset" + e];
	},
	    d = _gsScope._gsDefine.plugin({ propName: "scrollTo", API: 2, version: "1.7.6", init: function init(a, d, e) {
			return this._wdw = a === b, this._target = a, this._tween = e, "object" != (typeof d === "undefined" ? "undefined" : _typeof(d)) && (d = { y: d }), this.vars = d, this._autoKill = d.autoKill !== !1, this.x = this.xPrev = this.getX(), this.y = this.yPrev = this.getY(), null != d.x ? (this._addTween(this, "x", this.x, "max" === d.x ? c(a, "x") : d.x, "scrollTo_x", !0), this._overwriteProps.push("scrollTo_x")) : this.skipX = !0, null != d.y ? (this._addTween(this, "y", this.y, "max" === d.y ? c(a, "y") : d.y, "scrollTo_y", !0), this._overwriteProps.push("scrollTo_y")) : this.skipY = !0, !0;
		}, set: function set(a) {
			this._super.setRatio.call(this, a);var d = this._wdw || !this.skipX ? this.getX() : this.xPrev,
			    e = this._wdw || !this.skipY ? this.getY() : this.yPrev,
			    f = e - this.yPrev,
			    g = d - this.xPrev;this.x < 0 && (this.x = 0), this.y < 0 && (this.y = 0), this._autoKill && (!this.skipX && (g > 7 || -7 > g) && d < c(this._target, "x") && (this.skipX = !0), !this.skipY && (f > 7 || -7 > f) && e < c(this._target, "y") && (this.skipY = !0), this.skipX && this.skipY && (this._tween.kill(), this.vars.onAutoKill && this.vars.onAutoKill.apply(this.vars.onAutoKillScope || this._tween, this.vars.onAutoKillParams || []))), this._wdw ? b.scrollTo(this.skipX ? d : this.x, this.skipY ? e : this.y) : (this.skipY || (this._target.scrollTop = this.y), this.skipX || (this._target.scrollLeft = this.x)), this.xPrev = this.x, this.yPrev = this.y;
		} }),
	    e = d.prototype;d.max = c, e.getX = function () {
		return this._wdw ? null != b.pageXOffset ? b.pageXOffset : null != a.scrollLeft ? a.scrollLeft : document.body.scrollLeft : this._target.scrollLeft;
	}, e.getY = function () {
		return this._wdw ? null != b.pageYOffset ? b.pageYOffset : null != a.scrollTop ? a.scrollTop : document.body.scrollTop : this._target.scrollTop;
	}, e._kill = function (a) {
		return a.scrollTo_x && (this.skipX = !0), a.scrollTo_y && (this.skipY = !0), this._super._kill.call(this, a);
	};
}), _gsScope._gsDefine && _gsScope._gsQueue.pop()();
/*!
 * VERSION: 0.5.1
 * DATE: 2014-07-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
	"use strict";
	var a = function a(b) {
		var c = b.nodeType,
		    d = "";if (1 === c || 9 === c || 11 === c) {
			if ("string" == typeof b.textContent) return b.textContent;for (b = b.firstChild; b; b = b.nextSibling) {
				d += a(b);
			}
		} else if (3 === c || 4 === c) return b.nodeValue;return d;
	},
	    b = _gsScope._gsDefine.plugin({ propName: "text", API: 2, version: "0.5.1", init: function init(b, c, d) {
			var e, f;if (!("innerHTML" in b)) return !1;if (this._target = b, "object" != (typeof c === "undefined" ? "undefined" : _typeof(c)) && (c = { value: c }), void 0 === c.value) return this._text = this._original = [""], !0;for (this._delimiter = c.delimiter || "", this._original = a(b).replace(/\s+/g, " ").split(this._delimiter), this._text = c.value.replace(/\s+/g, " ").split(this._delimiter), this._runBackwards = d.vars.runBackwards === !0, this._runBackwards && (e = this._original, this._original = this._text, this._text = e), "string" == typeof c.newClass && (this._newClass = c.newClass, this._hasClass = !0), "string" == typeof c.oldClass && (this._oldClass = c.oldClass, this._hasClass = !0), e = this._original.length - this._text.length, f = 0 > e ? this._original : this._text, this._fillChar = c.fillChar || (c.padSpace ? "&nbsp;" : ""), 0 > e && (e = -e); --e > -1;) {
				f.push(this._fillChar);
			}return !0;
		}, set: function set(a) {
			a > 1 ? a = 1 : 0 > a && (a = 0), this._runBackwards && (a = 1 - a);var b,
			    c,
			    d,
			    e = this._text.length,
			    f = a * e + .5 | 0;this._hasClass ? (b = this._newClass && 0 !== f, c = this._oldClass && f !== e, d = (b ? "<span class='" + this._newClass + "'>" : "") + this._text.slice(0, f).join(this._delimiter) + (b ? "</span>" : "") + (c ? "<span class='" + this._oldClass + "'>" : "") + this._delimiter + this._original.slice(f).join(this._delimiter) + (c ? "</span>" : "")) : d = this._text.slice(0, f).join(this._delimiter) + this._delimiter + this._original.slice(f).join(this._delimiter), this._target.innerHTML = "&nbsp;" === this._fillChar && -1 !== d.indexOf("  ") ? d.split("  ").join("&nbsp;&nbsp;") : d;
		} }),
	    c = b.prototype;c._newClass = c._oldClass = c._delimiter = "";
}), _gsScope._gsDefine && _gsScope._gsQueue.pop()();
/*!
 * VERSION: 0.14.7
 * DATE: 2016-05-25
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * Requires TweenLite and CSSPlugin version 1.17.0 or later (TweenMax contains both TweenLite and CSSPlugin). ThrowPropsPlugin is required for momentum-based continuation of movement after the mouse/touch is released (ThrowPropsPlugin is a membership benefit of Club GreenSock - http://greensock.com/club/).
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
	"use strict";
	_gsScope._gsDefine("utils.Draggable", ["events.EventDispatcher", "TweenLite", "plugins.CSSPlugin"], function (a, b, c) {
		var d,
		    e,
		    f,
		    g,
		    h,
		    i,
		    j,
		    k,
		    l,
		    m = { css: {} },
		    n = { css: {} },
		    o = { css: {} },
		    p = { css: {} },
		    q = _gsScope._gsDefine.globals,
		    r = {},
		    s = document,
		    t = s.documentElement || {},
		    u = function u(a) {
			return s.createElementNS ? s.createElementNS("http://www.w3.org/1999/xhtml", a) : s.createElement(a);
		},
		    v = u("div"),
		    w = [],
		    x = function x() {
			return !1;
		},
		    y = 180 / Math.PI,
		    z = 999999999999999,
		    A = Date.now || function () {
			return new Date().getTime();
		},
		    B = !(s.addEventListener || !s.all),
		    C = s.createElement("div"),
		    D = [],
		    E = {},
		    F = 0,
		    G = /^(?:a|input|textarea|button|select)$/i,
		    H = 0,
		    I = -1 !== navigator.userAgent.toLowerCase().indexOf("android"),
		    J = 0,
		    K = {},
		    L = {},
		    M = function M(a) {
			if ("string" == typeof a && (a = b.selector(a)), !a || a.nodeType) return [a];var c,
			    d = [],
			    e = a.length;for (c = 0; c !== e; d.push(a[c++])) {}return d;
		},
		    N = function N(a) {
			var b,
			    c = {};for (b in a) {
				c[b] = a[b];
			}return c;
		},
		    O = function O() {
			for (var a = D.length; --a > -1;) {
				D[a]();
			}
		},
		    P = function P(a) {
			D.push(a), 1 === D.length && b.ticker.addEventListener("tick", O, this, !1, 1);
		},
		    Q = function Q(a) {
			for (var c = D.length; --c > -1;) {
				D[c] === a && D.splice(c, 1);
			}b.to(R, 0, { overwrite: "all", delay: 15, onComplete: R });
		},
		    R = function R() {
			D.length || b.ticker.removeEventListener("tick", O);
		},
		    S = function S(a, b) {
			var c;for (c in b) {
				void 0 === a[c] && (a[c] = b[c]);
			}return a;
		},
		    T = function T() {
			return null != window.pageYOffset ? window.pageYOffset : null != s.scrollTop ? s.scrollTop : t.scrollTop || s.body.scrollTop || 0;
		},
		    U = function U() {
			return null != window.pageXOffset ? window.pageXOffset : null != s.scrollLeft ? s.scrollLeft : t.scrollLeft || s.body.scrollLeft || 0;
		},
		    V = function V(a, b) {
			Ia(a, "scroll", b), X(a.parentNode) || V(a.parentNode, b);
		},
		    W = function W(a, b) {
			Ja(a, "scroll", b), X(a.parentNode) || W(a.parentNode, b);
		},
		    X = function X(a) {
			return !(a && a !== t && a !== s && a !== s.body && a !== window && a.nodeType && a.parentNode);
		},
		    Y = function Y(a, b) {
			var c = "x" === b ? "Width" : "Height",
			    d = "scroll" + c,
			    e = "client" + c,
			    f = s.body;return Math.max(0, X(a) ? Math.max(t[d], f[d]) - (window["inner" + c] || t[e] || f[e]) : a[d] - a[e]);
		},
		    Z = function Z(a) {
			var b = X(a),
			    c = Y(a, "x"),
			    d = Y(a, "y");b ? a = L : Z(a.parentNode), a._gsMaxScrollX = c, a._gsMaxScrollY = d, a._gsScrollX = a.scrollLeft || 0, a._gsScrollY = a.scrollTop || 0;
		},
		    $ = function $(a, b) {
			return a = a || window.event, r.pageX = a.clientX + s.body.scrollLeft + t.scrollLeft, r.pageY = a.clientY + s.body.scrollTop + t.scrollTop, b && (a.returnValue = !1), r;
		},
		    _ = function _(a) {
			return a ? ("string" == typeof a && (a = b.selector(a)), a.length && a !== window && a[0] && a[0].style && !a.nodeType && (a = a[0]), a === window || a.nodeType && a.style ? a : null) : a;
		},
		    aa = function aa(a, b) {
			var c,
			    e,
			    f,
			    g = a.style;if (void 0 === g[b]) {
				for (f = ["O", "Moz", "ms", "Ms", "Webkit"], e = 5, c = b.charAt(0).toUpperCase() + b.substr(1); --e > -1 && void 0 === g[f[e] + c];) {}if (0 > e) return "";d = 3 === e ? "ms" : f[e], b = d + c;
			}return b;
		},
		    ba = function ba(a, b, c) {
			var d = a.style;d && (void 0 === d[b] && (b = aa(a, b)), null == c ? d.removeProperty ? d.removeProperty(b.replace(/([A-Z])/g, "-$1").toLowerCase()) : d.removeAttribute(b) : void 0 !== d[b] && (d[b] = c));
		},
		    ca = s.defaultView ? s.defaultView.getComputedStyle : x,
		    da = /(?:Left|Right|Width)/i,
		    ea = /(?:\d|\-|\+|=|#|\.)*/g,
		    fa = function fa(a, b, c, d, e) {
			if ("px" === d || !d) return c;if ("auto" === d || !c) return 0;var f,
			    g = da.test(b),
			    h = a,
			    i = v.style,
			    j = 0 > c;return j && (c = -c), "%" === d && -1 !== b.indexOf("border") ? f = c / 100 * (g ? a.clientWidth : a.clientHeight) : (i.cssText = "border:0 solid red;position:" + ha(a, "position", !0) + ";line-height:0;", "%" !== d && h.appendChild ? i[g ? "borderLeftWidth" : "borderTopWidth"] = c + d : (h = a.parentNode || s.body, i[g ? "width" : "height"] = c + d), h.appendChild(v), f = parseFloat(v[g ? "offsetWidth" : "offsetHeight"]), h.removeChild(v), 0 !== f || e || (f = fa(a, b, c, d, !0))), j ? -f : f;
		},
		    ga = function ga(a, b) {
			if ("absolute" !== ha(a, "position", !0)) return 0;var c = "left" === b ? "Left" : "Top",
			    d = ha(a, "margin" + c, !0);return a["offset" + c] - (fa(a, b, parseFloat(d), (d + "").replace(ea, "")) || 0);
		},
		    ha = function ha(a, b, c) {
			var d,
			    e = (a._gsTransform || {})[b];return e || 0 === e ? e : (a.style[b] ? e = a.style[b] : (d = ca(a)) ? (e = d.getPropertyValue(b.replace(/([A-Z])/g, "-$1").toLowerCase()), e = e || d.length ? e : d[b]) : a.currentStyle && (e = a.currentStyle[b]), "auto" !== e || "top" !== b && "left" !== b || (e = ga(a, b)), c ? e : parseFloat(e) || 0);
		},
		    ia = function ia(a, b, c) {
			var d = a.vars,
			    e = d[c],
			    f = a._listeners[b];"function" == typeof e && e.apply(d[c + "Scope"] || d.callbackScope || a, d[c + "Params"] || [a.pointerEvent]), f && a.dispatchEvent(b);
		},
		    ja = function ja(a, b) {
			var c,
			    d,
			    e,
			    f = _(a);return f ? Da(f, b) : void 0 !== a.left ? (e = xa(b), { left: a.left - e.x, top: a.top - e.y, width: a.width, height: a.height }) : (d = a.min || a.minX || a.minRotation || 0, c = a.min || a.minY || 0, { left: d, top: c, width: (a.max || a.maxX || a.maxRotation || 0) - d, height: (a.max || a.maxY || 0) - c });
		},
		    ka = function ka() {
			if (!s.createElementNS) return g = 0, void (h = !1);var a,
			    b,
			    c,
			    d,
			    e = u("div"),
			    f = s.createElementNS("http://www.w3.org/2000/svg", "svg"),
			    l = u("div"),
			    m = e.style,
			    n = s.body || t;s.body && na && (m.position = "absolute", n.appendChild(l), l.appendChild(e), d = e.offsetParent, l.style[na] = "rotate(1deg)", k = e.offsetParent === d, l.style.position = "absolute", m.height = "10px", d = e.offsetTop, l.style.border = "5px solid red", j = d !== e.offsetTop, n.removeChild(l)), m = f.style, f.setAttributeNS(null, "width", "400px"), f.setAttributeNS(null, "height", "400px"), f.setAttributeNS(null, "viewBox", "0 0 400 400"), m.display = "block", m.boxSizing = "border-box", m.border = "0px solid red", m.transform = "none", e.style.cssText = "width:100px;height:100px;overflow:scroll;-ms-overflow-style:none;", n.appendChild(e), e.appendChild(f), c = f.createSVGPoint().matrixTransform(f.getScreenCTM()), b = c.y, e.scrollTop = 100, c.x = c.y = 0, c = c.matrixTransform(f.getScreenCTM()), i = b - c.y < 100.1 ? 0 : b - c.y - 150, e.removeChild(f), n.removeChild(e), n.appendChild(f), a = f.getScreenCTM(), b = a.e, m.border = "50px solid red", a = f.getScreenCTM(), 0 === b && 0 === a.e && 0 === a.f && 1 === a.a ? (g = 1, h = !0) : (g = b !== a.e ? 1 : 0, h = 1 !== a.a), n.removeChild(f);
		},
		    la = "" !== aa(v, "perspective"),
		    ma = aa(v, "transformOrigin").replace(/^ms/g, "Ms").replace(/([A-Z])/g, "-$1").toLowerCase(),
		    na = aa(v, "transform"),
		    oa = na.replace(/^ms/g, "Ms").replace(/([A-Z])/g, "-$1").toLowerCase(),
		    pa = {},
		    qa = {},
		    ra = window.SVGElement,
		    sa = function sa(a) {
			return !!(ra && "function" == typeof a.getBBox && a.getCTM && (!a.parentNode || a.parentNode.getBBox && a.parentNode.getCTM));
		},
		    ta = (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(navigator.userAgent) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(navigator.userAgent)) && parseFloat(RegExp.$1) < 11,
		    ua = [],
		    va = [],
		    wa = function wa(a) {
			if (!a.getBoundingClientRect || !a.parentNode || !na) return { offsetTop: 0, offsetLeft: 0, scaleX: 1, scaleY: 1, offsetParent: t };if (Sa.cacheSVGData !== !1 && a._gsCache && a._gsCache.lastUpdate === b.ticker.frame) return a._gsCache;var c,
			    d,
			    e,
			    f,
			    j,
			    k,
			    l,
			    m,
			    n,
			    o,
			    p,
			    q,
			    r = a,
			    u = ya(a);if (u.lastUpdate = b.ticker.frame, a.getBBox && !u.isSVGRoot) {
				for (r = a.parentNode, c = a.getBBox(); r && "svg" !== (r.nodeName + "").toLowerCase();) {
					r = r.parentNode;
				}return f = wa(r), u.offsetTop = c.y * f.scaleY, u.offsetLeft = c.x * f.scaleX, u.scaleX = f.scaleX, u.scaleY = f.scaleY, u.offsetParent = r || t, u;
			}for (e = u.offsetParent, e === s.body && (e = t), va.length = ua.length = 0; r && (j = ha(r, na, !0), "matrix(1, 0, 0, 1, 0, 0)" !== j && "none" !== j && "translate3d(0px, 0px, 0px)" !== j && (va.push(r), ua.push(r.style[na]), r.style[na] = "none"), r !== e);) {
				r = r.parentNode;
			}for (d = e.getBoundingClientRect(), j = a.getScreenCTM(), m = a.createSVGPoint(), l = m.matrixTransform(j), m.x = m.y = 10, m = m.matrixTransform(j), u.scaleX = (m.x - l.x) / 10, u.scaleY = (m.y - l.y) / 10, void 0 === g && ka(), u.borderBox && !h && a.getAttribute("width") && (f = ca(a) || {}, n = parseFloat(f.borderLeftWidth) + parseFloat(f.borderRightWidth) || 0, o = parseFloat(f.borderTopWidth) + parseFloat(f.borderBottomWidth) || 0, p = parseFloat(f.width) || 0, q = parseFloat(f.height) || 0, u.scaleX *= (p - n) / p, u.scaleY *= (q - o) / q), i ? (c = a.getBoundingClientRect(), u.offsetLeft = c.left - d.left, u.offsetTop = c.top - d.top) : (u.offsetLeft = l.x - d.left, u.offsetTop = l.y - d.top), u.offsetParent = e, k = va.length; --k > -1;) {
				va[k].style[na] = ua[k];
			}return u;
		},
		    xa = function xa(a, c) {
			if (c = c || {}, !a || a === t || !a.parentNode || a === window) return { x: 0, y: 0 };var d = ca(a),
			    e = ma && d ? d.getPropertyValue(ma) : "50% 50%",
			    f = e.split(" "),
			    g = -1 !== e.indexOf("left") ? "0%" : -1 !== e.indexOf("right") ? "100%" : f[0],
			    h = -1 !== e.indexOf("top") ? "0%" : -1 !== e.indexOf("bottom") ? "100%" : f[1];return ("center" === h || null == h) && (h = "50%"), ("center" === g || isNaN(parseFloat(g))) && (g = "50%"), a.getBBox && sa(a) ? (a._gsTransform || (b.set(a, { x: "+=0", overwrite: !1 }), void 0 === a._gsTransform.xOrigin && console.log("Draggable requires at least GSAP 1.17.0")), e = a.getBBox(), c.x = a._gsTransform.xOrigin - e.x, c.y = a._gsTransform.yOrigin - e.y) : (a.getBBox && -1 !== (g + h).indexOf("%") && (a = a.getBBox(), a = { offsetWidth: a.width, offsetHeight: a.height }), c.x = -1 !== g.indexOf("%") ? a.offsetWidth * parseFloat(g) / 100 : parseFloat(g), c.y = -1 !== h.indexOf("%") ? a.offsetHeight * parseFloat(h) / 100 : parseFloat(h)), c;
		},
		    ya = function ya(a) {
			if (Sa.cacheSVGData !== !1 && a._gsCache && a._gsCache.lastUpdate === b.ticker.frame) return a._gsCache;var c,
			    d = a._gsCache = a._gsCache || {},
			    e = ca(a),
			    f = a.getBBox && sa(a),
			    g = "svg" === (a.nodeName + "").toLowerCase();if (d.isSVG = f, d.isSVGRoot = g, d.borderBox = "border-box" === e.boxSizing, d.computedStyle = e, g) c = a.parentNode || t, c.insertBefore(v, a), d.offsetParent = v.offsetParent || t, c.removeChild(v);else if (f) {
				for (c = a.parentNode; c && "svg" !== (c.nodeName + "").toLowerCase();) {
					c = c.parentNode;
				}d.offsetParent = c;
			} else d.offsetParent = a.offsetParent;return d;
		},
		    za = function za(a, b, c, d) {
			if (a === window || !a || !a.style || !a.parentNode) return [1, 0, 0, 1, 0, 0];var e,
			    f,
			    h,
			    i,
			    l,
			    m,
			    n,
			    o,
			    p,
			    q,
			    r,
			    u,
			    v,
			    w,
			    x = a._gsCache || ya(a),
			    y = a.parentNode,
			    z = y._gsCache || ya(y),
			    A = x.computedStyle,
			    B = x.isSVG ? z.offsetParent : y.offsetParent;return e = x.isSVG && -1 !== (a.style[na] + "").indexOf("matrix") ? a.style[na] : A ? A.getPropertyValue(oa) : a.currentStyle ? a.currentStyle[na] : "1,0,0,1,0,0", a.getBBox && -1 !== (a.getAttribute("transform") + "").indexOf("matrix") && (e = a.getAttribute("transform")), e = (e + "").match(/(?:\-|\.|\b)(\d|\.|e\-)+/g) || [1, 0, 0, 1, 0, 0], e.length > 6 && (e = [e[0], e[1], e[4], e[5], e[12], e[13]]), d ? e[4] = e[5] = 0 : x.isSVG && (l = a._gsTransform) && (l.xOrigin || l.yOrigin) && (e[0] = parseFloat(e[0]), e[1] = parseFloat(e[1]), e[2] = parseFloat(e[2]), e[3] = parseFloat(e[3]), e[4] = parseFloat(e[4]) - (l.xOrigin - (l.xOrigin * e[0] + l.yOrigin * e[2])), e[5] = parseFloat(e[5]) - (l.yOrigin - (l.xOrigin * e[1] + l.yOrigin * e[3]))), b && (void 0 === g && ka(), h = x.isSVG || x.isSVGRoot ? wa(a) : a, x.isSVG ? (i = a.getBBox(), q = z.isSVGRoot ? { x: 0, y: 0 } : y.getBBox(), h = { offsetLeft: i.x - q.x, offsetTop: i.y - q.y, offsetParent: x.offsetParent }) : x.isSVGRoot ? (r = parseInt(A.borderTopWidth, 10) || 0, u = parseInt(A.borderLeftWidth, 10) || 0, v = (e[0] - g) * u + e[2] * r, w = e[1] * u + (e[3] - g) * r, m = b.x, n = b.y, o = m - (m * e[0] + n * e[2]), p = n - (m * e[1] + n * e[3]), e[4] = parseFloat(e[4]) + o, e[5] = parseFloat(e[5]) + p, b.x -= o, b.y -= p, m = h.scaleX, n = h.scaleY, b.x *= m, b.y *= n, e[0] *= m, e[1] *= n, e[2] *= m, e[3] *= n, ta || (b.x += v, b.y += w)) : !j && a.offsetParent && (b.x += parseInt(ha(a.offsetParent, "borderLeftWidth"), 10) || 0, b.y += parseInt(ha(a.offsetParent, "borderTopWidth"), 10) || 0), f = y === t || y === s.body, e[4] = Number(e[4]) + b.x + (h.offsetLeft || 0) - c.x - (f ? 0 : y.scrollLeft || 0), e[5] = Number(e[5]) + b.y + (h.offsetTop || 0) - c.y - (f ? 0 : y.scrollTop || 0), y && "fixed" === ha(a, "position", A) && (e[4] += U(), e[5] += T()), !y || y === t || B !== h.offsetParent || z.isSVG || k && "100100" !== za(y).join("") || (h = z.isSVGRoot ? wa(y) : y, e[4] -= h.offsetLeft || 0, e[5] -= h.offsetTop || 0, j || !z.offsetParent || x.isSVG || x.isSVGRoot || (e[4] -= parseInt(ha(z.offsetParent, "borderLeftWidth"), 10) || 0, e[5] -= parseInt(ha(z.offsetParent, "borderTopWidth"), 10) || 0))), e;
		},
		    Aa = function Aa(a, b) {
			if (!a || a === window || !a.parentNode) return [1, 0, 0, 1, 0, 0];for (var c, d, e, f, g, h, i, j, k = xa(a, pa), l = xa(a.parentNode, qa), m = za(a, k, l); (a = a.parentNode) && a.parentNode && a !== t;) {
				k = l, l = xa(a.parentNode, k === pa ? qa : pa), i = za(a, k, l), c = m[0], d = m[1], e = m[2], f = m[3], g = m[4], h = m[5], m[0] = c * i[0] + d * i[2], m[1] = c * i[1] + d * i[3], m[2] = e * i[0] + f * i[2], m[3] = e * i[1] + f * i[3], m[4] = g * i[0] + h * i[2] + i[4], m[5] = g * i[1] + h * i[3] + i[5];
			}return b && (c = m[0], d = m[1], e = m[2], f = m[3], g = m[4], h = m[5], j = c * f - d * e, m[0] = f / j, m[1] = -d / j, m[2] = -e / j, m[3] = c / j, m[4] = (e * h - f * g) / j, m[5] = -(c * h - d * g) / j), m;
		},
		    Ba = function Ba(a, b, c, d, e) {
			a = _(a);var f = Aa(a, !1, e),
			    g = b.x,
			    h = b.y;return c && (xa(a, b), g -= b.x, h -= b.y), d = d === !0 ? b : d || {}, d.x = g * f[0] + h * f[2] + f[4], d.y = g * f[1] + h * f[3] + f[5], d;
		},
		    Ca = function Ca(a, b, c) {
			var d = a.x * b[0] + a.y * b[2] + b[4],
			    e = a.x * b[1] + a.y * b[3] + b[5];return a.x = d * c[0] + e * c[2] + c[4], a.y = d * c[1] + e * c[3] + c[5], a;
		},
		    Da = function Da(a, b, c) {
			if (!(a = _(a))) return null;b = _(b);var d,
			    e,
			    f,
			    g,
			    h,
			    i,
			    j,
			    k,
			    l,
			    m,
			    n,
			    o,
			    p,
			    q,
			    r,
			    u,
			    v,
			    w,
			    x,
			    y,
			    z,
			    A,
			    C = a.getBBox && sa(a);if (a === window) g = T(), e = U(), f = e + (t.clientWidth || a.innerWidth || s.body.clientWidth || 0), h = g + ((a.innerHeight || 0) - 20 < t.clientHeight ? t.clientHeight : a.innerHeight || s.body.clientHeight || 0);else {
				if (void 0 === b || b === window) return a.getBoundingClientRect();d = xa(a), e = -d.x, g = -d.y, C ? (o = a.getBBox(), p = o.width, q = o.height) : "svg" !== (a.nodeName + "").toLowerCase() && a.offsetWidth ? (p = a.offsetWidth, q = a.offsetHeight) : (z = ca(a), p = parseFloat(z.width), q = parseFloat(z.height)), f = e + p, h = g + q, "svg" !== a.nodeName.toLowerCase() || B || (r = wa(a), A = r.computedStyle || {}, w = (a.getAttribute("viewBox") || "0 0").split(" "), x = parseFloat(w[0]), y = parseFloat(w[1]), u = parseFloat(A.borderLeftWidth) || 0, v = parseFloat(A.borderTopWidth) || 0, f -= p - (p - u) / r.scaleX - x, h -= q - (q - v) / r.scaleY - y, e -= u / r.scaleX - x, g -= v / r.scaleY - y, z && (f += (parseFloat(A.borderRightWidth) + u) / r.scaleX, h += (v + parseFloat(A.borderBottomWidth)) / r.scaleY));
			}return a === b ? { left: e, top: g, width: f - e, height: h - g } : (i = Aa(a), j = Aa(b, !0), k = Ca({ x: e, y: g }, i, j), l = Ca({ x: f, y: g }, i, j), m = Ca({ x: f, y: h }, i, j), n = Ca({ x: e, y: h }, i, j), e = Math.min(k.x, l.x, m.x, n.x), g = Math.min(k.y, l.y, m.y, n.y), K.x = K.y = 0, c && xa(b, K), { left: e + K.x, top: g + K.y, width: Math.max(k.x, l.x, m.x, n.x) - e, height: Math.max(k.y, l.y, m.y, n.y) - g });
		},
		    Ea = function Ea(a) {
			return a && a.length && a[0] && (a[0].nodeType && a[0].style && !a.nodeType || a[0].length && a[0][0]) ? !0 : !1;
		},
		    Fa = function Fa(a) {
			var b,
			    c,
			    d,
			    e = [],
			    f = a.length;for (b = 0; f > b; b++) {
				if (c = a[b], Ea(c)) for (d = c.length, d = 0; d < c.length; d++) {
					e.push(c[d]);
				} else c && 0 !== c.length && e.push(c);
			}return e;
		},
		    Ga = "ontouchstart" in t && "orientation" in window,
		    Ha = function (a) {
			for (var b = a.split(","), c = (void 0 !== v.onpointerdown ? "pointerdown,pointermove,pointerup,pointercancel" : void 0 !== v.onmspointerdown ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : a).split(","), d = {}, e = 8; --e > -1;) {
				d[b[e]] = c[e], d[c[e]] = b[e];
			}return d;
		}("touchstart,touchmove,touchend,touchcancel"),
		    Ia = function Ia(a, b, c, d) {
			a.addEventListener ? a.addEventListener(Ha[b] || b, c, d) : a.attachEvent && a.attachEvent("on" + b, c);
		},
		    Ja = function Ja(a, b, c) {
			a.removeEventListener ? a.removeEventListener(Ha[b] || b, c) : a.detachEvent && a.detachEvent("on" + b, c);
		},
		    Ka = function Ka(a, b) {
			for (var c = a.length; --c > -1;) {
				if (a[c].identifier === b) return !0;
			}return !1;
		},
		    La = function La(a) {
			e = a.touches && H < a.touches.length, Ja(a.target, "touchend", La);
		},
		    Ma = function Ma(a) {
			e = a.touches && H < a.touches.length, Ia(a.target, "touchend", La);
		},
		    Na = function Na(a, b, c, d, e, f) {
			var g,
			    h,
			    i,
			    j = {};if (b) if (1 !== e && b instanceof Array) {
				for (j.end = g = [], i = b.length, h = 0; i > h; h++) {
					g[h] = b[h] * e;
				}c += 1.1, d -= 1.1;
			} else "function" == typeof b ? j.end = function (c) {
				return b.call(a, c) * e;
			} : j.end = b;return (c || 0 === c) && (j.max = c), (d || 0 === d) && (j.min = d), f && (j.velocity = 0), j;
		},
		    Oa = function Oa(a) {
			var b;return a && a.getAttribute && "BODY" !== a.nodeName ? "true" === (b = a.getAttribute("data-clickable")) || "false" !== b && (a.onclick || G.test(a.nodeName + "") || "true" === a.getAttribute("contentEditable")) ? !0 : Oa(a.parentNode) : !1;
		},
		    Pa = function Pa(a, b) {
			for (var c, d = a.length; --d > -1;) {
				c = a[d], c.ondragstart = c.onselectstart = b ? null : x, ba(c, "userSelect", b ? "text" : "none");
			}
		},
		    Qa = function () {
			var a,
			    b = s.createElement("div"),
			    c = s.createElement("div"),
			    d = c.style,
			    e = s.body || v;return d.display = "inline-block", d.position = "relative", b.style.cssText = c.innerHTML = "width:90px; height:40px; padding:10px; overflow:auto; visibility: hidden", b.appendChild(c), e.appendChild(b), l = c.offsetHeight + 18 > b.scrollHeight, d.width = "100%", na || (d.paddingRight = "500px", a = b.scrollLeft = b.scrollWidth - b.clientWidth, d.left = "-90px", a = a !== b.scrollLeft), e.removeChild(b), a;
		}(),
		    Ra = function Ra(a, c) {
			a = _(a), c = c || {};var d,
			    e,
			    f,
			    g,
			    h,
			    i,
			    j = s.createElement("div"),
			    k = j.style,
			    m = a.firstChild,
			    n = 0,
			    o = 0,
			    p = a.scrollTop,
			    q = a.scrollLeft,
			    r = a.scrollWidth,
			    t = a.scrollHeight,
			    u = 0,
			    v = 0,
			    w = 0;la && c.force3D !== !1 ? (h = "translate3d(", i = "px,0px)") : na && (h = "translate(", i = "px)"), this.scrollTop = function (a, b) {
				return arguments.length ? void this.top(-a, b) : -this.top();
			}, this.scrollLeft = function (a, b) {
				return arguments.length ? void this.left(-a, b) : -this.left();
			}, this.left = function (d, e) {
				if (!arguments.length) return -(a.scrollLeft + o);var f = a.scrollLeft - q,
				    g = o;return (f > 2 || -2 > f) && !e ? (q = a.scrollLeft, b.killTweensOf(this, !0, { left: 1, scrollLeft: 1 }), this.left(-q), void (c.onKill && c.onKill())) : (d = -d, 0 > d ? (o = d - .5 | 0, d = 0) : d > v ? (o = d - v | 0, d = v) : o = 0, (o || g) && (h ? this._suspendTransforms || (k[na] = h + -o + "px," + -n + i) : k.left = -o + "px", Qa && o + u >= 0 && (k.paddingRight = o + u + "px")), a.scrollLeft = 0 | d, void (q = a.scrollLeft));
			}, this.top = function (d, e) {
				if (!arguments.length) return -(a.scrollTop + n);var f = a.scrollTop - p,
				    g = n;return (f > 2 || -2 > f) && !e ? (p = a.scrollTop, b.killTweensOf(this, !0, { top: 1, scrollTop: 1 }), this.top(-p), void (c.onKill && c.onKill())) : (d = -d, 0 > d ? (n = d - .5 | 0, d = 0) : d > w ? (n = d - w | 0, d = w) : n = 0, (n || g) && (h ? this._suspendTransforms || (k[na] = h + -o + "px," + -n + i) : k.top = -n + "px"), a.scrollTop = 0 | d, void (p = a.scrollTop));
			}, this.maxScrollTop = function () {
				return w;
			}, this.maxScrollLeft = function () {
				return v;
			}, this.disable = function () {
				for (m = j.firstChild; m;) {
					g = m.nextSibling, a.appendChild(m), m = g;
				}a === j.parentNode && a.removeChild(j);
			}, this.enable = function () {
				if (m = a.firstChild, m !== j) {
					for (; m;) {
						g = m.nextSibling, j.appendChild(m), m = g;
					}a.appendChild(j), this.calibrate();
				}
			}, this.calibrate = function (b) {
				var c,
				    g,
				    h = a.clientWidth === d;p = a.scrollTop, q = a.scrollLeft, (!h || a.clientHeight !== e || j.offsetHeight !== f || r !== a.scrollWidth || t !== a.scrollHeight || b) && ((n || o) && (c = this.left(), g = this.top(), this.left(-a.scrollLeft), this.top(-a.scrollTop)), (!h || b) && (k.display = "block", k.width = "auto", k.paddingRight = "0px", u = Math.max(0, a.scrollWidth - a.clientWidth), u && (u += ha(a, "paddingLeft") + (l ? ha(a, "paddingRight") : 0))), k.display = "inline-block", k.position = "relative", k.overflow = "visible", k.verticalAlign = "top", k.width = "100%", k.paddingRight = u + "px", l && (k.paddingBottom = ha(a, "paddingBottom", !0)), B && (k.zoom = "1"), d = a.clientWidth, e = a.clientHeight, r = a.scrollWidth, t = a.scrollHeight, v = a.scrollWidth - d, w = a.scrollHeight - e, f = j.offsetHeight, k.display = "block", (c || g) && (this.left(c), this.top(g)));
			}, this.content = j, this.element = a, this._suspendTransforms = !1, this.enable();
		},
		    Sa = function Sa(d, g) {
			a.call(this, d), d = _(d), f || (f = q.com.greensock.plugins.ThrowPropsPlugin), this.vars = g = N(g || {}), this.target = d, this.x = this.y = this.rotation = 0, this.dragResistance = parseFloat(g.dragResistance) || 0, this.edgeResistance = isNaN(g.edgeResistance) ? 1 : parseFloat(g.edgeResistance) || 0, this.lockAxis = g.lockAxis, this.autoScroll = g.autoScroll || 0, this.lockedAxis = null, this.allowEventDefault = !!g.allowEventDefault;var h,
			    i,
			    j,
			    k,
			    l,
			    r,
			    u,
			    v,
			    x,
			    D,
			    G,
			    K,
			    O,
			    R,
			    T,
			    U,
			    Y,
			    aa,
			    ca,
			    da,
			    ea,
			    fa,
			    ga,
			    ka,
			    la,
			    ma,
			    na,
			    oa,
			    pa,
			    qa,
			    ra,
			    sa,
			    ta = (g.type || (B ? "top,left" : "x,y")).toLowerCase(),
			    ua = -1 !== ta.indexOf("x") || -1 !== ta.indexOf("y"),
			    va = -1 !== ta.indexOf("rotation"),
			    wa = va ? "rotation" : ua ? "x" : "left",
			    xa = ua ? "y" : "top",
			    ya = -1 !== ta.indexOf("x") || -1 !== ta.indexOf("left") || "scroll" === ta,
			    za = -1 !== ta.indexOf("y") || -1 !== ta.indexOf("top") || "scroll" === ta,
			    Ca = g.minimumMovement || 2,
			    Da = this,
			    Ea = M(g.trigger || g.handle || d),
			    Fa = {},
			    La = 0,
			    Qa = !1,
			    Ta = g.clickableTest || Oa,
			    Ua = 0,
			    Va = function Va(a) {
				if (Da.autoScroll && Da.isDragging && (Qa || aa)) {
					var b,
					    c,
					    e,
					    f,
					    g,
					    h,
					    j,
					    k,
					    l = d,
					    m = 15 * Da.autoScroll;for (Qa = !1, L.scrollTop = null != window.pageYOffset ? window.pageYOffset : null != t.scrollTop ? t.scrollTop : s.body.scrollTop, L.scrollLeft = null != window.pageXOffset ? window.pageXOffset : null != t.scrollLeft ? t.scrollLeft : s.body.scrollLeft, f = Da.pointerX - L.scrollLeft, g = Da.pointerY - L.scrollTop; l && !c;) {
						c = X(l.parentNode), b = c ? L : l.parentNode, e = c ? { bottom: Math.max(t.clientHeight, window.innerHeight || 0), right: Math.max(t.clientWidth, window.innerWidth || 0), left: 0, top: 0 } : b.getBoundingClientRect(), h = j = 0, za && (k = b._gsMaxScrollY - b.scrollTop, 0 > k ? j = k : g > e.bottom - 40 && k ? (Qa = !0, j = Math.min(k, m * (1 - Math.max(0, e.bottom - g) / 40) | 0)) : g < e.top + 40 && b.scrollTop && (Qa = !0, j = -Math.min(b.scrollTop, m * (1 - Math.max(0, g - e.top) / 40) | 0)), j && (b.scrollTop += j)), ya && (k = b._gsMaxScrollX - b.scrollLeft, 0 > k ? h = k : f > e.right - 40 && k ? (Qa = !0, h = Math.min(k, m * (1 - Math.max(0, e.right - f) / 40) | 0)) : f < e.left + 40 && b.scrollLeft && (Qa = !0, h = -Math.min(b.scrollLeft, m * (1 - Math.max(0, f - e.left) / 40) | 0)), h && (b.scrollLeft += h)), c && (h || j) && (window.scrollTo(b.scrollLeft, b.scrollTop), gb(Da.pointerX + h, Da.pointerY + j)), l = b;
					}
				}if (aa) {
					var n = Da.x,
					    o = Da.y,
					    p = 1e-6;p > n && n > -p && (n = 0), p > o && o > -p && (o = 0), va ? (oa.data.rotation = Da.rotation = n, oa.setRatio(1)) : i ? (za && i.top(o), ya && i.left(n)) : ua ? (za && (oa.data.y = o), ya && (oa.data.x = n), oa.setRatio(1)) : (za && (d.style.top = o + "px"), ya && (d.style.left = n + "px")), !v || a || ra || (ra = !0, ia(Da, "drag", "onDrag"), ra = !1);
				}aa = !1;
			},
			    Xa = function Xa(a, c) {
				var e,
				    f = Da.x,
				    g = Da.y;d._gsTransform || !ua && !va || b.set(d, { x: "+=0", overwrite: !1 }), ua ? (Da.y = d._gsTransform.y, Da.x = d._gsTransform.x) : va ? Da.x = Da.rotation = d._gsTransform.rotation : i ? (Da.y = i.top(), Da.x = i.left()) : (Da.y = parseInt(d.style.top, 10) || 0, Da.x = parseInt(d.style.left, 10) || 0), !da && !ea || c || (da && (e = da(Da.x), e !== Da.x && (Da.x = e, va && (Da.rotation = e))), ea && (e = ea(Da.y), e !== Da.y && (Da.y = e))), (f !== Da.x || g !== Da.y) && Va(!0), a || ia(Da, "throwupdate", "onThrowUpdate");
			},
			    Ya = function Ya() {
				var a, b, c, e;u = !1, i ? (i.calibrate(), Da.minX = D = -i.maxScrollLeft(), Da.minY = K = -i.maxScrollTop(), Da.maxX = x = Da.maxY = G = 0, u = !0) : g.bounds && (a = ja(g.bounds, d.parentNode), va ? (Da.minX = D = a.left, Da.maxX = x = a.left + a.width, Da.minY = K = Da.maxY = G = 0) : void 0 !== g.bounds.maxX || void 0 !== g.bounds.maxY ? (a = g.bounds, Da.minX = D = a.minX, Da.minY = K = a.minY, Da.maxX = x = a.maxX, Da.maxY = G = a.maxY) : (b = ja(d, d.parentNode), Da.minX = D = ha(d, wa) + a.left - b.left, Da.minY = K = ha(d, xa) + a.top - b.top, Da.maxX = x = D + (a.width - b.width), Da.maxY = G = K + (a.height - b.height)), D > x && (Da.minX = x, Da.maxX = x = D, D = Da.minX), K > G && (Da.minY = G, Da.maxY = G = K, K = Da.minY), va && (Da.minRotation = D, Da.maxRotation = x), u = !0), g.liveSnap && (c = g.liveSnap === !0 ? g.snap || {} : g.liveSnap, e = c instanceof Array || "function" == typeof c, va ? (da = db(e ? c : c.rotation, D, x, 1), ea = null) : (ya && (da = db(e ? c : c.x || c.left || c.scrollLeft, D, x, i ? -1 : 1)), za && (ea = db(e ? c : c.y || c.top || c.scrollTop, K, G, i ? -1 : 1))));
			},
			    Za = function Za() {
				Da.isThrowing = !1, ia(Da, "throwcomplete", "onThrowComplete");
			},
			    $a = function $a() {
				Da.isThrowing = !1;
			},
			    _a = function _a(a, b) {
				var c, e, h, j;a && f ? (a === !0 && (c = g.snap || {}, e = c instanceof Array || "function" == typeof c, a = { resistance: (g.throwResistance || g.resistance || 1e3) / (va ? 10 : 1) }, va ? a.rotation = Na(Da, e ? c : c.rotation, x, D, 1, b) : (ya && (a[wa] = Na(Da, e ? c : c.x || c.left || c.scrollLeft, x, D, i ? -1 : 1, b || "x" === Da.lockedAxis)), za && (a[xa] = Na(Da, e ? c : c.y || c.top || c.scrollTop, G, K, i ? -1 : 1, b || "y" === Da.lockedAxis)))), Da.isThrowing = !0, j = isNaN(g.overshootTolerance) ? 1 === g.edgeResistance ? 0 : 1 - Da.edgeResistance + .2 : g.overshootTolerance, Da.tween = h = f.to(i || d, { throwProps: a, ease: g.ease || q.Power3.easeOut, onComplete: Za, onOverwrite: $a, onUpdate: g.fastMode ? ia : Xa, onUpdateParams: g.fastMode ? [Da, "onthrowupdate", "onThrowUpdate"] : w }, isNaN(g.maxDuration) ? 2 : g.maxDuration, isNaN(g.minDuration) ? 0 === j ? 0 : .5 : g.minDuration, j), g.fastMode || (i && (i._suspendTransforms = !0), h.render(h.duration(), !0, !0), Xa(!0, !0), Da.endX = Da.x, Da.endY = Da.y, va && (Da.endRotation = Da.x), h.play(0), Xa(!0, !0), i && (i._suspendTransforms = !1))) : u && Da.applyBounds();
			},
			    ab = function ab(a) {
				var b,
				    c,
				    e,
				    f,
				    g,
				    h,
				    i,
				    l,
				    m,
				    n = ka || [1, 0, 0, 1, 0, 0];ka = Aa(d.parentNode, !0), a && Da.isPressed && n.join(",") !== ka.join(",") && (b = n[0], c = n[1], e = n[2], f = n[3], g = n[4], h = n[5], i = b * f - c * e, l = j * (f / i) + k * (-e / i) + (e * h - f * g) / i, m = j * (-c / i) + k * (b / i) + -(b * h - c * g) / i, k = l * ka[1] + m * ka[3] + ka[5], j = l * ka[0] + m * ka[2] + ka[4]), ka[1] || ka[2] || 1 != ka[0] || 1 != ka[3] || 0 != ka[4] || 0 != ka[5] || (ka = null);
			},
			    bb = function bb() {
				var a = 1 - Da.edgeResistance;ab(!1), ka && (j = Da.pointerX * ka[0] + Da.pointerY * ka[2] + ka[4], k = Da.pointerX * ka[1] + Da.pointerY * ka[3] + ka[5]), aa && (gb(Da.pointerX, Da.pointerY), Va(!0)), i ? (Ya(), r = i.top(), l = i.left()) : (cb() ? (Xa(!0, !0), Ya()) : Da.applyBounds(), va ? (Y = Ba(d, { x: 0, y: 0 }), Xa(!0, !0), l = Da.x, r = Da.y = Math.atan2(Y.y - Da.pointerY, Da.pointerX - Y.x) * y) : (ma = d.parentNode ? d.parentNode.scrollTop || 0 : 0, na = d.parentNode ? d.parentNode.scrollLeft || 0 : 0, r = ha(d, xa), l = ha(d, wa))), u && a && (l > x ? l = x + (l - x) / a : D > l && (l = D - (D - l) / a), va || (r > G ? r = G + (r - G) / a : K > r && (r = K - (K - r) / a)));
			},
			    cb = function cb() {
				return Da.tween && Da.tween.isActive();
			},
			    db = function db(a, b, c, d) {
				return "function" == typeof a ? function (e) {
					var f = Da.isPressed ? 1 - Da.edgeResistance : 1;return a.call(Da, e > c ? c + (e - c) * f : b > e ? b + (e - b) * f : e) * d;
				} : a instanceof Array ? function (d) {
					for (var e, f, g = a.length, h = 0, i = z; --g > -1;) {
						e = a[g], f = e - d, 0 > f && (f = -f), i > f && e >= b && c >= e && (h = g, i = f);
					}return a[h];
				} : isNaN(a) ? function (a) {
					return a;
				} : function () {
					return a * d;
				};
			},
			    eb = function eb(a) {
				var c;if (!(!h || Da.isPressed || !a || ("mousedown" === a.type || "pointerdown" === a.type) && A() - Ua < 30 && Ha[Da.pointerEvent.type])) {
					if (la = cb(), Da.pointerEvent = a, Ha[a.type] ? (ga = -1 !== a.type.indexOf("touch") ? a.currentTarget || a.target : s, Ia(ga, "touchend", hb), Ia(ga, "touchmove", fb), Ia(ga, "touchcancel", hb), Ia(s, "touchstart", Ma)) : (ga = null, Ia(s, "mousemove", fb)), qa = null, Ia(s, "mouseup", hb), a && a.target && Ia(a.target, "mouseup", hb), fa = Ta.call(Da, a.target) && !g.dragClickables) return Ia(a.target, "change", hb), ia(Da, "press", "onPress"), void Pa(Ea, !0);if (pa = !ga || ya === za || i || Da.vars.allowNativeTouchScrolling === !1 ? !1 : ya ? "y" : "x", B ? a = $(a, !0) : pa || Da.allowEventDefault || (a.preventDefault(), a.preventManipulation && a.preventManipulation()), a.changedTouches ? (a = T = a.changedTouches[0], U = a.identifier) : a.pointerId ? U = a.pointerId : T = U = null, H++, P(Va), k = Da.pointerY = a.pageY, j = Da.pointerX = a.pageX, (pa || Da.autoScroll) && Z(d.parentNode), !Da.autoScroll || va || i || !d.parentNode || d.getBBox || !d.parentNode._gsMaxScrollX || C.parentNode || (C.style.width = d.parentNode.scrollWidth + "px", d.parentNode.appendChild(C)), bb(), Da.tween && Da.tween.kill(), Da.isThrowing = !1, b.killTweensOf(i || d, !0, Fa), i && b.killTweensOf(d, !0, { scrollTo: 1 }), Da.tween = Da.lockedAxis = null, (g.zIndexBoost || !va && !i && g.zIndexBoost !== !1) && (d.style.zIndex = Sa.zIndex++), Da.isPressed = !0, v = !(!g.onDrag && !Da._listeners.drag), !va) for (c = Ea.length; --c > -1;) {
						ba(Ea[c], "cursor", g.cursor || "move");
					}ia(Da, "press", "onPress");
				}
			},
			    fb = function fb(a) {
				var b,
				    c,
				    d,
				    f,
				    g = a;if (h && !e && Da.isPressed && a) {
					if (Da.pointerEvent = a, b = a.changedTouches) {
						if (a = b[0], a !== T && a.identifier !== U) {
							for (f = b.length; --f > -1 && (a = b[f]).identifier !== U;) {}if (0 > f) return;
						}
					} else if (a.pointerId && U && a.pointerId !== U) return;if (B) a = $(a, !0);else {
						if (ga && pa && !qa && (c = a.pageX, d = a.pageY, ka && (f = c * ka[0] + d * ka[2] + ka[4], d = c * ka[1] + d * ka[3] + ka[5], c = f), qa = Math.abs(c - j) > Math.abs(d - k) && ya ? "x" : "y", Da.vars.lockAxisOnTouchScroll !== !1 && (Da.lockedAxis = "x" === qa ? "y" : "x", "function" == typeof Da.vars.onLockAxis && Da.vars.onLockAxis.call(Da, g)), I && pa === qa)) return void hb(g);Da.allowEventDefault || pa && (!qa || pa === qa) || g.cancelable === !1 || (g.preventDefault(), g.preventManipulation && g.preventManipulation());
					}Da.autoScroll && (Qa = !0), gb(a.pageX, a.pageY);
				}
			},
			    gb = function gb(a, b) {
				var c,
				    d,
				    e,
				    f,
				    g,
				    h,
				    i = 1 - Da.dragResistance,
				    m = 1 - Da.edgeResistance;Da.pointerX = a, Da.pointerY = b, va ? (f = Math.atan2(Y.y - b, a - Y.x) * y, g = Da.y - f, Da.y = f, g > 180 ? r -= 360 : -180 > g && (r += 360), e = l + (r - f) * i) : (ka && (h = a * ka[0] + b * ka[2] + ka[4], b = a * ka[1] + b * ka[3] + ka[5], a = h), d = b - k, c = a - j, Ca > d && d > -Ca && (d = 0), Ca > c && c > -Ca && (c = 0), (Da.lockAxis || Da.lockedAxis) && (c || d) && (h = Da.lockedAxis, h || (Da.lockedAxis = h = ya && Math.abs(c) > Math.abs(d) ? "y" : za ? "x" : null, h && "function" == typeof Da.vars.onLockAxis && Da.vars.onLockAxis.call(Da, Da.pointerEvent)), "y" === h ? d = 0 : "x" === h && (c = 0)), e = l + c * i, f = r + d * i), da || ea ? (da && (e = da(e)), ea && (f = ea(f))) : u && (e > x ? e = x + (e - x) * m : D > e && (e = D + (e - D) * m), va || (f > G ? f = G + (f - G) * m : K > f && (f = K + (f - K) * m))), va || (e = Math.round(e), f = Math.round(f)), (Da.x !== e || Da.y !== f && !va) && (va ? Da.endRotation = Da.x = Da.endX = e : (za && (Da.y = Da.endY = f), ya && (Da.x = Da.endX = e)), aa = !0, !Da.isDragging && Da.isPressed && (Da.isDragging = !0, ia(Da, "dragstart", "onDragStart")));
			},
			    hb = function hb(a, c) {
				if (h && Da.isPressed && (!a || null == U || c || !(a.pointerId && a.pointerId !== U || a.changedTouches && !Ka(a.changedTouches, U)))) {
					Da.isPressed = !1;var e,
					    f,
					    i,
					    j,
					    k = a,
					    l = Da.isDragging;if (ga ? (Ja(ga, "touchend", hb), Ja(ga, "touchmove", fb), Ja(ga, "touchcancel", hb), Ja(s, "touchstart", Ma)) : Ja(s, "mousemove", fb), Ja(s, "mouseup", hb), a && a.target && Ja(a.target, "mouseup", hb), aa = !1, C.parentNode && C.parentNode.removeChild(C), fa) return a && Ja(a.target, "change", hb), Pa(Ea, !1), ia(Da, "release", "onRelease"), ia(Da, "click", "onClick"), void (fa = !1);if (Q(Va), !va) for (f = Ea.length; --f > -1;) {
						ba(Ea[f], "cursor", g.cursor || "move");
					}if (l && (La = J = A(), Da.isDragging = !1), H--, a) {
						if (B && (a = $(a, !1)), e = a.changedTouches, e && (a = e[0], a !== T && a.identifier !== U)) {
							for (f = e.length; --f > -1 && (a = e[f]).identifier !== U;) {}if (0 > f) return;
						}Da.pointerEvent = k, Da.pointerX = a.pageX, Da.pointerY = a.pageY;
					}return k && !l ? (la && (g.snap || g.bounds) && _a(g.throwProps), ia(Da, "release", "onRelease"), I && "touchmove" === k.type || (ia(Da, "click", "onClick"), j = k.target || k.srcElement || d, Ua = A(), b.delayedCall(1e-5, function () {
						Ua !== sa && Da.enabled() && !Da.isPressed && (j.click ? j.click() : s.createEvent && (i = s.createEvent("MouseEvents"), i.initMouseEvent("click", !0, !0, window, 1, Da.pointerEvent.screenX, Da.pointerEvent.screenY, Da.pointerX, Da.pointerY, !1, !1, !1, !1, 0, null), j.dispatchEvent(i)));
					}))) : (_a(g.throwProps), B || Da.allowEventDefault || !k || !g.dragClickables && Ta.call(Da, k.target) || !l || pa && (!qa || pa !== qa) || k.cancelable === !1 || (k.preventDefault(), k.preventManipulation && k.preventManipulation()), ia(Da, "release", "onRelease")), l && ia(Da, "dragend", "onDragEnd"), !0;
				}
			},
			    ib = function ib(a) {
				if (a && Da.isDragging) {
					var b = a.target || a.srcElement || d.parentNode,
					    c = b.scrollLeft - b._gsScrollX,
					    e = b.scrollTop - b._gsScrollY;(c || e) && (ka ? (j -= c * ka[0] + e * ka[2], k -= e * ka[3] + c * ka[1]) : (j -= c, k -= e), b._gsScrollX += c, b._gsScrollY += e, gb(Da.pointerX, Da.pointerY));
				}
			},
			    jb = function jb(a) {
				var b = A(),
				    c = 40 > b - Ua,
				    d = 40 > b - La;return c && sa !== Ua ? void (sa = Ua) : void ((Da.isPressed || d || c) && (a.preventDefault ? (a.preventDefault(), (c || d && Da.vars.suppressClickOnDrag !== !1) && a.stopImmediatePropagation()) : a.returnValue = !1, a.preventManipulation && a.preventManipulation()));
			};ca = Sa.get(this.target), ca && ca.kill(), this.startDrag = function (a) {
				eb(a), Da.isDragging || (Da.isDragging = !0, ia(Da, "dragstart", "onDragStart"));
			}, this.drag = fb, this.endDrag = function (a) {
				hb(a, !0);
			}, this.timeSinceDrag = function () {
				return Da.isDragging ? 0 : (A() - La) / 1e3;
			}, this.hitTest = function (a, b) {
				return Sa.hitTest(Da.target, a, b);
			}, this.getDirection = function (a, b) {
				var c,
				    d,
				    e,
				    g,
				    h,
				    i,
				    j = "velocity" === a && f ? a : "object" != (typeof a === "undefined" ? "undefined" : _typeof(a)) || va ? "start" : "element";return "element" === j && (h = Wa(Da.target), i = Wa(a)), c = "start" === j ? Da.x - l : "velocity" === j ? f.getVelocity(this.target, wa) : h.left + h.width / 2 - (i.left + i.width / 2), va ? 0 > c ? "counter-clockwise" : "clockwise" : (b = b || 2, d = "start" === j ? Da.y - r : "velocity" === j ? f.getVelocity(this.target, xa) : h.top + h.height / 2 - (i.top + i.height / 2), e = Math.abs(c / d), g = 1 / b > e ? "" : 0 > c ? "left" : "right", b > e && ("" !== g && (g += "-"), g += 0 > d ? "up" : "down"), g);
			}, this.applyBounds = function (a) {
				var b, c, e, f, h, i;if (a && g.bounds !== a) return g.bounds = a, Da.update(!0);if (Xa(!0), Ya(), u) {
					if (b = Da.x, c = Da.y, b > x ? b = x : D > b && (b = D), c > G ? c = G : K > c && (c = K), (Da.x !== b || Da.y !== c) && (e = !0, Da.x = Da.endX = b, va ? Da.endRotation = b : Da.y = Da.endY = c, aa = !0, Va(!0), Da.autoScroll && !Da.isDragging)) for (Z(d.parentNode), f = d, L.scrollTop = null != window.pageYOffset ? window.pageYOffset : null != t.scrollTop ? t.scrollTop : s.body.scrollTop, L.scrollLeft = null != window.pageXOffset ? window.pageXOffset : null != t.scrollLeft ? t.scrollLeft : s.body.scrollLeft; f && !i;) {
						i = X(f.parentNode), h = i ? L : f.parentNode, za && h.scrollTop > h._gsMaxScrollY && (h.scrollTop = h._gsMaxScrollY), ya && h.scrollLeft > h._gsMaxScrollX && (h.scrollLeft = h._gsMaxScrollX), f = h;
					}Da.isThrowing && (e || Da.endX > x || Da.endX < D || Da.endY > G || Da.endY < K) && _a(g.throwProps, e);
				}return Da;
			}, this.update = function (a, b, c) {
				var e = Da.x,
				    f = Da.y;return ab(!b), a ? Da.applyBounds() : (aa && c && Va(!0), Xa(!0)), gb(Da.pointerX, Da.pointerY), aa && Va(!0), Da.isPressed && !b && (ya && Math.abs(e - Da.x) > .01 || za && Math.abs(f - Da.y) > .01 && !va) && bb(), Da.autoScroll && (Z(d.parentNode), Qa = Da.isDragging, Va(!0)), Da.autoScroll && (W(d, ib), V(d, ib)), Da;
			}, this.enable = function (a) {
				var e, j, k;if ("soft" !== a) {
					for (j = Ea.length; --j > -1;) {
						k = Ea[j], Ia(k, "mousedown", eb), Ia(k, "touchstart", eb), Ia(k, "click", jb, !0), va || ba(k, "cursor", g.cursor || "move"), ba(k, "touchCallout", "none"), ba(k, "touchAction", ya === za || i ? "none" : ya ? "pan-y" : "pan-x");
					}Pa(Ea, !1);
				}return V(d, ib), h = !0, f && "soft" !== a && f.track(i || d, ua ? "x,y" : va ? "rotation" : "top,left"), i && i.enable(), d._gsDragID = e = "d" + F++, E[e] = this, i && (i.element._gsDragID = e), b.set(d, { x: "+=0", overwrite: !1 }), oa = { t: d, data: B ? R : d._gsTransform, tween: {}, setRatio: B ? function () {
						b.set(d, O);
					} : c._internals.setTransformRatio || c._internals.set3DTransformRatio }, bb(), Da.update(!0), Da;
			}, this.disable = function (a) {
				var b,
				    c,
				    e = Da.isDragging;if (!va) for (b = Ea.length; --b > -1;) {
					ba(Ea[b], "cursor", null);
				}if ("soft" !== a) {
					for (b = Ea.length; --b > -1;) {
						c = Ea[b], ba(c, "touchCallout", null), ba(c, "touchAction", null), Ja(c, "mousedown", eb), Ja(c, "touchstart", eb), Ja(c, "click", jb);
					}Pa(Ea, !0), ga && (Ja(ga, "touchcancel", hb), Ja(ga, "touchend", hb), Ja(ga, "touchmove", fb)), Ja(s, "mouseup", hb), Ja(s, "mousemove", fb);
				}return W(d, ib), h = !1, f && "soft" !== a && f.untrack(i || d, ua ? "x,y" : va ? "rotation" : "top,left"), i && i.disable(), Q(Va), Da.isDragging = Da.isPressed = fa = !1, e && ia(Da, "dragend", "onDragEnd"), Da;
			}, this.enabled = function (a, b) {
				return arguments.length ? a ? Da.enable(b) : Da.disable(b) : h;
			}, this.kill = function () {
				return Da.isThrowing = !1, b.killTweensOf(i || d, !0, Fa), Da.disable(), delete E[d._gsDragID], Da;
			}, -1 !== ta.indexOf("scroll") && (i = this.scrollProxy = new Ra(d, S({ onKill: function onKill() {
					Da.isPressed && hb(null);
				} }, g)), d.style.overflowY = za && !Ga ? "auto" : "hidden", d.style.overflowX = ya && !Ga ? "auto" : "hidden", d = i.content), g.force3D !== !1 && b.set(d, { force3D: !0 }), va ? Fa.rotation = 1 : (ya && (Fa[wa] = 1), za && (Fa[xa] = 1)), va ? (O = p, R = O.css, O.overwrite = !1) : ua && (O = ya && za ? m : ya ? n : o, R = O.css, O.overwrite = !1), this.enable();
		},
		    Ta = Sa.prototype = new a();Ta.constructor = Sa, Ta.pointerX = Ta.pointerY = 0, Ta.isDragging = Ta.isPressed = !1, Sa.version = "0.14.7", Sa.zIndex = 1e3, Ia(s, "touchcancel", function () {}), Ia(s, "contextmenu", function (a) {
			var b;for (b in E) {
				E[b].isPressed && E[b].endDrag();
			}
		}), Sa.create = function (a, c) {
			"string" == typeof a && (a = b.selector(a));for (var d = a && 0 !== a.length ? Ea(a) ? Fa(a) : [a] : [], e = d.length; --e > -1;) {
				d[e] = new Sa(d[e], c);
			}return d;
		}, Sa.get = function (a) {
			return E[(_(a) || {})._gsDragID];
		}, Sa.timeSinceDrag = function () {
			return (A() - J) / 1e3;
		};var Ua = {},
		    Va = function Va(a) {
			var b,
			    c,
			    d = 0,
			    e = 0;for (a = _(a), b = a.offsetWidth, c = a.offsetHeight; a;) {
				d += a.offsetTop, e += a.offsetLeft, a = a.offsetParent;
			}return { top: d, left: e, width: b, height: c };
		},
		    Wa = function Wa(a, b) {
			if (a === window) return Ua.left = Ua.top = 0, Ua.width = Ua.right = t.clientWidth || a.innerWidth || s.body.clientWidth || 0, Ua.height = Ua.bottom = (a.innerHeight || 0) - 20 < t.clientHeight ? t.clientHeight : a.innerHeight || s.body.clientHeight || 0, Ua;var c = a.pageX !== b ? { left: a.pageX - U(), top: a.pageY - T(), right: a.pageX - U() + 1, bottom: a.pageY - T() + 1 } : a.nodeType || a.left === b || a.top === b ? B ? Va(a) : _(a).getBoundingClientRect() : a;return c.right === b && c.width !== b ? (c.right = c.left + c.width, c.bottom = c.top + c.height) : c.width === b && (c = { width: c.right - c.left, height: c.bottom - c.top, right: c.right, left: c.left, bottom: c.bottom, top: c.top }), c;
		};return Sa.hitTest = function (a, b, c) {
			if (a === b) return !1;var d,
			    e,
			    f,
			    g = Wa(a),
			    h = Wa(b),
			    i = h.left > g.right || h.right < g.left || h.top > g.bottom || h.bottom < g.top;return i || !c ? !i : (f = -1 !== (c + "").indexOf("%"), c = parseFloat(c) || 0, d = { left: Math.max(g.left, h.left), top: Math.max(g.top, h.top) }, d.width = Math.min(g.right, h.right) - d.left, d.height = Math.min(g.bottom, h.bottom) - d.top, d.width < 0 || d.height < 0 ? !1 : f ? (c *= .01, e = d.width * d.height, e >= g.width * g.height * c || e >= h.width * h.height * c) : d.width > c && d.height > c);
		}, C.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;", Sa;
	}, !0);
}), _gsScope._gsDefine && _gsScope._gsQueue.pop()(), function (a) {
	"use strict";
	var b = function b() {
		return (_gsScope.GreenSockGlobals || _gsScope)[a];
	};"function" == typeof define && define.amd ? define(["../TweenLite", "../plugins/CSSPlugin"], b) : "undefined" != typeof module && module.exports && (require("../TweenLite.js"), require("../plugins/CSSPlugin.js"), module.exports = b());
}("Draggable");
/*!
 * ScrollMagic v2.0.6 (2018-10-08)
 * The javascript library for magical scroll interactions.
 * (c) 2018 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.6
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic main library.
 */
/**
 * @namespace ScrollMagic
 */
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(factory);
	} else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
		// CommonJS
		module.exports = factory();
	} else {
		// Browser global
		root.ScrollMagic = factory();
	}
})(this, function () {
	"use strict";

	var ScrollMagic = function ScrollMagic() {
		_util.log(2, '(COMPATIBILITY NOTICE) -> As of ScrollMagic 2.0.0 you need to use \'new ScrollMagic.Controller()\' to create a new controller instance. Use \'new ScrollMagic.Scene()\' to instance a scene.');
	};

	ScrollMagic.version = "2.0.6";

	// TODO: temporary workaround for chrome's scroll jitter bug
	window.addEventListener("mousewheel", function () {});

	// global const
	var PIN_SPACER_ATTRIBUTE = "data-scrollmagic-pin-spacer";

	/**
  * The main class that is needed once per scroll container.
  *
  * @class
  *
  * @example
  * // basic initialization
  * var controller = new ScrollMagic.Controller();
  *
  * // passing options
  * var controller = new ScrollMagic.Controller({container: "#myContainer", loglevel: 3});
  *
  * @param {object} [options] - An object containing one or more options for the controller.
  * @param {(string|object)} [options.container=window] - A selector, DOM object that references the main container for scrolling.
  * @param {boolean} [options.vertical=true] - Sets the scroll mode to vertical (`true`) or horizontal (`false`) scrolling.
  * @param {object} [options.globalSceneOptions={}] - These options will be passed to every Scene that is added to the controller using the addScene method. For more information on Scene options see {@link ScrollMagic.Scene}.
  * @param {number} [options.loglevel=2] Loglevel for debugging. Note that logging is disabled in the minified version of ScrollMagic.
  ** `0` => silent
  ** `1` => errors
  ** `2` => errors, warnings
  ** `3` => errors, warnings, debuginfo
  * @param {boolean} [options.refreshInterval=100] - Some changes don't call events by default, like changing the container size or moving a scene trigger element.  
  This interval polls these parameters to fire the necessary events.  
  If you don't use custom containers, trigger elements or have static layouts, where the positions of the trigger elements don't change, you can set this to 0 disable interval checking and improve performance.
  *
  */
	ScrollMagic.Controller = function (options) {
		/*
  	 * ----------------------------------------------------------------
  	 * settings
  	 * ----------------------------------------------------------------
  	 */
		var NAMESPACE = 'ScrollMagic.Controller',
		    SCROLL_DIRECTION_FORWARD = 'FORWARD',
		    SCROLL_DIRECTION_REVERSE = 'REVERSE',
		    SCROLL_DIRECTION_PAUSED = 'PAUSED',
		    DEFAULT_OPTIONS = CONTROLLER_OPTIONS.defaults;

		/*
  	 * ----------------------------------------------------------------
  	 * private vars
  	 * ----------------------------------------------------------------
  	 */
		var Controller = this,
		    _options = _util.extend({}, DEFAULT_OPTIONS, options),
		    _sceneObjects = [],
		    _updateScenesOnNextCycle = false,

		// can be boolean (true => all scenes) or an array of scenes to be updated
		_scrollPos = 0,
		    _scrollDirection = SCROLL_DIRECTION_PAUSED,
		    _isDocument = true,
		    _viewPortSize = 0,
		    _enabled = true,
		    _updateTimeout,
		    _refreshTimeout;

		/*
  	 * ----------------------------------------------------------------
  	 * private functions
  	 * ----------------------------------------------------------------
  	 */

		/**
   * Internal constructor function of the ScrollMagic Controller
   * @private
   */
		var construct = function construct() {
			for (var key in _options) {
				if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
					log(2, "WARNING: Unknown option \"" + key + "\"");
					delete _options[key];
				}
			}
			_options.container = _util.get.elements(_options.container)[0];
			// check ScrollContainer
			if (!_options.container) {
				log(1, "ERROR creating object " + NAMESPACE + ": No valid scroll container supplied");
				throw NAMESPACE + " init failed."; // cancel
			}
			_isDocument = _options.container === window || _options.container === document.body || !document.body.contains(_options.container);
			// normalize to window
			if (_isDocument) {
				_options.container = window;
			}
			// update container size immediately
			_viewPortSize = getViewportSize();
			// set event handlers
			_options.container.addEventListener("resize", onChange);
			_options.container.addEventListener("scroll", onChange);

			var ri = parseInt(_options.refreshInterval, 10);
			_options.refreshInterval = _util.type.Number(ri) ? ri : DEFAULT_OPTIONS.refreshInterval;
			scheduleRefresh();

			log(3, "added new " + NAMESPACE + " controller (v" + ScrollMagic.version + ")");
		};

		/**
   * Schedule the next execution of the refresh function
   * @private
   */
		var scheduleRefresh = function scheduleRefresh() {
			if (_options.refreshInterval > 0) {
				_refreshTimeout = window.setTimeout(refresh, _options.refreshInterval);
			}
		};

		/**
   * Default function to get scroll pos - overwriteable using `Controller.scrollPos(newFunction)`
   * @private
   */
		var getScrollPos = function getScrollPos() {
			return _options.vertical ? _util.get.scrollTop(_options.container) : _util.get.scrollLeft(_options.container);
		};

		/**
   * Returns the current viewport Size (width vor horizontal, height for vertical)
   * @private
   */
		var getViewportSize = function getViewportSize() {
			return _options.vertical ? _util.get.height(_options.container) : _util.get.width(_options.container);
		};

		/**
   * Default function to set scroll pos - overwriteable using `Controller.scrollTo(newFunction)`
   * Make available publicly for pinned mousewheel workaround.
   * @private
   */
		var setScrollPos = this._setScrollPos = function (pos) {
			if (_options.vertical) {
				if (_isDocument) {
					window.scrollTo(_util.get.scrollLeft(), pos);
				} else {
					_options.container.scrollTop = pos;
				}
			} else {
				if (_isDocument) {
					window.scrollTo(pos, _util.get.scrollTop());
				} else {
					_options.container.scrollLeft = pos;
				}
			}
		};

		/**
   * Handle updates in cycles instead of on scroll (performance)
   * @private
   */
		var updateScenes = function updateScenes() {
			if (_enabled && _updateScenesOnNextCycle) {
				// determine scenes to update
				var scenesToUpdate = _util.type.Array(_updateScenesOnNextCycle) ? _updateScenesOnNextCycle : _sceneObjects.slice(0);
				// reset scenes
				_updateScenesOnNextCycle = false;
				var oldScrollPos = _scrollPos;
				// update scroll pos now instead of onChange, as it might have changed since scheduling (i.e. in-browser smooth scroll)
				_scrollPos = Controller.scrollPos();
				var deltaScroll = _scrollPos - oldScrollPos;
				if (deltaScroll !== 0) {
					// scroll position changed?
					_scrollDirection = deltaScroll > 0 ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_REVERSE;
				}
				// reverse order of scenes if scrolling reverse
				if (_scrollDirection === SCROLL_DIRECTION_REVERSE) {
					scenesToUpdate.reverse();
				}
				// update scenes
				scenesToUpdate.forEach(function (scene, index) {
					log(3, "updating Scene " + (index + 1) + "/" + scenesToUpdate.length + " (" + _sceneObjects.length + " total)");
					scene.update(true);
				});
				if (scenesToUpdate.length === 0 && _options.loglevel >= 3) {
					log(3, "updating 0 Scenes (nothing added to controller)");
				}
			}
		};

		/**
   * Initializes rAF callback
   * @private
   */
		var debounceUpdate = function debounceUpdate() {
			_updateTimeout = _util.rAF(updateScenes);
		};

		/**
   * Handles Container changes
   * @private
   */
		var onChange = function onChange(e) {
			log(3, "event fired causing an update:", e.type);
			if (e.type == "resize") {
				// resize
				_viewPortSize = getViewportSize();
				_scrollDirection = SCROLL_DIRECTION_PAUSED;
			}
			// schedule update
			if (_updateScenesOnNextCycle !== true) {
				_updateScenesOnNextCycle = true;
				debounceUpdate();
			}
		};

		var refresh = function refresh() {
			if (!_isDocument) {
				// simulate resize event. Only works for viewport relevant param (performance)
				if (_viewPortSize != getViewportSize()) {
					var resizeEvent;
					try {
						resizeEvent = new Event('resize', {
							bubbles: false,
							cancelable: false
						});
					} catch (e) {
						// stupid IE
						resizeEvent = document.createEvent("Event");
						resizeEvent.initEvent("resize", false, false);
					}
					_options.container.dispatchEvent(resizeEvent);
				}
			}
			_sceneObjects.forEach(function (scene, index) {
				// refresh all scenes
				scene.refresh();
			});
			scheduleRefresh();
		};

		/**
   * Send a debug message to the console.
   * provided publicly with _log for plugins
   * @private
   *
   * @param {number} loglevel - The loglevel required to initiate output for the message.
   * @param {...mixed} output - One or more variables that should be passed to the console.
   */
		var log = this._log = function (loglevel, output) {
			if (_options.loglevel >= loglevel) {
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
				_util.log.apply(window, arguments);
			}
		};
		// for scenes we have getters for each option, but for the controller we don't, so we need to make it available externally for plugins
		this._options = _options;

		/**
   * Sort scenes in ascending order of their start offset.
   * @private
   *
   * @param {array} ScenesArray - an array of ScrollMagic Scenes that should be sorted
   * @return {array} The sorted array of Scenes.
   */
		var sortScenes = function sortScenes(ScenesArray) {
			if (ScenesArray.length <= 1) {
				return ScenesArray;
			} else {
				var scenes = ScenesArray.slice(0);
				scenes.sort(function (a, b) {
					return a.scrollOffset() > b.scrollOffset() ? 1 : -1;
				});
				return scenes;
			}
		};

		/**
   * ----------------------------------------------------------------
   * public functions
   * ----------------------------------------------------------------
   */

		/**
   * Add one ore more scene(s) to the controller.  
   * This is the equivalent to `Scene.addTo(controller)`.
   * @public
   * @example
   * // with a previously defined scene
   * controller.addScene(scene);
   *
   * // with a newly created scene.
   * controller.addScene(new ScrollMagic.Scene({duration : 0}));
   *
   * // adding multiple scenes
   * controller.addScene([scene, scene2, new ScrollMagic.Scene({duration : 0})]);
   *
   * @param {(ScrollMagic.Scene|array)} newScene - ScrollMagic Scene or Array of Scenes to be added to the controller.
   * @return {Controller} Parent object for chaining.
   */
		this.addScene = function (newScene) {
			if (_util.type.Array(newScene)) {
				newScene.forEach(function (scene, index) {
					Controller.addScene(scene);
				});
			} else if (newScene instanceof ScrollMagic.Scene) {
				if (newScene.controller() !== Controller) {
					newScene.addTo(Controller);
				} else if (_sceneObjects.indexOf(newScene) < 0) {
					// new scene
					_sceneObjects.push(newScene); // add to array
					_sceneObjects = sortScenes(_sceneObjects); // sort
					newScene.on("shift.controller_sort", function () {
						// resort whenever scene moves
						_sceneObjects = sortScenes(_sceneObjects);
					});
					// insert Global defaults.
					for (var key in _options.globalSceneOptions) {
						if (newScene[key]) {
							newScene[key].call(newScene, _options.globalSceneOptions[key]);
						}
					}
					log(3, "adding Scene (now " + _sceneObjects.length + " total)");
				}
			} else {
				log(1, "ERROR: invalid argument supplied for '.addScene()'");
			}
			return Controller;
		};

		/**
   * Remove one ore more scene(s) from the controller.  
   * This is the equivalent to `Scene.remove()`.
   * @public
   * @example
   * // remove a scene from the controller
   * controller.removeScene(scene);
   *
   * // remove multiple scenes from the controller
   * controller.removeScene([scene, scene2, scene3]);
   *
   * @param {(ScrollMagic.Scene|array)} Scene - ScrollMagic Scene or Array of Scenes to be removed from the controller.
   * @returns {Controller} Parent object for chaining.
   */
		this.removeScene = function (Scene) {
			if (_util.type.Array(Scene)) {
				Scene.forEach(function (scene, index) {
					Controller.removeScene(scene);
				});
			} else {
				var index = _sceneObjects.indexOf(Scene);
				if (index > -1) {
					Scene.off("shift.controller_sort");
					_sceneObjects.splice(index, 1);
					log(3, "removing Scene (now " + _sceneObjects.length + " left)");
					Scene.remove();
				}
			}
			return Controller;
		};

		/**
   * Update one ore more scene(s) according to the scroll position of the container.  
   * This is the equivalent to `Scene.update()`.  
   * The update method calculates the scene's start and end position (based on the trigger element, trigger hook, duration and offset) and checks it against the current scroll position of the container.  
   * It then updates the current scene state accordingly (or does nothing, if the state is already correct)  Pins will be set to their correct position and tweens will be updated to their correct progress.  
   * _**Note:** This method gets called constantly whenever Controller detects a change. The only application for you is if you change something outside of the realm of ScrollMagic, like moving the trigger or changing tween parameters._
   * @public
   * @example
   * // update a specific scene on next cycle
   * controller.updateScene(scene);
   *
   * // update a specific scene immediately
   * controller.updateScene(scene, true);
   *
   * // update multiple scenes scene on next cycle
   * controller.updateScene([scene1, scene2, scene3]);
   *
   * @param {ScrollMagic.Scene} Scene - ScrollMagic Scene or Array of Scenes that is/are supposed to be updated.
   * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle.  
   This is useful when changing multiple properties of the scene - this way it will only be updated once all new properties are set (updateScenes).
   * @return {Controller} Parent object for chaining.
   */
		this.updateScene = function (Scene, immediately) {
			if (_util.type.Array(Scene)) {
				Scene.forEach(function (scene, index) {
					Controller.updateScene(scene, immediately);
				});
			} else {
				if (immediately) {
					Scene.update(true);
				} else if (_updateScenesOnNextCycle !== true && Scene instanceof ScrollMagic.Scene) {
					// if _updateScenesOnNextCycle is true, all connected scenes are already scheduled for update
					// prep array for next update cycle
					_updateScenesOnNextCycle = _updateScenesOnNextCycle || [];
					if (_updateScenesOnNextCycle.indexOf(Scene) == -1) {
						_updateScenesOnNextCycle.push(Scene);
					}
					_updateScenesOnNextCycle = sortScenes(_updateScenesOnNextCycle); // sort
					debounceUpdate();
				}
			}
			return Controller;
		};

		/**
   * Updates the controller params and calls updateScene on every scene, that is attached to the controller.  
   * See `Controller.updateScene()` for more information about what this means.  
   * In most cases you will not need this function, as it is called constantly, whenever ScrollMagic detects a state change event, like resize or scroll.  
   * The only application for this method is when ScrollMagic fails to detect these events.  
   * One application is with some external scroll libraries (like iScroll) that move an internal container to a negative offset instead of actually scrolling. In this case the update on the controller needs to be called whenever the child container's position changes.
   * For this case there will also be the need to provide a custom function to calculate the correct scroll position. See `Controller.scrollPos()` for details.
   * @public
   * @example
   * // update the controller on next cycle (saves performance due to elimination of redundant updates)
   * controller.update();
   *
   * // update the controller immediately
   * controller.update(true);
   *
   * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle (better performance)
   * @return {Controller} Parent object for chaining.
   */
		this.update = function (immediately) {
			onChange({
				type: "resize"
			}); // will update size and set _updateScenesOnNextCycle to true
			if (immediately) {
				updateScenes();
			}
			return Controller;
		};

		/**
   * Scroll to a numeric scroll offset, a DOM element, the start of a scene or provide an alternate method for scrolling.  
   * For vertical controllers it will change the top scroll offset and for horizontal applications it will change the left offset.
   * @public
   *
   * @since 1.1.0
   * @example
   * // scroll to an offset of 100
   * controller.scrollTo(100);
   *
   * // scroll to a DOM element
   * controller.scrollTo("#anchor");
   *
   * // scroll to the beginning of a scene
   * var scene = new ScrollMagic.Scene({offset: 200});
   * controller.scrollTo(scene);
   *
   * // define a new scroll position modification function (jQuery animate instead of jump)
   * controller.scrollTo(function (newScrollPos) {
   *	$("html, body").animate({scrollTop: newScrollPos});
   * });
   * controller.scrollTo(100); // call as usual, but the new function will be used instead
   *
   * // define a new scroll function with an additional parameter
   * controller.scrollTo(function (newScrollPos, message) {
   *  console.log(message);
   *	$(this).animate({scrollTop: newScrollPos});
   * });
   * // call as usual, but supply an extra parameter to the defined custom function
   * controller.scrollTo(100, "my message");
   *
   * // define a new scroll function with an additional parameter containing multiple variables
   * controller.scrollTo(function (newScrollPos, options) {
   *  someGlobalVar = options.a + options.b;
   *	$(this).animate({scrollTop: newScrollPos});
   * });
   * // call as usual, but supply an extra parameter containing multiple options
   * controller.scrollTo(100, {a: 1, b: 2});
   *
   * // define a new scroll function with a callback supplied as an additional parameter
   * controller.scrollTo(function (newScrollPos, callback) {
   *	$(this).animate({scrollTop: newScrollPos}, 400, "swing", callback);
   * });
   * // call as usual, but supply an extra parameter, which is used as a callback in the previously defined custom scroll function
   * controller.scrollTo(100, function() {
   *	console.log("scroll has finished.");
   * });
   *
   * @param {mixed} scrollTarget - The supplied argument can be one of these types:
   * 1. `number` -> The container will scroll to this new scroll offset.
   * 2. `string` or `object` -> Can be a selector or a DOM object.  
   *  The container will scroll to the position of this element.
   * 3. `ScrollMagic Scene` -> The container will scroll to the start of this scene.
   * 4. `function` -> This function will be used for future scroll position modifications.  
   *  This provides a way for you to change the behaviour of scrolling and adding new behaviour like animation. The function receives the new scroll position as a parameter and a reference to the container element using `this`.  
   *  It may also optionally receive an optional additional parameter (see below)  
   *  _**NOTE:**  
   *  All other options will still work as expected, using the new function to scroll._
   * @param {mixed} [additionalParameter] - If a custom scroll function was defined (see above 4.), you may want to supply additional parameters to it, when calling it. You can do this using this parameter  see examples for details. Please note, that this parameter will have no effect, if you use the default scrolling function.
   * @returns {Controller} Parent object for chaining.
   */
		this.scrollTo = function (scrollTarget, additionalParameter) {
			if (_util.type.Number(scrollTarget)) {
				// excecute
				setScrollPos.call(_options.container, scrollTarget, additionalParameter);
			} else if (scrollTarget instanceof ScrollMagic.Scene) {
				// scroll to scene
				if (scrollTarget.controller() === Controller) {
					// check if the controller is associated with this scene
					Controller.scrollTo(scrollTarget.scrollOffset(), additionalParameter);
				} else {
					log(2, "scrollTo(): The supplied scene does not belong to this controller. Scroll cancelled.", scrollTarget);
				}
			} else if (_util.type.Function(scrollTarget)) {
				// assign new scroll function
				setScrollPos = scrollTarget;
			} else {
				// scroll to element
				var elem = _util.get.elements(scrollTarget)[0];
				if (elem) {
					// if parent is pin spacer, use spacer position instead so correct start position is returned for pinned elements.
					while (elem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						elem = elem.parentNode;
					}

					var param = _options.vertical ? "top" : "left",

					// which param is of interest ?
					containerOffset = _util.get.offset(_options.container),

					// container position is needed because element offset is returned in relation to document, not in relation to container.
					elementOffset = _util.get.offset(elem);

					if (!_isDocument) {
						// container is not the document root, so substract scroll Position to get correct trigger element position relative to scrollcontent
						containerOffset[param] -= Controller.scrollPos();
					}

					Controller.scrollTo(elementOffset[param] - containerOffset[param], additionalParameter);
				} else {
					log(2, "scrollTo(): The supplied argument is invalid. Scroll cancelled.", scrollTarget);
				}
			}
			return Controller;
		};

		/**
   * **Get** the current scrollPosition or **Set** a new method to calculate it.  
   * -> **GET**:
   * When used as a getter this function will return the current scroll position.  
   * To get a cached value use Controller.info("scrollPos"), which will be updated in the update cycle.  
   * For vertical controllers it will return the top scroll offset and for horizontal applications it will return the left offset.
   *
   * -> **SET**:
   * When used as a setter this method prodes a way to permanently overwrite the controller's scroll position calculation.  
   * A typical usecase is when the scroll position is not reflected by the containers scrollTop or scrollLeft values, but for example by the inner offset of a child container.  
   * Moving a child container inside a parent is a commonly used method for several scrolling frameworks, including iScroll.  
   * By providing an alternate calculation function you can make sure ScrollMagic receives the correct scroll position.  
   * Please also bear in mind that your function should return y values for vertical scrolls an x for horizontals.
   *
   * To change the current scroll position please use `Controller.scrollTo()`.
   * @public
   *
   * @example
   * // get the current scroll Position
   * var scrollPos = controller.scrollPos();
   *
   * // set a new scroll position calculation method
   * controller.scrollPos(function () {
   *	return this.info("vertical") ? -mychildcontainer.y : -mychildcontainer.x
   * });
   *
   * @param {function} [scrollPosMethod] - The function to be used for the scroll position calculation of the container.
   * @returns {(number|Controller)} Current scroll position or parent object for chaining.
   */
		this.scrollPos = function (scrollPosMethod) {
			if (!arguments.length) {
				// get
				return getScrollPos.call(Controller);
			} else {
				// set
				if (_util.type.Function(scrollPosMethod)) {
					getScrollPos = scrollPosMethod;
				} else {
					log(2, "Provided value for method 'scrollPos' is not a function. To change the current scroll position use 'scrollTo()'.");
				}
			}
			return Controller;
		};

		/**
   * **Get** all infos or one in particular about the controller.
   * @public
   * @example
   * // returns the current scroll position (number)
   * var scrollPos = controller.info("scrollPos");
   *
   * // returns all infos as an object
   * var infos = controller.info();
   *
   * @param {string} [about] - If passed only this info will be returned instead of an object containing all.  
   Valid options are:
   ** `"size"` => the current viewport size of the container
   ** `"vertical"` => true if vertical scrolling, otherwise false
   ** `"scrollPos"` => the current scroll position
   ** `"scrollDirection"` => the last known direction of the scroll
   ** `"container"` => the container element
   ** `"isDocument"` => true if container element is the document.
   * @returns {(mixed|object)} The requested info(s).
   */
		this.info = function (about) {
			var values = {
				size: _viewPortSize,
				// contains height or width (in regard to orientation);
				vertical: _options.vertical,
				scrollPos: _scrollPos,
				scrollDirection: _scrollDirection,
				container: _options.container,
				isDocument: _isDocument
			};
			if (!arguments.length) {
				// get all as an object
				return values;
			} else if (values[about] !== undefined) {
				return values[about];
			} else {
				log(1, "ERROR: option \"" + about + "\" is not available");
				return;
			}
		};

		/**
   * **Get** or **Set** the current loglevel option value.
   * @public
   *
   * @example
   * // get the current value
   * var loglevel = controller.loglevel();
   *
   * // set a new value
   * controller.loglevel(3);
   *
   * @param {number} [newLoglevel] - The new loglevel setting of the Controller. `[0-3]`
   * @returns {(number|Controller)} Current loglevel or parent object for chaining.
   */
		this.loglevel = function (newLoglevel) {
			if (!arguments.length) {
				// get
				return _options.loglevel;
			} else if (_options.loglevel != newLoglevel) {
				// set
				_options.loglevel = newLoglevel;
			}
			return Controller;
		};

		/**
   * **Get** or **Set** the current enabled state of the controller.  
   * This can be used to disable all Scenes connected to the controller without destroying or removing them.
   * @public
   *
   * @example
   * // get the current value
   * var enabled = controller.enabled();
   *
   * // disable the controller
   * controller.enabled(false);
   *
   * @param {boolean} [newState] - The new enabled state of the controller `true` or `false`.
   * @returns {(boolean|Controller)} Current enabled state or parent object for chaining.
   */
		this.enabled = function (newState) {
			if (!arguments.length) {
				// get
				return _enabled;
			} else if (_enabled != newState) {
				// set
				_enabled = !!newState;
				Controller.updateScene(_sceneObjects, true);
			}
			return Controller;
		};

		/**
   * Destroy the Controller, all Scenes and everything.
   * @public
   *
   * @example
   * // without resetting the scenes
   * controller = controller.destroy();
   *
   * // with scene reset
   * controller = controller.destroy(true);
   *
   * @param {boolean} [resetScenes=false] - If `true` the pins and tweens (if existent) of all scenes will be reset.
   * @returns {null} Null to unset handler variables.
   */
		this.destroy = function (resetScenes) {
			window.clearTimeout(_refreshTimeout);
			var i = _sceneObjects.length;
			while (i--) {
				_sceneObjects[i].destroy(resetScenes);
			}
			_options.container.removeEventListener("resize", onChange);
			_options.container.removeEventListener("scroll", onChange);
			_util.cAF(_updateTimeout);
			log(3, "destroyed " + NAMESPACE + " (reset: " + (resetScenes ? "true" : "false") + ")");
			return null;
		};

		// INIT
		construct();
		return Controller;
	};

	// store pagewide controller options
	var CONTROLLER_OPTIONS = {
		defaults: {
			container: window,
			vertical: true,
			globalSceneOptions: {},
			loglevel: 2,
			refreshInterval: 100
		}
	};
	/*
  * method used to add an option to ScrollMagic Scenes.
  */
	ScrollMagic.Controller.addOption = function (name, defaultValue) {
		CONTROLLER_OPTIONS.defaults[name] = defaultValue;
	};
	// instance extension function for plugins
	ScrollMagic.Controller.extend = function (extension) {
		var oldClass = this;
		ScrollMagic.Controller = function () {
			oldClass.apply(this, arguments);
			this.$super = _util.extend({}, this); // copy parent state
			return extension.apply(this, arguments) || this;
		};
		_util.extend(ScrollMagic.Controller, oldClass); // copy properties
		ScrollMagic.Controller.prototype = oldClass.prototype; // copy prototype
		ScrollMagic.Controller.prototype.constructor = ScrollMagic.Controller; // restore constructor
	};

	/**
  * A Scene defines where the controller should react and how.
  *
  * @class
  *
  * @example
  * // create a standard scene and add it to a controller
  * new ScrollMagic.Scene()
  *		.addTo(controller);
  *
  * // create a scene with custom options and assign a handler to it.
  * var scene = new ScrollMagic.Scene({
  * 		duration: 100,
  *		offset: 200,
  *		triggerHook: "onEnter",
  *		reverse: false
  * });
  *
  * @param {object} [options] - Options for the Scene. The options can be updated at any time.  
  Instead of setting the options for each scene individually you can also set them globally in the controller as the controllers `globalSceneOptions` option. The object accepts the same properties as the ones below.  
  When a scene is added to the controller the options defined using the Scene constructor will be overwritten by those set in `globalSceneOptions`.
  * @param {(number|function)} [options.duration=0] - The duration of the scene. 
  If `0` tweens will auto-play when reaching the scene start point, pins will be pinned indefinetly starting at the start position.  
  A function retuning the duration value is also supported. Please see `Scene.duration()` for details.
  * @param {number} [options.offset=0] - Offset Value for the Trigger Position. If no triggerElement is defined this will be the scroll distance from the start of the page, after which the scene will start.
  * @param {(string|object)} [options.triggerElement=null] - Selector or DOM object that defines the start of the scene. If undefined the scene will start right at the start of the page (unless an offset is set).
  * @param {(number|string)} [options.triggerHook="onCenter"] - Can be a number between 0 and 1 defining the position of the trigger Hook in relation to the viewport.  
  Can also be defined using a string:
  ** `"onEnter"` => `1`
  ** `"onCenter"` => `0.5`
  ** `"onLeave"` => `0`
  * @param {boolean} [options.reverse=true] - Should the scene reverse, when scrolling up?
  * @param {number} [options.loglevel=2] - Loglevel for debugging. Note that logging is disabled in the minified version of ScrollMagic.
  ** `0` => silent
  ** `1` => errors
  ** `2` => errors, warnings
  ** `3` => errors, warnings, debuginfo
  * 
  */
	ScrollMagic.Scene = function (options) {

		/*
  	 * ----------------------------------------------------------------
  	 * settings
  	 * ----------------------------------------------------------------
  	 */

		var NAMESPACE = 'ScrollMagic.Scene',
		    SCENE_STATE_BEFORE = 'BEFORE',
		    SCENE_STATE_DURING = 'DURING',
		    SCENE_STATE_AFTER = 'AFTER',
		    DEFAULT_OPTIONS = SCENE_OPTIONS.defaults;

		/*
  	 * ----------------------------------------------------------------
  	 * private vars
  	 * ----------------------------------------------------------------
  	 */

		var Scene = this,
		    _options = _util.extend({}, DEFAULT_OPTIONS, options),
		    _state = SCENE_STATE_BEFORE,
		    _progress = 0,
		    _scrollOffset = {
			start: 0,
			end: 0
		},

		// reflects the controllers's scroll position for the start and end of the scene respectively
		_triggerPos = 0,
		    _enabled = true,
		    _durationUpdateMethod,
		    _controller;

		/**
   * Internal constructor function of the ScrollMagic Scene
   * @private
   */
		var construct = function construct() {
			for (var key in _options) {
				// check supplied options
				if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
					log(2, "WARNING: Unknown option \"" + key + "\"");
					delete _options[key];
				}
			}
			// add getters/setters for all possible options
			for (var optionName in DEFAULT_OPTIONS) {
				addSceneOption(optionName);
			}
			// validate all options
			validateOption();
		};

		/*
   * ----------------------------------------------------------------
   * Event Management
   * ----------------------------------------------------------------
   */

		var _listeners = {};
		/**
   * Scene start event.  
   * Fires whenever the scroll position its the starting point of the scene.  
   * It will also fire when scrolling back up going over the start position of the scene. If you want something to happen only when scrolling down/right, use the scrollDirection parameter passed to the callback.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#start
   *
   * @example
   * scene.on("start", function (event) {
   * 	console.log("Hit start point of scene.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"BEFORE"` or `"DURING"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene end event.  
   * Fires whenever the scroll position its the ending point of the scene.  
   * It will also fire when scrolling back up from after the scene and going over its end position. If you want something to happen only when scrolling down/right, use the scrollDirection parameter passed to the callback.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#end
   *
   * @example
   * scene.on("end", function (event) {
   * 	console.log("Hit end point of scene.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"DURING"` or `"AFTER"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene enter event.  
   * Fires whenever the scene enters the "DURING" state.  
   * Keep in mind that it doesn't matter if the scene plays forward or backward: This event always fires when the scene enters its active scroll timeframe, regardless of the scroll-direction.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#enter
   *
   * @example
   * scene.on("enter", function (event) {
   * 	console.log("Scene entered.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene - always `"DURING"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene leave event.  
   * Fires whenever the scene's state goes from "DURING" to either "BEFORE" or "AFTER".  
   * Keep in mind that it doesn't matter if the scene plays forward or backward: This event always fires when the scene leaves its active scroll timeframe, regardless of the scroll-direction.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#leave
   *
   * @example
   * scene.on("leave", function (event) {
   * 	console.log("Scene left.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"BEFORE"` or `"AFTER"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene update event.  
   * Fires whenever the scene is updated (but not necessarily changes the progress).
   *
   * @event ScrollMagic.Scene#update
   *
   * @example
   * scene.on("update", function (event) {
   * 	console.log("Scene updated.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.startPos - The starting position of the scene (in relation to the conainer)
   * @property {number} event.endPos - The ending position of the scene (in relation to the conainer)
   * @property {number} event.scrollPos - The current scroll position of the container
   */
		/**
   * Scene progress event.  
   * Fires whenever the progress of the scene changes.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#progress
   *
   * @example
   * scene.on("progress", function (event) {
   * 	console.log("Scene progress changed to " + event.progress);
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"BEFORE"`, `"DURING"` or `"AFTER"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene change event.  
   * Fires whenvever a property of the scene is changed.
   *
   * @event ScrollMagic.Scene#change
   *
   * @example
   * scene.on("change", function (event) {
   * 	console.log("Scene Property \"" + event.what + "\" changed to " + event.newval);
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {string} event.what - Indicates what value has been changed
   * @property {mixed} event.newval - The new value of the changed property
   */
		/**
   * Scene shift event.  
   * Fires whenvever the start or end **scroll offset** of the scene change.
   * This happens explicitely, when one of these values change: `offset`, `duration` or `triggerHook`.
   * It will fire implicitly when the `triggerElement` changes, if the new element has a different position (most cases).
   * It will also fire implicitly when the size of the container changes and the triggerHook is anything other than `onLeave`.
   *
   * @event ScrollMagic.Scene#shift
   * @since 1.1.0
   *
   * @example
   * scene.on("shift", function (event) {
   * 	console.log("Scene moved, because the " + event.reason + " has changed.)");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {string} event.reason - Indicates why the scene has shifted
   */
		/**
   * Scene destroy event.  
   * Fires whenvever the scene is destroyed.
   * This can be used to tidy up custom behaviour used in events.
   *
   * @event ScrollMagic.Scene#destroy
   * @since 1.1.0
   *
   * @example
   * scene.on("enter", function (event) {
   *        // add custom action
   *        $("#my-elem").left("200");
   *      })
   *      .on("destroy", function (event) {
   *        // reset my element to start position
   *        if (event.reset) {
   *          $("#my-elem").left("0");
   *        }
   *      });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {boolean} event.reset - Indicates if the destroy method was called with reset `true` or `false`.
   */
		/**
   * Scene add event.  
   * Fires when the scene is added to a controller.
   * This is mostly used by plugins to know that change might be due.
   *
   * @event ScrollMagic.Scene#add
   * @since 2.0.0
   *
   * @example
   * scene.on("add", function (event) {
   * 	console.log('Scene was added to a new controller.');
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {boolean} event.controller - The controller object the scene was added to.
   */
		/**
   * Scene remove event.  
   * Fires when the scene is removed from a controller.
   * This is mostly used by plugins to know that change might be due.
   *
   * @event ScrollMagic.Scene#remove
   * @since 2.0.0
   *
   * @example
   * scene.on("remove", function (event) {
   * 	console.log('Scene was removed from its controller.');
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   */

		/**
   * Add one ore more event listener.  
   * The callback function will be fired at the respective event, and an object containing relevant data will be passed to the callback.
   * @method ScrollMagic.Scene#on
   *
   * @example
   * function callback (event) {
   * 		console.log("Event fired! (" + event.type + ")");
   * }
   * // add listeners
   * scene.on("change update progress start end enter leave", callback);
   *
   * @param {string} names - The name or names of the event the callback should be attached to.
   * @param {function} callback - A function that should be executed, when the event is dispatched. An event object will be passed to the callback.
   * @returns {Scene} Parent object for chaining.
   */
		this.on = function (names, callback) {
			if (_util.type.Function(callback)) {
				names = names.trim().split(' ');
				names.forEach(function (fullname) {
					var nameparts = fullname.split('.'),
					    eventname = nameparts[0],
					    namespace = nameparts[1];
					if (eventname != "*") {
						// disallow wildcards
						if (!_listeners[eventname]) {
							_listeners[eventname] = [];
						}
						_listeners[eventname].push({
							namespace: namespace || '',
							callback: callback
						});
					}
				});
			} else {
				log(1, "ERROR when calling '.on()': Supplied callback for '" + names + "' is not a valid function!");
			}
			return Scene;
		};

		/**
   * Remove one or more event listener.
   * @method ScrollMagic.Scene#off
   *
   * @example
   * function callback (event) {
   * 		console.log("Event fired! (" + event.type + ")");
   * }
   * // add listeners
   * scene.on("change update", callback);
   * // remove listeners
   * scene.off("change update", callback);
   *
   * @param {string} names - The name or names of the event that should be removed.
   * @param {function} [callback] - A specific callback function that should be removed. If none is passed all callbacks to the event listener will be removed.
   * @returns {Scene} Parent object for chaining.
   */
		this.off = function (names, callback) {
			if (!names) {
				log(1, "ERROR: Invalid event name supplied.");
				return Scene;
			}
			names = names.trim().split(' ');
			names.forEach(function (fullname, key) {
				var nameparts = fullname.split('.'),
				    eventname = nameparts[0],
				    namespace = nameparts[1] || '',
				    removeList = eventname === '*' ? Object.keys(_listeners) : [eventname];
				removeList.forEach(function (remove) {
					var list = _listeners[remove] || [],
					    i = list.length;
					while (i--) {
						var listener = list[i];
						if (listener && (namespace === listener.namespace || namespace === '*') && (!callback || callback == listener.callback)) {
							list.splice(i, 1);
						}
					}
					if (!list.length) {
						delete _listeners[remove];
					}
				});
			});
			return Scene;
		};

		/**
   * Trigger an event.
   * @method ScrollMagic.Scene#trigger
   *
   * @example
   * this.trigger("change");
   *
   * @param {string} name - The name of the event that should be triggered.
   * @param {object} [vars] - An object containing info that should be passed to the callback.
   * @returns {Scene} Parent object for chaining.
   */
		this.trigger = function (name, vars) {
			if (name) {
				var nameparts = name.trim().split('.'),
				    eventname = nameparts[0],
				    namespace = nameparts[1],
				    listeners = _listeners[eventname];
				log(3, 'event fired:', eventname, vars ? "->" : '', vars || '');
				if (listeners) {
					listeners.forEach(function (listener, key) {
						if (!namespace || namespace === listener.namespace) {
							listener.callback.call(Scene, new ScrollMagic.Event(eventname, listener.namespace, Scene, vars));
						}
					});
				}
			} else {
				log(1, "ERROR: Invalid event name supplied.");
			}
			return Scene;
		};

		// set event listeners
		Scene.on("change.internal", function (e) {
			if (e.what !== "loglevel" && e.what !== "tweenChanges") {
				// no need for a scene update scene with these options...
				if (e.what === "triggerElement") {
					updateTriggerElementPosition();
				} else if (e.what === "reverse") {
					// the only property left that may have an impact on the current scene state. Everything else is handled by the shift event.
					Scene.update();
				}
			}
		}).on("shift.internal", function (e) {
			updateScrollOffset();
			Scene.update(); // update scene to reflect new position
		});

		/**
   * Send a debug message to the console.
   * @private
   * but provided publicly with _log for plugins
   *
   * @param {number} loglevel - The loglevel required to initiate output for the message.
   * @param {...mixed} output - One or more variables that should be passed to the console.
   */
		var log = this._log = function (loglevel, output) {
			if (_options.loglevel >= loglevel) {
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
				_util.log.apply(window, arguments);
			}
		};

		/**
   * Add the scene to a controller.  
   * This is the equivalent to `Controller.addScene(scene)`.
   * @method ScrollMagic.Scene#addTo
   *
   * @example
   * // add a scene to a ScrollMagic Controller
   * scene.addTo(controller);
   *
   * @param {ScrollMagic.Controller} controller - The controller to which the scene should be added.
   * @returns {Scene} Parent object for chaining.
   */
		this.addTo = function (controller) {
			if (!(controller instanceof ScrollMagic.Controller)) {
				log(1, "ERROR: supplied argument of 'addTo()' is not a valid ScrollMagic Controller");
			} else if (_controller != controller) {
				// new controller
				if (_controller) {
					// was associated to a different controller before, so remove it...
					_controller.removeScene(Scene);
				}
				_controller = controller;
				validateOption();
				updateDuration(true);
				updateTriggerElementPosition(true);
				updateScrollOffset();
				_controller.info("container").addEventListener('resize', onContainerResize);
				controller.addScene(Scene);
				Scene.trigger("add", {
					controller: _controller
				});
				log(3, "added " + NAMESPACE + " to controller");
				Scene.update();
			}
			return Scene;
		};

		/**
   * **Get** or **Set** the current enabled state of the scene.  
   * This can be used to disable this scene without removing or destroying it.
   * @method ScrollMagic.Scene#enabled
   *
   * @example
   * // get the current value
   * var enabled = scene.enabled();
   *
   * // disable the scene
   * scene.enabled(false);
   *
   * @param {boolean} [newState] - The new enabled state of the scene `true` or `false`.
   * @returns {(boolean|Scene)} Current enabled state or parent object for chaining.
   */
		this.enabled = function (newState) {
			if (!arguments.length) {
				// get
				return _enabled;
			} else if (_enabled != newState) {
				// set
				_enabled = !!newState;
				Scene.update(true);
			}
			return Scene;
		};

		/**
   * Remove the scene from the controller.  
   * This is the equivalent to `Controller.removeScene(scene)`.
   * The scene will not be updated anymore until you readd it to a controller.
   * To remove the pin or the tween you need to call removeTween() or removePin() respectively.
   * @method ScrollMagic.Scene#remove
   * @example
   * // remove the scene from its controller
   * scene.remove();
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.remove = function () {
			if (_controller) {
				_controller.info("container").removeEventListener('resize', onContainerResize);
				var tmpParent = _controller;
				_controller = undefined;
				tmpParent.removeScene(Scene);
				Scene.trigger("remove");
				log(3, "removed " + NAMESPACE + " from controller");
			}
			return Scene;
		};

		/**
   * Destroy the scene and everything.
   * @method ScrollMagic.Scene#destroy
   * @example
   * // destroy the scene without resetting the pin and tween to their initial positions
   * scene = scene.destroy();
   *
   * // destroy the scene and reset the pin and tween
   * scene = scene.destroy(true);
   *
   * @param {boolean} [reset=false] - If `true` the pin and tween (if existent) will be reset.
   * @returns {null} Null to unset handler variables.
   */
		this.destroy = function (reset) {
			Scene.trigger("destroy", {
				reset: reset
			});
			Scene.remove();
			Scene.off("*.*");
			log(3, "destroyed " + NAMESPACE + " (reset: " + (reset ? "true" : "false") + ")");
			return null;
		};

		/**
   * Updates the Scene to reflect the current state.  
   * This is the equivalent to `Controller.updateScene(scene, immediately)`.  
   * The update method calculates the scene's start and end position (based on the trigger element, trigger hook, duration and offset) and checks it against the current scroll position of the container.  
   * It then updates the current scene state accordingly (or does nothing, if the state is already correct)  Pins will be set to their correct position and tweens will be updated to their correct progress.
   * This means an update doesn't necessarily result in a progress change. The `progress` event will be fired if the progress has indeed changed between this update and the last.  
   * _**NOTE:** This method gets called constantly whenever ScrollMagic detects a change. The only application for you is if you change something outside of the realm of ScrollMagic, like moving the trigger or changing tween parameters._
   * @method ScrollMagic.Scene#update
   * @example
   * // update the scene on next tick
   * scene.update();
   *
   * // update the scene immediately
   * scene.update(true);
   *
   * @fires Scene.update
   *
   * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle (better performance).
   * @returns {Scene} Parent object for chaining.
   */
		this.update = function (immediately) {
			if (_controller) {
				if (immediately) {
					if (_controller.enabled() && _enabled) {
						var scrollPos = _controller.info("scrollPos"),
						    newProgress;

						if (_options.duration > 0) {
							newProgress = (scrollPos - _scrollOffset.start) / (_scrollOffset.end - _scrollOffset.start);
						} else {
							newProgress = scrollPos >= _scrollOffset.start ? 1 : 0;
						}

						Scene.trigger("update", {
							startPos: _scrollOffset.start,
							endPos: _scrollOffset.end,
							scrollPos: scrollPos
						});

						Scene.progress(newProgress);
					} else if (_pin && _state === SCENE_STATE_DURING) {
						updatePinState(true); // unpin in position
					}
				} else {
					_controller.updateScene(Scene, false);
				}
			}
			return Scene;
		};

		/**
   * Updates dynamic scene variables like the trigger element position or the duration.
   * This method is automatically called in regular intervals from the controller. See {@link ScrollMagic.Controller} option `refreshInterval`.
   * 
   * You can call it to minimize lag, for example when you intentionally change the position of the triggerElement.
   * If you don't it will simply be updated in the next refresh interval of the container, which is usually sufficient.
   *
   * @method ScrollMagic.Scene#refresh
   * @since 1.1.0
   * @example
   * scene = new ScrollMagic.Scene({triggerElement: "#trigger"});
   * 
   * // change the position of the trigger
   * $("#trigger").css("top", 500);
   * // immediately let the scene know of this change
   * scene.refresh();
   *
   * @fires {@link Scene.shift}, if the trigger element position or the duration changed
   * @fires {@link Scene.change}, if the duration changed
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.refresh = function () {
			updateDuration();
			updateTriggerElementPosition();
			// update trigger element position
			return Scene;
		};

		/**
   * **Get** or **Set** the scene's progress.  
   * Usually it shouldn't be necessary to use this as a setter, as it is set automatically by scene.update().  
   * The order in which the events are fired depends on the duration of the scene:
   *  1. Scenes with `duration == 0`:  
   *  Scenes that have no duration by definition have no ending. Thus the `end` event will never be fired.  
   *  When the trigger position of the scene is passed the events are always fired in this order:  
   *  `enter`, `start`, `progress` when scrolling forward  
   *  and  
   *  `progress`, `start`, `leave` when scrolling in reverse
   *  2. Scenes with `duration > 0`:  
   *  Scenes with a set duration have a defined start and end point.  
   *  When scrolling past the start position of the scene it will fire these events in this order:  
   *  `enter`, `start`, `progress`  
   *  When continuing to scroll and passing the end point it will fire these events:  
   *  `progress`, `end`, `leave`  
   *  When reversing through the end point these events are fired:  
   *  `enter`, `end`, `progress`  
   *  And when continuing to scroll past the start position in reverse it will fire:  
   *  `progress`, `start`, `leave`  
   *  In between start and end the `progress` event will be called constantly, whenever the progress changes.
   * 
   * In short:  
   * `enter` events will always trigger **before** the progress update and `leave` envents will trigger **after** the progress update.  
   * `start` and `end` will always trigger at their respective position.
   * 
   * Please review the event descriptions for details on the events and the event object that is passed to the callback.
   * 
   * @method ScrollMagic.Scene#progress
   * @example
   * // get the current scene progress
   * var progress = scene.progress();
   *
   * // set new scene progress
   * scene.progress(0.3);
   *
   * @fires {@link Scene.enter}, when used as setter
   * @fires {@link Scene.start}, when used as setter
   * @fires {@link Scene.progress}, when used as setter
   * @fires {@link Scene.end}, when used as setter
   * @fires {@link Scene.leave}, when used as setter
   *
   * @param {number} [progress] - The new progress value of the scene `[0-1]`.
   * @returns {number} `get` -  Current scene progress.
   * @returns {Scene} `set` -  Parent object for chaining.
   */
		this.progress = function (progress) {
			if (!arguments.length) {
				// get
				return _progress;
			} else {
				// set
				var doUpdate = false,
				    oldState = _state,
				    scrollDirection = _controller ? _controller.info("scrollDirection") : 'PAUSED',
				    reverseOrForward = _options.reverse || progress >= _progress;
				if (_options.duration === 0) {
					// zero duration scenes
					doUpdate = _progress != progress;
					_progress = progress < 1 && reverseOrForward ? 0 : 1;
					_state = _progress === 0 ? SCENE_STATE_BEFORE : SCENE_STATE_DURING;
				} else {
					// scenes with start and end
					if (progress < 0 && _state !== SCENE_STATE_BEFORE && reverseOrForward) {
						// go back to initial state
						_progress = 0;
						_state = SCENE_STATE_BEFORE;
						doUpdate = true;
					} else if (progress >= 0 && progress < 1 && reverseOrForward) {
						_progress = progress;
						_state = SCENE_STATE_DURING;
						doUpdate = true;
					} else if (progress >= 1 && _state !== SCENE_STATE_AFTER) {
						_progress = 1;
						_state = SCENE_STATE_AFTER;
						doUpdate = true;
					} else if (_state === SCENE_STATE_DURING && !reverseOrForward) {
						updatePinState(); // in case we scrolled backwards mid-scene and reverse is disabled => update the pin position, so it doesn't move back as well.
					}
				}
				if (doUpdate) {
					// fire events
					var eventVars = {
						progress: _progress,
						state: _state,
						scrollDirection: scrollDirection
					},
					    stateChanged = _state != oldState;

					var trigger = function trigger(eventName) {
						// tmp helper to simplify code
						Scene.trigger(eventName, eventVars);
					};

					if (stateChanged) {
						// enter events
						if (oldState !== SCENE_STATE_DURING) {
							trigger("enter");
							trigger(oldState === SCENE_STATE_BEFORE ? "start" : "end");
						}
					}
					trigger("progress");
					if (stateChanged) {
						// leave events
						if (_state !== SCENE_STATE_DURING) {
							trigger(_state === SCENE_STATE_BEFORE ? "start" : "end");
							trigger("leave");
						}
					}
				}

				return Scene;
			}
		};

		/**
   * Update the start and end scrollOffset of the container.
   * The positions reflect what the controller's scroll position will be at the start and end respectively.
   * Is called, when:
   *   - Scene event "change" is called with: offset, triggerHook, duration 
   *   - scroll container event "resize" is called
   *   - the position of the triggerElement changes
   *   - the controller changes -> addTo()
   * @private
   */
		var updateScrollOffset = function updateScrollOffset() {
			_scrollOffset = {
				start: _triggerPos + _options.offset
			};
			if (_controller && _options.triggerElement) {
				// take away triggerHook portion to get relative to top
				_scrollOffset.start -= _controller.info("size") * _options.triggerHook;
			}
			_scrollOffset.end = _scrollOffset.start + _options.duration;
		};

		/**
   * Updates the duration if set to a dynamic function.
   * This method is called when the scene is added to a controller and in regular intervals from the controller through scene.refresh().
   * 
   * @fires {@link Scene.change}, if the duration changed
   * @fires {@link Scene.shift}, if the duration changed
   *
   * @param {boolean} [suppressEvents=false] - If true the shift event will be suppressed.
   * @private
   */
		var updateDuration = function updateDuration(suppressEvents) {
			// update duration
			if (_durationUpdateMethod) {
				var varname = "duration";
				if (changeOption(varname, _durationUpdateMethod.call(Scene)) && !suppressEvents) {
					// set
					Scene.trigger("change", {
						what: varname,
						newval: _options[varname]
					});
					Scene.trigger("shift", {
						reason: varname
					});
				}
			}
		};

		/**
   * Updates the position of the triggerElement, if present.
   * This method is called ...
   *  - ... when the triggerElement is changed
   *  - ... when the scene is added to a (new) controller
   *  - ... in regular intervals from the controller through scene.refresh().
   * 
   * @fires {@link Scene.shift}, if the position changed
   *
   * @param {boolean} [suppressEvents=false] - If true the shift event will be suppressed.
   * @private
   */
		var updateTriggerElementPosition = function updateTriggerElementPosition(suppressEvents) {
			var elementPos = 0,
			    telem = _options.triggerElement;
			if (_controller && (telem || _triggerPos > 0)) {
				// either an element exists or was removed and the triggerPos is still > 0
				if (telem) {
					// there currently a triggerElement set
					if (telem.parentNode) {
						// check if element is still attached to DOM
						var controllerInfo = _controller.info(),
						    containerOffset = _util.get.offset(controllerInfo.container),

						// container position is needed because element offset is returned in relation to document, not in relation to container.
						param = controllerInfo.vertical ? "top" : "left"; // which param is of interest ?
						// if parent is spacer, use spacer position instead so correct start position is returned for pinned elements.
						while (telem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
							telem = telem.parentNode;
						}

						var elementOffset = _util.get.offset(telem);

						if (!controllerInfo.isDocument) {
							// container is not the document root, so substract scroll Position to get correct trigger element position relative to scrollcontent
							containerOffset[param] -= _controller.scrollPos();
						}

						elementPos = elementOffset[param] - containerOffset[param];
					} else {
						// there was an element, but it was removed from DOM
						log(2, "WARNING: triggerElement was removed from DOM and will be reset to", undefined);
						Scene.triggerElement(undefined); // unset, so a change event is triggered
					}
				}

				var changed = elementPos != _triggerPos;
				_triggerPos = elementPos;
				if (changed && !suppressEvents) {
					Scene.trigger("shift", {
						reason: "triggerElementPosition"
					});
				}
			}
		};

		/**
   * Trigger a shift event, when the container is resized and the triggerHook is > 1.
   * @private
   */
		var onContainerResize = function onContainerResize(e) {
			if (_options.triggerHook > 0) {
				Scene.trigger("shift", {
					reason: "containerResize"
				});
			}
		};

		var _validate = _util.extend(SCENE_OPTIONS.validate, {
			// validation for duration handled internally for reference to private var _durationMethod
			duration: function duration(val) {
				if (_util.type.String(val) && val.match(/^(\.|\d)*\d+%$/)) {
					// percentage value
					var perc = parseFloat(val) / 100;
					val = function val() {
						return _controller ? _controller.info("size") * perc : 0;
					};
				}
				if (_util.type.Function(val)) {
					// function
					_durationUpdateMethod = val;
					try {
						val = parseFloat(_durationUpdateMethod());
					} catch (e) {
						val = -1; // will cause error below
					}
				}
				// val has to be float
				val = parseFloat(val);
				if (!_util.type.Number(val) || val < 0) {
					if (_durationUpdateMethod) {
						_durationUpdateMethod = undefined;
						throw ["Invalid return value of supplied function for option \"duration\":", val];
					} else {
						throw ["Invalid value for option \"duration\":", val];
					}
				}
				return val;
			}
		});

		/**
   * Checks the validity of a specific or all options and reset to default if neccessary.
   * @private
   */
		var validateOption = function validateOption(check) {
			check = arguments.length ? [check] : Object.keys(_validate);
			check.forEach(function (optionName, key) {
				var value;
				if (_validate[optionName]) {
					// there is a validation method for this option
					try {
						// validate value
						value = _validate[optionName](_options[optionName]);
					} catch (e) {
						// validation failed -> reset to default
						value = DEFAULT_OPTIONS[optionName];
						var logMSG = _util.type.String(e) ? [e] : e;
						if (_util.type.Array(logMSG)) {
							logMSG[0] = "ERROR: " + logMSG[0];
							logMSG.unshift(1); // loglevel 1 for error msg
							log.apply(this, logMSG);
						} else {
							log(1, "ERROR: Problem executing validation callback for option '" + optionName + "':", e.message);
						}
					} finally {
						_options[optionName] = value;
					}
				}
			});
		};

		/**
   * Helper used by the setter/getters for scene options
   * @private
   */
		var changeOption = function changeOption(varname, newval) {
			var changed = false,
			    oldval = _options[varname];
			if (_options[varname] != newval) {
				_options[varname] = newval;
				validateOption(varname); // resets to default if necessary
				changed = oldval != _options[varname];
			}
			return changed;
		};

		// generate getters/setters for all options
		var addSceneOption = function addSceneOption(optionName) {
			if (!Scene[optionName]) {
				Scene[optionName] = function (newVal) {
					if (!arguments.length) {
						// get
						return _options[optionName];
					} else {
						if (optionName === "duration") {
							// new duration is set, so any previously set function must be unset
							_durationUpdateMethod = undefined;
						}
						if (changeOption(optionName, newVal)) {
							// set
							Scene.trigger("change", {
								what: optionName,
								newval: _options[optionName]
							});
							if (SCENE_OPTIONS.shifts.indexOf(optionName) > -1) {
								Scene.trigger("shift", {
									reason: optionName
								});
							}
						}
					}
					return Scene;
				};
			}
		};

		/**
   * **Get** or **Set** the duration option value.
   * As a setter it also accepts a function returning a numeric value.  
   * This is particularly useful for responsive setups.
   *
   * The duration is updated using the supplied function every time `Scene.refresh()` is called, which happens periodically from the controller (see ScrollMagic.Controller option `refreshInterval`).  
   * _**NOTE:** Be aware that it's an easy way to kill performance, if you supply a function that has high CPU demand.  
   * Even for size and position calculations it is recommended to use a variable to cache the value. (see example)  
   * This counts double if you use the same function for multiple scenes._
   *
   * @method ScrollMagic.Scene#duration
   * @example
   * // get the current duration value
   * var duration = scene.duration();
   *
   * // set a new duration
   * scene.duration(300);
   *
   * // use a function to automatically adjust the duration to the window height.
   * var durationValueCache;
   * function getDuration () {
   *   return durationValueCache;
   * }
   * function updateDuration (e) {
   *   durationValueCache = window.innerHeight;
   * }
   * $(window).on("resize", updateDuration); // update the duration when the window size changes
   * $(window).triggerHandler("resize"); // set to initial value
   * scene.duration(getDuration); // supply duration method
   *
   * @fires {@link Scene.change}, when used as setter
   * @fires {@link Scene.shift}, when used as setter
   * @param {(number|function)} [newDuration] - The new duration of the scene.
   * @returns {number} `get` -  Current scene duration.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the offset option value.
   * @method ScrollMagic.Scene#offset
   * @example
   * // get the current offset
   * var offset = scene.offset();
   *
   * // set a new offset
   * scene.offset(100);
   *
   * @fires {@link Scene.change}, when used as setter
   * @fires {@link Scene.shift}, when used as setter
   * @param {number} [newOffset] - The new offset of the scene.
   * @returns {number} `get` -  Current scene offset.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the triggerElement option value.
   * Does **not** fire `Scene.shift`, because changing the trigger Element doesn't necessarily mean the start position changes. This will be determined in `Scene.refresh()`, which is automatically triggered.
   * @method ScrollMagic.Scene#triggerElement
   * @example
   * // get the current triggerElement
   * var triggerElement = scene.triggerElement();
   *
   * // set a new triggerElement using a selector
   * scene.triggerElement("#trigger");
   * // set a new triggerElement using a DOM object
   * scene.triggerElement(document.getElementById("trigger"));
   *
   * @fires {@link Scene.change}, when used as setter
   * @param {(string|object)} [newTriggerElement] - The new trigger element for the scene.
   * @returns {(string|object)} `get` -  Current triggerElement.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the triggerHook option value.
   * @method ScrollMagic.Scene#triggerHook
   * @example
   * // get the current triggerHook value
   * var triggerHook = scene.triggerHook();
   *
   * // set a new triggerHook using a string
   * scene.triggerHook("onLeave");
   * // set a new triggerHook using a number
   * scene.triggerHook(0.7);
   *
   * @fires {@link Scene.change}, when used as setter
   * @fires {@link Scene.shift}, when used as setter
   * @param {(number|string)} [newTriggerHook] - The new triggerHook of the scene. See {@link Scene} parameter description for value options.
   * @returns {number} `get` -  Current triggerHook (ALWAYS numerical).
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the reverse option value.
   * @method ScrollMagic.Scene#reverse
   * @example
   * // get the current reverse option
   * var reverse = scene.reverse();
   *
   * // set new reverse option
   * scene.reverse(false);
   *
   * @fires {@link Scene.change}, when used as setter
   * @param {boolean} [newReverse] - The new reverse setting of the scene.
   * @returns {boolean} `get` -  Current reverse option value.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the loglevel option value.
   * @method ScrollMagic.Scene#loglevel
   * @example
   * // get the current loglevel
   * var loglevel = scene.loglevel();
   *
   * // set new loglevel
   * scene.loglevel(3);
   *
   * @fires {@link Scene.change}, when used as setter
   * @param {number} [newLoglevel] - The new loglevel setting of the scene. `[0-3]`
   * @returns {number} `get` -  Current loglevel.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** the associated controller.
   * @method ScrollMagic.Scene#controller
   * @example
   * // get the controller of a scene
   * var controller = scene.controller();
   *
   * @returns {ScrollMagic.Controller} Parent controller or `undefined`
   */
		this.controller = function () {
			return _controller;
		};

		/**
   * **Get** the current state.
   * @method ScrollMagic.Scene#state
   * @example
   * // get the current state
   * var state = scene.state();
   *
   * @returns {string} `"BEFORE"`, `"DURING"` or `"AFTER"`
   */
		this.state = function () {
			return _state;
		};

		/**
   * **Get** the current scroll offset for the start of the scene.  
   * Mind, that the scrollOffset is related to the size of the container, if `triggerHook` is bigger than `0` (or `"onLeave"`).  
   * This means, that resizing the container or changing the `triggerHook` will influence the scene's start offset.
   * @method ScrollMagic.Scene#scrollOffset
   * @example
   * // get the current scroll offset for the start and end of the scene.
   * var start = scene.scrollOffset();
   * var end = scene.scrollOffset() + scene.duration();
   * console.log("the scene starts at", start, "and ends at", end);
   *
   * @returns {number} The scroll offset (of the container) at which the scene will trigger. Y value for vertical and X value for horizontal scrolls.
   */
		this.scrollOffset = function () {
			return _scrollOffset.start;
		};

		/**
   * **Get** the trigger position of the scene (including the value of the `offset` option).  
   * @method ScrollMagic.Scene#triggerPosition
   * @example
   * // get the scene's trigger position
   * var triggerPosition = scene.triggerPosition();
   *
   * @returns {number} Start position of the scene. Top position value for vertical and left position value for horizontal scrolls.
   */
		this.triggerPosition = function () {
			var pos = _options.offset; // the offset is the basis
			if (_controller) {
				// get the trigger position
				if (_options.triggerElement) {
					// Element as trigger
					pos += _triggerPos;
				} else {
					// return the height of the triggerHook to start at the beginning
					pos += _controller.info("size") * Scene.triggerHook();
				}
			}
			return pos;
		};

		var _pin, _pinOptions;

		Scene.on("shift.internal", function (e) {
			var durationChanged = e.reason === "duration";
			if (_state === SCENE_STATE_AFTER && durationChanged || _state === SCENE_STATE_DURING && _options.duration === 0) {
				// if [duration changed after a scene (inside scene progress updates pin position)] or [duration is 0, we are in pin phase and some other value changed].
				updatePinState();
			}
			if (durationChanged) {
				updatePinDimensions();
			}
		}).on("progress.internal", function (e) {
			updatePinState();
		}).on("add.internal", function (e) {
			updatePinDimensions();
		}).on("destroy.internal", function (e) {
			Scene.removePin(e.reset);
		});
		/**
   * Update the pin state.
   * @private
   */
		var updatePinState = function updatePinState(forceUnpin) {
			if (_pin && _controller) {
				var containerInfo = _controller.info(),
				    pinTarget = _pinOptions.spacer.firstChild; // may be pin element or another spacer, if cascading pins
				if (!forceUnpin && _state === SCENE_STATE_DURING) {
					// during scene or if duration is 0 and we are past the trigger
					// pinned state
					if (_util.css(pinTarget, "position") != "fixed") {
						// change state before updating pin spacer (position changes due to fixed collapsing might occur.)
						_util.css(pinTarget, {
							"position": "fixed"
						});
						// update pin spacer
						updatePinDimensions();
					}

					var fixedPos = _util.get.offset(_pinOptions.spacer, true),

					// get viewport position of spacer
					scrollDistance = _options.reverse || _options.duration === 0 ? containerInfo.scrollPos - _scrollOffset.start // quicker
					: Math.round(_progress * _options.duration * 10) / 10; // if no reverse and during pin the position needs to be recalculated using the progress
					// add scrollDistance
					fixedPos[containerInfo.vertical ? "top" : "left"] += scrollDistance;

					// set new values
					_util.css(_pinOptions.spacer.firstChild, {
						top: fixedPos.top,
						left: fixedPos.left
					});
				} else {
					// unpinned state
					var newCSS = {
						position: _pinOptions.inFlow ? "relative" : "absolute",
						top: 0,
						left: 0
					},
					    change = _util.css(pinTarget, "position") != newCSS.position;

					if (!_pinOptions.pushFollowers) {
						newCSS[containerInfo.vertical ? "top" : "left"] = _options.duration * _progress;
					} else if (_options.duration > 0) {
						// only concerns scenes with duration
						if (_state === SCENE_STATE_AFTER && parseFloat(_util.css(_pinOptions.spacer, "padding-top")) === 0) {
							change = true; // if in after state but havent updated spacer yet (jumped past pin)
						} else if (_state === SCENE_STATE_BEFORE && parseFloat(_util.css(_pinOptions.spacer, "padding-bottom")) === 0) {
							// before
							change = true; // jumped past fixed state upward direction
						}
					}
					// set new values
					_util.css(pinTarget, newCSS);
					if (change) {
						// update pin spacer if state changed
						updatePinDimensions();
					}
				}
			}
		};

		/**
   * Update the pin spacer and/or element size.
   * The size of the spacer needs to be updated whenever the duration of the scene changes, if it is to push down following elements.
   * @private
   */
		var updatePinDimensions = function updatePinDimensions() {
			if (_pin && _controller && _pinOptions.inFlow) {
				// no spacerresize, if original position is absolute
				var after = _state === SCENE_STATE_AFTER,
				    before = _state === SCENE_STATE_BEFORE,
				    during = _state === SCENE_STATE_DURING,
				    vertical = _controller.info("vertical"),
				    pinTarget = _pinOptions.spacer.firstChild,

				// usually the pined element but can also be another spacer (cascaded pins)
				marginCollapse = _util.isMarginCollapseType(_util.css(_pinOptions.spacer, "display")),
				    css = {};

				// set new size
				// if relsize: spacer -> pin | else: pin -> spacer
				if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
					if (during) {
						_util.css(_pin, {
							"width": _util.get.width(_pinOptions.spacer)
						});
					} else {
						_util.css(_pin, {
							"width": "100%"
						});
					}
				} else {
					// minwidth is needed for cascaded pins.
					css["min-width"] = _util.get.width(vertical ? _pin : pinTarget, true, true);
					css.width = during ? css["min-width"] : "auto";
				}
				if (_pinOptions.relSize.height) {
					if (during) {
						// the only padding the spacer should ever include is the duration (if pushFollowers = true), so we need to substract that.
						_util.css(_pin, {
							"height": _util.get.height(_pinOptions.spacer) - (_pinOptions.pushFollowers ? _options.duration : 0)
						});
					} else {
						_util.css(_pin, {
							"height": "100%"
						});
					}
				} else {
					// margin is only included if it's a cascaded pin to resolve an IE9 bug
					css["min-height"] = _util.get.height(vertical ? pinTarget : _pin, true, !marginCollapse); // needed for cascading pins
					css.height = during ? css["min-height"] : "auto";
				}

				// add space for duration if pushFollowers is true
				if (_pinOptions.pushFollowers) {
					css["padding" + (vertical ? "Top" : "Left")] = _options.duration * _progress;
					css["padding" + (vertical ? "Bottom" : "Right")] = _options.duration * (1 - _progress);
				}
				_util.css(_pinOptions.spacer, css);
			}
		};

		/**
   * Updates the Pin state (in certain scenarios)
   * If the controller container is not the document and we are mid-pin-phase scrolling or resizing the main document can result to wrong pin positions.
   * So this function is called on resize and scroll of the document.
   * @private
   */
		var updatePinInContainer = function updatePinInContainer() {
			if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
				updatePinState();
			}
		};

		/**
   * Updates the Pin spacer size state (in certain scenarios)
   * If container is resized during pin and relatively sized the size of the pin might need to be updated...
   * So this function is called on resize of the container.
   * @private
   */
		var updateRelativePinSpacer = function updateRelativePinSpacer() {
			if (_controller && _pin && // well, duh
			_state === SCENE_STATE_DURING && ( // element in pinned state?
			// is width or height relatively sized, but not in relation to body? then we need to recalc.
			(_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) && _util.get.width(window) != _util.get.width(_pinOptions.spacer.parentNode) || _pinOptions.relSize.height && _util.get.height(window) != _util.get.height(_pinOptions.spacer.parentNode))) {
				updatePinDimensions();
			}
		};

		/**
   * Is called, when the mousewhel is used while over a pinned element inside a div container.
   * If the scene is in fixed state scroll events would be counted towards the body. This forwards the event to the scroll container.
   * @private
   */
		var onMousewheelOverPin = function onMousewheelOverPin(e) {
			if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
				// in pin state
				e.preventDefault();
				_controller._setScrollPos(_controller.info("scrollPos") - ((e.wheelDelta || e[_controller.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || -e.detail * 30));
			}
		};

		/**
   * Pin an element for the duration of the tween.  
   * If the scene duration is 0 the element will only be unpinned, if the user scrolls back past the start position.  
   * Make sure only one pin is applied to an element at the same time.
   * An element can be pinned multiple times, but only successively.
   * _**NOTE:** The option `pushFollowers` has no effect, when the scene duration is 0._
   * @method ScrollMagic.Scene#setPin
   * @example
   * // pin element and push all following elements down by the amount of the pin duration.
   * scene.setPin("#pin");
   *
   * // pin element and keeping all following elements in their place. The pinned element will move past them.
   * scene.setPin("#pin", {pushFollowers: false});
   *
   * @param {(string|object)} element - A Selector targeting an element or a DOM object that is supposed to be pinned.
   * @param {object} [settings] - settings for the pin
   * @param {boolean} [settings.pushFollowers=true] - If `true` following elements will be "pushed" down for the duration of the pin, if `false` the pinned element will just scroll past them.  
   Ignored, when duration is `0`.
   * @param {string} [settings.spacerClass="scrollmagic-pin-spacer"] - Classname of the pin spacer element, which is used to replace the element.
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.setPin = function (element, settings) {
			var defaultSettings = {
				pushFollowers: true,
				spacerClass: "scrollmagic-pin-spacer"
			};
			settings = _util.extend({}, defaultSettings, settings);

			// validate Element
			element = _util.get.elements(element)[0];
			if (!element) {
				log(1, "ERROR calling method 'setPin()': Invalid pin element supplied.");
				return Scene; // cancel
			} else if (_util.css(element, "position") === "fixed") {
				log(1, "ERROR calling method 'setPin()': Pin does not work with elements that are positioned 'fixed'.");
				return Scene; // cancel
			}

			if (_pin) {
				// preexisting pin?
				if (_pin === element) {
					// same pin we already have -> do nothing
					return Scene; // cancel
				} else {
					// kill old pin
					Scene.removePin();
				}
			}
			_pin = element;

			var parentDisplay = _pin.parentNode.style.display,
			    boundsParams = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];

			_pin.parentNode.style.display = 'none'; // hack start to force css to return stylesheet values instead of calculated px values.
			var inFlow = _util.css(_pin, "position") != "absolute",
			    pinCSS = _util.css(_pin, boundsParams.concat(["display"])),
			    sizeCSS = _util.css(_pin, ["width", "height"]);
			_pin.parentNode.style.display = parentDisplay; // hack end.
			if (!inFlow && settings.pushFollowers) {
				log(2, "WARNING: If the pinned element is positioned absolutely pushFollowers will be disabled.");
				settings.pushFollowers = false;
			}
			window.setTimeout(function () {
				// wait until all finished, because with responsive duration it will only be set after scene is added to controller
				if (_pin && _options.duration === 0 && settings.pushFollowers) {
					log(2, "WARNING: pushFollowers =", true, "has no effect, when scene duration is 0.");
				}
			}, 0);

			// create spacer and insert
			var spacer = _pin.parentNode.insertBefore(document.createElement('div'), _pin),
			    spacerCSS = _util.extend(pinCSS, {
				position: inFlow ? "relative" : "absolute",
				boxSizing: "content-box",
				mozBoxSizing: "content-box",
				webkitBoxSizing: "content-box"
			});

			if (!inFlow) {
				// copy size if positioned absolutely, to work for bottom/right positioned elements.
				_util.extend(spacerCSS, _util.css(_pin, ["width", "height"]));
			}

			_util.css(spacer, spacerCSS);
			spacer.setAttribute(PIN_SPACER_ATTRIBUTE, "");
			_util.addClass(spacer, settings.spacerClass);

			// set the pin Options
			_pinOptions = {
				spacer: spacer,
				relSize: { // save if size is defined using % values. if so, handle spacer resize differently...
					width: sizeCSS.width.slice(-1) === "%",
					height: sizeCSS.height.slice(-1) === "%",
					autoFullWidth: sizeCSS.width === "auto" && inFlow && _util.isMarginCollapseType(pinCSS.display)
				},
				pushFollowers: settings.pushFollowers,
				inFlow: inFlow
				// stores if the element takes up space in the document flow
			};

			if (!_pin.___origStyle) {
				_pin.___origStyle = {};
				var pinInlineCSS = _pin.style,
				    copyStyles = boundsParams.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]);
				copyStyles.forEach(function (val) {
					_pin.___origStyle[val] = pinInlineCSS[val] || "";
				});
			}

			// if relative size, transfer it to spacer and make pin calculate it...
			if (_pinOptions.relSize.width) {
				_util.css(spacer, {
					width: sizeCSS.width
				});
			}
			if (_pinOptions.relSize.height) {
				_util.css(spacer, {
					height: sizeCSS.height
				});
			}

			// now place the pin element inside the spacer	
			spacer.appendChild(_pin);
			// and set new css
			_util.css(_pin, {
				position: inFlow ? "relative" : "absolute",
				margin: "auto",
				top: "auto",
				left: "auto",
				bottom: "auto",
				right: "auto"
			});

			if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
				_util.css(_pin, {
					boxSizing: "border-box",
					mozBoxSizing: "border-box",
					webkitBoxSizing: "border-box"
				});
			}

			// add listener to document to update pin position in case controller is not the document.
			window.addEventListener('scroll', updatePinInContainer);
			window.addEventListener('resize', updatePinInContainer);
			window.addEventListener('resize', updateRelativePinSpacer);
			// add mousewheel listener to catch scrolls over fixed elements
			_pin.addEventListener("mousewheel", onMousewheelOverPin);
			_pin.addEventListener("DOMMouseScroll", onMousewheelOverPin);

			log(3, "added pin");

			// finally update the pin to init
			updatePinState();

			return Scene;
		};

		/**
   * Remove the pin from the scene.
   * @method ScrollMagic.Scene#removePin
   * @example
   * // remove the pin from the scene without resetting it (the spacer is not removed)
   * scene.removePin();
   *
   * // remove the pin from the scene and reset the pin element to its initial position (spacer is removed)
   * scene.removePin(true);
   *
   * @param {boolean} [reset=false] - If `false` the spacer will not be removed and the element's position will not be reset.
   * @returns {Scene} Parent object for chaining.
   */
		this.removePin = function (reset) {
			if (_pin) {
				if (_state === SCENE_STATE_DURING) {
					updatePinState(true); // force unpin at position
				}
				if (reset || !_controller) {
					// if there's no controller no progress was made anyway...
					var pinTarget = _pinOptions.spacer.firstChild; // usually the pin element, but may be another spacer (cascaded pins)...
					if (pinTarget.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						// copy margins to child spacer
						var style = _pinOptions.spacer.style,
						    values = ["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"],
						    margins = {};
						values.forEach(function (val) {
							margins[val] = style[val] || "";
						});
						_util.css(pinTarget, margins);
					}
					_pinOptions.spacer.parentNode.insertBefore(pinTarget, _pinOptions.spacer);
					_pinOptions.spacer.parentNode.removeChild(_pinOptions.spacer);
					if (!_pin.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						// if it's the last pin for this element -> restore inline styles
						// TODO: only correctly set for first pin (when cascading) - how to fix?
						_util.css(_pin, _pin.___origStyle);
						delete _pin.___origStyle;
					}
				}
				window.removeEventListener('scroll', updatePinInContainer);
				window.removeEventListener('resize', updatePinInContainer);
				window.removeEventListener('resize', updateRelativePinSpacer);
				_pin.removeEventListener("mousewheel", onMousewheelOverPin);
				_pin.removeEventListener("DOMMouseScroll", onMousewheelOverPin);
				_pin = undefined;
				log(3, "removed pin (reset: " + (reset ? "true" : "false") + ")");
			}
			return Scene;
		};

		var _cssClasses,
		    _cssClassElems = [];

		Scene.on("destroy.internal", function (e) {
			Scene.removeClassToggle(e.reset);
		});
		/**
   * Define a css class modification while the scene is active.  
   * When the scene triggers the classes will be added to the supplied element and removed, when the scene is over.
   * If the scene duration is 0 the classes will only be removed if the user scrolls back past the start position.
   * @method ScrollMagic.Scene#setClassToggle
   * @example
   * // add the class 'myclass' to the element with the id 'my-elem' for the duration of the scene
   * scene.setClassToggle("#my-elem", "myclass");
   *
   * // add multiple classes to multiple elements defined by the selector '.classChange'
   * scene.setClassToggle(".classChange", "class1 class2 class3");
   *
   * @param {(string|object)} element - A Selector targeting one or more elements or a DOM object that is supposed to be modified.
   * @param {string} classes - One or more Classnames (separated by space) that should be added to the element during the scene.
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.setClassToggle = function (element, classes) {
			var elems = _util.get.elements(element);
			if (elems.length === 0 || !_util.type.String(classes)) {
				log(1, "ERROR calling method 'setClassToggle()': Invalid " + (elems.length === 0 ? "element" : "classes") + " supplied.");
				return Scene;
			}
			if (_cssClassElems.length > 0) {
				// remove old ones
				Scene.removeClassToggle();
			}
			_cssClasses = classes;
			_cssClassElems = elems;
			Scene.on("enter.internal_class leave.internal_class", function (e) {
				var toggle = e.type === "enter" ? _util.addClass : _util.removeClass;
				_cssClassElems.forEach(function (elem, key) {
					toggle(elem, _cssClasses);
				});
			});
			return Scene;
		};

		/**
   * Remove the class binding from the scene.
   * @method ScrollMagic.Scene#removeClassToggle
   * @example
   * // remove class binding from the scene without reset
   * scene.removeClassToggle();
   *
   * // remove class binding and remove the changes it caused
   * scene.removeClassToggle(true);
   *
   * @param {boolean} [reset=false] - If `false` and the classes are currently active, they will remain on the element. If `true` they will be removed.
   * @returns {Scene} Parent object for chaining.
   */
		this.removeClassToggle = function (reset) {
			if (reset) {
				_cssClassElems.forEach(function (elem, key) {
					_util.removeClass(elem, _cssClasses);
				});
			}
			Scene.off("start.internal_class end.internal_class");
			_cssClasses = undefined;
			_cssClassElems = [];
			return Scene;
		};

		// INIT
		construct();
		return Scene;
	};

	// store pagewide scene options
	var SCENE_OPTIONS = {
		defaults: {
			duration: 0,
			offset: 0,
			triggerElement: undefined,
			triggerHook: 0.5,
			reverse: true,
			loglevel: 2
		},
		validate: {
			offset: function offset(val) {
				val = parseFloat(val);
				if (!_util.type.Number(val)) {
					throw ["Invalid value for option \"offset\":", val];
				}
				return val;
			},
			triggerElement: function triggerElement(val) {
				val = val || undefined;
				if (val) {
					var elem = _util.get.elements(val)[0];
					if (elem && elem.parentNode) {
						val = elem;
					} else {
						throw ["Element defined in option \"triggerElement\" was not found:", val];
					}
				}
				return val;
			},
			triggerHook: function triggerHook(val) {
				var translate = {
					"onCenter": 0.5,
					"onEnter": 1,
					"onLeave": 0
				};
				if (_util.type.Number(val)) {
					val = Math.max(0, Math.min(parseFloat(val), 1)); //  make sure its betweeen 0 and 1
				} else if (val in translate) {
					val = translate[val];
				} else {
					throw ["Invalid value for option \"triggerHook\": ", val];
				}
				return val;
			},
			reverse: function reverse(val) {
				return !!val; // force boolean
			},
			loglevel: function loglevel(val) {
				val = parseInt(val);
				if (!_util.type.Number(val) || val < 0 || val > 3) {
					throw ["Invalid value for option \"loglevel\":", val];
				}
				return val;
			}
		},
		// holder for  validation methods. duration validation is handled in 'getters-setters.js'
		shifts: ["duration", "offset", "triggerHook"]
		// list of options that trigger a `shift` event
	};
	/*
  * method used to add an option to ScrollMagic Scenes.
  * TODO: DOC (private for dev)
  */
	ScrollMagic.Scene.addOption = function (name, defaultValue, validationCallback, shifts) {
		if (!(name in SCENE_OPTIONS.defaults)) {
			SCENE_OPTIONS.defaults[name] = defaultValue;
			SCENE_OPTIONS.validate[name] = validationCallback;
			if (shifts) {
				SCENE_OPTIONS.shifts.push(name);
			}
		} else {
			ScrollMagic._util.log(1, "[static] ScrollMagic.Scene -> Cannot add Scene option '" + name + "', because it already exists.");
		}
	};
	// instance extension function for plugins
	// TODO: DOC (private for dev)
	ScrollMagic.Scene.extend = function (extension) {
		var oldClass = this;
		ScrollMagic.Scene = function () {
			oldClass.apply(this, arguments);
			this.$super = _util.extend({}, this); // copy parent state
			return extension.apply(this, arguments) || this;
		};
		_util.extend(ScrollMagic.Scene, oldClass); // copy properties
		ScrollMagic.Scene.prototype = oldClass.prototype; // copy prototype
		ScrollMagic.Scene.prototype.constructor = ScrollMagic.Scene; // restore constructor
	};

	/**
  * TODO: DOCS (private for dev)
  * @class
  * @private
  */

	ScrollMagic.Event = function (type, namespace, target, vars) {
		vars = vars || {};
		for (var key in vars) {
			this[key] = vars[key];
		}
		this.type = type;
		this.target = this.currentTarget = target;
		this.namespace = namespace || '';
		this.timeStamp = this.timestamp = Date.now();
		return this;
	};

	/*
  * TODO: DOCS (private for dev)
  */

	var _util = ScrollMagic._util = function (window) {
		var U = {},
		    i;

		/**
   * ------------------------------
   * internal helpers
   * ------------------------------
   */

		// parse float and fall back to 0.
		var floatval = function floatval(number) {
			return parseFloat(number) || 0;
		};
		// get current style IE safe (otherwise IE would return calculated values for 'auto')
		var _getComputedStyle = function _getComputedStyle(elem) {
			return elem.currentStyle ? elem.currentStyle : window.getComputedStyle(elem);
		};

		// get element dimension (width or height)
		var _dimension = function _dimension(which, elem, outer, includeMargin) {
			elem = elem === document ? window : elem;
			if (elem === window) {
				includeMargin = false;
			} else if (!_type.DomElement(elem)) {
				return 0;
			}
			which = which.charAt(0).toUpperCase() + which.substr(1).toLowerCase();
			var dimension = (outer ? elem['offset' + which] || elem['outer' + which] : elem['client' + which] || elem['inner' + which]) || 0;
			if (outer && includeMargin) {
				var style = _getComputedStyle(elem);
				dimension += which === 'Height' ? floatval(style.marginTop) + floatval(style.marginBottom) : floatval(style.marginLeft) + floatval(style.marginRight);
			}
			return dimension;
		};
		// converts 'margin-top' into 'marginTop'
		var _camelCase = function _camelCase(str) {
			return str.replace(/^[^a-z]+([a-z])/g, '$1').replace(/-([a-z])/g, function (g) {
				return g[1].toUpperCase();
			});
		};

		/**
   * ------------------------------
   * external helpers
   * ------------------------------
   */

		// extend obj  same as jQuery.extend({}, objA, objB)
		U.extend = function (obj) {
			obj = obj || {};
			for (i = 1; i < arguments.length; i++) {
				if (!arguments[i]) {
					continue;
				}
				for (var key in arguments[i]) {
					if (arguments[i].hasOwnProperty(key)) {
						obj[key] = arguments[i][key];
					}
				}
			}
			return obj;
		};

		// check if a css display type results in margin-collapse or not
		U.isMarginCollapseType = function (str) {
			return ["block", "flex", "list-item", "table", "-webkit-box"].indexOf(str) > -1;
		};

		// implementation of requestAnimationFrame
		// based on https://gist.github.com/paulirish/1579671
		var lastTime = 0,
		    vendors = ['ms', 'moz', 'webkit', 'o'];
		var _requestAnimationFrame = window.requestAnimationFrame;
		var _cancelAnimationFrame = window.cancelAnimationFrame;
		// try vendor prefixes if the above doesn't work
		for (i = 0; !_requestAnimationFrame && i < vendors.length; ++i) {
			_requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
			_cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];
		}

		// fallbacks
		if (!_requestAnimationFrame) {
			_requestAnimationFrame = function _requestAnimationFrame(callback) {
				var currTime = new Date().getTime(),
				    timeToCall = Math.max(0, 16 - (currTime - lastTime)),
				    id = window.setTimeout(function () {
					callback(currTime + timeToCall);
				}, timeToCall);
				lastTime = currTime + timeToCall;
				return id;
			};
		}
		if (!_cancelAnimationFrame) {
			_cancelAnimationFrame = function _cancelAnimationFrame(id) {
				window.clearTimeout(id);
			};
		}
		U.rAF = _requestAnimationFrame.bind(window);
		U.cAF = _cancelAnimationFrame.bind(window);

		var loglevels = ["error", "warn", "log"],
		    console = window.console || {};

		console.log = console.log || function () {}; // no console log, well - do nothing then...
		// make sure methods for all levels exist.
		for (i = 0; i < loglevels.length; i++) {
			var method = loglevels[i];
			if (!console[method]) {
				console[method] = console.log; // prefer .log over nothing
			}
		}
		U.log = function (loglevel) {
			if (loglevel > loglevels.length || loglevel <= 0) loglevel = loglevels.length;
			var now = new Date(),
			    time = ("0" + now.getHours()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2) + ":" + ("00" + now.getMilliseconds()).slice(-3),
			    method = loglevels[loglevel - 1],
			    args = Array.prototype.splice.call(arguments, 1),
			    func = Function.prototype.bind.call(console[method], console);
			args.unshift(time);
			func.apply(console, args);
		};

		/**
   * ------------------------------
   * type testing
   * ------------------------------
   */

		var _type = U.type = function (v) {
			return Object.prototype.toString.call(v).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
		};
		_type.String = function (v) {
			return _type(v) === 'string';
		};
		_type.Function = function (v) {
			return _type(v) === 'function';
		};
		_type.Array = function (v) {
			return Array.isArray(v);
		};
		_type.Number = function (v) {
			return !_type.Array(v) && v - parseFloat(v) + 1 >= 0;
		};
		_type.DomElement = function (o) {
			return (typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement)) === "object" ? o instanceof HTMLElement : //DOM2
			o && (typeof o === "undefined" ? "undefined" : _typeof(o)) === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
		};

		/**
   * ------------------------------
   * DOM Element info
   * ------------------------------
   */
		// always returns a list of matching DOM elements, from a selector, a DOM element or an list of elements or even an array of selectors
		var _get = U.get = {};
		_get.elements = function (selector) {
			var arr = [];
			if (_type.String(selector)) {
				try {
					selector = document.querySelectorAll(selector);
				} catch (e) {
					// invalid selector
					return arr;
				}
			}
			if (_type(selector) === 'nodelist' || _type.Array(selector)) {
				for (var i = 0, ref = arr.length = selector.length; i < ref; i++) {
					// list of elements
					var elem = selector[i];
					arr[i] = _type.DomElement(elem) ? elem : _get.elements(elem); // if not an element, try to resolve recursively
				}
			} else if (_type.DomElement(selector) || selector === document || selector === window) {
				arr = [selector]; // only the element
			}
			return arr;
		};
		// get scroll top value
		_get.scrollTop = function (elem) {
			return elem && typeof elem.scrollTop === 'number' ? elem.scrollTop : window.pageYOffset || 0;
		};
		// get scroll left value
		_get.scrollLeft = function (elem) {
			return elem && typeof elem.scrollLeft === 'number' ? elem.scrollLeft : window.pageXOffset || 0;
		};
		// get element height
		_get.width = function (elem, outer, includeMargin) {
			return _dimension('width', elem, outer, includeMargin);
		};
		// get element width
		_get.height = function (elem, outer, includeMargin) {
			return _dimension('height', elem, outer, includeMargin);
		};

		// get element position (optionally relative to viewport)
		_get.offset = function (elem, relativeToViewport) {
			var offset = {
				top: 0,
				left: 0
			};
			if (elem && elem.getBoundingClientRect) {
				// check if available
				var rect = elem.getBoundingClientRect();
				offset.top = rect.top;
				offset.left = rect.left;
				if (!relativeToViewport) {
					// clientRect is by default relative to viewport...
					offset.top += _get.scrollTop();
					offset.left += _get.scrollLeft();
				}
			}
			return offset;
		};

		/**
   * ------------------------------
   * DOM Element manipulation
   * ------------------------------
   */

		U.addClass = function (elem, classname) {
			if (classname) {
				if (elem.classList) elem.classList.add(classname);else elem.className += ' ' + classname;
			}
		};
		U.removeClass = function (elem, classname) {
			if (classname) {
				if (elem.classList) elem.classList.remove(classname);else elem.className = elem.className.replace(new RegExp('(^|\\b)' + classname.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
			}
		};
		// if options is string -> returns css value
		// if options is array -> returns object with css value pairs
		// if options is object -> set new css values
		U.css = function (elem, options) {
			if (_type.String(options)) {
				return _getComputedStyle(elem)[_camelCase(options)];
			} else if (_type.Array(options)) {
				var obj = {},
				    style = _getComputedStyle(elem);
				options.forEach(function (option, key) {
					obj[option] = style[_camelCase(option)];
				});
				return obj;
			} else {
				for (var option in options) {
					var val = options[option];
					if (val == parseFloat(val)) {
						// assume pixel for seemingly numerical values
						val += 'px';
					}
					elem.style[_camelCase(option)] = val;
				}
			}
		};

		return U;
	}(window || {});

	ScrollMagic.Scene.prototype.addIndicators = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling addIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
		return this;
	};
	ScrollMagic.Scene.prototype.removeIndicators = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
		return this;
	};
	ScrollMagic.Scene.prototype.setTween = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
		return this;
	};
	ScrollMagic.Scene.prototype.removeTween = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
		return this;
	};
	ScrollMagic.Scene.prototype.setVelocity = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
		return this;
	};
	ScrollMagic.Scene.prototype.removeVelocity = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
		return this;
	};

	return ScrollMagic;
});
/*!
 * ScrollMagic v2.0.6 (2018-10-08)
 * The javascript library for magical scroll interactions.
 * (c) 2018 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.6
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic GSAP Animation Plugin.
 *
 * requires: GSAP ~1.14
 * Powered by the Greensock Animation Platform (GSAP): http://www.greensock.com/js
 * Greensock License info at http://www.greensock.com/licensing/
 */
/**
 * This plugin is meant to be used in conjunction with the Greensock Animation Plattform.  
 * It offers an easy API to trigger Tweens or synchronize them to the scrollbar movement.
 *
 * Both the `lite` and the `max` versions of the GSAP library are supported.  
 * The most basic requirement is `TweenLite`.
 * 
 * To have access to this extension, please include `plugins/animation.gsap.js`.
 * @requires {@link http://greensock.com/gsap|GSAP ~1.14.x}
 * @mixin animation.GSAP
 */
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['ScrollMagic', 'TweenMax', 'TimelineMax'], factory);
	} else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
		// CommonJS
		// Loads whole gsap package onto global scope.
		require('gsap');
		factory(require('scrollmagic'), TweenMax, TimelineMax);
	} else {
		// Browser globals
		factory(root.ScrollMagic || root.jQuery && root.jQuery.ScrollMagic, root.TweenMax || root.TweenLite, root.TimelineMax || root.TimelineLite);
	}
})(this, function (ScrollMagic, Tween, Timeline) {
	"use strict";

	var NAMESPACE = "animation.gsap";

	var console = window.console || {},
	    err = Function.prototype.bind.call(console.error || console.log || function () {}, console);
	if (!ScrollMagic) {
		err("(" + NAMESPACE + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs.");
	}
	if (!Tween) {
		err("(" + NAMESPACE + ") -> ERROR: TweenLite or TweenMax could not be found. Please make sure GSAP is loaded before ScrollMagic or use an asynchronous loader like requirejs.");
	}

	/*
 	 * ----------------------------------------------------------------
 	 * Extensions for Scene
 	 * ----------------------------------------------------------------
 	 */
	/**
  * Every instance of ScrollMagic.Scene now accepts an additional option.  
  * See {@link ScrollMagic.Scene} for a complete list of the standard options.
  * @memberof! animation.GSAP#
  * @method new ScrollMagic.Scene(options)
  * @example
  * var scene = new ScrollMagic.Scene({tweenChanges: true});
  *
  * @param {object} [options] - Options for the Scene. The options can be updated at any time.
  * @param {boolean} [options.tweenChanges=false] - Tweens Animation to the progress target instead of setting it.  
  Does not affect animations where duration is `0`.
  */
	/**
  * **Get** or **Set** the tweenChanges option value.  
  * This only affects scenes with a duration. If `tweenChanges` is `true`, the progress update when scrolling will not be immediate, but instead the animation will smoothly animate to the target state.  
  * For a better understanding, try enabling and disabling this option in the [Scene Manipulation Example](../examples/basic/scene_manipulation.html).
  * @memberof! animation.GSAP#
  * @method Scene.tweenChanges
  * 
  * @example
  * // get the current tweenChanges option
  * var tweenChanges = scene.tweenChanges();
  *
  * // set new tweenChanges option
  * scene.tweenChanges(true);
  *
  * @fires {@link Scene.change}, when used as setter
  * @param {boolean} [newTweenChanges] - The new tweenChanges setting of the scene.
  * @returns {boolean} `get` -  Current tweenChanges option value.
  * @returns {Scene} `set` -  Parent object for chaining.
  */
	// add option (TODO: DOC (private for dev))
	ScrollMagic.Scene.addOption("tweenChanges", // name
	false, // default


	function (val) {
		// validation callback
		return !!val;
	});
	// extend scene
	ScrollMagic.Scene.extend(function () {
		var Scene = this,
		    _tween;

		var log = function log() {
			if (Scene._log) {
				// not available, when main source minified
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
				Scene._log.apply(this, arguments);
			}
		};

		// set listeners
		Scene.on("progress.plugin_gsap", function () {
			updateTweenProgress();
		});
		Scene.on("destroy.plugin_gsap", function (e) {
			Scene.removeTween(e.reset);
		});

		/**
   * Update the tween progress to current position.
   * @private
   */
		var updateTweenProgress = function updateTweenProgress() {
			if (_tween) {
				var progress = Scene.progress(),
				    state = Scene.state();
				if (_tween.repeat && _tween.repeat() === -1) {
					// infinite loop, so not in relation to progress
					if (state === 'DURING' && _tween.paused()) {
						_tween.play();
					} else if (state !== 'DURING' && !_tween.paused()) {
						_tween.pause();
					}
				} else if (progress != _tween.progress()) {
					// do we even need to update the progress?
					// no infinite loop - so should we just play or go to a specific point in time?
					if (Scene.duration() === 0) {
						// play the animation
						if (progress > 0) {
							// play from 0 to 1
							_tween.play();
						} else {
							// play from 1 to 0
							_tween.reverse();
						}
					} else {
						// go to a specific point in time
						if (Scene.tweenChanges() && _tween.tweenTo) {
							// go smooth
							_tween.tweenTo(progress * _tween.duration());
						} else {
							// just hard set it
							_tween.progress(progress).pause();
						}
					}
				}
			}
		};

		/**
   * Add a tween to the scene.  
   * If you want to add multiple tweens, add them into a GSAP Timeline object and supply it instead (see example below).  
   * 
   * If the scene has a duration, the tween's duration will be projected to the scroll distance of the scene, meaning its progress will be synced to scrollbar movement.  
   * For a scene with a duration of `0`, the tween will be triggered when scrolling forward past the scene's trigger position and reversed, when scrolling back.  
   * To gain better understanding, check out the [Simple Tweening example](../examples/basic/simple_tweening.html).
   *
   * Instead of supplying a tween this method can also be used as a shorthand for `TweenMax.to()` (see example below).
   * @memberof! animation.GSAP#
   *
   * @example
   * // add a single tween directly
   * scene.setTween(TweenMax.to("obj"), 1, {x: 100});
   *
   * // add a single tween via variable
   * var tween = TweenMax.to("obj"), 1, {x: 100};
   * scene.setTween(tween);
   *
   * // add multiple tweens, wrapped in a timeline.
   * var timeline = new TimelineMax();
   * var tween1 = TweenMax.from("obj1", 1, {x: 100});
   * var tween2 = TweenMax.to("obj2", 1, {y: 100});
   * timeline
   *		.add(tween1)
   *		.add(tween2);
   * scene.addTween(timeline);
   *
   * // short hand to add a TweenMax.to() tween
   * scene.setTween("obj3", 0.5, {y: 100});
   *
   * // short hand to add a TweenMax.to() tween for 1 second
   * // this is useful, when the scene has a duration and the tween duration isn't important anyway
   * scene.setTween("obj3", {y: 100});
   *
   * @param {(object|string)} TweenObject - A TweenMax, TweenLite, TimelineMax or TimelineLite object that should be animated in the scene. Can also be a Dom Element or Selector, when using direct tween definition (see examples).
   * @param {(number|object)} duration - A duration for the tween, or tween parameters. If an object containing parameters are supplied, a default duration of 1 will be used.
   * @param {object} params - The parameters for the tween
   * @returns {Scene} Parent object for chaining.
   */
		Scene.setTween = function (TweenObject, duration, params) {
			var newTween;
			if (arguments.length > 1) {
				if (arguments.length < 3) {
					params = duration;
					duration = 1;
				}
				TweenObject = Tween.to(TweenObject, duration, params);
			}
			try {
				// wrap Tween into a Timeline Object if available to include delay and repeats in the duration and standardize methods.
				if (Timeline) {
					newTween = new Timeline({
						smoothChildTiming: true
					}).add(TweenObject);
				} else {
					newTween = TweenObject;
				}
				newTween.pause();
			} catch (e) {
				log(1, "ERROR calling method 'setTween()': Supplied argument is not a valid TweenObject");
				return Scene;
			}
			if (_tween) {
				// kill old tween?
				Scene.removeTween();
			}
			_tween = newTween;

			// some properties need to be transferred it to the wrapper, otherwise they would get lost.
			if (TweenObject.repeat && TweenObject.repeat() === -1) {
				// TweenMax or TimelineMax Object?
				_tween.repeat(-1);
				_tween.yoyo(TweenObject.yoyo());
			}
			// Some tween validations and debugging helpers
			if (Scene.tweenChanges() && !_tween.tweenTo) {
				log(2, "WARNING: tweenChanges will only work if the TimelineMax object is available for ScrollMagic.");
			}

			// check if there are position tweens defined for the trigger and warn about it :)
			if (_tween && Scene.controller() && Scene.triggerElement() && Scene.loglevel() >= 2) {
				// controller is needed to know scroll direction.
				var triggerTweens = Tween.getTweensOf(Scene.triggerElement()),
				    vertical = Scene.controller().info("vertical");
				triggerTweens.forEach(function (value, index) {
					var tweenvars = value.vars.css || value.vars,
					    condition = vertical ? tweenvars.top !== undefined || tweenvars.bottom !== undefined : tweenvars.left !== undefined || tweenvars.right !== undefined;
					if (condition) {
						log(2, "WARNING: Tweening the position of the trigger element affects the scene timing and should be avoided!");
						return false;
					}
				});
			}

			// warn about tween overwrites, when an element is tweened multiple times
			if (parseFloat(TweenLite.version) >= 1.14) {
				// onOverwrite only present since GSAP v1.14.0
				var list = _tween.getChildren ? _tween.getChildren(true, true, false) : [_tween],

				// get all nested tween objects
				newCallback = function newCallback() {
					log(2, "WARNING: tween was overwritten by another. To learn how to avoid this issue see here: https://github.com/janpaepke/ScrollMagic/wiki/WARNING:-tween-was-overwritten-by-another");
				};
				for (var i = 0, thisTween, oldCallback; i < list.length; i++) {
					/*jshint loopfunc: true */
					thisTween = list[i];
					if (oldCallback !== newCallback) {
						// if tweens is added more than once
						oldCallback = thisTween.vars.onOverwrite;
						thisTween.vars.onOverwrite = function () {
							if (oldCallback) {
								oldCallback.apply(this, arguments);
							}
							newCallback.apply(this, arguments);
						};
					}
				}
			}
			log(3, "added tween");

			updateTweenProgress();
			return Scene;
		};

		/**
   * Remove the tween from the scene.  
   * This will terminate the control of the Scene over the tween.
   *
   * Using the reset option you can decide if the tween should remain in the current state or be rewound to set the target elements back to the state they were in before the tween was added to the scene.
   * @memberof! animation.GSAP#
   *
   * @example
   * // remove the tween from the scene without resetting it
   * scene.removeTween();
   *
   * // remove the tween from the scene and reset it to initial position
   * scene.removeTween(true);
   *
   * @param {boolean} [reset=false] - If `true` the tween will be reset to its initial values.
   * @returns {Scene} Parent object for chaining.
   */
		Scene.removeTween = function (reset) {
			if (_tween) {
				if (reset) {
					_tween.progress(0).pause();
				}
				_tween.kill();
				_tween = undefined;
				log(3, "removed tween (reset: " + (reset ? "true" : "false") + ")");
			}
			return Scene;
		};
	});
});
/*! lightgallery - v1.2.19 - 2016-05-17
* http://sachinchoolur.github.io/lightGallery/
* Copyright (c) 2016 Sachin N; Licensed Apache 2.0 */
!function (a, b, c, d) {
	"use strict";
	function e(b, d) {
		if (this.el = b, this.$el = a(b), this.s = a.extend({}, f, d), this.s.dynamic && "undefined" !== this.s.dynamicEl && this.s.dynamicEl.constructor === Array && !this.s.dynamicEl.length) throw "When using dynamic mode, you must also define dynamicEl as an Array.";return this.modules = {}, this.lGalleryOn = !1, this.lgBusy = !1, this.hideBartimeout = !1, this.isTouch = "ontouchstart" in c.documentElement, this.s.slideEndAnimatoin && (this.s.hideControlOnEnd = !1), this.s.dynamic ? this.$items = this.s.dynamicEl : "this" === this.s.selector ? this.$items = this.$el : "" !== this.s.selector ? this.s.selectWithin ? this.$items = a(this.s.selectWithin).find(this.s.selector) : this.$items = this.$el.find(a(this.s.selector)) : this.$items = this.$el.children(), this.$slide = "", this.$outer = "", this.init(), this;
	}var f = { mode: "lg-slide", cssEasing: "ease", easing: "linear", speed: 600, height: "100%", width: "100%", addClass: "", startClass: "lg-start-zoom", backdropDuration: 150, hideBarsDelay: 6e3, useLeft: !1, closable: !0, loop: !0, escKey: !0, keyPress: !0, controls: !0, slideEndAnimatoin: !0, hideControlOnEnd: !1, mousewheel: !0, getCaptionFromTitleOrAlt: !0, appendSubHtmlTo: ".lg-sub-html", preload: 1, showAfterLoad: !0, selector: "", selectWithin: "", nextHtml: "", prevHtml: "", index: !1, iframeMaxWidth: "100%", download: !0, counter: !0, appendCounterTo: ".lg-toolbar", swipeThreshold: 50, enableSwipe: !0, enableDrag: !0, dynamic: !1, dynamicEl: [], galleryId: 1 };e.prototype.init = function () {
		var c = this;c.s.preload > c.$items.length && (c.s.preload = c.$items.length);var d = b.location.hash;d.indexOf("lg=" + this.s.galleryId) > 0 && (c.index = parseInt(d.split("&slide=")[1], 10), a("body").addClass("lg-from-hash"), a("body").hasClass("lg-on") || setTimeout(function () {
			c.build(c.index), a("body").addClass("lg-on");
		})), c.s.dynamic ? (c.$el.trigger("onBeforeOpen.lg"), c.index = c.s.index || 0, a("body").hasClass("lg-on") || setTimeout(function () {
			c.build(c.index), a("body").addClass("lg-on");
		})) : c.$items.on("click.lgcustom", function (b) {
			try {
				b.preventDefault(), b.preventDefault();
			} catch (d) {
				b.returnValue = !1;
			}c.$el.trigger("onBeforeOpen.lg"), c.index = c.s.index || c.$items.index(this), a("body").hasClass("lg-on") || (c.build(c.index), a("body").addClass("lg-on"));
		});
	}, e.prototype.build = function (b) {
		var c = this;c.structure(), a.each(a.fn.lightGallery.modules, function (b) {
			c.modules[b] = new a.fn.lightGallery.modules[b](c.el);
		}), c.slide(b, !1, !1), c.s.keyPress && c.keyPress(), c.$items.length > 1 && (c.arrow(), setTimeout(function () {
			c.enableDrag(), c.enableSwipe();
		}, 50), c.s.mousewheel && c.mousewheel()), c.counter(), c.closeGallery(), c.$el.trigger("onAfterOpen.lg"), c.$outer.on("mousemove.lg click.lg touchstart.lg", function () {
			c.$outer.removeClass("lg-hide-items"), clearTimeout(c.hideBartimeout), c.hideBartimeout = setTimeout(function () {
				c.$outer.addClass("lg-hide-items");
			}, c.s.hideBarsDelay);
		});
	}, e.prototype.structure = function () {
		var c,
		    d = "",
		    e = "",
		    f = 0,
		    g = "",
		    h = this;for (a("body").append('<div class="lg-backdrop"></div>'), a(".lg-backdrop").css("transition-duration", this.s.backdropDuration + "ms"), f = 0; f < this.$items.length; f++) {
			d += '<div class="lg-item"></div>';
		}if (this.s.controls && this.$items.length > 1 && (e = '<div class="lg-actions"><div class="lg-prev lg-icon">' + this.s.prevHtml + '</div><div class="lg-next lg-icon">' + this.s.nextHtml + "</div></div>"), ".lg-sub-html" === this.s.appendSubHtmlTo && (g = '<div class="lg-sub-html"></div>'), c = '<div class="lg-outer ' + this.s.addClass + " " + this.s.startClass + '"><div class="lg" style="width:' + this.s.width + "; height:" + this.s.height + '"><div class="lg-inner">' + d + '</div><div class="lg-toolbar group"><span class="lg-close lg-icon"></span></div>' + e + g + "</div></div>", a("body").append(c), this.$outer = a(".lg-outer"), this.$slide = this.$outer.find(".lg-item"), this.s.useLeft ? (this.$outer.addClass("lg-use-left"), this.s.mode = "lg-slide") : this.$outer.addClass("lg-use-css3"), h.setTop(), a(b).on("resize.lg orientationchange.lg", function () {
			setTimeout(function () {
				h.setTop();
			}, 100);
		}), this.$slide.eq(this.index).addClass("lg-current"), this.doCss() ? this.$outer.addClass("lg-css3") : (this.$outer.addClass("lg-css"), this.s.speed = 0), this.$outer.addClass(this.s.mode), this.s.enableDrag && this.$items.length > 1 && this.$outer.addClass("lg-grab"), this.s.showAfterLoad && this.$outer.addClass("lg-show-after-load"), this.doCss()) {
			var i = this.$outer.find(".lg-inner");i.css("transition-timing-function", this.s.cssEasing), i.css("transition-duration", this.s.speed + "ms");
		}a(".lg-backdrop").addClass("in"), setTimeout(function () {
			h.$outer.addClass("lg-visible");
		}, this.s.backdropDuration), this.s.download && this.$outer.find(".lg-toolbar").append('<a id="lg-download" target="_blank" download class="lg-download lg-icon"></a>'), this.prevScrollTop = a(b).scrollTop();
	}, e.prototype.setTop = function () {
		if ("100%" !== this.s.height) {
			var c = a(b).height(),
			    d = (c - parseInt(this.s.height, 10)) / 2,
			    e = this.$outer.find(".lg");c >= parseInt(this.s.height, 10) ? e.css("top", d + "px") : e.css("top", "0px");
		}
	}, e.prototype.doCss = function () {
		var a = function a() {
			var a = ["transition", "MozTransition", "WebkitTransition", "OTransition", "msTransition", "KhtmlTransition"],
			    b = c.documentElement,
			    d = 0;for (d = 0; d < a.length; d++) {
				if (a[d] in b.style) return !0;
			}
		};return !!a();
	}, e.prototype.isVideo = function (a, b) {
		var c;if (c = this.s.dynamic ? this.s.dynamicEl[b].html : this.$items.eq(b).attr("data-html"), !a && c) return { html5: !0 };var d = a.match(/\/\/(?:www\.)?youtu(?:\.be|be\.com)\/(?:watch\?v=|embed\/)?([a-z0-9\-\_\%]+)/i),
		    e = a.match(/\/\/(?:www\.)?vimeo.com\/([0-9a-z\-_]+)/i),
		    f = a.match(/\/\/(?:www\.)?dai.ly\/([0-9a-z\-_]+)/i),
		    g = a.match(/\/\/(?:www\.)?(?:vk\.com|vkontakte\.ru)\/(?:video_ext\.php\?)(.*)/i);return d ? { youtube: d } : e ? { vimeo: e } : f ? { dailymotion: f } : g ? { vk: g } : void 0;
	}, e.prototype.counter = function () {
		this.s.counter && a(this.s.appendCounterTo).append('<div id="lg-counter"><span id="lg-counter-current">' + (parseInt(this.index, 10) + 1) + '</span> / <span id="lg-counter-all">' + this.$items.length + "</span></div>");
	}, e.prototype.addHtml = function (b) {
		var c,
		    d = null;if (this.s.dynamic ? this.s.dynamicEl[b].subHtmlUrl ? c = this.s.dynamicEl[b].subHtmlUrl : d = this.s.dynamicEl[b].subHtml : this.$items.eq(b).attr("data-sub-html-url") ? c = this.$items.eq(b).attr("data-sub-html-url") : (d = this.$items.eq(b).attr("data-sub-html"), this.s.getCaptionFromTitleOrAlt && !d && (d = this.$items.eq(b).attr("title") || this.$items.eq(b).find("img").first().attr("alt"))), !c) if ("undefined" != typeof d && null !== d) {
			var e = d.substring(0, 1);"." !== e && "#" !== e || (d = a(d).html());
		} else d = "";".lg-sub-html" === this.s.appendSubHtmlTo ? c ? this.$outer.find(this.s.appendSubHtmlTo).load(c) : this.$outer.find(this.s.appendSubHtmlTo).html(d) : c ? this.$slide.eq(b).load(c) : this.$slide.eq(b).append(d), "undefined" != typeof d && null !== d && ("" === d ? this.$outer.find(this.s.appendSubHtmlTo).addClass("lg-empty-html") : this.$outer.find(this.s.appendSubHtmlTo).removeClass("lg-empty-html")), this.$el.trigger("onAfterAppendSubHtml.lg", [b]);
	}, e.prototype.preload = function (a) {
		var b = 1,
		    c = 1;for (b = 1; b <= this.s.preload && !(b >= this.$items.length - a); b++) {
			this.loadContent(a + b, !1, 0);
		}for (c = 1; c <= this.s.preload && !(0 > a - c); c++) {
			this.loadContent(a - c, !1, 0);
		}
	}, e.prototype.loadContent = function (c, d, e) {
		var f,
		    g,
		    h,
		    i,
		    j,
		    k,
		    l = this,
		    m = !1,
		    n = function n(c) {
			for (var d = [], e = [], f = 0; f < c.length; f++) {
				var h = c[f].split(" ");"" === h[0] && h.splice(0, 1), e.push(h[0]), d.push(h[1]);
			}for (var i = a(b).width(), j = 0; j < d.length; j++) {
				if (parseInt(d[j], 10) > i) {
					g = e[j];break;
				}
			}
		};if (l.s.dynamic) {
			if (l.s.dynamicEl[c].poster && (m = !0, h = l.s.dynamicEl[c].poster), k = l.s.dynamicEl[c].html, g = l.s.dynamicEl[c].src, l.s.dynamicEl[c].responsive) {
				var o = l.s.dynamicEl[c].responsive.split(",");n(o);
			}i = l.s.dynamicEl[c].srcset, j = l.s.dynamicEl[c].sizes;
		} else {
			if (l.$items.eq(c).attr("data-poster") && (m = !0, h = l.$items.eq(c).attr("data-poster")), k = l.$items.eq(c).attr("data-html"), g = l.$items.eq(c).attr("href") || l.$items.eq(c).attr("data-src"), l.$items.eq(c).attr("data-responsive")) {
				var p = l.$items.eq(c).attr("data-responsive").split(",");n(p);
			}i = l.$items.eq(c).attr("data-srcset"), j = l.$items.eq(c).attr("data-sizes");
		}var q = !1;l.s.dynamic ? l.s.dynamicEl[c].iframe && (q = !0) : "true" === l.$items.eq(c).attr("data-iframe") && (q = !0);var r = l.isVideo(g, c);if (!l.$slide.eq(c).hasClass("lg-loaded")) {
			if (q) l.$slide.eq(c).prepend('<div class="lg-video-cont" style="max-width:' + l.s.iframeMaxWidth + '"><div class="lg-video"><iframe class="lg-object" frameborder="0" src="' + g + '"  allowfullscreen="true"></iframe></div></div>');else if (m) {
				var s = "";s = r && r.youtube ? "lg-has-youtube" : r && r.vimeo ? "lg-has-vimeo" : "lg-has-html5", l.$slide.eq(c).prepend('<div class="lg-video-cont ' + s + ' "><div class="lg-video"><span class="lg-video-play"></span><img class="lg-object lg-has-poster" src="' + h + '" /></div></div>');
			} else r ? (l.$slide.eq(c).prepend('<div class="lg-video-cont "><div class="lg-video"></div></div>'), l.$el.trigger("hasVideo.lg", [c, g, k])) : l.$slide.eq(c).prepend('<div class="lg-img-wrap"><img class="lg-object lg-image" src="' + g + '" /></div>');if (l.$el.trigger("onAferAppendSlide.lg", [c]), f = l.$slide.eq(c).find(".lg-object"), j && f.attr("sizes", j), i) {
				f.attr("srcset", i);try {
					picturefill({ elements: [f[0]] });
				} catch (t) {
					console.error("Make sure you have included Picturefill version 2");
				}
			}".lg-sub-html" !== this.s.appendSubHtmlTo && l.addHtml(c), l.$slide.eq(c).addClass("lg-loaded");
		}l.$slide.eq(c).find(".lg-object").on("load.lg error.lg", function () {
			var b = 0;e && !a("body").hasClass("lg-from-hash") && (b = e), setTimeout(function () {
				l.$slide.eq(c).addClass("lg-complete"), l.$el.trigger("onSlideItemLoad.lg", [c, e || 0]);
			}, b);
		}), r && r.html5 && !m && l.$slide.eq(c).addClass("lg-complete"), d === !0 && (l.$slide.eq(c).hasClass("lg-complete") ? l.preload(c) : l.$slide.eq(c).find(".lg-object").on("load.lg error.lg", function () {
			l.preload(c);
		}));
	}, e.prototype.slide = function (b, c, d) {
		var e = this.$outer.find(".lg-current").index(),
		    f = this;if (!f.lGalleryOn || e !== b) {
			var g = this.$slide.length,
			    h = f.lGalleryOn ? this.s.speed : 0,
			    i = !1,
			    j = !1;if (!f.lgBusy) {
				if (this.s.download) {
					var k;k = f.s.dynamic ? f.s.dynamicEl[b].downloadUrl !== !1 && (f.s.dynamicEl[b].downloadUrl || f.s.dynamicEl[b].src) : "false" !== f.$items.eq(b).attr("data-download-url") && (f.$items.eq(b).attr("data-download-url") || f.$items.eq(b).attr("href") || f.$items.eq(b).attr("data-src")), k ? (a("#lg-download").attr("href", k), f.$outer.removeClass("lg-hide-download")) : f.$outer.addClass("lg-hide-download");
				}if (this.$el.trigger("onBeforeSlide.lg", [e, b, c, d]), f.lgBusy = !0, clearTimeout(f.hideBartimeout), ".lg-sub-html" === this.s.appendSubHtmlTo && setTimeout(function () {
					f.addHtml(b);
				}, h), this.arrowDisable(b), c) {
					var l = b - 1,
					    m = b + 1;0 === b && e === g - 1 ? (m = 0, l = g - 1) : b === g - 1 && 0 === e && (m = 0, l = g - 1), this.$slide.removeClass("lg-prev-slide lg-current lg-next-slide"), f.$slide.eq(l).addClass("lg-prev-slide"), f.$slide.eq(m).addClass("lg-next-slide"), f.$slide.eq(b).addClass("lg-current");
				} else f.$outer.addClass("lg-no-trans"), this.$slide.removeClass("lg-prev-slide lg-next-slide"), e > b ? (j = !0, 0 !== b || e !== g - 1 || d || (j = !1, i = !0)) : b > e && (i = !0, b !== g - 1 || 0 !== e || d || (j = !0, i = !1)), j ? (this.$slide.eq(b).addClass("lg-prev-slide"), this.$slide.eq(e).addClass("lg-next-slide")) : i && (this.$slide.eq(b).addClass("lg-next-slide"), this.$slide.eq(e).addClass("lg-prev-slide")), setTimeout(function () {
					f.$slide.removeClass("lg-current"), f.$slide.eq(b).addClass("lg-current"), f.$outer.removeClass("lg-no-trans");
				}, 50);f.lGalleryOn ? (setTimeout(function () {
					f.loadContent(b, !0, 0);
				}, this.s.speed + 50), setTimeout(function () {
					f.lgBusy = !1, f.$el.trigger("onAfterSlide.lg", [e, b, c, d]);
				}, this.s.speed)) : (f.loadContent(b, !0, f.s.backdropDuration), f.lgBusy = !1, f.$el.trigger("onAfterSlide.lg", [e, b, c, d])), f.lGalleryOn = !0, this.s.counter && a("#lg-counter-current").text(b + 1);
			}
		}
	}, e.prototype.goToNextSlide = function (a) {
		var b = this;b.lgBusy || (b.index + 1 < b.$slide.length ? (b.index++, b.$el.trigger("onBeforeNextSlide.lg", [b.index]), b.slide(b.index, a, !1)) : b.s.loop ? (b.index = 0, b.$el.trigger("onBeforeNextSlide.lg", [b.index]), b.slide(b.index, a, !1)) : b.s.slideEndAnimatoin && (b.$outer.addClass("lg-right-end"), setTimeout(function () {
			b.$outer.removeClass("lg-right-end");
		}, 400)));
	}, e.prototype.goToPrevSlide = function (a) {
		var b = this;b.lgBusy || (b.index > 0 ? (b.index--, b.$el.trigger("onBeforePrevSlide.lg", [b.index, a]), b.slide(b.index, a, !1)) : b.s.loop ? (b.index = b.$items.length - 1, b.$el.trigger("onBeforePrevSlide.lg", [b.index, a]), b.slide(b.index, a, !1)) : b.s.slideEndAnimatoin && (b.$outer.addClass("lg-left-end"), setTimeout(function () {
			b.$outer.removeClass("lg-left-end");
		}, 400)));
	}, e.prototype.keyPress = function () {
		var c = this;this.$items.length > 1 && a(b).on("keyup.lg", function (a) {
			c.$items.length > 1 && (37 === a.keyCode && (a.preventDefault(), c.goToPrevSlide()), 39 === a.keyCode && (a.preventDefault(), c.goToNextSlide()));
		}), a(b).on("keydown.lg", function (a) {
			c.s.escKey === !0 && 27 === a.keyCode && (a.preventDefault(), c.$outer.hasClass("lg-thumb-open") ? c.$outer.removeClass("lg-thumb-open") : c.destroy());
		});
	}, e.prototype.arrow = function () {
		var a = this;this.$outer.find(".lg-prev").on("click.lg", function () {
			a.goToPrevSlide();
		}), this.$outer.find(".lg-next").on("click.lg", function () {
			a.goToNextSlide();
		});
	}, e.prototype.arrowDisable = function (a) {
		!this.s.loop && this.s.hideControlOnEnd && (a + 1 < this.$slide.length ? this.$outer.find(".lg-next").removeAttr("disabled").removeClass("disabled") : this.$outer.find(".lg-next").attr("disabled", "disabled").addClass("disabled"), a > 0 ? this.$outer.find(".lg-prev").removeAttr("disabled").removeClass("disabled") : this.$outer.find(".lg-prev").attr("disabled", "disabled").addClass("disabled"));
	}, e.prototype.setTranslate = function (a, b, c) {
		this.s.useLeft ? a.css("left", b) : a.css({ transform: "translate3d(" + b + "px, " + c + "px, 0px)" });
	}, e.prototype.touchMove = function (b, c) {
		var d = c - b;Math.abs(d) > 15 && (this.$outer.addClass("lg-dragging"), this.setTranslate(this.$slide.eq(this.index), d, 0), this.setTranslate(a(".lg-prev-slide"), -this.$slide.eq(this.index).width() + d, 0), this.setTranslate(a(".lg-next-slide"), this.$slide.eq(this.index).width() + d, 0));
	}, e.prototype.touchEnd = function (a) {
		var b = this;"lg-slide" !== b.s.mode && b.$outer.addClass("lg-slide"), this.$slide.not(".lg-current, .lg-prev-slide, .lg-next-slide").css("opacity", "0"), setTimeout(function () {
			b.$outer.removeClass("lg-dragging"), 0 > a && Math.abs(a) > b.s.swipeThreshold ? b.goToNextSlide(!0) : a > 0 && Math.abs(a) > b.s.swipeThreshold ? b.goToPrevSlide(!0) : Math.abs(a) < 5 && b.$el.trigger("onSlideClick.lg"), b.$slide.removeAttr("style");
		}), setTimeout(function () {
			b.$outer.hasClass("lg-dragging") || "lg-slide" === b.s.mode || b.$outer.removeClass("lg-slide");
		}, b.s.speed + 100);
	}, e.prototype.enableSwipe = function () {
		var a = this,
		    b = 0,
		    c = 0,
		    d = !1;a.s.enableSwipe && a.isTouch && a.doCss() && (a.$slide.on("touchstart.lg", function (c) {
			a.$outer.hasClass("lg-zoomed") || a.lgBusy || (c.preventDefault(), a.manageSwipeClass(), b = c.originalEvent.targetTouches[0].pageX);
		}), a.$slide.on("touchmove.lg", function (e) {
			a.$outer.hasClass("lg-zoomed") || (e.preventDefault(), c = e.originalEvent.targetTouches[0].pageX, a.touchMove(b, c), d = !0);
		}), a.$slide.on("touchend.lg", function () {
			a.$outer.hasClass("lg-zoomed") || (d ? (d = !1, a.touchEnd(c - b)) : a.$el.trigger("onSlideClick.lg"));
		}));
	}, e.prototype.enableDrag = function () {
		var c = this,
		    d = 0,
		    e = 0,
		    f = !1,
		    g = !1;c.s.enableDrag && !c.isTouch && c.doCss() && (c.$slide.on("mousedown.lg", function (b) {
			c.$outer.hasClass("lg-zoomed") || (a(b.target).hasClass("lg-object") || a(b.target).hasClass("lg-video-play")) && (b.preventDefault(), c.lgBusy || (c.manageSwipeClass(), d = b.pageX, f = !0, c.$outer.scrollLeft += 1, c.$outer.scrollLeft -= 1, c.$outer.removeClass("lg-grab").addClass("lg-grabbing"), c.$el.trigger("onDragstart.lg")));
		}), a(b).on("mousemove.lg", function (a) {
			f && (g = !0, e = a.pageX, c.touchMove(d, e), c.$el.trigger("onDragmove.lg"));
		}), a(b).on("mouseup.lg", function (b) {
			g ? (g = !1, c.touchEnd(e - d), c.$el.trigger("onDragend.lg")) : (a(b.target).hasClass("lg-object") || a(b.target).hasClass("lg-video-play")) && c.$el.trigger("onSlideClick.lg"), f && (f = !1, c.$outer.removeClass("lg-grabbing").addClass("lg-grab"));
		}));
	}, e.prototype.manageSwipeClass = function () {
		var a = this.index + 1,
		    b = this.index - 1,
		    c = this.$slide.length;this.s.loop && (0 === this.index ? b = c - 1 : this.index === c - 1 && (a = 0)), this.$slide.removeClass("lg-next-slide lg-prev-slide"), b > -1 && this.$slide.eq(b).addClass("lg-prev-slide"), this.$slide.eq(a).addClass("lg-next-slide");
	}, e.prototype.mousewheel = function () {
		var a = this;a.$outer.on("mousewheel.lg", function (b) {
			b.deltaY && (b.deltaY > 0 ? a.goToPrevSlide() : a.goToNextSlide(), b.preventDefault());
		});
	}, e.prototype.closeGallery = function () {
		var b = this,
		    c = !1;this.$outer.find(".lg-close").on("click.lg", function () {
			b.destroy();
		}), b.s.closable && (b.$outer.on("mousedown.lg", function (b) {
			c = !!(a(b.target).is(".lg-outer") || a(b.target).is(".lg-item ") || a(b.target).is(".lg-img-wrap"));
		}), b.$outer.on("mouseup.lg", function (d) {
			(a(d.target).is(".lg-outer") || a(d.target).is(".lg-item ") || a(d.target).is(".lg-img-wrap") && c) && (b.$outer.hasClass("lg-dragging") || b.destroy());
		}));
	}, e.prototype.destroy = function (c) {
		var d = this;c || d.$el.trigger("onBeforeClose.lg"), a(b).scrollTop(d.prevScrollTop), c && (d.s.dynamic || this.$items.off("click.lg click.lgcustom"), a.removeData(d.el, "lightGallery")), this.$el.off(".lg.tm"), a.each(a.fn.lightGallery.modules, function (a) {
			d.modules[a] && d.modules[a].destroy();
		}), this.lGalleryOn = !1, clearTimeout(d.hideBartimeout), this.hideBartimeout = !1, a(b).off(".lg"), a("body").removeClass("lg-on lg-from-hash"), d.$outer && d.$outer.removeClass("lg-visible"), a(".lg-backdrop").removeClass("in"), setTimeout(function () {
			d.$outer && d.$outer.remove(), a(".lg-backdrop").remove(), c || d.$el.trigger("onCloseAfter.lg");
		}, d.s.backdropDuration + 50);
	}, a.fn.lightGallery = function (b) {
		return this.each(function () {
			if (a.data(this, "lightGallery")) try {
				a(this).data("lightGallery").init();
			} catch (c) {
				console.error("lightGallery has not initiated properly");
			} else a.data(this, "lightGallery", new e(this, b));
		});
	}, a.fn.lightGallery.modules = {};
}(jQuery, window, document), function (a, b, c, d) {
	"use strict";
	var e = { autoplay: !1, pause: 5e3, progressBar: !0, fourceAutoplay: !1, autoplayControls: !0, appendAutoplayControlsTo: ".lg-toolbar" },
	    f = function f(b) {
		return this.core = a(b).data("lightGallery"), this.$el = a(b), this.core.$items.length < 2 ? !1 : (this.core.s = a.extend({}, e, this.core.s), this.interval = !1, this.fromAuto = !0, this.canceledOnTouch = !1, this.fourceAutoplayTemp = this.core.s.fourceAutoplay, this.core.doCss() || (this.core.s.progressBar = !1), this.init(), this);
	};f.prototype.init = function () {
		var a = this;a.core.s.autoplayControls && a.controls(), a.core.s.progressBar && a.core.$outer.find(".lg").append('<div class="lg-progress-bar"><div class="lg-progress"></div></div>'), a.progress(), a.core.s.autoplay && a.startlAuto(), a.$el.on("onDragstart.lg.tm touchstart.lg.tm", function () {
			a.interval && (a.cancelAuto(), a.canceledOnTouch = !0);
		}), a.$el.on("onDragend.lg.tm touchend.lg.tm onSlideClick.lg.tm", function () {
			!a.interval && a.canceledOnTouch && (a.startlAuto(), a.canceledOnTouch = !1);
		});
	}, f.prototype.progress = function () {
		var a,
		    b,
		    c = this;c.$el.on("onBeforeSlide.lg.tm", function () {
			c.core.s.progressBar && c.fromAuto && (a = c.core.$outer.find(".lg-progress-bar"), b = c.core.$outer.find(".lg-progress"), c.interval && (b.removeAttr("style"), a.removeClass("lg-start"), setTimeout(function () {
				b.css("transition", "width " + (c.core.s.speed + c.core.s.pause) + "ms ease 0s"), a.addClass("lg-start");
			}, 20))), c.fromAuto || c.core.s.fourceAutoplay || c.cancelAuto(), c.fromAuto = !1;
		});
	}, f.prototype.controls = function () {
		var b = this,
		    c = '<span class="lg-autoplay-button lg-icon"></span>';a(this.core.s.appendAutoplayControlsTo).append(c), b.core.$outer.find(".lg-autoplay-button").on("click.lg", function () {
			a(b.core.$outer).hasClass("lg-show-autoplay") ? (b.cancelAuto(), b.core.s.fourceAutoplay = !1) : b.interval || (b.startlAuto(), b.core.s.fourceAutoplay = b.fourceAutoplayTemp);
		});
	}, f.prototype.startlAuto = function () {
		var a = this;a.core.$outer.find(".lg-progress").css("transition", "width " + (a.core.s.speed + a.core.s.pause) + "ms ease 0s"), a.core.$outer.addClass("lg-show-autoplay"), a.core.$outer.find(".lg-progress-bar").addClass("lg-start"), a.interval = setInterval(function () {
			a.core.index + 1 < a.core.$items.length ? a.core.index = a.core.index : a.core.index = -1, a.core.index++, a.fromAuto = !0, a.core.slide(a.core.index, !1, !1);
		}, a.core.s.speed + a.core.s.pause);
	}, f.prototype.cancelAuto = function () {
		clearInterval(this.interval), this.interval = !1, this.core.$outer.find(".lg-progress").removeAttr("style"), this.core.$outer.removeClass("lg-show-autoplay"), this.core.$outer.find(".lg-progress-bar").removeClass("lg-start");
	}, f.prototype.destroy = function () {
		this.cancelAuto(), this.core.$outer.find(".lg-progress-bar").remove();
	}, a.fn.lightGallery.modules.autoplay = f;
}(jQuery, window, document), function (a, b, c, d) {
	"use strict";
	var e = { fullScreen: !0 },
	    f = function f(b) {
		return this.core = a(b).data("lightGallery"), this.$el = a(b), this.core.s = a.extend({}, e, this.core.s), this.init(), this;
	};f.prototype.init = function () {
		var a = "";if (this.core.s.fullScreen) {
			if (!(c.fullscreenEnabled || c.webkitFullscreenEnabled || c.mozFullScreenEnabled || c.msFullscreenEnabled)) return;a = '<span class="lg-fullscreen lg-icon"></span>', this.core.$outer.find(".lg-toolbar").append(a), this.fullScreen();
		}
	}, f.prototype.requestFullscreen = function () {
		var a = c.documentElement;a.requestFullscreen ? a.requestFullscreen() : a.msRequestFullscreen ? a.msRequestFullscreen() : a.mozRequestFullScreen ? a.mozRequestFullScreen() : a.webkitRequestFullscreen && a.webkitRequestFullscreen();
	}, f.prototype.exitFullscreen = function () {
		c.exitFullscreen ? c.exitFullscreen() : c.msExitFullscreen ? c.msExitFullscreen() : c.mozCancelFullScreen ? c.mozCancelFullScreen() : c.webkitExitFullscreen && c.webkitExitFullscreen();
	}, f.prototype.fullScreen = function () {
		var b = this;a(c).on("fullscreenchange.lg webkitfullscreenchange.lg mozfullscreenchange.lg MSFullscreenChange.lg", function () {
			b.core.$outer.toggleClass("lg-fullscreen-on");
		}), this.core.$outer.find(".lg-fullscreen").on("click.lg", function () {
			c.fullscreenElement || c.mozFullScreenElement || c.webkitFullscreenElement || c.msFullscreenElement ? b.exitFullscreen() : b.requestFullscreen();
		});
	}, f.prototype.destroy = function () {
		this.exitFullscreen(), a(c).off("fullscreenchange.lg webkitfullscreenchange.lg mozfullscreenchange.lg MSFullscreenChange.lg");
	}, a.fn.lightGallery.modules.fullscreen = f;
}(jQuery, window, document), function (a, b, c, d) {
	"use strict";
	var e = { pager: !1 },
	    f = function f(b) {
		return this.core = a(b).data("lightGallery"), this.$el = a(b), this.core.s = a.extend({}, e, this.core.s), this.core.s.pager && this.core.$items.length > 1 && this.init(), this;
	};f.prototype.init = function () {
		var b,
		    c,
		    d,
		    e = this,
		    f = "";if (e.core.$outer.find(".lg").append('<div class="lg-pager-outer"></div>'), e.core.s.dynamic) for (var g = 0; g < e.core.s.dynamicEl.length; g++) {
			f += '<span class="lg-pager-cont"> <span class="lg-pager"></span><div class="lg-pager-thumb-cont"><span class="lg-caret"></span> <img src="' + e.core.s.dynamicEl[g].thumb + '" /></div></span>';
		} else e.core.$items.each(function () {
			f += e.core.s.exThumbImage ? '<span class="lg-pager-cont"> <span class="lg-pager"></span><div class="lg-pager-thumb-cont"><span class="lg-caret"></span> <img src="' + a(this).attr(e.core.s.exThumbImage) + '" /></div></span>' : '<span class="lg-pager-cont"> <span class="lg-pager"></span><div class="lg-pager-thumb-cont"><span class="lg-caret"></span> <img src="' + a(this).find("img").attr("src") + '" /></div></span>';
		});c = e.core.$outer.find(".lg-pager-outer"), c.html(f), b = e.core.$outer.find(".lg-pager-cont"), b.on("click.lg touchend.lg", function () {
			var b = a(this);e.core.index = b.index(), e.core.slide(e.core.index, !1, !1);
		}), c.on("mouseover.lg", function () {
			clearTimeout(d), c.addClass("lg-pager-hover");
		}), c.on("mouseout.lg", function () {
			d = setTimeout(function () {
				c.removeClass("lg-pager-hover");
			});
		}), e.core.$el.on("onBeforeSlide.lg.tm", function (a, c, d) {
			b.removeClass("lg-pager-active"), b.eq(d).addClass("lg-pager-active");
		});
	}, f.prototype.destroy = function () {}, a.fn.lightGallery.modules.pager = f;
}(jQuery, window, document), function (a, b, c, d) {
	"use strict";
	var e = { thumbnail: !0, animateThumb: !0, currentPagerPosition: "middle", thumbWidth: 100, thumbContHeight: 100, thumbMargin: 5, exThumbImage: !1, showThumbByDefault: !0, toogleThumb: !0, pullCaptionUp: !0, enableThumbDrag: !0, enableThumbSwipe: !0, swipeThreshold: 50, loadYoutubeThumbnail: !0, youtubeThumbSize: 1, loadVimeoThumbnail: !0, vimeoThumbSize: "thumbnail_small", loadDailymotionThumbnail: !0 },
	    f = function f(b) {
		return this.core = a(b).data("lightGallery"), this.core.s = a.extend({}, e, this.core.s), this.$el = a(b), this.$thumbOuter = null, this.thumbOuterWidth = 0, this.thumbTotalWidth = this.core.$items.length * (this.core.s.thumbWidth + this.core.s.thumbMargin), this.thumbIndex = this.core.index, this.left = 0, this.init(), this;
	};f.prototype.init = function () {
		var a = this;this.core.s.thumbnail && this.core.$items.length > 1 && (this.core.s.showThumbByDefault && setTimeout(function () {
			a.core.$outer.addClass("lg-thumb-open");
		}, 700), this.core.s.pullCaptionUp && this.core.$outer.addClass("lg-pull-caption-up"), this.build(), this.core.s.animateThumb ? (this.core.s.enableThumbDrag && !this.core.isTouch && this.core.doCss() && this.enableThumbDrag(), this.core.s.enableThumbSwipe && this.core.isTouch && this.core.doCss() && this.enableThumbSwipe(), this.thumbClickable = !1) : this.thumbClickable = !0, this.toogle(), this.thumbkeyPress());
	}, f.prototype.build = function () {
		function c(a, b, c) {
			var d,
			    h = e.core.isVideo(a, c) || {},
			    i = "";h.youtube || h.vimeo || h.dailymotion ? h.youtube ? d = e.core.s.loadYoutubeThumbnail ? "//img.youtube.com/vi/" + h.youtube[1] + "/" + e.core.s.youtubeThumbSize + ".jpg" : b : h.vimeo ? e.core.s.loadVimeoThumbnail ? (d = "//i.vimeocdn.com/video/error_" + g + ".jpg", i = h.vimeo[1]) : d = b : h.dailymotion && (d = e.core.s.loadDailymotionThumbnail ? "//www.dailymotion.com/thumbnail/video/" + h.dailymotion[1] : b) : d = b, f += '<div data-vimeo-id="' + i + '" class="lg-thumb-item" style="width:' + e.core.s.thumbWidth + "px; margin-right: " + e.core.s.thumbMargin + 'px"><img src="' + d + '" /></div>', i = "";
		}var d,
		    e = this,
		    f = "",
		    g = "",
		    h = '<div class="lg-thumb-outer"><div class="lg-thumb group"></div></div>';switch (this.core.s.vimeoThumbSize) {case "thumbnail_large":
				g = "640";break;case "thumbnail_medium":
				g = "200x150";break;case "thumbnail_small":
				g = "100x75";}if (e.core.$outer.addClass("lg-has-thumb"), e.core.$outer.find(".lg").append(h), e.$thumbOuter = e.core.$outer.find(".lg-thumb-outer"), e.thumbOuterWidth = e.$thumbOuter.width(), e.core.s.animateThumb && e.core.$outer.find(".lg-thumb").css({ width: e.thumbTotalWidth + "px", position: "relative" }), this.core.s.animateThumb && e.$thumbOuter.css("height", e.core.s.thumbContHeight + "px"), e.core.s.dynamic) for (var i = 0; i < e.core.s.dynamicEl.length; i++) {
			c(e.core.s.dynamicEl[i].src, e.core.s.dynamicEl[i].thumb, i);
		} else e.core.$items.each(function (b) {
			e.core.s.exThumbImage ? c(a(this).attr("href") || a(this).attr("data-src"), a(this).attr(e.core.s.exThumbImage), b) : c(a(this).attr("href") || a(this).attr("data-src"), a(this).find("img").attr("src"), b);
		});e.core.$outer.find(".lg-thumb").html(f), d = e.core.$outer.find(".lg-thumb-item"), d.each(function () {
			var b = a(this),
			    c = b.attr("data-vimeo-id");c && a.getJSON("//www.vimeo.com/api/v2/video/" + c + ".json?callback=?", { format: "json" }, function (a) {
				b.find("img").attr("src", a[0][e.core.s.vimeoThumbSize]);
			});
		}), d.eq(e.core.index).addClass("active"), e.core.$el.on("onBeforeSlide.lg.tm", function () {
			d.removeClass("active"), d.eq(e.core.index).addClass("active");
		}), d.on("click.lg touchend.lg", function () {
			var b = a(this);setTimeout(function () {
				(e.thumbClickable && !e.core.lgBusy || !e.core.doCss()) && (e.core.index = b.index(), e.core.slide(e.core.index, !1, !0));
			}, 50);
		}), e.core.$el.on("onBeforeSlide.lg.tm", function () {
			e.animateThumb(e.core.index);
		}), a(b).on("resize.lg.thumb orientationchange.lg.thumb", function () {
			setTimeout(function () {
				e.animateThumb(e.core.index), e.thumbOuterWidth = e.$thumbOuter.width();
			}, 200);
		});
	}, f.prototype.setTranslate = function (a) {
		this.core.$outer.find(".lg-thumb").css({ transform: "translate3d(-" + a + "px, 0px, 0px)" });
	}, f.prototype.animateThumb = function (a) {
		var b = this.core.$outer.find(".lg-thumb");if (this.core.s.animateThumb) {
			var c;switch (this.core.s.currentPagerPosition) {case "left":
					c = 0;break;case "middle":
					c = this.thumbOuterWidth / 2 - this.core.s.thumbWidth / 2;break;case "right":
					c = this.thumbOuterWidth - this.core.s.thumbWidth;}this.left = (this.core.s.thumbWidth + this.core.s.thumbMargin) * a - 1 - c, this.left > this.thumbTotalWidth - this.thumbOuterWidth && (this.left = this.thumbTotalWidth - this.thumbOuterWidth), this.left < 0 && (this.left = 0), this.core.lGalleryOn ? (b.hasClass("on") || this.core.$outer.find(".lg-thumb").css("transition-duration", this.core.s.speed + "ms"), this.core.doCss() || b.animate({ left: -this.left + "px" }, this.core.s.speed)) : this.core.doCss() || b.css("left", -this.left + "px"), this.setTranslate(this.left);
		}
	}, f.prototype.enableThumbDrag = function () {
		var c = this,
		    d = 0,
		    e = 0,
		    f = !1,
		    g = !1,
		    h = 0;c.$thumbOuter.addClass("lg-grab"), c.core.$outer.find(".lg-thumb").on("mousedown.lg.thumb", function (a) {
			c.thumbTotalWidth > c.thumbOuterWidth && (a.preventDefault(), d = a.pageX, f = !0, c.core.$outer.scrollLeft += 1, c.core.$outer.scrollLeft -= 1, c.thumbClickable = !1, c.$thumbOuter.removeClass("lg-grab").addClass("lg-grabbing"));
		}), a(b).on("mousemove.lg.thumb", function (a) {
			f && (h = c.left, g = !0, e = a.pageX, c.$thumbOuter.addClass("lg-dragging"), h -= e - d, h > c.thumbTotalWidth - c.thumbOuterWidth && (h = c.thumbTotalWidth - c.thumbOuterWidth), 0 > h && (h = 0), c.setTranslate(h));
		}), a(b).on("mouseup.lg.thumb", function () {
			g ? (g = !1, c.$thumbOuter.removeClass("lg-dragging"), c.left = h, Math.abs(e - d) < c.core.s.swipeThreshold && (c.thumbClickable = !0)) : c.thumbClickable = !0, f && (f = !1, c.$thumbOuter.removeClass("lg-grabbing").addClass("lg-grab"));
		});
	}, f.prototype.enableThumbSwipe = function () {
		var a = this,
		    b = 0,
		    c = 0,
		    d = !1,
		    e = 0;a.core.$outer.find(".lg-thumb").on("touchstart.lg", function (c) {
			a.thumbTotalWidth > a.thumbOuterWidth && (c.preventDefault(), b = c.originalEvent.targetTouches[0].pageX, a.thumbClickable = !1);
		}), a.core.$outer.find(".lg-thumb").on("touchmove.lg", function (f) {
			a.thumbTotalWidth > a.thumbOuterWidth && (f.preventDefault(), c = f.originalEvent.targetTouches[0].pageX, d = !0, a.$thumbOuter.addClass("lg-dragging"), e = a.left, e -= c - b, e > a.thumbTotalWidth - a.thumbOuterWidth && (e = a.thumbTotalWidth - a.thumbOuterWidth), 0 > e && (e = 0), a.setTranslate(e));
		}), a.core.$outer.find(".lg-thumb").on("touchend.lg", function () {
			a.thumbTotalWidth > a.thumbOuterWidth && d ? (d = !1, a.$thumbOuter.removeClass("lg-dragging"), Math.abs(c - b) < a.core.s.swipeThreshold && (a.thumbClickable = !0), a.left = e) : a.thumbClickable = !0;
		});
	}, f.prototype.toogle = function () {
		var a = this;a.core.s.toogleThumb && (a.core.$outer.addClass("lg-can-toggle"), a.$thumbOuter.append('<span class="lg-toogle-thumb lg-icon"></span>'), a.core.$outer.find(".lg-toogle-thumb").on("click.lg", function () {
			a.core.$outer.toggleClass("lg-thumb-open");
		}));
	}, f.prototype.thumbkeyPress = function () {
		var c = this;a(b).on("keydown.lg.thumb", function (a) {
			38 === a.keyCode ? (a.preventDefault(), c.core.$outer.addClass("lg-thumb-open")) : 40 === a.keyCode && (a.preventDefault(), c.core.$outer.removeClass("lg-thumb-open"));
		});
	}, f.prototype.destroy = function () {
		this.core.s.thumbnail && this.core.$items.length > 1 && (a(b).off("resize.lg.thumb orientationchange.lg.thumb keydown.lg.thumb"), this.$thumbOuter.remove(), this.core.$outer.removeClass("lg-has-thumb"));
	}, a.fn.lightGallery.modules.Thumbnail = f;
}(jQuery, window, document), function (a, b, c, d) {
	"use strict";
	var e = { videoMaxWidth: "855px", youtubePlayerParams: !1, vimeoPlayerParams: !1, dailymotionPlayerParams: !1, vkPlayerParams: !1, videojs: !1, videojsOptions: {} },
	    f = function f(b) {
		return this.core = a(b).data("lightGallery"), this.$el = a(b), this.core.s = a.extend({}, e, this.core.s), this.videoLoaded = !1, this.init(), this;
	};f.prototype.init = function () {
		var b = this;b.core.$el.on("hasVideo.lg.tm", function (a, c, d, e) {
			if (b.core.$slide.eq(c).find(".lg-video").append(b.loadVideo(d, "lg-object", !0, c, e)), e) if (b.core.s.videojs) try {
				videojs(b.core.$slide.eq(c).find(".lg-html5").get(0), b.core.s.videojsOptions, function () {
					b.videoLoaded || this.play();
				});
			} catch (f) {
				console.error("Make sure you have included videojs");
			} else b.core.$slide.eq(c).find(".lg-html5").get(0).play();
		}), b.core.$el.on("onAferAppendSlide.lg.tm", function (a, c) {
			b.core.$slide.eq(c).find(".lg-video-cont").css("max-width", b.core.s.videoMaxWidth), b.videoLoaded = !0;
		});var c = function c(a) {
			if (a.find(".lg-object").hasClass("lg-has-poster") && a.find(".lg-object").is(":visible")) if (a.hasClass("lg-has-video")) {
				var c = a.find(".lg-youtube").get(0),
				    d = a.find(".lg-vimeo").get(0),
				    e = a.find(".lg-dailymotion").get(0),
				    f = a.find(".lg-html5").get(0);if (c) c.contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', "*");else if (d) try {
					$f(d).api("play");
				} catch (g) {
					console.error("Make sure you have included froogaloop2 js");
				} else if (e) e.contentWindow.postMessage("play", "*");else if (f) if (b.core.s.videojs) try {
					videojs(f).play();
				} catch (g) {
					console.error("Make sure you have included videojs");
				} else f.play();a.addClass("lg-video-playing");
			} else {
				a.addClass("lg-video-playing lg-has-video");
				var h,
				    i,
				    j = function j(c, d) {
					if (a.find(".lg-video").append(b.loadVideo(c, "", !1, b.core.index, d)), d) if (b.core.s.videojs) try {
						videojs(b.core.$slide.eq(b.core.index).find(".lg-html5").get(0), b.core.s.videojsOptions, function () {
							this.play();
						});
					} catch (e) {
						console.error("Make sure you have included videojs");
					} else b.core.$slide.eq(b.core.index).find(".lg-html5").get(0).play();
				};b.core.s.dynamic ? (h = b.core.s.dynamicEl[b.core.index].src, i = b.core.s.dynamicEl[b.core.index].html, j(h, i)) : (h = b.core.$items.eq(b.core.index).attr("href") || b.core.$items.eq(b.core.index).attr("data-src"), i = b.core.$items.eq(b.core.index).attr("data-html"), j(h, i));var k = a.find(".lg-object");a.find(".lg-video").append(k), a.find(".lg-video-object").hasClass("lg-html5") || (a.removeClass("lg-complete"), a.find(".lg-video-object").on("load.lg error.lg", function () {
					a.addClass("lg-complete");
				}));
			}
		};b.core.doCss() && b.core.$items.length > 1 && (b.core.s.enableSwipe && b.core.isTouch || b.core.s.enableDrag && !b.core.isTouch) ? b.core.$el.on("onSlideClick.lg.tm", function () {
			var a = b.core.$slide.eq(b.core.index);c(a);
		}) : b.core.$slide.on("click.lg", function () {
			c(a(this));
		}), b.core.$el.on("onBeforeSlide.lg.tm", function (c, d, e) {
			var f = b.core.$slide.eq(d),
			    g = f.find(".lg-youtube").get(0),
			    h = f.find(".lg-vimeo").get(0),
			    i = f.find(".lg-dailymotion").get(0),
			    j = f.find(".lg-vk").get(0),
			    k = f.find(".lg-html5").get(0);if (g) g.contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', "*");else if (h) try {
				$f(h).api("pause");
			} catch (l) {
				console.error("Make sure you have included froogaloop2 js");
			} else if (i) i.contentWindow.postMessage("pause", "*");else if (k) if (b.core.s.videojs) try {
				videojs(k).pause();
			} catch (l) {
				console.error("Make sure you have included videojs");
			} else k.pause();j && a(j).attr("src", a(j).attr("src").replace("&autoplay", "&noplay"));var m;m = b.core.s.dynamic ? b.core.s.dynamicEl[e].src : b.core.$items.eq(e).attr("href") || b.core.$items.eq(e).attr("data-src");var n = b.core.isVideo(m, e) || {};(n.youtube || n.vimeo || n.dailymotion || n.vk) && b.core.$outer.addClass("lg-hide-download");
		}), b.core.$el.on("onAfterSlide.lg.tm", function (a, c) {
			b.core.$slide.eq(c).removeClass("lg-video-playing");
		});
	}, f.prototype.loadVideo = function (b, c, d, e, f) {
		var g = "",
		    h = 1,
		    i = "",
		    j = this.core.isVideo(b, e) || {};if (d && (h = this.videoLoaded ? 0 : 1), j.youtube) i = "?wmode=opaque&autoplay=" + h + "&enablejsapi=1", this.core.s.youtubePlayerParams && (i = i + "&" + a.param(this.core.s.youtubePlayerParams)), g = '<iframe class="lg-video-object lg-youtube ' + c + '" width="560" height="315" src="//www.youtube.com/embed/' + j.youtube[1] + i + '" frameborder="0" allowfullscreen></iframe>';else if (j.vimeo) i = "?autoplay=" + h + "&api=1", this.core.s.vimeoPlayerParams && (i = i + "&" + a.param(this.core.s.vimeoPlayerParams)), g = '<iframe class="lg-video-object lg-vimeo ' + c + '" width="560" height="315"  src="//player.vimeo.com/video/' + j.vimeo[1] + i + '" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>';else if (j.dailymotion) i = "?wmode=opaque&autoplay=" + h + "&api=postMessage", this.core.s.dailymotionPlayerParams && (i = i + "&" + a.param(this.core.s.dailymotionPlayerParams)), g = '<iframe class="lg-video-object lg-dailymotion ' + c + '" width="560" height="315" src="//www.dailymotion.com/embed/video/' + j.dailymotion[1] + i + '" frameborder="0" allowfullscreen></iframe>';else if (j.html5) {
			var k = f.substring(0, 1);"." !== k && "#" !== k || (f = a(f).html()), g = f;
		} else j.vk && (i = "&autoplay=" + h, this.core.s.vkPlayerParams && (i = i + "&" + a.param(this.core.s.vkPlayerParams)), g = '<iframe class="lg-video-object lg-vk ' + c + '" width="560" height="315" src="http://vk.com/video_ext.php?' + j.vk[1] + i + '" frameborder="0" allowfullscreen></iframe>');return g;
	}, f.prototype.destroy = function () {
		this.videoLoaded = !1;
	}, a.fn.lightGallery.modules.video = f;
}(jQuery, window, document), function (a, b, c, d) {
	"use strict";
	var e = { scale: 1, zoom: !0, actualSize: !0, enableZoomAfter: 300 },
	    f = function f(c) {
		return this.core = a(c).data("lightGallery"), this.core.s = a.extend({}, e, this.core.s), this.core.s.zoom && this.core.doCss() && (this.init(), this.zoomabletimeout = !1, this.pageX = a(b).width() / 2, this.pageY = a(b).height() / 2 + a(b).scrollTop()), this;
	};f.prototype.init = function () {
		var c = this,
		    d = '<span id="lg-zoom-in" class="lg-icon"></span><span id="lg-zoom-out" class="lg-icon"></span>';c.core.s.actualSize && (d += '<span id="lg-actual-size" class="lg-icon"></span>'), this.core.$outer.find(".lg-toolbar").append(d), c.core.$el.on("onSlideItemLoad.lg.tm.zoom", function (b, d, e) {
			var f = c.core.s.enableZoomAfter + e;a("body").hasClass("lg-from-hash") && e ? f = 0 : a("body").removeClass("lg-from-hash"), c.zoomabletimeout = setTimeout(function () {
				c.core.$slide.eq(d).addClass("lg-zoomable");
			}, f + 30);
		});var e = 1,
		    f = function f(d) {
			var e,
			    f,
			    g = c.core.$outer.find(".lg-current .lg-image"),
			    h = (a(b).width() - g.width()) / 2,
			    i = (a(b).height() - g.height()) / 2 + a(b).scrollTop();e = c.pageX - h, f = c.pageY - i;var j = (d - 1) * e,
			    k = (d - 1) * f;g.css("transform", "scale3d(" + d + ", " + d + ", 1)").attr("data-scale", d), g.parent().css({ left: -j + "px", top: -k + "px" }).attr("data-x", j).attr("data-y", k);
		},
		    g = function g() {
			e > 1 ? c.core.$outer.addClass("lg-zoomed") : c.resetZoom(), 1 > e && (e = 1), f(e);
		},
		    h = function (_h) {
			function h(_x, _x2, _x3, _x4) {
				return _h.apply(this, arguments);
			}

			h.toString = function () {
				return _h.toString();
			};

			return h;
		}(function (d, f, h, i) {
			var j,
			    k = f.width();j = c.core.s.dynamic ? c.core.s.dynamicEl[h].width || f[0].naturalWidth || k : c.core.$items.eq(h).attr("data-width") || f[0].naturalWidth || k;var l;c.core.$outer.hasClass("lg-zoomed") ? e = 1 : j > k && (l = j / k, e = l || 2), i ? (c.pageX = a(b).width() / 2, c.pageY = a(b).height() / 2 + a(b).scrollTop()) : (c.pageX = d.pageX || d.originalEvent.targetTouches[0].pageX, c.pageY = d.pageY || d.originalEvent.targetTouches[0].pageY), g(), setTimeout(function () {
				c.core.$outer.removeClass("lg-grabbing").addClass("lg-grab");
			}, 10);
		}),
		    i = !1;c.core.$el.on("onAferAppendSlide.lg.tm.zoom", function (a, b) {
			var d = c.core.$slide.eq(b).find(".lg-image");d.on("dblclick", function (a) {
				h(a, d, b);
			}), d.on("touchstart", function (a) {
				i ? (clearTimeout(i), i = null, h(a, d, b)) : i = setTimeout(function () {
					i = null;
				}, 300), a.preventDefault();
			});
		}), a(b).on("resize.lg.zoom scroll.lg.zoom orientationchange.lg.zoom", function () {
			c.pageX = a(b).width() / 2, c.pageY = a(b).height() / 2 + a(b).scrollTop(), f(e);
		}), a("#lg-zoom-out").on("click.lg", function () {
			c.core.$outer.find(".lg-current .lg-image").length && (e -= c.core.s.scale, g());
		}), a("#lg-zoom-in").on("click.lg", function () {
			c.core.$outer.find(".lg-current .lg-image").length && (e += c.core.s.scale, g());
		}), a("#lg-actual-size").on("click.lg", function (a) {
			h(a, c.core.$slide.eq(c.core.index).find(".lg-image"), c.core.index, !0);
		}), c.core.$el.on("onBeforeSlide.lg.tm", function () {
			e = 1, c.resetZoom();
		}), c.core.isTouch || c.zoomDrag(), c.core.isTouch && c.zoomSwipe();
	}, f.prototype.resetZoom = function () {
		this.core.$outer.removeClass("lg-zoomed"), this.core.$slide.find(".lg-img-wrap").removeAttr("style data-x data-y"), this.core.$slide.find(".lg-image").removeAttr("style data-scale"), this.pageX = a(b).width() / 2, this.pageY = a(b).height() / 2 + a(b).scrollTop();
	}, f.prototype.zoomSwipe = function () {
		var a = this,
		    b = {},
		    c = {},
		    d = !1,
		    e = !1,
		    f = !1;a.core.$slide.on("touchstart.lg", function (c) {
			if (a.core.$outer.hasClass("lg-zoomed")) {
				var d = a.core.$slide.eq(a.core.index).find(".lg-object");f = d.outerHeight() * d.attr("data-scale") > a.core.$outer.find(".lg").height(), e = d.outerWidth() * d.attr("data-scale") > a.core.$outer.find(".lg").width(), (e || f) && (c.preventDefault(), b = { x: c.originalEvent.targetTouches[0].pageX, y: c.originalEvent.targetTouches[0].pageY });
			}
		}), a.core.$slide.on("touchmove.lg", function (g) {
			if (a.core.$outer.hasClass("lg-zoomed")) {
				var h,
				    i,
				    j = a.core.$slide.eq(a.core.index).find(".lg-img-wrap");g.preventDefault(), d = !0, c = { x: g.originalEvent.targetTouches[0].pageX, y: g.originalEvent.targetTouches[0].pageY }, a.core.$outer.addClass("lg-zoom-dragging"), i = f ? -Math.abs(j.attr("data-y")) + (c.y - b.y) : -Math.abs(j.attr("data-y")), h = e ? -Math.abs(j.attr("data-x")) + (c.x - b.x) : -Math.abs(j.attr("data-x")), (Math.abs(c.x - b.x) > 15 || Math.abs(c.y - b.y) > 15) && j.css({ left: h + "px", top: i + "px" });
			}
		}), a.core.$slide.on("touchend.lg", function () {
			a.core.$outer.hasClass("lg-zoomed") && d && (d = !1, a.core.$outer.removeClass("lg-zoom-dragging"), a.touchendZoom(b, c, e, f));
		});
	}, f.prototype.zoomDrag = function () {
		var c = this,
		    d = {},
		    e = {},
		    f = !1,
		    g = !1,
		    h = !1,
		    i = !1;c.core.$slide.on("mousedown.lg.zoom", function (b) {
			var e = c.core.$slide.eq(c.core.index).find(".lg-object");i = e.outerHeight() * e.attr("data-scale") > c.core.$outer.find(".lg").height(), h = e.outerWidth() * e.attr("data-scale") > c.core.$outer.find(".lg").width(), c.core.$outer.hasClass("lg-zoomed") && a(b.target).hasClass("lg-object") && (h || i) && (b.preventDefault(), d = { x: b.pageX, y: b.pageY }, f = !0, c.core.$outer.scrollLeft += 1, c.core.$outer.scrollLeft -= 1, c.core.$outer.removeClass("lg-grab").addClass("lg-grabbing"));
		}), a(b).on("mousemove.lg.zoom", function (a) {
			if (f) {
				var b,
				    j,
				    k = c.core.$slide.eq(c.core.index).find(".lg-img-wrap");g = !0, e = { x: a.pageX, y: a.pageY }, c.core.$outer.addClass("lg-zoom-dragging"), j = i ? -Math.abs(k.attr("data-y")) + (e.y - d.y) : -Math.abs(k.attr("data-y")), b = h ? -Math.abs(k.attr("data-x")) + (e.x - d.x) : -Math.abs(k.attr("data-x")), k.css({ left: b + "px", top: j + "px" });
			}
		}), a(b).on("mouseup.lg.zoom", function (a) {
			f && (f = !1, c.core.$outer.removeClass("lg-zoom-dragging"), !g || d.x === e.x && d.y === e.y || (e = { x: a.pageX, y: a.pageY }, c.touchendZoom(d, e, h, i)), g = !1), c.core.$outer.removeClass("lg-grabbing").addClass("lg-grab");
		});
	}, f.prototype.touchendZoom = function (a, b, c, d) {
		var e = this,
		    f = e.core.$slide.eq(e.core.index).find(".lg-img-wrap"),
		    g = e.core.$slide.eq(e.core.index).find(".lg-object"),
		    h = -Math.abs(f.attr("data-x")) + (b.x - a.x),
		    i = -Math.abs(f.attr("data-y")) + (b.y - a.y),
		    j = (e.core.$outer.find(".lg").height() - g.outerHeight()) / 2,
		    k = Math.abs(g.outerHeight() * Math.abs(g.attr("data-scale")) - e.core.$outer.find(".lg").height() + j),
		    l = (e.core.$outer.find(".lg").width() - g.outerWidth()) / 2,
		    m = Math.abs(g.outerWidth() * Math.abs(g.attr("data-scale")) - e.core.$outer.find(".lg").width() + l);(Math.abs(b.x - a.x) > 15 || Math.abs(b.y - a.y) > 15) && (d && (-k >= i ? i = -k : i >= -j && (i = -j)), c && (-m >= h ? h = -m : h >= -l && (h = -l)), d ? f.attr("data-y", Math.abs(i)) : i = -Math.abs(f.attr("data-y")), c ? f.attr("data-x", Math.abs(h)) : h = -Math.abs(f.attr("data-x")), f.css({ left: h + "px", top: i + "px" }));
	}, f.prototype.destroy = function () {
		var c = this;c.core.$el.off(".lg.zoom"), a(b).off(".lg.zoom"), c.core.$slide.off(".lg.zoom"), c.core.$el.off(".lg.tm.zoom"), c.resetZoom(), clearTimeout(c.zoomabletimeout), c.zoomabletimeout = !1;
	}, a.fn.lightGallery.modules.zoom = f;
}(jQuery, window, document), function (a, b, c, d) {
	"use strict";
	var e = { hash: !0 },
	    f = function f(c) {
		return this.core = a(c).data("lightGallery"), this.core.s = a.extend({}, e, this.core.s), this.core.s.hash && (this.oldHash = b.location.hash, this.init()), this;
	};f.prototype.init = function () {
		var c,
		    d = this;d.core.$el.on("onAfterSlide.lg.tm", function (a, c, e) {
			b.location.hash = "lg=" + d.core.s.galleryId + "&slide=" + e;
		}), a(b).on("hashchange.lg.hash", function () {
			c = b.location.hash;var a = parseInt(c.split("&slide=")[1], 10);c.indexOf("lg=" + d.core.s.galleryId) > -1 ? d.core.slide(a, !1, !1) : d.core.lGalleryOn && d.core.destroy();
		});
	}, f.prototype.destroy = function () {
		this.core.s.hash && (this.oldHash && this.oldHash.indexOf("lg=" + this.core.s.galleryId) < 0 ? b.location.hash = this.oldHash : history.pushState ? history.pushState("", c.title, b.location.pathname + b.location.search) : b.location.hash = "", this.core.$el.off(".lg.hash"));
	}, a.fn.lightGallery.modules.hash = f;
}(jQuery, window, document);
/*!
* jquery.inputmask.bundle.js
* https://github.com/RobinHerbots/Inputmask
* Copyright (c) 2010 - 2017 Robin Herbots
* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
* Version: 3.3.8
*/

!function (a) {
	function b(d) {
		if (c[d]) return c[d].exports;var e = c[d] = { i: d, l: !1, exports: {} };return a[d].call(e.exports, e, e.exports, b), e.l = !0, e.exports;
	}var c = {};b.m = a, b.c = c, b.i = function (a) {
		return a;
	}, b.d = function (a, c, d) {
		b.o(a, c) || Object.defineProperty(a, c, { configurable: !1, enumerable: !0, get: d });
	}, b.n = function (a) {
		var c = a && a.__esModule ? function () {
			return a.default;
		} : function () {
			return a;
		};return b.d(c, "a", c), c;
	}, b.o = function (a, b) {
		return Object.prototype.hasOwnProperty.call(a, b);
	}, b.p = "", b(b.s = 10);
}([function (a, b, c) {
	"use strict";
	var d, e, f;"function" == typeof Symbol && Symbol.iterator;!function (g) {
		e = [c(2)], d = g, void 0 !== (f = "function" == typeof d ? d.apply(b, e) : d) && (a.exports = f);
	}(function (a) {
		return a;
	});
}, function (a, b, c) {
	"use strict";
	var d,
	    e,
	    f,
	    g = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (a) {
		return typeof a === "undefined" ? "undefined" : _typeof(a);
	} : function (a) {
		return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a === "undefined" ? "undefined" : _typeof(a);
	};!function (g) {
		e = [c(0), c(12), c(11)], d = g, void 0 !== (f = "function" == typeof d ? d.apply(b, e) : d) && (a.exports = f);
	}(function (a, b, c, d) {
		function e(b, c, g) {
			if (!(this instanceof e)) return new e(b, c, g);this.el = d, this.events = {}, this.maskset = d, this.refreshValue = !1, !0 !== g && (a.isPlainObject(b) ? c = b : (c = c || {}, c.alias = b), this.opts = a.extend(!0, {}, this.defaults, c), this.noMasksCache = c && c.definitions !== d, this.userOptions = c || {}, this.isRTL = this.opts.numericInput, f(this.opts.alias, c, this.opts));
		}function f(b, c, g) {
			var h = e.prototype.aliases[b];return h ? (h.alias && f(h.alias, d, g), a.extend(!0, g, h), a.extend(!0, g, c), !0) : (null === g.mask && (g.mask = b), !1);
		}function h(b, c) {
			function f(b, f, g) {
				var h = !1;if (null !== b && "" !== b || (h = null !== g.regex, h ? (b = g.regex, b = b.replace(/^(\^)(.*)(\$)$/, "$2")) : (h = !0, b = ".*")), 1 === b.length && !1 === g.greedy && 0 !== g.repeat && (g.placeholder = ""), g.repeat > 0 || "*" === g.repeat || "+" === g.repeat) {
					var i = "*" === g.repeat ? 0 : "+" === g.repeat ? 1 : g.repeat;b = g.groupmarker.start + b + g.groupmarker.end + g.quantifiermarker.start + i + "," + g.repeat + g.quantifiermarker.end;
				}var j,
				    k = h ? "regex_" + g.regex : g.numericInput ? b.split("").reverse().join("") : b;return e.prototype.masksCache[k] === d || !0 === c ? (j = { mask: b, maskToken: e.prototype.analyseMask(b, h, g), validPositions: {}, _buffer: d, buffer: d, tests: {}, metadata: f, maskLength: d }, !0 !== c && (e.prototype.masksCache[k] = j, j = a.extend(!0, {}, e.prototype.masksCache[k]))) : j = a.extend(!0, {}, e.prototype.masksCache[k]), j;
			}if (a.isFunction(b.mask) && (b.mask = b.mask(b)), a.isArray(b.mask)) {
				if (b.mask.length > 1) {
					b.keepStatic = null === b.keepStatic || b.keepStatic;var g = b.groupmarker.start;return a.each(b.numericInput ? b.mask.reverse() : b.mask, function (c, e) {
						g.length > 1 && (g += b.groupmarker.end + b.alternatormarker + b.groupmarker.start), e.mask === d || a.isFunction(e.mask) ? g += e : g += e.mask;
					}), g += b.groupmarker.end, f(g, b.mask, b);
				}b.mask = b.mask.pop();
			}return b.mask && b.mask.mask !== d && !a.isFunction(b.mask.mask) ? f(b.mask.mask, b.mask, b) : f(b.mask, b.mask, b);
		}function i(f, h, j) {
			function o(a, b, c) {
				b = b || 0;var e,
				    f,
				    g,
				    h = [],
				    i = 0,
				    k = r();do {
					!0 === a && p().validPositions[i] ? (g = p().validPositions[i], f = g.match, e = g.locator.slice(), h.push(!0 === c ? g.input : !1 === c ? f.nativeDef : J(i, f))) : (g = u(i, e, i - 1), f = g.match, e = g.locator.slice(), (!1 === j.jitMasking || i < k || "number" == typeof j.jitMasking && isFinite(j.jitMasking) && j.jitMasking > i) && h.push(!1 === c ? f.nativeDef : J(i, f))), i++;
				} while ((V === d || i < V) && (null !== f.fn || "" !== f.def) || b > i);return "" === h[h.length - 1] && h.pop(), p().maskLength = i + 1, h;
			}function p() {
				return h;
			}function q(a) {
				var b = p();b.buffer = d, !0 !== a && (b.validPositions = {}, b.p = 0);
			}function r(a, b, c) {
				var e = -1,
				    f = -1,
				    g = c || p().validPositions;a === d && (a = -1);for (var h in g) {
					var i = parseInt(h);g[i] && (b || !0 !== g[i].generatedInput) && (i <= a && (e = i), i >= a && (f = i));
				}return -1 !== e && a - e > 1 || f < a ? e : f;
			}function s(b, c, e, f) {
				var g,
				    h = b,
				    i = a.extend(!0, {}, p().validPositions),
				    k = !1;for (p().p = b, g = c - 1; g >= h; g--) {
					p().validPositions[g] !== d && (!0 !== e && (!p().validPositions[g].match.optionality && function (a) {
						var b = p().validPositions[a];if (b !== d && null === b.match.fn) {
							var c = p().validPositions[a - 1],
							    e = p().validPositions[a + 1];return c !== d && e !== d;
						}return !1;
					}(g) || !1 === j.canClearPosition(p(), g, r(), f, j)) || delete p().validPositions[g]);
				}for (q(!0), g = h + 1; g <= r();) {
					for (; p().validPositions[h] !== d;) {
						h++;
					}if (g < h && (g = h + 1), p().validPositions[g] === d && E(g)) g++;else {
						var l = u(g);!1 === k && i[h] && i[h].match.def === l.match.def ? (p().validPositions[h] = a.extend(!0, {}, i[h]), p().validPositions[h].input = l.input, delete p().validPositions[g], g++) : w(h, l.match.def) ? !1 !== D(h, l.input || J(g), !0) && (delete p().validPositions[g], g++, k = !0) : E(g) || (g++, h--), h++;
					}
				}q(!0);
			}function t(a, b) {
				for (var c, e = a, f = r(), g = p().validPositions[f] || x(0)[0], h = g.alternation !== d ? g.locator[g.alternation].toString().split(",") : [], i = 0; i < e.length && (c = e[i], !(c.match && (j.greedy && !0 !== c.match.optionalQuantifier || (!1 === c.match.optionality || !1 === c.match.newBlockMarker) && !0 !== c.match.optionalQuantifier) && (g.alternation === d || g.alternation !== c.alternation || c.locator[g.alternation] !== d && C(c.locator[g.alternation].toString().split(","), h))) || !0 === b && (null !== c.match.fn || /[0-9a-bA-Z]/.test(c.match.def))); i++) {}return c;
			}function u(a, b, c) {
				return p().validPositions[a] || t(x(a, b ? b.slice() : b, c));
			}function v(a) {
				return p().validPositions[a] ? p().validPositions[a] : x(a)[0];
			}function w(a, b) {
				for (var c = !1, d = x(a), e = 0; e < d.length; e++) {
					if (d[e].match && d[e].match.def === b) {
						c = !0;break;
					}
				}return c;
			}function x(b, c, e) {
				function f(c, e, g, i) {
					function l(g, i, q) {
						function r(b, c) {
							var d = 0 === a.inArray(b, c.matches);return d || a.each(c.matches, function (a, e) {
								if (!0 === e.isQuantifier && (d = r(b, c.matches[a - 1]))) return !1;
							}), d;
						}function s(b, c, e) {
							var f, g;if (p().validPositions[b - 1] && e && p().tests[b]) for (var h = p().validPositions[b - 1].locator, i = p().tests[b][0].locator, j = 0; j < e; j++) {
								if (h[j] !== i[j]) return h.slice(e + 1);
							}return (p().tests[b] || p().validPositions[b]) && a.each(p().tests[b] || [p().validPositions[b]], function (a, b) {
								var h = e !== d ? e : b.alternation,
								    i = b.locator[h] !== d ? b.locator[h].toString().indexOf(c) : -1;(g === d || i < g) && -1 !== i && (f = b, g = i);
							}), f ? f.locator.slice((e !== d ? e : f.alternation) + 1) : e !== d ? s(b, c) : d;
						}if (k > 1e4) throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + p().mask;if (k === b && g.matches === d) return m.push({ match: g, locator: i.reverse(), cd: o }), !0;if (g.matches !== d) {
							if (g.isGroup && q !== g) {
								if (g = l(c.matches[a.inArray(g, c.matches) + 1], i)) return !0;
							} else if (g.isOptional) {
								var t = g;if (g = f(g, e, i, q)) {
									if (h = m[m.length - 1].match, !r(h, t)) return !0;n = !0, k = b;
								}
							} else if (g.isAlternator) {
								var u,
								    v = g,
								    w = [],
								    x = m.slice(),
								    y = i.length,
								    z = e.length > 0 ? e.shift() : -1;if (-1 === z || "string" == typeof z) {
									var A,
									    B = k,
									    C = e.slice(),
									    D = [];if ("string" == typeof z) D = z.split(",");else for (A = 0; A < v.matches.length; A++) {
										D.push(A);
									}for (var E = 0; E < D.length; E++) {
										if (A = parseInt(D[E]), m = [], e = s(k, A, y) || C.slice(), !0 !== (g = l(v.matches[A] || c.matches[A], [A].concat(i), q) || g) && g !== d && D[D.length - 1] < v.matches.length) {
											var F = a.inArray(g, c.matches) + 1;c.matches.length > F && (g = l(c.matches[F], [F].concat(i.slice(1, i.length)), q)) && (D.push(F.toString()), a.each(m, function (a, b) {
												b.alternation = i.length - 1;
											}));
										}u = m.slice(), k = B, m = [];for (var G = 0; G < u.length; G++) {
											var H = u[G],
											    I = !1;H.alternation = H.alternation || y;for (var J = 0; J < w.length; J++) {
												var K = w[J];if ("string" != typeof z || -1 !== a.inArray(H.locator[H.alternation].toString(), D)) {
													if (function (a, b) {
														return a.match.nativeDef === b.match.nativeDef || a.match.def === b.match.nativeDef || a.match.nativeDef === b.match.def;
													}(H, K)) {
														I = !0, H.alternation === K.alternation && -1 === K.locator[K.alternation].toString().indexOf(H.locator[H.alternation]) && (K.locator[K.alternation] = K.locator[K.alternation] + "," + H.locator[H.alternation], K.alternation = H.alternation), H.match.nativeDef === K.match.def && (H.locator[H.alternation] = K.locator[K.alternation], w.splice(w.indexOf(K), 1, H));break;
													}if (H.match.def === K.match.def) {
														I = !1;break;
													}if (function (a, c) {
														return null === a.match.fn && null !== c.match.fn && c.match.fn.test(a.match.def, p(), b, !1, j, !1);
													}(H, K) || function (a, c) {
														return null !== a.match.fn && null !== c.match.fn && c.match.fn.test(a.match.def.replace(/[\[\]]/g, ""), p(), b, !1, j, !1);
													}(H, K)) {
														H.alternation === K.alternation && -1 === H.locator[H.alternation].toString().indexOf(K.locator[K.alternation].toString().split("")[0]) && (H.na = H.na || H.locator[H.alternation].toString(), -1 === H.na.indexOf(H.locator[H.alternation].toString().split("")[0]) && (H.na = H.na + "," + H.locator[K.alternation].toString().split("")[0]), I = !0, H.locator[H.alternation] = K.locator[K.alternation].toString().split("")[0] + "," + H.locator[H.alternation], w.splice(w.indexOf(K), 0, H));break;
													}
												}
											}I || w.push(H);
										}
									}"string" == typeof z && (w = a.map(w, function (b, c) {
										if (isFinite(c)) {
											var e = b.alternation,
											    f = b.locator[e].toString().split(",");b.locator[e] = d, b.alternation = d;for (var g = 0; g < f.length; g++) {
												-1 !== a.inArray(f[g], D) && (b.locator[e] !== d ? (b.locator[e] += ",", b.locator[e] += f[g]) : b.locator[e] = parseInt(f[g]), b.alternation = e);
											}if (b.locator[e] !== d) return b;
										}
									})), m = x.concat(w), k = b, n = m.length > 0, g = w.length > 0, e = C.slice();
								} else g = l(v.matches[z] || c.matches[z], [z].concat(i), q);if (g) return !0;
							} else if (g.isQuantifier && q !== c.matches[a.inArray(g, c.matches) - 1]) for (var L = g, M = e.length > 0 ? e.shift() : 0; M < (isNaN(L.quantifier.max) ? M + 1 : L.quantifier.max) && k <= b; M++) {
								var N = c.matches[a.inArray(L, c.matches) - 1];if (g = l(N, [M].concat(i), N)) {
									if (h = m[m.length - 1].match, h.optionalQuantifier = M > L.quantifier.min - 1, r(h, N)) {
										if (M > L.quantifier.min - 1) {
											n = !0, k = b;break;
										}return !0;
									}return !0;
								}
							} else if (g = f(g, e, i, q)) return !0;
						} else k++;
					}for (var q = e.length > 0 ? e.shift() : 0; q < c.matches.length; q++) {
						if (!0 !== c.matches[q].isQuantifier) {
							var r = l(c.matches[q], [q].concat(g), i);if (r && k === b) return r;if (k > b) break;
						}
					}
				}function g(a) {
					if (j.keepStatic && b > 0 && a.length > 1 + ("" === a[a.length - 1].match.def ? 1 : 0) && !0 !== a[0].match.optionality && !0 !== a[0].match.optionalQuantifier && null === a[0].match.fn && !/[0-9a-bA-Z]/.test(a[0].match.def)) {
						if (p().validPositions[b - 1] === d) return [t(a)];if (p().validPositions[b - 1].alternation === a[0].alternation) return [t(a)];if (p().validPositions[b - 1]) return [t(a)];
					}return a;
				}var h,
				    i = p().maskToken,
				    k = c ? e : 0,
				    l = c ? c.slice() : [0],
				    m = [],
				    n = !1,
				    o = c ? c.join("") : "";if (b > -1) {
					if (c === d) {
						for (var q, r = b - 1; (q = p().validPositions[r] || p().tests[r]) === d && r > -1;) {
							r--;
						}q !== d && r > -1 && (l = function (b) {
							var c = [];return a.isArray(b) || (b = [b]), b.length > 0 && (b[0].alternation === d ? (c = t(b.slice()).locator.slice(), 0 === c.length && (c = b[0].locator.slice())) : a.each(b, function (a, b) {
								if ("" !== b.def) if (0 === c.length) c = b.locator.slice();else for (var d = 0; d < c.length; d++) {
									b.locator[d] && -1 === c[d].toString().indexOf(b.locator[d]) && (c[d] += "," + b.locator[d]);
								}
							})), c;
						}(q), o = l.join(""), k = r);
					}if (p().tests[b] && p().tests[b][0].cd === o) return g(p().tests[b]);for (var s = l.shift(); s < i.length; s++) {
						if (f(i[s], l, [s]) && k === b || k > b) break;
					}
				}return (0 === m.length || n) && m.push({ match: { fn: null, cardinality: 0, optionality: !0, casing: null, def: "", placeholder: "" }, locator: [], cd: o }), c !== d && p().tests[b] ? g(a.extend(!0, [], m)) : (p().tests[b] = a.extend(!0, [], m), g(p().tests[b]));
			}function y() {
				return p()._buffer === d && (p()._buffer = o(!1, 1), p().buffer === d && (p().buffer = p()._buffer.slice())), p()._buffer;
			}function z(a) {
				return p().buffer !== d && !0 !== a || (p().buffer = o(!0, r(), !0)), p().buffer;
			}function A(a, b, c) {
				var e, f;if (!0 === a) q(), a = 0, b = c.length;else for (e = a; e < b; e++) {
					delete p().validPositions[e];
				}for (f = a, e = a; e < b; e++) {
					if (q(!0), c[e] !== j.skipOptionalPartCharacter) {
						var g = D(f, c[e], !0, !0);!1 !== g && (q(!0), f = g.caret !== d ? g.caret : g.pos + 1);
					}
				}
			}function B(b, c, d) {
				switch (j.casing || c.casing) {case "upper":
						b = b.toUpperCase();break;case "lower":
						b = b.toLowerCase();break;case "title":
						var f = p().validPositions[d - 1];b = 0 === d || f && f.input === String.fromCharCode(e.keyCode.SPACE) ? b.toUpperCase() : b.toLowerCase();break;default:
						if (a.isFunction(j.casing)) {
							var g = Array.prototype.slice.call(arguments);g.push(p().validPositions), b = j.casing.apply(this, g);
						}}return b;
			}function C(b, c, e) {
				for (var f, g = j.greedy ? c : c.slice(0, 1), h = !1, i = e !== d ? e.split(",") : [], k = 0; k < i.length; k++) {
					-1 !== (f = b.indexOf(i[k])) && b.splice(f, 1);
				}for (var l = 0; l < b.length; l++) {
					if (-1 !== a.inArray(b[l], g)) {
						h = !0;break;
					}
				}return h;
			}function D(b, c, f, g, h, i) {
				function k(a) {
					var b = Z ? a.begin - a.end > 1 || a.begin - a.end == 1 : a.end - a.begin > 1 || a.end - a.begin == 1;return b && 0 === a.begin && a.end === p().maskLength ? "full" : b;
				}function l(c, e, f) {
					var h = !1;return a.each(x(c), function (i, l) {
						for (var n = l.match, o = e ? 1 : 0, t = "", u = n.cardinality; u > o; u--) {
							t += H(c - (u - 1));
						}if (e && (t += e), z(!0), !1 !== (h = null != n.fn ? n.fn.test(t, p(), c, f, j, k(b)) : (e === n.def || e === j.skipOptionalPartCharacter) && "" !== n.def && { c: J(c, n, !0) || n.def, pos: c })) {
							var v = h.c !== d ? h.c : e;v = v === j.skipOptionalPartCharacter && null === n.fn ? J(c, n, !0) || n.def : v;var w = c,
							    x = z();if (h.remove !== d && (a.isArray(h.remove) || (h.remove = [h.remove]), a.each(h.remove.sort(function (a, b) {
								return b - a;
							}), function (a, b) {
								s(b, b + 1, !0);
							})), h.insert !== d && (a.isArray(h.insert) || (h.insert = [h.insert]), a.each(h.insert.sort(function (a, b) {
								return a - b;
							}), function (a, b) {
								D(b.pos, b.c, !0, g);
							})), h.refreshFromBuffer) {
								var y = h.refreshFromBuffer;if (A(!0 === y ? y : y.start, y.end, x), h.pos === d && h.c === d) return h.pos = r(), !1;if ((w = h.pos !== d ? h.pos : c) !== c) return h = a.extend(h, D(w, v, !0, g)), !1;
							} else if (!0 !== h && h.pos !== d && h.pos !== c && (w = h.pos, A(c, w, z().slice()), w !== c)) return h = a.extend(h, D(w, v, !0)), !1;return (!0 === h || h.pos !== d || h.c !== d) && (i > 0 && q(!0), m(w, a.extend({}, l, { input: B(v, n, w) }), g, k(b)) || (h = !1), !1);
						}
					}), h;
				}function m(b, c, e, f) {
					if (f || j.insertMode && p().validPositions[b] !== d && e === d) {
						var g,
						    h = a.extend(!0, {}, p().validPositions),
						    i = r(d, !0);for (g = b; g <= i; g++) {
							delete p().validPositions[g];
						}p().validPositions[b] = a.extend(!0, {}, c);var k,
						    l = !0,
						    m = p().validPositions,
						    o = !1,
						    s = p().maskLength;for (g = k = b; g <= i; g++) {
							var t = h[g];if (t !== d) for (var u = k; u < p().maskLength && (null === t.match.fn && m[g] && (!0 === m[g].match.optionalQuantifier || !0 === m[g].match.optionality) || null != t.match.fn);) {
								if (u++, !1 === o && h[u] && h[u].match.def === t.match.def) p().validPositions[u] = a.extend(!0, {}, h[u]), p().validPositions[u].input = t.input, n(u), k = u, l = !0;else if (w(u, t.match.def)) {
									var v = D(u, t.input, !0, !0);l = !1 !== v, k = v.caret || v.insert ? r() : u, o = !0;
								} else if (!(l = !0 === t.generatedInput) && u >= p().maskLength - 1) break;if (p().maskLength < s && (p().maskLength = s), l) break;
							}if (!l) break;
						}if (!l) return p().validPositions = a.extend(!0, {}, h), q(!0), !1;
					} else p().validPositions[b] = a.extend(!0, {}, c);return q(!0), !0;
				}function n(b) {
					for (var c = b - 1; c > -1 && !p().validPositions[c]; c--) {}var e, f;for (c++; c < b; c++) {
						p().validPositions[c] === d && (!1 === j.jitMasking || j.jitMasking > c) && (f = x(c, u(c - 1).locator, c - 1).slice(), "" === f[f.length - 1].match.def && f.pop(), (e = t(f)) && (e.match.def === j.radixPointDefinitionSymbol || !E(c, !0) || a.inArray(j.radixPoint, z()) < c && e.match.fn && e.match.fn.test(J(c), p(), c, !1, j)) && !1 !== (v = l(c, J(c, e.match, !0) || (null == e.match.fn ? e.match.def : "" !== J(c) ? J(c) : z()[c]), !0)) && (p().validPositions[v.pos || c].generatedInput = !0));
					}
				}f = !0 === f;var o = b;b.begin !== d && (o = Z && !k(b) ? b.end : b.begin);var v = !0,
				    y = a.extend(!0, {}, p().validPositions);if (a.isFunction(j.preValidation) && !f && !0 !== g && !0 !== i && (v = j.preValidation(z(), o, c, k(b), j)), !0 === v) {
					if (n(o), k(b) && (Q(d, e.keyCode.DELETE, b, !0, !0), o = p().p), o < p().maskLength && (V === d || o < V) && (v = l(o, c, f), (!f || !0 === g) && !1 === v && !0 !== i)) {
						var G = p().validPositions[o];if (!G || null !== G.match.fn || G.match.def !== c && c !== j.skipOptionalPartCharacter) {
							if ((j.insertMode || p().validPositions[F(o)] === d) && !E(o, !0)) for (var I = o + 1, K = F(o); I <= K; I++) {
								if (!1 !== (v = l(I, c, f))) {
									!function (b, c) {
										var e = p().validPositions[c];if (e) for (var f = e.locator, g = f.length, h = b; h < c; h++) {
											if (p().validPositions[h] === d && !E(h, !0)) {
												var i = x(h).slice(),
												    j = t(i, !0),
												    k = -1;"" === i[i.length - 1].match.def && i.pop(), a.each(i, function (a, b) {
													for (var c = 0; c < g; c++) {
														if (b.locator[c] === d || !C(b.locator[c].toString().split(","), f[c].toString().split(","), b.na)) {
															var e = f[c],
															    h = j.locator[c],
															    i = b.locator[c];e - h > Math.abs(e - i) && (j = b);break;
														}k < c && (k = c, j = b);
													}
												}), j = a.extend({}, j, { input: J(h, j.match, !0) || j.match.def }), j.generatedInput = !0, m(h, j, !0), p().validPositions[c] = d, l(c, e.input, !0);
											}
										}
									}(o, v.pos !== d ? v.pos : I), o = I;break;
								}
							}
						} else v = { caret: F(o) };
					}!1 === v && j.keepStatic && !f && !0 !== h && (v = function (b, c, e) {
						var f,
						    h,
						    i,
						    k,
						    l,
						    m,
						    n,
						    o,
						    s = a.extend(!0, {}, p().validPositions),
						    t = !1,
						    u = r();for (k = p().validPositions[u]; u >= 0; u--) {
							if ((i = p().validPositions[u]) && i.alternation !== d) {
								if (f = u, h = p().validPositions[f].alternation, k.locator[i.alternation] !== i.locator[i.alternation]) break;k = i;
							}
						}if (h !== d) {
							o = parseInt(f);var v = k.locator[k.alternation || h] !== d ? k.locator[k.alternation || h] : n[0];v.length > 0 && (v = v.split(",")[0]);var w = p().validPositions[o],
							    y = p().validPositions[o - 1];a.each(x(o, y ? y.locator : d, o - 1), function (f, i) {
								n = i.locator[h] ? i.locator[h].toString().split(",") : [];for (var k = 0; k < n.length; k++) {
									var u = [],
									    x = 0,
									    y = 0,
									    z = !1;if (v < n[k] && (i.na === d || -1 === a.inArray(n[k], i.na.split(",")) || -1 === a.inArray(v.toString(), n))) {
										p().validPositions[o] = a.extend(!0, {}, i);var A = p().validPositions[o].locator;for (p().validPositions[o].locator[h] = parseInt(n[k]), null == i.match.fn ? (w.input !== i.match.def && (z = !0, !0 !== w.generatedInput && u.push(w.input)), y++, p().validPositions[o].generatedInput = !/[0-9a-bA-Z]/.test(i.match.def), p().validPositions[o].input = i.match.def) : p().validPositions[o].input = w.input, l = o + 1; l < r(d, !0) + 1; l++) {
											m = p().validPositions[l], m && !0 !== m.generatedInput && /[0-9a-bA-Z]/.test(m.input) ? u.push(m.input) : l < b && x++, delete p().validPositions[l];
										}for (z && u[0] === i.match.def && u.shift(), q(!0), t = !0; u.length > 0;) {
											var B = u.shift();if (B !== j.skipOptionalPartCharacter && !(t = D(r(d, !0) + 1, B, !1, g, !0))) break;
										}if (t) {
											p().validPositions[o].locator = A;var C = r(b) + 1;for (l = o + 1; l < r() + 1; l++) {
												((m = p().validPositions[l]) === d || null == m.match.fn) && l < b + (y - x) && y++;
											}b += y - x, t = D(b > C ? C : b, c, e, g, !0);
										}if (t) return !1;q(), p().validPositions = a.extend(!0, {}, s);
									}
								}
							});
						}return t;
					}(o, c, f)), !0 === v && (v = { pos: o });
				}if (a.isFunction(j.postValidation) && !1 !== v && !f && !0 !== g && !0 !== i) {
					var L = j.postValidation(z(!0), v, j);if (L.refreshFromBuffer && L.buffer) {
						var M = L.refreshFromBuffer;A(!0 === M ? M : M.start, M.end, L.buffer);
					}v = !0 === L ? v : L;
				}return v && v.pos === d && (v.pos = o), !1 !== v && !0 !== i || (q(!0), p().validPositions = a.extend(!0, {}, y)), v;
			}function E(a, b) {
				var c = u(a).match;if ("" === c.def && (c = v(a).match), null != c.fn) return c.fn;if (!0 !== b && a > -1) {
					var d = x(a);return d.length > 1 + ("" === d[d.length - 1].match.def ? 1 : 0);
				}return !1;
			}function F(a, b) {
				var c = p().maskLength;if (a >= c) return c;var d = a;for (x(c + 1).length > 1 && (o(!0, c + 1, !0), c = p().maskLength); ++d < c && (!0 === b && (!0 !== v(d).match.newBlockMarker || !E(d)) || !0 !== b && !E(d));) {}return d;
			}function G(a, b) {
				var c,
				    d = a;if (d <= 0) return 0;for (; --d > 0 && (!0 === b && !0 !== v(d).match.newBlockMarker || !0 !== b && !E(d) && (c = x(d), c.length < 2 || 2 === c.length && "" === c[1].match.def));) {}return d;
			}function H(a) {
				return p().validPositions[a] === d ? J(a) : p().validPositions[a].input;
			}function I(b, c, e, f, g) {
				if (f && a.isFunction(j.onBeforeWrite)) {
					var h = j.onBeforeWrite.call(X, f, c, e, j);if (h) {
						if (h.refreshFromBuffer) {
							var i = h.refreshFromBuffer;A(!0 === i ? i : i.start, i.end, h.buffer || c), c = z(!0);
						}e !== d && (e = h.caret !== d ? h.caret : e);
					}
				}b !== d && (b.inputmask._valueSet(c.join("")), e === d || f !== d && "blur" === f.type ? S(b, e, 0 === c.length) : n && f && "input" === f.type ? setTimeout(function () {
					M(b, e);
				}, 0) : M(b, e), !0 === g && (_ = !0, a(b).trigger("input")));
			}function J(b, c, e) {
				if (c = c || v(b).match, c.placeholder !== d || !0 === e) return a.isFunction(c.placeholder) ? c.placeholder(j) : c.placeholder;if (null === c.fn) {
					if (b > -1 && p().validPositions[b] === d) {
						var f,
						    g = x(b),
						    h = [];if (g.length > 1 + ("" === g[g.length - 1].match.def ? 1 : 0)) for (var i = 0; i < g.length; i++) {
							if (!0 !== g[i].match.optionality && !0 !== g[i].match.optionalQuantifier && (null === g[i].match.fn || f === d || !1 !== g[i].match.fn.test(f.match.def, p(), b, !0, j)) && (h.push(g[i]), null === g[i].match.fn && (f = g[i]), h.length > 1 && /[0-9a-bA-Z]/.test(h[0].match.def))) return j.placeholder.charAt(b % j.placeholder.length);
						}
					}return c.def;
				}return j.placeholder.charAt(b % j.placeholder.length);
			}function K(b, f, g, h, i) {
				function k(a, b) {
					return -1 !== y().slice(a, F(a)).join("").indexOf(b) && !E(a) && v(a).match.nativeDef === b.charAt(b.length - 1);
				}var l = h.slice(),
				    m = "",
				    n = -1,
				    o = d;if (q(), g || !0 === j.autoUnmask) n = F(n);else {
					var s = y().slice(0, F(-1)).join(""),
					    t = l.join("").match(new RegExp("^" + e.escapeRegex(s), "g"));t && t.length > 0 && (l.splice(0, t.length * s.length), n = F(n));
				}if (-1 === n ? (p().p = F(n), n = 0) : p().p = n, a.each(l, function (c, e) {
					if (e !== d) if (p().validPositions[c] === d && l[c] === J(c) && E(c, !0) && !1 === D(c, l[c], !0, d, d, !0)) p().p++;else {
						var f = new a.Event("_checkval");f.which = e.charCodeAt(0), m += e;var h = r(d, !0),
						    i = p().validPositions[h],
						    s = u(h + 1, i ? i.locator.slice() : d, h);if (!k(n, m) || g || j.autoUnmask) {
							var t = g ? c : null == s.match.fn && s.match.optionality && h + 1 < p().p ? h + 1 : p().p;o = da.keypressEvent.call(b, f, !0, !1, g, t), n = t + 1, m = "";
						} else o = da.keypressEvent.call(b, f, !0, !1, !0, h + 1);if (!1 !== o && !g && a.isFunction(j.onBeforeWrite)) {
							var v = o;if (o = j.onBeforeWrite.call(X, f, z(), o.forwardPosition, j), (o = a.extend(v, o)) && o.refreshFromBuffer) {
								var w = o.refreshFromBuffer;A(!0 === w ? w : w.start, w.end, o.buffer), q(!0), o.caret && (p().p = o.caret, o.forwardPosition = o.caret);
							}
						}
					}
				}), f) {
					var w = d;c.activeElement === b && o && (w = j.numericInput ? G(o.forwardPosition) : o.forwardPosition), I(b, z(), w, i || new a.Event("checkval"), i && "input" === i.type);
				}
			}function L(b) {
				if (b) {
					if (b.inputmask === d) return b.value;b.inputmask && b.inputmask.refreshValue && da.setValueEvent.call(b);
				}var c = [],
				    e = p().validPositions;for (var f in e) {
					e[f].match && null != e[f].match.fn && c.push(e[f].input);
				}var g = 0 === c.length ? "" : (Z ? c.reverse() : c).join("");if (a.isFunction(j.onUnMask)) {
					var h = (Z ? z().slice().reverse() : z()).join("");g = j.onUnMask.call(X, h, g, j);
				}return g;
			}function M(a, e, f, g) {
				function h(a) {
					if (!0 !== g && Z && "number" == typeof a && (!j.greedy || "" !== j.placeholder)) {
						a = z().join("").length - a;
					}return a;
				}var i;if (e === d) return a.setSelectionRange ? (e = a.selectionStart, f = a.selectionEnd) : b.getSelection ? (i = b.getSelection().getRangeAt(0), i.commonAncestorContainer.parentNode !== a && i.commonAncestorContainer !== a || (e = i.startOffset, f = i.endOffset)) : c.selection && c.selection.createRange && (i = c.selection.createRange(), e = 0 - i.duplicate().moveStart("character", -a.inputmask._valueGet().length), f = e + i.text.length), { begin: h(e), end: h(f) };if (e.begin !== d && (f = e.end, e = e.begin), "number" == typeof e) {
					e = h(e), f = h(f), f = "number" == typeof f ? f : e;var l = parseInt(((a.ownerDocument.defaultView || b).getComputedStyle ? (a.ownerDocument.defaultView || b).getComputedStyle(a, null) : a.currentStyle).fontSize) * f;if (a.scrollLeft = l > a.scrollWidth ? l : 0, k || !1 !== j.insertMode || e !== f || f++, a.setSelectionRange) a.selectionStart = e, a.selectionEnd = f;else if (b.getSelection) {
						if (i = c.createRange(), a.firstChild === d || null === a.firstChild) {
							var m = c.createTextNode("");a.appendChild(m);
						}i.setStart(a.firstChild, e < a.inputmask._valueGet().length ? e : a.inputmask._valueGet().length), i.setEnd(a.firstChild, f < a.inputmask._valueGet().length ? f : a.inputmask._valueGet().length), i.collapse(!0);var n = b.getSelection();n.removeAllRanges(), n.addRange(i);
					} else a.createTextRange && (i = a.createTextRange(), i.collapse(!0), i.moveEnd("character", f), i.moveStart("character", e), i.select());S(a, { begin: e, end: f });
				}
			}function N(b) {
				var c,
				    e,
				    f = z(),
				    g = f.length,
				    h = r(),
				    i = {},
				    j = p().validPositions[h],
				    k = j !== d ? j.locator.slice() : d;for (c = h + 1; c < f.length; c++) {
					e = u(c, k, c - 1), k = e.locator.slice(), i[c] = a.extend(!0, {}, e);
				}var l = j && j.alternation !== d ? j.locator[j.alternation] : d;for (c = g - 1; c > h && (e = i[c], (e.match.optionality || e.match.optionalQuantifier && e.match.newBlockMarker || l && (l !== i[c].locator[j.alternation] && null != e.match.fn || null === e.match.fn && e.locator[j.alternation] && C(e.locator[j.alternation].toString().split(","), l.toString().split(",")) && "" !== x(c)[0].def)) && f[c] === J(c, e.match)); c--) {
					g--;
				}return b ? { l: g, def: i[g] ? i[g].match : d } : g;
			}function O(a) {
				for (var b, c = N(), e = a.length, f = p().validPositions[r()]; c < e && !E(c, !0) && (b = f !== d ? u(c, f.locator.slice(""), f) : v(c)) && !0 !== b.match.optionality && (!0 !== b.match.optionalQuantifier && !0 !== b.match.newBlockMarker || c + 1 === e && "" === (f !== d ? u(c + 1, f.locator.slice(""), f) : v(c + 1)).match.def);) {
					c++;
				}for (; (b = p().validPositions[c - 1]) && b && b.match.optionality && b.input === j.skipOptionalPartCharacter;) {
					c--;
				}return a.splice(c), a;
			}function P(b) {
				if (a.isFunction(j.isComplete)) return j.isComplete(b, j);if ("*" === j.repeat) return d;var c = !1,
				    e = N(!0),
				    f = G(e.l);if (e.def === d || e.def.newBlockMarker || e.def.optionality || e.def.optionalQuantifier) {
					c = !0;for (var g = 0; g <= f; g++) {
						var h = u(g).match;if (null !== h.fn && p().validPositions[g] === d && !0 !== h.optionality && !0 !== h.optionalQuantifier || null === h.fn && b[g] !== J(g, h)) {
							c = !1;break;
						}
					}
				}return c;
			}function Q(b, c, f, g, h) {
				if ((j.numericInput || Z) && (c === e.keyCode.BACKSPACE ? c = e.keyCode.DELETE : c === e.keyCode.DELETE && (c = e.keyCode.BACKSPACE), Z)) {
					var i = f.end;f.end = f.begin, f.begin = i;
				}c === e.keyCode.BACKSPACE && (f.end - f.begin < 1 || !1 === j.insertMode) ? (f.begin = G(f.begin), p().validPositions[f.begin] !== d && p().validPositions[f.begin].input === j.groupSeparator && f.begin--) : c === e.keyCode.DELETE && f.begin === f.end && (f.end = E(f.end, !0) && p().validPositions[f.end] && p().validPositions[f.end].input !== j.radixPoint ? f.end + 1 : F(f.end) + 1, p().validPositions[f.begin] !== d && p().validPositions[f.begin].input === j.groupSeparator && f.end++), s(f.begin, f.end, !1, g), !0 !== g && function () {
					if (j.keepStatic) {
						for (var c = [], e = r(-1, !0), f = a.extend(!0, {}, p().validPositions), g = p().validPositions[e]; e >= 0; e--) {
							var h = p().validPositions[e];if (h) {
								if (!0 !== h.generatedInput && /[0-9a-bA-Z]/.test(h.input) && c.push(h.input), delete p().validPositions[e], h.alternation !== d && h.locator[h.alternation] !== g.locator[h.alternation]) break;g = h;
							}
						}if (e > -1) for (p().p = F(r(-1, !0)); c.length > 0;) {
							var i = new a.Event("keypress");i.which = c.pop().charCodeAt(0), da.keypressEvent.call(b, i, !0, !1, !1, p().p);
						} else p().validPositions = a.extend(!0, {}, f);
					}
				}();var k = r(f.begin, !0);if (k < f.begin) p().p = F(k);else if (!0 !== g && (p().p = f.begin, !0 !== h)) for (; p().p < k && p().validPositions[p().p] === d;) {
					p().p++;
				}
			}function R(d) {
				function e(a) {
					var b,
					    e = c.createElement("span");for (var g in f) {
						isNaN(g) && -1 !== g.indexOf("font") && (e.style[g] = f[g]);
					}e.style.textTransform = f.textTransform, e.style.letterSpacing = f.letterSpacing, e.style.position = "absolute", e.style.height = "auto", e.style.width = "auto", e.style.visibility = "hidden", e.style.whiteSpace = "nowrap", c.body.appendChild(e);var h,
					    i = d.inputmask._valueGet(),
					    j = 0;for (b = 0, h = i.length; b <= h; b++) {
						if (e.innerHTML += i.charAt(b) || "_", e.offsetWidth >= a) {
							var k = a - j,
							    l = e.offsetWidth - a;e.innerHTML = i.charAt(b), k -= e.offsetWidth / 3, b = k < l ? b - 1 : b;break;
						}j = e.offsetWidth;
					}return c.body.removeChild(e), b;
				}var f = (d.ownerDocument.defaultView || b).getComputedStyle(d, null),
				    g = c.createElement("div");g.style.width = f.width, g.style.textAlign = f.textAlign, W = c.createElement("div"), W.className = "im-colormask", d.parentNode.insertBefore(W, d), d.parentNode.removeChild(d), W.appendChild(g), W.appendChild(d), d.style.left = g.offsetLeft + "px", a(d).on("click", function (a) {
					return M(d, e(a.clientX)), da.clickEvent.call(d, [a]);
				}), a(d).on("keydown", function (a) {
					a.shiftKey || !1 === j.insertMode || setTimeout(function () {
						S(d);
					}, 0);
				});
			}function S(a, b, e) {
				function f() {
					m || null !== h.fn && i.input !== d ? m && (null !== h.fn && i.input !== d || "" === h.def) && (m = !1, l += "</span>") : (m = !0, l += "<span class='im-static'>");
				}function g(d) {
					!0 !== d && n !== b.begin || c.activeElement !== a || (l += "<span class='im-caret' style='border-right-width: 1px;border-right-style: solid;'></span>");
				}var h,
				    i,
				    k,
				    l = "",
				    m = !1,
				    n = 0;if (W !== d) {
					var o = z();if (b === d ? b = M(a) : b.begin === d && (b = { begin: b, end: b }), !0 !== e) {
						var q = r();do {
							g(), p().validPositions[n] ? (i = p().validPositions[n], h = i.match, k = i.locator.slice(), f(), l += o[n]) : (i = u(n, k, n - 1), h = i.match, k = i.locator.slice(), (!1 === j.jitMasking || n < q || "number" == typeof j.jitMasking && isFinite(j.jitMasking) && j.jitMasking > n) && (f(), l += J(n, h))), n++;
						} while ((V === d || n < V) && (null !== h.fn || "" !== h.def) || q > n || m);-1 === l.indexOf("im-caret") && g(!0), m && f();
					}var s = W.getElementsByTagName("div")[0];s.innerHTML = l, a.inputmask.positionColorMask(a, s);
				}
			}h = h || this.maskset, j = j || this.opts;var T,
			    U,
			    V,
			    W,
			    X = this,
			    Y = this.el,
			    Z = this.isRTL,
			    $ = !1,
			    _ = !1,
			    aa = !1,
			    ba = !1,
			    ca = { on: function on(b, c, f) {
					var g = function g(b) {
						if (this.inputmask === d && "FORM" !== this.nodeName) {
							var c = a.data(this, "_inputmask_opts");c ? new e(c).mask(this) : ca.off(this);
						} else {
							if ("setvalue" === b.type || "FORM" === this.nodeName || !(this.disabled || this.readOnly && !("keydown" === b.type && b.ctrlKey && 67 === b.keyCode || !1 === j.tabThrough && b.keyCode === e.keyCode.TAB))) {
								switch (b.type) {case "input":
										if (!0 === _) return _ = !1, b.preventDefault();break;case "keydown":
										$ = !1, _ = !1;break;case "keypress":
										if (!0 === $) return b.preventDefault();$ = !0;break;case "click":
										if (l || m) {
											var g = this,
											    h = arguments;return setTimeout(function () {
												f.apply(g, h);
											}, 0), !1;
										}}var i = f.apply(this, arguments);return !1 === i && (b.preventDefault(), b.stopPropagation()), i;
							}b.preventDefault();
						}
					};b.inputmask.events[c] = b.inputmask.events[c] || [], b.inputmask.events[c].push(g), -1 !== a.inArray(c, ["submit", "reset"]) ? null !== b.form && a(b.form).on(c, g) : a(b).on(c, g);
				}, off: function off(b, c) {
					if (b.inputmask && b.inputmask.events) {
						var d;c ? (d = [], d[c] = b.inputmask.events[c]) : d = b.inputmask.events, a.each(d, function (c, d) {
							for (; d.length > 0;) {
								var e = d.pop();-1 !== a.inArray(c, ["submit", "reset"]) ? null !== b.form && a(b.form).off(c, e) : a(b).off(c, e);
							}delete b.inputmask.events[c];
						});
					}
				} },
			    da = { keydownEvent: function keydownEvent(b) {
					var d = this,
					    f = a(d),
					    g = b.keyCode,
					    h = M(d);if (g === e.keyCode.BACKSPACE || g === e.keyCode.DELETE || m && g === e.keyCode.BACKSPACE_SAFARI || b.ctrlKey && g === e.keyCode.X && !function (a) {
						var b = c.createElement("input"),
						    d = "on" + a,
						    e = d in b;return e || (b.setAttribute(d, "return;"), e = "function" == typeof b[d]), b = null, e;
					}("cut")) b.preventDefault(), Q(d, g, h), I(d, z(!0), p().p, b, d.inputmask._valueGet() !== z().join("")), d.inputmask._valueGet() === y().join("") ? f.trigger("cleared") : !0 === P(z()) && f.trigger("complete");else if (g === e.keyCode.END || g === e.keyCode.PAGE_DOWN) {
						b.preventDefault();var i = F(r());j.insertMode || i !== p().maskLength || b.shiftKey || i--, M(d, b.shiftKey ? h.begin : i, i, !0);
					} else g === e.keyCode.HOME && !b.shiftKey || g === e.keyCode.PAGE_UP ? (b.preventDefault(), M(d, 0, b.shiftKey ? h.begin : 0, !0)) : (j.undoOnEscape && g === e.keyCode.ESCAPE || 90 === g && b.ctrlKey) && !0 !== b.altKey ? (K(d, !0, !1, T.split("")), f.trigger("click")) : g !== e.keyCode.INSERT || b.shiftKey || b.ctrlKey ? !0 === j.tabThrough && g === e.keyCode.TAB ? (!0 === b.shiftKey ? (null === v(h.begin).match.fn && (h.begin = F(h.begin)), h.end = G(h.begin, !0), h.begin = G(h.end, !0)) : (h.begin = F(h.begin, !0), h.end = F(h.begin, !0), h.end < p().maskLength && h.end--), h.begin < p().maskLength && (b.preventDefault(), M(d, h.begin, h.end))) : b.shiftKey || !1 === j.insertMode && (g === e.keyCode.RIGHT ? setTimeout(function () {
						var a = M(d);M(d, a.begin);
					}, 0) : g === e.keyCode.LEFT && setTimeout(function () {
						var a = M(d);M(d, Z ? a.begin + 1 : a.begin - 1);
					}, 0)) : (j.insertMode = !j.insertMode, M(d, j.insertMode || h.begin !== p().maskLength ? h.begin : h.begin - 1));j.onKeyDown.call(this, b, z(), M(d).begin, j), aa = -1 !== a.inArray(g, j.ignorables);
				}, keypressEvent: function keypressEvent(b, c, f, g, h) {
					var i = this,
					    k = a(i),
					    l = b.which || b.charCode || b.keyCode;if (!(!0 === c || b.ctrlKey && b.altKey) && (b.ctrlKey || b.metaKey || aa)) return l === e.keyCode.ENTER && T !== z().join("") && (T = z().join(""), setTimeout(function () {
						k.trigger("change");
					}, 0)), !0;if (l) {
						46 === l && !1 === b.shiftKey && "" !== j.radixPoint && (l = j.radixPoint.charCodeAt(0));var m,
						    n = c ? { begin: h, end: h } : M(i),
						    o = String.fromCharCode(l);p().writeOutBuffer = !0;var r = D(n, o, g);if (!1 !== r && (q(!0), m = r.caret !== d ? r.caret : c ? r.pos + 1 : F(r.pos), p().p = m), !1 !== f && (setTimeout(function () {
							j.onKeyValidation.call(i, l, r, j);
						}, 0), p().writeOutBuffer && !1 !== r)) {
							var s = z();I(i, s, j.numericInput && r.caret === d ? G(m) : m, b, !0 !== c), !0 !== c && setTimeout(function () {
								!0 === P(s) && k.trigger("complete");
							}, 0);
						}if (b.preventDefault(), c) return !1 !== r && (r.forwardPosition = m), r;
					}
				}, pasteEvent: function pasteEvent(c) {
					var d,
					    e = this,
					    f = c.originalEvent || c,
					    g = a(e),
					    h = e.inputmask._valueGet(!0),
					    i = M(e);Z && (d = i.end, i.end = i.begin, i.begin = d);var k = h.substr(0, i.begin),
					    l = h.substr(i.end, h.length);if (k === (Z ? y().reverse() : y()).slice(0, i.begin).join("") && (k = ""), l === (Z ? y().reverse() : y()).slice(i.end).join("") && (l = ""), Z && (d = k, k = l, l = d), b.clipboardData && b.clipboardData.getData) h = k + b.clipboardData.getData("Text") + l;else {
						if (!f.clipboardData || !f.clipboardData.getData) return !0;h = k + f.clipboardData.getData("text/plain") + l;
					}var m = h;if (a.isFunction(j.onBeforePaste)) {
						if (!1 === (m = j.onBeforePaste.call(X, h, j))) return c.preventDefault();m || (m = h);
					}return K(e, !1, !1, Z ? m.split("").reverse() : m.toString().split("")), I(e, z(), F(r()), c, T !== z().join("")), !0 === P(z()) && g.trigger("complete"), c.preventDefault();
				}, inputFallBackEvent: function inputFallBackEvent(b) {
					var c = this,
					    d = c.inputmask._valueGet();if (z().join("") !== d) {
						var f = M(c);if (!1 === function (b, c, d) {
							if ("." === c.charAt(d.begin - 1) && "" !== j.radixPoint && (c = c.split(""), c[d.begin - 1] = j.radixPoint.charAt(0), c = c.join("")), c.charAt(d.begin - 1) === j.radixPoint && c.length > z().length) {
								var e = new a.Event("keypress");return e.which = j.radixPoint.charCodeAt(0), da.keypressEvent.call(b, e, !0, !0, !1, d.begin - 1), !1;
							}
						}(c, d, f)) return !1;if (d = d.replace(new RegExp("(" + e.escapeRegex(y().join("")) + ")*"), ""), !1 === function (b, c, d) {
							if (l) {
								var e = c.replace(z().join(""), "");if (1 === e.length) {
									var f = new a.Event("keypress");return f.which = e.charCodeAt(0), da.keypressEvent.call(b, f, !0, !0, !1, p().validPositions[d.begin - 1] ? d.begin : d.begin - 1), !1;
								}
							}
						}(c, d, f)) return !1;f.begin > d.length && (M(c, d.length), f = M(c));var g = z().join(""),
						    h = d.substr(0, f.begin),
						    i = d.substr(f.begin),
						    k = g.substr(0, f.begin),
						    m = g.substr(f.begin),
						    n = f,
						    o = "",
						    q = !1;if (h !== k) {
							n.begin = 0;for (var r = (q = h.length >= k.length) ? h.length : k.length, s = 0; h.charAt(s) === k.charAt(s) && s < r; s++) {
								n.begin++;
							}q && (o += h.slice(n.begin, n.end));
						}i !== m && (i.length > m.length ? q && (n.end = n.begin) : i.length < m.length ? n.end += m.length - i.length : i.charAt(0) !== m.charAt(0) && n.end++), I(c, z(), n), o.length > 0 ? a.each(o.split(""), function (b, d) {
							var e = new a.Event("keypress");e.which = d.charCodeAt(0), aa = !1, da.keypressEvent.call(c, e);
						}) : (n.begin === n.end - 1 && M(c, G(n.begin + 1), n.end), b.keyCode = e.keyCode.DELETE, da.keydownEvent.call(c, b)), b.preventDefault();
					}
				}, setValueEvent: function setValueEvent(b) {
					this.inputmask.refreshValue = !1;var c = this,
					    d = c.inputmask._valueGet(!0);a.isFunction(j.onBeforeMask) && (d = j.onBeforeMask.call(X, d, j) || d), d = d.split(""), K(c, !0, !1, Z ? d.reverse() : d), T = z().join(""), (j.clearMaskOnLostFocus || j.clearIncomplete) && c.inputmask._valueGet() === y().join("") && c.inputmask._valueSet("");
				}, focusEvent: function focusEvent(a) {
					var b = this,
					    c = b.inputmask._valueGet();j.showMaskOnFocus && (!j.showMaskOnHover || j.showMaskOnHover && "" === c) && (b.inputmask._valueGet() !== z().join("") ? I(b, z(), F(r())) : !1 === ba && M(b, F(r()))), !0 === j.positionCaretOnTab && !1 === ba && "" !== c && (I(b, z(), M(b)), da.clickEvent.apply(b, [a, !0])), T = z().join("");
				}, mouseleaveEvent: function mouseleaveEvent(a) {
					var b = this;if (ba = !1, j.clearMaskOnLostFocus && c.activeElement !== b) {
						var d = z().slice(),
						    e = b.inputmask._valueGet();e !== b.getAttribute("placeholder") && "" !== e && (-1 === r() && e === y().join("") ? d = [] : O(d), I(b, d));
					}
				}, clickEvent: function clickEvent(b, e) {
					function f(b) {
						if ("" !== j.radixPoint) {
							var c = p().validPositions;if (c[b] === d || c[b].input === J(b)) {
								if (b < F(-1)) return !0;var e = a.inArray(j.radixPoint, z());if (-1 !== e) {
									for (var f in c) {
										if (e < f && c[f].input !== J(f)) return !1;
									}return !0;
								}
							}
						}return !1;
					}var g = this;setTimeout(function () {
						if (c.activeElement === g) {
							var a = M(g);if (e && (Z ? a.end = a.begin : a.begin = a.end), a.begin === a.end) switch (j.positionCaretOnClick) {case "none":
									break;case "radixFocus":
									if (f(a.begin)) {
										var b = z().join("").indexOf(j.radixPoint);M(g, j.numericInput ? F(b) : b);break;
									}default:
									var h = a.begin,
									    i = r(h, !0),
									    k = F(i);if (h < k) M(g, E(h, !0) || E(h - 1, !0) ? h : F(h));else {
										var l = p().validPositions[i],
										    m = u(k, l ? l.match.locator : d, l),
										    n = J(k, m.match);if ("" !== n && z()[k] !== n && !0 !== m.match.optionalQuantifier && !0 !== m.match.newBlockMarker || !E(k, !0) && m.match.def === n) {
											var o = F(k);(h >= o || h === k) && (k = o);
										}M(g, k);
									}}
						}
					}, 0);
				}, dblclickEvent: function dblclickEvent(a) {
					var b = this;setTimeout(function () {
						M(b, 0, F(r()));
					}, 0);
				}, cutEvent: function cutEvent(d) {
					var f = this,
					    g = a(f),
					    h = M(f),
					    i = d.originalEvent || d,
					    j = b.clipboardData || i.clipboardData,
					    k = Z ? z().slice(h.end, h.begin) : z().slice(h.begin, h.end);j.setData("text", Z ? k.reverse().join("") : k.join("")), c.execCommand && c.execCommand("copy"), Q(f, e.keyCode.DELETE, h), I(f, z(), p().p, d, T !== z().join("")), f.inputmask._valueGet() === y().join("") && g.trigger("cleared");
				}, blurEvent: function blurEvent(b) {
					var c = a(this),
					    e = this;if (e.inputmask) {
						var f = e.inputmask._valueGet(),
						    g = z().slice();"" !== f && (j.clearMaskOnLostFocus && (-1 === r() && f === y().join("") ? g = [] : O(g)), !1 === P(g) && (setTimeout(function () {
							c.trigger("incomplete");
						}, 0), j.clearIncomplete && (q(), g = j.clearMaskOnLostFocus ? [] : y().slice())), I(e, g, d, b)), T !== z().join("") && (T = g.join(""), c.trigger("change"));
					}
				}, mouseenterEvent: function mouseenterEvent(a) {
					var b = this;ba = !0, c.activeElement !== b && j.showMaskOnHover && b.inputmask._valueGet() !== z().join("") && I(b, z());
				}, submitEvent: function submitEvent(a) {
					T !== z().join("") && U.trigger("change"), j.clearMaskOnLostFocus && -1 === r() && Y.inputmask._valueGet && Y.inputmask._valueGet() === y().join("") && Y.inputmask._valueSet(""), j.removeMaskOnSubmit && (Y.inputmask._valueSet(Y.inputmask.unmaskedvalue(), !0), setTimeout(function () {
						I(Y, z());
					}, 0));
				}, resetEvent: function resetEvent(a) {
					Y.inputmask.refreshValue = !0, setTimeout(function () {
						U.trigger("setvalue");
					}, 0);
				} };e.prototype.positionColorMask = function (a, b) {
				a.style.left = b.offsetLeft + "px";
			};var ea;if (f !== d) switch (f.action) {case "isComplete":
					return Y = f.el, P(z());case "unmaskedvalue":
					return Y !== d && f.value === d || (ea = f.value, ea = (a.isFunction(j.onBeforeMask) ? j.onBeforeMask.call(X, ea, j) || ea : ea).split(""), K(d, !1, !1, Z ? ea.reverse() : ea), a.isFunction(j.onBeforeWrite) && j.onBeforeWrite.call(X, d, z(), 0, j)), L(Y);case "mask":
					!function (b) {
						ca.off(b);var e = function (b, e) {
							var f = b.getAttribute("type"),
							    h = "INPUT" === b.tagName && -1 !== a.inArray(f, e.supportsInputType) || b.isContentEditable || "TEXTAREA" === b.tagName;if (!h) if ("INPUT" === b.tagName) {
								var i = c.createElement("input");i.setAttribute("type", f), h = "text" === i.type, i = null;
							} else h = "partial";return !1 !== h ? function (b) {
								function f() {
									return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== r() || !0 !== e.nullable ? c.activeElement === this && e.clearMaskOnLostFocus ? (Z ? O(z().slice()).reverse() : O(z().slice())).join("") : i.call(this) : "" : i.call(this);
								}function h(b) {
									j.call(this, b), this.inputmask && a(this).trigger("setvalue");
								}var i, j;if (!b.inputmask.__valueGet) {
									if (!0 !== e.noValuePatching) {
										if (Object.getOwnPropertyDescriptor) {
											"function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === g("test".__proto__) ? function (a) {
												return a.__proto__;
											} : function (a) {
												return a.constructor.prototype;
											});var k = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(b), "value") : d;k && k.get && k.set ? (i = k.get, j = k.set, Object.defineProperty(b, "value", { get: f, set: h, configurable: !0 })) : "INPUT" !== b.tagName && (i = function i() {
												return this.textContent;
											}, j = function j(a) {
												this.textContent = a;
											}, Object.defineProperty(b, "value", { get: f, set: h, configurable: !0 }));
										} else c.__lookupGetter__ && b.__lookupGetter__("value") && (i = b.__lookupGetter__("value"), j = b.__lookupSetter__("value"), b.__defineGetter__("value", f), b.__defineSetter__("value", h));b.inputmask.__valueGet = i, b.inputmask.__valueSet = j;
									}b.inputmask._valueGet = function (a) {
										return Z && !0 !== a ? i.call(this.el).split("").reverse().join("") : i.call(this.el);
									}, b.inputmask._valueSet = function (a, b) {
										j.call(this.el, null === a || a === d ? "" : !0 !== b && Z ? a.split("").reverse().join("") : a);
									}, i === d && (i = function i() {
										return this.value;
									}, j = function j(a) {
										this.value = a;
									}, function (b) {
										if (a.valHooks && (a.valHooks[b] === d || !0 !== a.valHooks[b].inputmaskpatch)) {
											var c = a.valHooks[b] && a.valHooks[b].get ? a.valHooks[b].get : function (a) {
												return a.value;
											},
											    f = a.valHooks[b] && a.valHooks[b].set ? a.valHooks[b].set : function (a, b) {
												return a.value = b, a;
											};a.valHooks[b] = { get: function get(a) {
													if (a.inputmask) {
														if (a.inputmask.opts.autoUnmask) return a.inputmask.unmaskedvalue();var b = c(a);return -1 !== r(d, d, a.inputmask.maskset.validPositions) || !0 !== e.nullable ? b : "";
													}return c(a);
												}, set: function set(b, c) {
													var d,
													    e = a(b);return d = f(b, c), b.inputmask && e.trigger("setvalue"), d;
												}, inputmaskpatch: !0 };
										}
									}(b.type), function (b) {
										ca.on(b, "mouseenter", function (b) {
											var c = a(this);this.inputmask._valueGet() !== z().join("") && c.trigger("setvalue");
										});
									}(b));
								}
							}(b) : b.inputmask = d, h;
						}(b, j);if (!1 !== e && (Y = b, U = a(Y), V = Y !== d ? Y.maxLength : d, -1 === V && (V = d), !0 === j.colorMask && R(Y), n && (Y.hasOwnProperty("inputmode") && (Y.inputmode = j.inputmode, Y.setAttribute("inputmode", j.inputmode)), "rtfm" === j.androidHack && (!0 !== j.colorMask && R(Y), Y.type = "password")), !0 === e && (ca.on(Y, "submit", da.submitEvent), ca.on(Y, "reset", da.resetEvent), ca.on(Y, "mouseenter", da.mouseenterEvent), ca.on(Y, "blur", da.blurEvent), ca.on(Y, "focus", da.focusEvent), ca.on(Y, "mouseleave", da.mouseleaveEvent), !0 !== j.colorMask && ca.on(Y, "click", da.clickEvent), ca.on(Y, "dblclick", da.dblclickEvent), ca.on(Y, "paste", da.pasteEvent), ca.on(Y, "dragdrop", da.pasteEvent), ca.on(Y, "drop", da.pasteEvent), ca.on(Y, "cut", da.cutEvent), ca.on(Y, "complete", j.oncomplete), ca.on(Y, "incomplete", j.onincomplete), ca.on(Y, "cleared", j.oncleared), n || !0 === j.inputEventOnly ? Y.removeAttribute("maxLength") : (ca.on(Y, "keydown", da.keydownEvent), ca.on(Y, "keypress", da.keypressEvent)), ca.on(Y, "compositionstart", a.noop), ca.on(Y, "compositionupdate", a.noop), ca.on(Y, "compositionend", a.noop), ca.on(Y, "keyup", a.noop), ca.on(Y, "input", da.inputFallBackEvent), ca.on(Y, "beforeinput", a.noop)), ca.on(Y, "setvalue", da.setValueEvent), T = y().join(""), "" !== Y.inputmask._valueGet(!0) || !1 === j.clearMaskOnLostFocus || c.activeElement === Y)) {
							var f = a.isFunction(j.onBeforeMask) ? j.onBeforeMask.call(X, Y.inputmask._valueGet(!0), j) || Y.inputmask._valueGet(!0) : Y.inputmask._valueGet(!0);"" !== f && K(Y, !0, !1, Z ? f.split("").reverse() : f.split(""));var h = z().slice();T = h.join(""), !1 === P(h) && j.clearIncomplete && q(), j.clearMaskOnLostFocus && c.activeElement !== Y && (-1 === r() ? h = [] : O(h)), I(Y, h), c.activeElement === Y && M(Y, F(r()));
						}
					}(Y);break;case "format":
					return ea = (a.isFunction(j.onBeforeMask) ? j.onBeforeMask.call(X, f.value, j) || f.value : f.value).split(""), K(d, !0, !1, Z ? ea.reverse() : ea), f.metadata ? { value: Z ? z().slice().reverse().join("") : z().join(""), metadata: i.call(this, { action: "getmetadata" }, h, j) } : Z ? z().slice().reverse().join("") : z().join("");case "isValid":
					f.value ? (ea = f.value.split(""), K(d, !0, !0, Z ? ea.reverse() : ea)) : f.value = z().join("");for (var fa = z(), ga = N(), ha = fa.length - 1; ha > ga && !E(ha); ha--) {}return fa.splice(ga, ha + 1 - ga), P(fa) && f.value === z().join("");case "getemptymask":
					return y().join("");case "remove":
					if (Y && Y.inputmask) {
						U = a(Y), Y.inputmask._valueSet(j.autoUnmask ? L(Y) : Y.inputmask._valueGet(!0)), ca.off(Y);Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Y), "value") && Y.inputmask.__valueGet && Object.defineProperty(Y, "value", { get: Y.inputmask.__valueGet, set: Y.inputmask.__valueSet, configurable: !0 }) : c.__lookupGetter__ && Y.__lookupGetter__("value") && Y.inputmask.__valueGet && (Y.__defineGetter__("value", Y.inputmask.__valueGet), Y.__defineSetter__("value", Y.inputmask.__valueSet)), Y.inputmask = d;
					}return Y;case "getmetadata":
					if (a.isArray(h.metadata)) {
						var ia = o(!0, 0, !1).join("");return a.each(h.metadata, function (a, b) {
							if (b.mask === ia) return ia = b, !1;
						}), ia;
					}return h.metadata;}
		}var j = navigator.userAgent,
		    k = /mobile/i.test(j),
		    l = /iemobile/i.test(j),
		    m = /iphone/i.test(j) && !l,
		    n = /android/i.test(j) && !l;return e.prototype = { dataAttribute: "data-inputmask", defaults: { placeholder: "_", optionalmarker: { start: "[", end: "]" }, quantifiermarker: { start: "{", end: "}" }, groupmarker: { start: "(", end: ")" }, alternatormarker: "|", escapeChar: "\\", mask: null, regex: null, oncomplete: a.noop, onincomplete: a.noop, oncleared: a.noop, repeat: 0, greedy: !0, autoUnmask: !1, removeMaskOnSubmit: !1, clearMaskOnLostFocus: !0, insertMode: !0, clearIncomplete: !1, alias: null, onKeyDown: a.noop, onBeforeMask: null, onBeforePaste: function onBeforePaste(b, c) {
					return a.isFunction(c.onBeforeMask) ? c.onBeforeMask.call(this, b, c) : b;
				}, onBeforeWrite: null, onUnMask: null, showMaskOnFocus: !0, showMaskOnHover: !0, onKeyValidation: a.noop, skipOptionalPartCharacter: " ", numericInput: !1, rightAlign: !1, undoOnEscape: !0, radixPoint: "", radixPointDefinitionSymbol: d, groupSeparator: "", keepStatic: null, positionCaretOnTab: !0, tabThrough: !1, supportsInputType: ["text", "tel", "password"], ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229], isComplete: null, canClearPosition: a.noop, preValidation: null, postValidation: null, staticDefinitionSymbol: d, jitMasking: !1, nullable: !0, inputEventOnly: !1, noValuePatching: !1, positionCaretOnClick: "lvp", casing: null, inputmode: "verbatim", colorMask: !1, androidHack: !1, importDataAttributes: !0 }, definitions: { 9: { validator: "[0-9\uFF11-\uFF19]", cardinality: 1, definitionSymbol: "*" }, a: { validator: "[A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]", cardinality: 1, definitionSymbol: "*" }, "*": { validator: "[0-9\uFF11-\uFF19A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]", cardinality: 1 } }, aliases: {}, masksCache: {}, mask: function mask(g) {
				function j(c, e, g, h) {
					if (!0 === e.importDataAttributes) {
						var i,
						    j,
						    k,
						    l,
						    m = function m(a, e) {
							null !== (e = e !== d ? e : c.getAttribute(h + "-" + a)) && ("string" == typeof e && (0 === a.indexOf("on") ? e = b[e] : "false" === e ? e = !1 : "true" === e && (e = !0)), g[a] = e);
						},
						    n = c.getAttribute(h);if (n && "" !== n && (n = n.replace(new RegExp("'", "g"), '"'), j = JSON.parse("{" + n + "}")), j) {
							k = d;for (l in j) {
								if ("alias" === l.toLowerCase()) {
									k = j[l];break;
								}
							}
						}m("alias", k), g.alias && f(g.alias, g, e);for (i in e) {
							if (j) {
								k = d;for (l in j) {
									if (l.toLowerCase() === i.toLowerCase()) {
										k = j[l];break;
									}
								}
							}m(i, k);
						}
					}return a.extend(!0, e, g), ("rtl" === c.dir || e.rightAlign) && (c.style.textAlign = "right"), ("rtl" === c.dir || e.numericInput) && (c.dir = "ltr", c.removeAttribute("dir"), e.isRTL = !0), e;
				}var k = this;return "string" == typeof g && (g = c.getElementById(g) || c.querySelectorAll(g)), g = g.nodeName ? [g] : g, a.each(g, function (b, c) {
					var f = a.extend(!0, {}, k.opts);j(c, f, a.extend(!0, {}, k.userOptions), k.dataAttribute);var g = h(f, k.noMasksCache);g !== d && (c.inputmask !== d && (c.inputmask.opts.autoUnmask = !0, c.inputmask.remove()), c.inputmask = new e(d, d, !0), c.inputmask.opts = f, c.inputmask.noMasksCache = k.noMasksCache, c.inputmask.userOptions = a.extend(!0, {}, k.userOptions), c.inputmask.isRTL = f.isRTL || f.numericInput, c.inputmask.el = c, c.inputmask.maskset = g, a.data(c, "_inputmask_opts", f), i.call(c.inputmask, { action: "mask" }));
				}), g && g[0] ? g[0].inputmask || this : this;
			}, option: function option(b, c) {
				return "string" == typeof b ? this.opts[b] : "object" === (void 0 === b ? "undefined" : g(b)) ? (a.extend(this.userOptions, b), this.el && !0 !== c && this.mask(this.el), this) : void 0;
			}, unmaskedvalue: function unmaskedvalue(a) {
				return this.maskset = this.maskset || h(this.opts, this.noMasksCache), i.call(this, { action: "unmaskedvalue", value: a });
			}, remove: function remove() {
				return i.call(this, { action: "remove" });
			}, getemptymask: function getemptymask() {
				return this.maskset = this.maskset || h(this.opts, this.noMasksCache), i.call(this, { action: "getemptymask" });
			}, hasMaskedValue: function hasMaskedValue() {
				return !this.opts.autoUnmask;
			}, isComplete: function isComplete() {
				return this.maskset = this.maskset || h(this.opts, this.noMasksCache), i.call(this, { action: "isComplete" });
			}, getmetadata: function getmetadata() {
				return this.maskset = this.maskset || h(this.opts, this.noMasksCache), i.call(this, { action: "getmetadata" });
			}, isValid: function isValid(a) {
				return this.maskset = this.maskset || h(this.opts, this.noMasksCache), i.call(this, { action: "isValid", value: a });
			}, format: function format(a, b) {
				return this.maskset = this.maskset || h(this.opts, this.noMasksCache), i.call(this, { action: "format", value: a, metadata: b });
			}, analyseMask: function analyseMask(b, c, f) {
				function g(a, b, c, d) {
					this.matches = [], this.openGroup = a || !1, this.alternatorGroup = !1, this.isGroup = a || !1, this.isOptional = b || !1, this.isQuantifier = c || !1, this.isAlternator = d || !1, this.quantifier = { min: 1, max: 1 };
				}function h(b, g, h) {
					h = h !== d ? h : b.matches.length;var i = b.matches[h - 1];if (c) 0 === g.indexOf("[") || u && /\\d|\\s|\\w]/i.test(g) || "." === g ? b.matches.splice(h++, 0, { fn: new RegExp(g, f.casing ? "i" : ""), cardinality: 1, optionality: b.isOptional, newBlockMarker: i === d || i.def !== g, casing: null, def: g, placeholder: d, nativeDef: g }) : (u && (g = g[g.length - 1]), a.each(g.split(""), function (a, c) {
						i = b.matches[h - 1], b.matches.splice(h++, 0, { fn: null, cardinality: 0, optionality: b.isOptional, newBlockMarker: i === d || i.def !== c && null !== i.fn, casing: null, def: f.staticDefinitionSymbol || c, placeholder: f.staticDefinitionSymbol !== d ? c : d, nativeDef: c });
					})), u = !1;else {
						var j = (f.definitions ? f.definitions[g] : d) || e.prototype.definitions[g];if (j && !u) {
							for (var k = j.prevalidator, l = k ? k.length : 0, m = 1; m < j.cardinality; m++) {
								var n = l >= m ? k[m - 1] : [],
								    o = n.validator,
								    p = n.cardinality;b.matches.splice(h++, 0, { fn: o ? "string" == typeof o ? new RegExp(o, f.casing ? "i" : "") : new function () {
										this.test = o;
									}() : new RegExp("."), cardinality: p || 1, optionality: b.isOptional, newBlockMarker: i === d || i.def !== (j.definitionSymbol || g), casing: j.casing, def: j.definitionSymbol || g, placeholder: j.placeholder, nativeDef: g }), i = b.matches[h - 1];
							}b.matches.splice(h++, 0, { fn: j.validator ? "string" == typeof j.validator ? new RegExp(j.validator, f.casing ? "i" : "") : new function () {
									this.test = j.validator;
								}() : new RegExp("."), cardinality: j.cardinality, optionality: b.isOptional, newBlockMarker: i === d || i.def !== (j.definitionSymbol || g), casing: j.casing, def: j.definitionSymbol || g, placeholder: j.placeholder, nativeDef: g });
						} else b.matches.splice(h++, 0, { fn: null, cardinality: 0, optionality: b.isOptional, newBlockMarker: i === d || i.def !== g && null !== i.fn, casing: null, def: f.staticDefinitionSymbol || g, placeholder: f.staticDefinitionSymbol !== d ? g : d, nativeDef: g }), u = !1;
					}
				}function i(b) {
					b && b.matches && a.each(b.matches, function (a, e) {
						var g = b.matches[a + 1];(g === d || g.matches === d || !1 === g.isQuantifier) && e && e.isGroup && (e.isGroup = !1, c || (h(e, f.groupmarker.start, 0), !0 !== e.openGroup && h(e, f.groupmarker.end))), i(e);
					});
				}function j() {
					if (w.length > 0) {
						if (o = w[w.length - 1], h(o, m), o.isAlternator) {
							p = w.pop();for (var a = 0; a < p.matches.length; a++) {
								p.matches[a].isGroup = !1;
							}w.length > 0 ? (o = w[w.length - 1], o.matches.push(p)) : v.matches.push(p);
						}
					} else h(v, m);
				}function k(a) {
					a.matches = a.matches.reverse();for (var b in a.matches) {
						if (a.matches.hasOwnProperty(b)) {
							var c = parseInt(b);if (a.matches[b].isQuantifier && a.matches[c + 1] && a.matches[c + 1].isGroup) {
								var e = a.matches[b];a.matches.splice(b, 1), a.matches.splice(c + 1, 0, e);
							}a.matches[b].matches !== d ? a.matches[b] = k(a.matches[b]) : a.matches[b] = function (a) {
								return a === f.optionalmarker.start ? a = f.optionalmarker.end : a === f.optionalmarker.end ? a = f.optionalmarker.start : a === f.groupmarker.start ? a = f.groupmarker.end : a === f.groupmarker.end && (a = f.groupmarker.start), a;
							}(a.matches[b]);
						}
					}return a;
				}var l,
				    m,
				    n,
				    o,
				    p,
				    q,
				    r,
				    s = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?\})|[^.?*+^${[]()|\\]+|./g,
				    t = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
				    u = !1,
				    v = new g(),
				    w = [],
				    x = [];for (c && (f.optionalmarker.start = d, f.optionalmarker.end = d); l = c ? t.exec(b) : s.exec(b);) {
					if (m = l[0], c) switch (m.charAt(0)) {case "?":
							m = "{0,1}";break;case "+":case "*":
							m = "{" + m + "}";}if (u) j();else switch (m.charAt(0)) {case f.escapeChar:
							u = !0, c && j();break;case f.optionalmarker.end:case f.groupmarker.end:
							if (n = w.pop(), n.openGroup = !1, n !== d) {
								if (w.length > 0) {
									if (o = w[w.length - 1], o.matches.push(n), o.isAlternator) {
										p = w.pop();for (var y = 0; y < p.matches.length; y++) {
											p.matches[y].isGroup = !1, p.matches[y].alternatorGroup = !1;
										}w.length > 0 ? (o = w[w.length - 1], o.matches.push(p)) : v.matches.push(p);
									}
								} else v.matches.push(n);
							} else j();break;case f.optionalmarker.start:
							w.push(new g(!1, !0));break;case f.groupmarker.start:
							w.push(new g(!0));break;case f.quantifiermarker.start:
							var z = new g(!1, !1, !0);m = m.replace(/[{}]/g, "");var A = m.split(","),
							    B = isNaN(A[0]) ? A[0] : parseInt(A[0]),
							    C = 1 === A.length ? B : isNaN(A[1]) ? A[1] : parseInt(A[1]);if ("*" !== C && "+" !== C || (B = "*" === C ? 0 : 1), z.quantifier = { min: B, max: C }, w.length > 0) {
								var D = w[w.length - 1].matches;l = D.pop(), l.isGroup || (r = new g(!0), r.matches.push(l), l = r), D.push(l), D.push(z);
							} else l = v.matches.pop(), l.isGroup || (c && null === l.fn && "." === l.def && (l.fn = new RegExp(l.def, f.casing ? "i" : "")), r = new g(!0), r.matches.push(l), l = r), v.matches.push(l), v.matches.push(z);break;case f.alternatormarker:
							if (w.length > 0) {
								o = w[w.length - 1];var E = o.matches[o.matches.length - 1];q = o.openGroup && (E.matches === d || !1 === E.isGroup && !1 === E.isAlternator) ? w.pop() : o.matches.pop();
							} else q = v.matches.pop();if (q.isAlternator) w.push(q);else if (q.alternatorGroup ? (p = w.pop(), q.alternatorGroup = !1) : p = new g(!1, !1, !1, !0), p.matches.push(q), w.push(p), q.openGroup) {
								q.openGroup = !1;var F = new g(!0);F.alternatorGroup = !0, w.push(F);
							}break;default:
							j();}
				}for (; w.length > 0;) {
					n = w.pop(), v.matches.push(n);
				}return v.matches.length > 0 && (i(v), x.push(v)), (f.numericInput || f.isRTL) && k(x[0]), x;
			} }, e.extendDefaults = function (b) {
			a.extend(!0, e.prototype.defaults, b);
		}, e.extendDefinitions = function (b) {
			a.extend(!0, e.prototype.definitions, b);
		}, e.extendAliases = function (b) {
			a.extend(!0, e.prototype.aliases, b);
		}, e.format = function (a, b, c) {
			return e(b).format(a, c);
		}, e.unmask = function (a, b) {
			return e(b).unmaskedvalue(a);
		}, e.isValid = function (a, b) {
			return e(b).isValid(a);
		}, e.remove = function (b) {
			a.each(b, function (a, b) {
				b.inputmask && b.inputmask.remove();
			});
		}, e.escapeRegex = function (a) {
			var b = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"];return a.replace(new RegExp("(\\" + b.join("|\\") + ")", "gim"), "\\$1");
		}, e.keyCode = { ALT: 18, BACKSPACE: 8, BACKSPACE_SAFARI: 127, CAPS_LOCK: 20, COMMA: 188, COMMAND: 91, COMMAND_LEFT: 91, COMMAND_RIGHT: 93, CONTROL: 17, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, INSERT: 45, LEFT: 37, MENU: 93, NUMPAD_ADD: 107, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, NUMPAD_ENTER: 108, NUMPAD_MULTIPLY: 106, NUMPAD_SUBTRACT: 109, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SHIFT: 16, SPACE: 32, TAB: 9, UP: 38, WINDOWS: 91, X: 88 }, e;
	});
}, function (a, b) {
	a.exports = jQuery;
}, function (a, b, c) {
	"use strict";
	var d, e, f;"function" == typeof Symbol && Symbol.iterator;!function (g) {
		e = [c(0), c(1)], d = g, void 0 !== (f = "function" == typeof d ? d.apply(b, e) : d) && (a.exports = f);
	}(function (a, b) {
		function c(a) {
			return isNaN(a) || 29 === new Date(a, 2, 0).getDate();
		}return b.extendAliases({ "dd/mm/yyyy": { mask: "1/2/y", placeholder: "dd/mm/yyyy", regex: { val1pre: new RegExp("[0-3]"), val1: new RegExp("0[1-9]|[12][0-9]|3[01]"), val2pre: function val2pre(a) {
						var c = b.escapeRegex.call(this, a);return new RegExp("((0[1-9]|[12][0-9]|3[01])" + c + "[01])");
					}, val2: function val2(a) {
						var c = b.escapeRegex.call(this, a);return new RegExp("((0[1-9]|[12][0-9])" + c + "(0[1-9]|1[012]))|(30" + c + "(0[13-9]|1[012]))|(31" + c + "(0[13578]|1[02]))");
					} }, leapday: "29/02/", separator: "/", yearrange: { minyear: 1900, maxyear: 2099 }, isInYearRange: function isInYearRange(a, b, c) {
					if (isNaN(a)) return !1;var d = parseInt(a.concat(b.toString().slice(a.length))),
					    e = parseInt(a.concat(c.toString().slice(a.length)));return !isNaN(d) && b <= d && d <= c || !isNaN(e) && b <= e && e <= c;
				}, determinebaseyear: function determinebaseyear(a, b, c) {
					var d = new Date().getFullYear();if (a > d) return a;if (b < d) {
						for (var e = b.toString().slice(0, 2), f = b.toString().slice(2, 4); b < e + c;) {
							e--;
						}var g = e + f;return a > g ? a : g;
					}if (a <= d && d <= b) {
						for (var h = d.toString().slice(0, 2); b < h + c;) {
							h--;
						}var i = h + c;return i < a ? a : i;
					}return d;
				}, onKeyDown: function onKeyDown(c, d, e, f) {
					var g = a(this);if (c.ctrlKey && c.keyCode === b.keyCode.RIGHT) {
						var h = new Date();g.val(h.getDate().toString() + (h.getMonth() + 1).toString() + h.getFullYear().toString()), g.trigger("setvalue");
					}
				}, getFrontValue: function getFrontValue(a, b, c) {
					for (var d = 0, e = 0, f = 0; f < a.length && "2" !== a.charAt(f); f++) {
						var g = c.definitions[a.charAt(f)];g ? (d += e, e = g.cardinality) : e++;
					}return b.join("").substr(d, e);
				}, postValidation: function postValidation(a, b, d) {
					var e,
					    f,
					    g = a.join("");return 0 === d.mask.indexOf("y") ? (f = g.substr(0, 4), e = g.substring(4, 10)) : (f = g.substring(6, 10), e = g.substr(0, 6)), b && (e !== d.leapday || c(f));
				}, definitions: { 1: { validator: function validator(a, b, c, d, e) {
							if ("3" == a.charAt(0)) {
								if (new RegExp("[2-9]").test(a.charAt(1))) return a = "30", b.buffer[c] = "0", c++, { pos: c };
							}var f = e.regex.val1.test(a);return d || f || a.charAt(1) !== e.separator && -1 === "-./".indexOf(a.charAt(1)) || !(f = e.regex.val1.test("0" + a.charAt(0))) ? f : (b.buffer[c - 1] = "0", { refreshFromBuffer: { start: c - 1, end: c }, pos: c, c: a.charAt(0) });
						}, cardinality: 2, prevalidator: [{ validator: function validator(a, b, c, d, e) {
								var f = a;isNaN(b.buffer[c + 1]) || (f += b.buffer[c + 1]);var g = 1 === f.length ? e.regex.val1pre.test(f) : e.regex.val1.test(f);if (!d && !g) {
									if (g = e.regex.val1.test(a + "0")) return b.buffer[c] = a, b.buffer[++c] = "0", { pos: c, c: "0" };if (g = e.regex.val1.test("0" + a)) return b.buffer[c] = "0", c++, { pos: c };
								}return g;
							}, cardinality: 1 }] }, 2: { validator: function validator(a, b, c, d, e) {
							var f = e.getFrontValue(b.mask, b.buffer, e);if (-1 !== f.indexOf(e.placeholder[0]) && (f = "01" + e.separator), "1" == a.charAt(0)) {
								if (new RegExp("[3-9]").test(a.charAt(1))) return a = "10", b.buffer[c] = "0", c++, { pos: c };
							}var g = e.regex.val2(e.separator).test(f + a);return d || g || a.charAt(1) !== e.separator && -1 === "-./".indexOf(a.charAt(1)) || !(g = e.regex.val2(e.separator).test(f + "0" + a.charAt(0))) ? g : (b.buffer[c - 1] = "0", { refreshFromBuffer: { start: c - 1, end: c }, pos: c, c: a.charAt(0) });
						}, cardinality: 2, prevalidator: [{ validator: function validator(a, b, c, d, e) {
								isNaN(b.buffer[c + 1]) || (a += b.buffer[c + 1]);var f = e.getFrontValue(b.mask, b.buffer, e);-1 !== f.indexOf(e.placeholder[0]) && (f = "01" + e.separator);var g = 1 === a.length ? e.regex.val2pre(e.separator).test(f + a) : e.regex.val2(e.separator).test(f + a);return d || g || !(g = e.regex.val2(e.separator).test(f + "0" + a)) ? g : (b.buffer[c] = "0", c++, { pos: c });
							}, cardinality: 1 }] }, y: { validator: function validator(a, b, c, d, e) {
							return e.isInYearRange(a, e.yearrange.minyear, e.yearrange.maxyear);
						}, cardinality: 4, prevalidator: [{ validator: function validator(a, b, c, d, e) {
								var f = e.isInYearRange(a, e.yearrange.minyear, e.yearrange.maxyear);if (!d && !f) {
									var g = e.determinebaseyear(e.yearrange.minyear, e.yearrange.maxyear, a + "0").toString().slice(0, 1);if (f = e.isInYearRange(g + a, e.yearrange.minyear, e.yearrange.maxyear)) return b.buffer[c++] = g.charAt(0), { pos: c };if (g = e.determinebaseyear(e.yearrange.minyear, e.yearrange.maxyear, a + "0").toString().slice(0, 2), f = e.isInYearRange(g + a, e.yearrange.minyear, e.yearrange.maxyear)) return b.buffer[c++] = g.charAt(0), b.buffer[c++] = g.charAt(1), { pos: c };
								}return f;
							}, cardinality: 1 }, { validator: function validator(a, b, c, d, e) {
								var f = e.isInYearRange(a, e.yearrange.minyear, e.yearrange.maxyear);if (!d && !f) {
									var g = e.determinebaseyear(e.yearrange.minyear, e.yearrange.maxyear, a).toString().slice(0, 2);if (f = e.isInYearRange(a[0] + g[1] + a[1], e.yearrange.minyear, e.yearrange.maxyear)) return b.buffer[c++] = g.charAt(1), { pos: c };if (g = e.determinebaseyear(e.yearrange.minyear, e.yearrange.maxyear, a).toString().slice(0, 2), f = e.isInYearRange(g + a, e.yearrange.minyear, e.yearrange.maxyear)) return b.buffer[c - 1] = g.charAt(0), b.buffer[c++] = g.charAt(1), b.buffer[c++] = a.charAt(0), { refreshFromBuffer: { start: c - 3, end: c }, pos: c };
								}return f;
							}, cardinality: 2 }, { validator: function validator(a, b, c, d, e) {
								return e.isInYearRange(a, e.yearrange.minyear, e.yearrange.maxyear);
							}, cardinality: 3 }] } }, insertMode: !1, autoUnmask: !1 }, "mm/dd/yyyy": { placeholder: "mm/dd/yyyy", alias: "dd/mm/yyyy", regex: { val2pre: function val2pre(a) {
						var c = b.escapeRegex.call(this, a);return new RegExp("((0[13-9]|1[012])" + c + "[0-3])|(02" + c + "[0-2])");
					}, val2: function val2(a) {
						var c = b.escapeRegex.call(this, a);return new RegExp("((0[1-9]|1[012])" + c + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + c + "30)|((0[13578]|1[02])" + c + "31)");
					}, val1pre: new RegExp("[01]"), val1: new RegExp("0[1-9]|1[012]") }, leapday: "02/29/", onKeyDown: function onKeyDown(c, d, e, f) {
					var g = a(this);if (c.ctrlKey && c.keyCode === b.keyCode.RIGHT) {
						var h = new Date();g.val((h.getMonth() + 1).toString() + h.getDate().toString() + h.getFullYear().toString()), g.trigger("setvalue");
					}
				} }, "yyyy/mm/dd": { mask: "y/1/2", placeholder: "yyyy/mm/dd", alias: "mm/dd/yyyy", leapday: "/02/29", onKeyDown: function onKeyDown(c, d, e, f) {
					var g = a(this);if (c.ctrlKey && c.keyCode === b.keyCode.RIGHT) {
						var h = new Date();g.val(h.getFullYear().toString() + (h.getMonth() + 1).toString() + h.getDate().toString()), g.trigger("setvalue");
					}
				} }, "dd.mm.yyyy": { mask: "1.2.y", placeholder: "dd.mm.yyyy", leapday: "29.02.", separator: ".", alias: "dd/mm/yyyy" }, "dd-mm-yyyy": { mask: "1-2-y", placeholder: "dd-mm-yyyy", leapday: "29-02-", separator: "-", alias: "dd/mm/yyyy" }, "mm.dd.yyyy": { mask: "1.2.y", placeholder: "mm.dd.yyyy", leapday: "02.29.", separator: ".", alias: "mm/dd/yyyy" }, "mm-dd-yyyy": { mask: "1-2-y", placeholder: "mm-dd-yyyy", leapday: "02-29-", separator: "-", alias: "mm/dd/yyyy" }, "yyyy.mm.dd": { mask: "y.1.2", placeholder: "yyyy.mm.dd", leapday: ".02.29", separator: ".", alias: "yyyy/mm/dd" }, "yyyy-mm-dd": { mask: "y-1-2", placeholder: "yyyy-mm-dd", leapday: "-02-29", separator: "-", alias: "yyyy/mm/dd" }, datetime: { mask: "1/2/y h:s", placeholder: "dd/mm/yyyy hh:mm", alias: "dd/mm/yyyy", regex: { hrspre: new RegExp("[012]"), hrs24: new RegExp("2[0-4]|1[3-9]"), hrs: new RegExp("[01][0-9]|2[0-4]"), ampm: new RegExp("^[a|p|A|P][m|M]"), mspre: new RegExp("[0-5]"), ms: new RegExp("[0-5][0-9]") }, timeseparator: ":", hourFormat: "24", definitions: { h: { validator: function validator(a, b, c, d, e) {
							if ("24" === e.hourFormat && 24 === parseInt(a, 10)) return b.buffer[c - 1] = "0", b.buffer[c] = "0", { refreshFromBuffer: { start: c - 1, end: c }, c: "0" };var f = e.regex.hrs.test(a);if (!d && !f && (a.charAt(1) === e.timeseparator || -1 !== "-.:".indexOf(a.charAt(1))) && (f = e.regex.hrs.test("0" + a.charAt(0)))) return b.buffer[c - 1] = "0", b.buffer[c] = a.charAt(0), c++, { refreshFromBuffer: { start: c - 2, end: c }, pos: c, c: e.timeseparator };if (f && "24" !== e.hourFormat && e.regex.hrs24.test(a)) {
								var g = parseInt(a, 10);return 24 === g ? (b.buffer[c + 5] = "a", b.buffer[c + 6] = "m") : (b.buffer[c + 5] = "p", b.buffer[c + 6] = "m"), g -= 12, g < 10 ? (b.buffer[c] = g.toString(), b.buffer[c - 1] = "0") : (b.buffer[c] = g.toString().charAt(1), b.buffer[c - 1] = g.toString().charAt(0)), { refreshFromBuffer: { start: c - 1, end: c + 6 }, c: b.buffer[c] };
							}return f;
						}, cardinality: 2, prevalidator: [{ validator: function validator(a, b, c, d, e) {
								var f = e.regex.hrspre.test(a);return d || f || !(f = e.regex.hrs.test("0" + a)) ? f : (b.buffer[c] = "0", c++, { pos: c });
							}, cardinality: 1 }] }, s: { validator: "[0-5][0-9]", cardinality: 2, prevalidator: [{ validator: function validator(a, b, c, d, e) {
								var f = e.regex.mspre.test(a);return d || f || !(f = e.regex.ms.test("0" + a)) ? f : (b.buffer[c] = "0", c++, { pos: c });
							}, cardinality: 1 }] }, t: { validator: function validator(a, b, c, d, e) {
							return e.regex.ampm.test(a + "m");
						}, casing: "lower", cardinality: 1 } }, insertMode: !1, autoUnmask: !1 }, datetime12: { mask: "1/2/y h:s t\\m", placeholder: "dd/mm/yyyy hh:mm xm", alias: "datetime", hourFormat: "12" }, "mm/dd/yyyy hh:mm xm": { mask: "1/2/y h:s t\\m", placeholder: "mm/dd/yyyy hh:mm xm", alias: "datetime12", regex: { val2pre: function val2pre(a) {
						var c = b.escapeRegex.call(this, a);return new RegExp("((0[13-9]|1[012])" + c + "[0-3])|(02" + c + "[0-2])");
					}, val2: function val2(a) {
						var c = b.escapeRegex.call(this, a);return new RegExp("((0[1-9]|1[012])" + c + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + c + "30)|((0[13578]|1[02])" + c + "31)");
					}, val1pre: new RegExp("[01]"), val1: new RegExp("0[1-9]|1[012]") }, leapday: "02/29/", onKeyDown: function onKeyDown(c, d, e, f) {
					var g = a(this);if (c.ctrlKey && c.keyCode === b.keyCode.RIGHT) {
						var h = new Date();g.val((h.getMonth() + 1).toString() + h.getDate().toString() + h.getFullYear().toString()), g.trigger("setvalue");
					}
				} }, "hh:mm t": { mask: "h:s t\\m", placeholder: "hh:mm xm", alias: "datetime", hourFormat: "12" }, "h:s t": { mask: "h:s t\\m", placeholder: "hh:mm xm", alias: "datetime", hourFormat: "12" }, "hh:mm:ss": { mask: "h:s:s", placeholder: "hh:mm:ss", alias: "datetime", autoUnmask: !1 }, "hh:mm": { mask: "h:s", placeholder: "hh:mm", alias: "datetime", autoUnmask: !1 }, date: { alias: "dd/mm/yyyy" }, "mm/yyyy": { mask: "1/y", placeholder: "mm/yyyy", leapday: "donotuse", separator: "/", alias: "mm/dd/yyyy" }, shamsi: { regex: { val2pre: function val2pre(a) {
						var c = b.escapeRegex.call(this, a);return new RegExp("((0[1-9]|1[012])" + c + "[0-3])");
					}, val2: function val2(a) {
						var c = b.escapeRegex.call(this, a);return new RegExp("((0[1-9]|1[012])" + c + "(0[1-9]|[12][0-9]))|((0[1-9]|1[012])" + c + "30)|((0[1-6])" + c + "31)");
					}, val1pre: new RegExp("[01]"), val1: new RegExp("0[1-9]|1[012]") }, yearrange: { minyear: 1300, maxyear: 1499 }, mask: "y/1/2", leapday: "/12/30", placeholder: "yyyy/mm/dd", alias: "mm/dd/yyyy", clearIncomplete: !0 }, "yyyy-mm-dd hh:mm:ss": { mask: "y-1-2 h:s:s", placeholder: "yyyy-mm-dd hh:mm:ss", alias: "datetime", separator: "-", leapday: "-02-29", regex: { val2pre: function val2pre(a) {
						var c = b.escapeRegex.call(this, a);return new RegExp("((0[13-9]|1[012])" + c + "[0-3])|(02" + c + "[0-2])");
					}, val2: function val2(a) {
						var c = b.escapeRegex.call(this, a);return new RegExp("((0[1-9]|1[012])" + c + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + c + "30)|((0[13578]|1[02])" + c + "31)");
					}, val1pre: new RegExp("[01]"), val1: new RegExp("0[1-9]|1[012]") }, onKeyDown: function onKeyDown(a, b, c, d) {} } }), b;
	});
}, function (a, b, c) {
	"use strict";
	var d, e, f;"function" == typeof Symbol && Symbol.iterator;!function (g) {
		e = [c(0), c(1)], d = g, void 0 !== (f = "function" == typeof d ? d.apply(b, e) : d) && (a.exports = f);
	}(function (a, b) {
		return b.extendDefinitions({ A: { validator: "[A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]", cardinality: 1, casing: "upper" }, "&": { validator: "[0-9A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]", cardinality: 1, casing: "upper" }, "#": { validator: "[0-9A-Fa-f]", cardinality: 1, casing: "upper" } }), b.extendAliases({ url: { definitions: { i: { validator: ".", cardinality: 1 } }, mask: "(\\http://)|(\\http\\s://)|(ftp://)|(ftp\\s://)i{+}", insertMode: !1, autoUnmask: !1, inputmode: "url" }, ip: { mask: "i[i[i]].i[i[i]].i[i[i]].i[i[i]]", definitions: { i: { validator: function validator(a, b, c, d, e) {
							return c - 1 > -1 && "." !== b.buffer[c - 1] ? (a = b.buffer[c - 1] + a, a = c - 2 > -1 && "." !== b.buffer[c - 2] ? b.buffer[c - 2] + a : "0" + a) : a = "00" + a, new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]").test(a);
						}, cardinality: 1 } }, onUnMask: function onUnMask(a, b, c) {
					return a;
				}, inputmode: "numeric" }, email: { mask: "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]", greedy: !1, onBeforePaste: function onBeforePaste(a, b) {
					return a = a.toLowerCase(), a.replace("mailto:", "");
				}, definitions: { "*": { validator: "[0-9A-Za-z!#$%&'*+/=?^_`{|}~-]", cardinality: 1, casing: "lower" }, "-": { validator: "[0-9A-Za-z-]", cardinality: 1, casing: "lower" } }, onUnMask: function onUnMask(a, b, c) {
					return a;
				}, inputmode: "email" }, mac: { mask: "##:##:##:##:##:##" }, vin: { mask: "V{13}9{4}", definitions: { V: { validator: "[A-HJ-NPR-Za-hj-npr-z\\d]", cardinality: 1, casing: "upper" } }, clearIncomplete: !0, autoUnmask: !0 } }), b;
	});
}, function (a, b, c) {
	"use strict";
	var d, e, f;"function" == typeof Symbol && Symbol.iterator;!function (g) {
		e = [c(0), c(1)], d = g, void 0 !== (f = "function" == typeof d ? d.apply(b, e) : d) && (a.exports = f);
	}(function (a, b, c) {
		function d(a, c) {
			for (var d = "", e = 0; e < a.length; e++) {
				b.prototype.definitions[a.charAt(e)] || c.definitions[a.charAt(e)] || c.optionalmarker.start === a.charAt(e) || c.optionalmarker.end === a.charAt(e) || c.quantifiermarker.start === a.charAt(e) || c.quantifiermarker.end === a.charAt(e) || c.groupmarker.start === a.charAt(e) || c.groupmarker.end === a.charAt(e) || c.alternatormarker === a.charAt(e) ? d += "\\" + a.charAt(e) : d += a.charAt(e);
			}return d;
		}return b.extendAliases({ numeric: { mask: function mask(a) {
					if (0 !== a.repeat && isNaN(a.integerDigits) && (a.integerDigits = a.repeat), a.repeat = 0, a.groupSeparator === a.radixPoint && ("." === a.radixPoint ? a.groupSeparator = "," : "," === a.radixPoint ? a.groupSeparator = "." : a.groupSeparator = ""), " " === a.groupSeparator && (a.skipOptionalPartCharacter = c), a.autoGroup = a.autoGroup && "" !== a.groupSeparator, a.autoGroup && ("string" == typeof a.groupSize && isFinite(a.groupSize) && (a.groupSize = parseInt(a.groupSize)), isFinite(a.integerDigits))) {
						var b = Math.floor(a.integerDigits / a.groupSize),
						    e = a.integerDigits % a.groupSize;a.integerDigits = parseInt(a.integerDigits) + (0 === e ? b - 1 : b), a.integerDigits < 1 && (a.integerDigits = "*");
					}a.placeholder.length > 1 && (a.placeholder = a.placeholder.charAt(0)), "radixFocus" === a.positionCaretOnClick && "" === a.placeholder && !1 === a.integerOptional && (a.positionCaretOnClick = "lvp"), a.definitions[";"] = a.definitions["~"], a.definitions[";"].definitionSymbol = "~", !0 === a.numericInput && (a.positionCaretOnClick = "radixFocus" === a.positionCaretOnClick ? "lvp" : a.positionCaretOnClick, a.digitsOptional = !1, isNaN(a.digits) && (a.digits = 2), a.decimalProtect = !1);var f = "[+]";if (f += d(a.prefix, a), !0 === a.integerOptional ? f += "~{1," + a.integerDigits + "}" : f += "~{" + a.integerDigits + "}", a.digits !== c) {
						a.radixPointDefinitionSymbol = a.decimalProtect ? ":" : a.radixPoint;var g = a.digits.toString().split(",");isFinite(g[0] && g[1] && isFinite(g[1])) ? f += a.radixPointDefinitionSymbol + ";{" + a.digits + "}" : (isNaN(a.digits) || parseInt(a.digits) > 0) && (a.digitsOptional ? f += "[" + a.radixPointDefinitionSymbol + ";{1," + a.digits + "}]" : f += a.radixPointDefinitionSymbol + ";{" + a.digits + "}");
					}return f += d(a.suffix, a), f += "[-]", a.greedy = !1, f;
				}, placeholder: "", greedy: !1, digits: "*", digitsOptional: !0, enforceDigitsOnBlur: !1, radixPoint: ".", positionCaretOnClick: "radixFocus", groupSize: 3, groupSeparator: "", autoGroup: !1, allowMinus: !0, negationSymbol: { front: "-", back: "" }, integerDigits: "+", integerOptional: !0, prefix: "", suffix: "", rightAlign: !0, decimalProtect: !0, min: null, max: null, step: 1, insertMode: !0, autoUnmask: !1, unmaskAsNumber: !1, inputmode: "numeric", preValidation: function preValidation(b, d, e, f, g) {
					if ("-" === e || e === g.negationSymbol.front) return !0 === g.allowMinus && (g.isNegative = g.isNegative === c || !g.isNegative, "" === b.join("") || { caret: d, dopost: !0 });if (!1 === f && e === g.radixPoint && g.digits !== c && (isNaN(g.digits) || parseInt(g.digits) > 0)) {
						var h = a.inArray(g.radixPoint, b);if (-1 !== h) return !0 === g.numericInput ? d === h : { caret: h + 1 };
					}return !0;
				}, postValidation: function postValidation(d, e, f) {
					var g = f.suffix.split(""),
					    h = f.prefix.split("");if (e.pos === c && e.caret !== c && !0 !== e.dopost) return e;var i = e.caret !== c ? e.caret : e.pos,
					    j = d.slice();f.numericInput && (i = j.length - i - 1, j = j.reverse());var k = j[i];if (k === f.groupSeparator && (i += 1, k = j[i]), i === j.length - f.suffix.length - 1 && k === f.radixPoint) return e;k !== c && k !== f.radixPoint && k !== f.negationSymbol.front && k !== f.negationSymbol.back && (j[i] = "?", f.prefix.length > 0 && i >= (!1 === f.isNegative ? 1 : 0) && i < f.prefix.length - 1 + (!1 === f.isNegative ? 1 : 0) ? h[i - (!1 === f.isNegative ? 1 : 0)] = "?" : f.suffix.length > 0 && i >= j.length - f.suffix.length - (!1 === f.isNegative ? 1 : 0) && (g[i - (j.length - f.suffix.length - (!1 === f.isNegative ? 1 : 0))] = "?")), h = h.join(""), g = g.join("");var l = j.join("").replace(h, "");if (l = l.replace(g, ""), l = l.replace(new RegExp(b.escapeRegex(f.groupSeparator), "g"), ""), l = l.replace(new RegExp("[-" + b.escapeRegex(f.negationSymbol.front) + "]", "g"), ""), l = l.replace(new RegExp(b.escapeRegex(f.negationSymbol.back) + "$"), ""), isNaN(f.placeholder) && (l = l.replace(new RegExp(b.escapeRegex(f.placeholder), "g"), "")), l.length > 1 && 1 !== l.indexOf(f.radixPoint) && ("0" === k && (l = l.replace(/^\?/g, "")), l = l.replace(/^0/g, "")), l.charAt(0) === f.radixPoint && "" !== f.radixPoint && !0 !== f.numericInput && (l = "0" + l), "" !== l) {
						if (l = l.split(""), (!f.digitsOptional || f.enforceDigitsOnBlur && "blur" === e.event) && isFinite(f.digits)) {
							var m = a.inArray(f.radixPoint, l),
							    n = a.inArray(f.radixPoint, j);-1 === m && (l.push(f.radixPoint), m = l.length - 1);for (var o = 1; o <= f.digits; o++) {
								f.digitsOptional && (!f.enforceDigitsOnBlur || "blur" !== e.event) || l[m + o] !== c && l[m + o] !== f.placeholder.charAt(0) ? -1 !== n && j[n + o] !== c && (l[m + o] = l[m + o] || j[n + o]) : l[m + o] = e.placeholder || f.placeholder.charAt(0);
							}
						}if (!0 !== f.autoGroup || "" === f.groupSeparator || k === f.radixPoint && e.pos === c && !e.dopost) l = l.join("");else {
							var p = l[l.length - 1] === f.radixPoint && e.c === f.radixPoint;l = b(function (a, b) {
								var c = "";if (c += "(" + b.groupSeparator + "*{" + b.groupSize + "}){*}", "" !== b.radixPoint) {
									var d = a.join("").split(b.radixPoint);d[1] && (c += b.radixPoint + "*{" + d[1].match(/^\d*\??\d*/)[0].length + "}");
								}return c;
							}(l, f), { numericInput: !0, jitMasking: !0, definitions: { "*": { validator: "[0-9?]", cardinality: 1 } } }).format(l.join("")), p && (l += f.radixPoint), l.charAt(0) === f.groupSeparator && l.substr(1);
						}
					}if (f.isNegative && "blur" === e.event && (f.isNegative = "0" !== l), l = h + l, l += g, f.isNegative && (l = f.negationSymbol.front + l, l += f.negationSymbol.back), l = l.split(""), k !== c) if (k !== f.radixPoint && k !== f.negationSymbol.front && k !== f.negationSymbol.back) i = a.inArray("?", l), i > -1 ? l[i] = k : i = e.caret || 0;else if (k === f.radixPoint || k === f.negationSymbol.front || k === f.negationSymbol.back) {
						var q = a.inArray(k, l);-1 !== q && (i = q);
					}f.numericInput && (i = l.length - i - 1, l = l.reverse());var r = { caret: k === c || e.pos !== c ? i + (f.numericInput ? -1 : 1) : i, buffer: l, refreshFromBuffer: e.dopost || d.join("") !== l.join("") };return r.refreshFromBuffer ? r : e;
				}, onBeforeWrite: function onBeforeWrite(d, e, f, g) {
					if (d) switch (d.type) {case "keydown":
							return g.postValidation(e, { caret: f, dopost: !0 }, g);case "blur":case "checkval":
							var h;if (function (a) {
								a.parseMinMaxOptions === c && (null !== a.min && (a.min = a.min.toString().replace(new RegExp(b.escapeRegex(a.groupSeparator), "g"), ""), "," === a.radixPoint && (a.min = a.min.replace(a.radixPoint, ".")), a.min = isFinite(a.min) ? parseFloat(a.min) : NaN, isNaN(a.min) && (a.min = Number.MIN_VALUE)), null !== a.max && (a.max = a.max.toString().replace(new RegExp(b.escapeRegex(a.groupSeparator), "g"), ""), "," === a.radixPoint && (a.max = a.max.replace(a.radixPoint, ".")), a.max = isFinite(a.max) ? parseFloat(a.max) : NaN, isNaN(a.max) && (a.max = Number.MAX_VALUE)), a.parseMinMaxOptions = "done");
							}(g), null !== g.min || null !== g.max) {
								if (h = g.onUnMask(e.join(""), c, a.extend({}, g, { unmaskAsNumber: !0 })), null !== g.min && h < g.min) return g.isNegative = g.min < 0, g.postValidation(g.min.toString().replace(".", g.radixPoint).split(""), { caret: f, dopost: !0, placeholder: "0" }, g);if (null !== g.max && h > g.max) return g.isNegative = g.max < 0, g.postValidation(g.max.toString().replace(".", g.radixPoint).split(""), { caret: f, dopost: !0, placeholder: "0" }, g);
							}return g.postValidation(e, { caret: f, placeholder: "0", event: "blur" }, g);case "_checkval":
							return { caret: f };}
				}, regex: { integerPart: function integerPart(a, c) {
						return c ? new RegExp("[" + b.escapeRegex(a.negationSymbol.front) + "+]?") : new RegExp("[" + b.escapeRegex(a.negationSymbol.front) + "+]?\\d+");
					}, integerNPart: function integerNPart(a) {
						return new RegExp("[\\d" + b.escapeRegex(a.groupSeparator) + b.escapeRegex(a.placeholder.charAt(0)) + "]+");
					} }, definitions: { "~": { validator: function validator(a, d, e, f, g, h) {
							var i = f ? new RegExp("[0-9" + b.escapeRegex(g.groupSeparator) + "]").test(a) : new RegExp("[0-9]").test(a);if (!0 === i) {
								if (!0 !== g.numericInput && d.validPositions[e] !== c && "~" === d.validPositions[e].match.def && !h) {
									var j = d.buffer.join("");j = j.replace(new RegExp("[-" + b.escapeRegex(g.negationSymbol.front) + "]", "g"), ""), j = j.replace(new RegExp(b.escapeRegex(g.negationSymbol.back) + "$"), "");var k = j.split(g.radixPoint);k.length > 1 && (k[1] = k[1].replace(/0/g, g.placeholder.charAt(0))), "0" === k[0] && (k[0] = k[0].replace(/0/g, g.placeholder.charAt(0))), j = k[0] + g.radixPoint + k[1] || "";var l = d._buffer.join("");for (j === g.radixPoint && (j = l); null === j.match(b.escapeRegex(l) + "$");) {
										l = l.slice(1);
									}j = j.replace(l, ""), j = j.split(""), i = j[e] === c ? { pos: e, remove: e } : { pos: e };
								}
							} else f || a !== g.radixPoint || d.validPositions[e - 1] !== c || (d.buffer[e] = "0", i = { pos: e + 1 });return i;
						}, cardinality: 1 }, "+": { validator: function validator(a, b, c, d, e) {
							return e.allowMinus && ("-" === a || a === e.negationSymbol.front);
						}, cardinality: 1, placeholder: "" }, "-": { validator: function validator(a, b, c, d, e) {
							return e.allowMinus && a === e.negationSymbol.back;
						}, cardinality: 1, placeholder: "" }, ":": { validator: function validator(a, c, d, e, f) {
							var g = "[" + b.escapeRegex(f.radixPoint) + "]",
							    h = new RegExp(g).test(a);return h && c.validPositions[d] && c.validPositions[d].match.placeholder === f.radixPoint && (h = { caret: d + 1 }), h;
						}, cardinality: 1, placeholder: function placeholder(a) {
							return a.radixPoint;
						} } }, onUnMask: function onUnMask(a, c, d) {
					if ("" === c && !0 === d.nullable) return c;var e = a.replace(d.prefix, "");return e = e.replace(d.suffix, ""), e = e.replace(new RegExp(b.escapeRegex(d.groupSeparator), "g"), ""), "" !== d.placeholder.charAt(0) && (e = e.replace(new RegExp(d.placeholder.charAt(0), "g"), "0")), d.unmaskAsNumber ? ("" !== d.radixPoint && -1 !== e.indexOf(d.radixPoint) && (e = e.replace(b.escapeRegex.call(this, d.radixPoint), ".")), e = e.replace(new RegExp("^" + b.escapeRegex(d.negationSymbol.front)), "-"), e = e.replace(new RegExp(b.escapeRegex(d.negationSymbol.back) + "$"), ""), Number(e)) : e;
				}, isComplete: function isComplete(a, c) {
					var d = a.join("");if (a.slice().join("") !== d) return !1;var e = d.replace(c.prefix, "");return e = e.replace(c.suffix, ""), e = e.replace(new RegExp(b.escapeRegex(c.groupSeparator), "g"), ""), "," === c.radixPoint && (e = e.replace(b.escapeRegex(c.radixPoint), ".")), isFinite(e);
				}, onBeforeMask: function onBeforeMask(a, d) {
					if (d.isNegative = c, a = a.toString().charAt(a.length - 1) === d.radixPoint ? a.toString().substr(0, a.length - 1) : a.toString(), "" !== d.radixPoint && isFinite(a)) {
						var e = a.split("."),
						    f = "" !== d.groupSeparator ? parseInt(d.groupSize) : 0;2 === e.length && (e[0].length > f || e[1].length > f || e[0].length <= f && e[1].length < f) && (a = a.replace(".", d.radixPoint));
					}var g = a.match(/,/g),
					    h = a.match(/\./g);if (h && g ? h.length > g.length ? (a = a.replace(/\./g, ""), a = a.replace(",", d.radixPoint)) : g.length > h.length ? (a = a.replace(/,/g, ""), a = a.replace(".", d.radixPoint)) : a = a.indexOf(".") < a.indexOf(",") ? a.replace(/\./g, "") : a.replace(/,/g, "") : a = a.replace(new RegExp(b.escapeRegex(d.groupSeparator), "g"), ""), 0 === d.digits && (-1 !== a.indexOf(".") ? a = a.substring(0, a.indexOf(".")) : -1 !== a.indexOf(",") && (a = a.substring(0, a.indexOf(",")))), "" !== d.radixPoint && isFinite(d.digits) && -1 !== a.indexOf(d.radixPoint)) {
						var i = a.split(d.radixPoint),
						    j = i[1].match(new RegExp("\\d*"))[0];if (parseInt(d.digits) < j.toString().length) {
							var k = Math.pow(10, parseInt(d.digits));a = a.replace(b.escapeRegex(d.radixPoint), "."), a = Math.round(parseFloat(a) * k) / k, a = a.toString().replace(".", d.radixPoint);
						}
					}return a;
				}, canClearPosition: function canClearPosition(a, b, c, d, e) {
					var f = a.validPositions[b],
					    g = f.input !== e.radixPoint || null !== a.validPositions[b].match.fn && !1 === e.decimalProtect || f.input === e.radixPoint && a.validPositions[b + 1] && null === a.validPositions[b + 1].match.fn || isFinite(f.input) || b === c || f.input === e.groupSeparator || f.input === e.negationSymbol.front || f.input === e.negationSymbol.back;return !g || "+" !== f.match.nativeDef && "-" !== f.match.nativeDef || (e.isNegative = !1), g;
				}, onKeyDown: function onKeyDown(c, d, e, f) {
					var g = a(this);if (c.ctrlKey) switch (c.keyCode) {case b.keyCode.UP:
							g.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(f.step)), g.trigger("setvalue");break;case b.keyCode.DOWN:
							g.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(f.step)), g.trigger("setvalue");}
				} }, currency: { prefix: "$ ", groupSeparator: ",", alias: "numeric", placeholder: "0", autoGroup: !0, digits: 2, digitsOptional: !1, clearMaskOnLostFocus: !1 }, decimal: { alias: "numeric" }, integer: { alias: "numeric", digits: 0, radixPoint: "" }, percentage: { alias: "numeric", digits: 2, digitsOptional: !0, radixPoint: ".", placeholder: "0", autoGroup: !1, min: 0, max: 100, suffix: " %", allowMinus: !1 } }), b;
	});
}, function (a, b, c) {
	"use strict";
	var d, e, f;"function" == typeof Symbol && Symbol.iterator;!function (g) {
		e = [c(0), c(1)], d = g, void 0 !== (f = "function" == typeof d ? d.apply(b, e) : d) && (a.exports = f);
	}(function (a, b) {
		function c(a, b) {
			var c = (a.mask || a).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""),
			    d = (b.mask || b).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""),
			    e = (a.mask || a).split("#")[0],
			    f = (b.mask || b).split("#")[0];return 0 === f.indexOf(e) ? -1 : 0 === e.indexOf(f) ? 1 : c.localeCompare(d);
		}var d = b.prototype.analyseMask;return b.prototype.analyseMask = function (b, c, e) {
			function f(a, c, d) {
				c = c || "", d = d || h, "" !== c && (d[c] = {});for (var e = "", g = d[c] || d, i = a.length - 1; i >= 0; i--) {
					b = a[i].mask || a[i], e = b.substr(0, 1), g[e] = g[e] || [], g[e].unshift(b.substr(1)), a.splice(i, 1);
				}for (var j in g) {
					g[j].length > 500 && f(g[j].slice(), j, g);
				}
			}function g(b) {
				var c = "",
				    d = [];for (var f in b) {
					a.isArray(b[f]) ? 1 === b[f].length ? d.push(f + b[f]) : d.push(f + e.groupmarker.start + b[f].join(e.groupmarker.end + e.alternatormarker + e.groupmarker.start) + e.groupmarker.end) : d.push(f + g(b[f]));
				}return 1 === d.length ? c += d[0] : c += e.groupmarker.start + d.join(e.groupmarker.end + e.alternatormarker + e.groupmarker.start) + e.groupmarker.end, c;
			}var h = {};return e.phoneCodes && (e.phoneCodes && e.phoneCodes.length > 1e3 && (b = b.substr(1, b.length - 2), f(b.split(e.groupmarker.end + e.alternatormarker + e.groupmarker.start)), b = g(h)), b = b.replace(/9/g, "\\9")), d.call(this, b, c, e);
		}, b.extendAliases({ abstractphone: { groupmarker: { start: "<", end: ">" }, countrycode: "", phoneCodes: [], mask: function mask(a) {
					return a.definitions = { "#": b.prototype.definitions[9] }, a.phoneCodes.sort(c);
				}, keepStatic: !0, onBeforeMask: function onBeforeMask(a, b) {
					var c = a.replace(/^0{1,2}/, "").replace(/[\s]/g, "");return (c.indexOf(b.countrycode) > 1 || -1 === c.indexOf(b.countrycode)) && (c = "+" + b.countrycode + c), c;
				}, onUnMask: function onUnMask(a, b, c) {
					return a.replace(/[()#-]/g, "");
				}, inputmode: "tel" } }), b;
	});
}, function (a, b, c) {
	"use strict";
	var d, e, f;"function" == typeof Symbol && Symbol.iterator;!function (g) {
		e = [c(0), c(1)], d = g, void 0 !== (f = "function" == typeof d ? d.apply(b, e) : d) && (a.exports = f);
	}(function (a, b) {
		return b.extendAliases({ Regex: { mask: "r", greedy: !1, repeat: "*", regex: null, regexTokens: null, tokenizer: /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g, quantifierFilter: /[0-9]+[^,]/, isComplete: function isComplete(a, b) {
					return new RegExp(b.regex, b.casing ? "i" : "").test(a.join(""));
				}, definitions: { r: { validator: function validator(b, c, d, e, f) {
							function g(a, b) {
								this.matches = [], this.isGroup = a || !1, this.isQuantifier = b || !1, this.quantifier = { min: 1, max: 1 }, this.repeaterPart = void 0;
							}function h(b, c) {
								var d = !1;c && (l += "(", n++);for (var e = 0; e < b.matches.length; e++) {
									var g = b.matches[e];if (!0 === g.isGroup) d = h(g, !0);else if (!0 === g.isQuantifier) {
										var j = a.inArray(g, b.matches),
										    k = b.matches[j - 1],
										    m = l;if (isNaN(g.quantifier.max)) {
											for (; g.repeaterPart && g.repeaterPart !== l && g.repeaterPart.length > l.length && !(d = h(k, !0));) {}d = d || h(k, !0), d && (g.repeaterPart = l), l = m + g.quantifier.max;
										} else {
											for (var o = 0, p = g.quantifier.max - 1; o < p && !(d = h(k, !0)); o++) {}l = m + "{" + g.quantifier.min + "," + g.quantifier.max + "}";
										}
									} else if (void 0 !== g.matches) for (var q = 0; q < g.length && !(d = h(g[q], c)); q++) {} else {
										var r;if ("[" == g.charAt(0)) {
											r = l, r += g;for (var s = 0; s < n; s++) {
												r += ")";
											}var t = new RegExp("^(" + r + ")$", f.casing ? "i" : "");d = t.test(i);
										} else for (var u = 0, v = g.length; u < v; u++) {
											if ("\\" !== g.charAt(u)) {
												r = l, r += g.substr(0, u + 1), r = r.replace(/\|$/, "");for (var s = 0; s < n; s++) {
													r += ")";
												}var t = new RegExp("^(" + r + ")$", f.casing ? "i" : "");if (d = t.test(i)) break;
											}
										}l += g;
									}if (d) break;
								}return c && (l += ")", n--), d;
							}var i,
							    j,
							    k = c.buffer.slice(),
							    l = "",
							    m = !1,
							    n = 0;null === f.regexTokens && function () {
								var a,
								    b,
								    c = new g(),
								    d = [];for (f.regexTokens = []; a = f.tokenizer.exec(f.regex);) {
									switch (b = a[0], b.charAt(0)) {case "(":
											d.push(new g(!0));break;case ")":
											j = d.pop(), d.length > 0 ? d[d.length - 1].matches.push(j) : c.matches.push(j);break;case "{":case "+":case "*":
											var e = new g(!1, !0);b = b.replace(/[{}]/g, "");var h = b.split(","),
											    i = isNaN(h[0]) ? h[0] : parseInt(h[0]),
											    k = 1 === h.length ? i : isNaN(h[1]) ? h[1] : parseInt(h[1]);if (e.quantifier = { min: i, max: k }, d.length > 0) {
												var l = d[d.length - 1].matches;a = l.pop(), a.isGroup || (j = new g(!0), j.matches.push(a), a = j), l.push(a), l.push(e);
											} else a = c.matches.pop(), a.isGroup || (j = new g(!0), j.matches.push(a), a = j), c.matches.push(a), c.matches.push(e);break;default:
											d.length > 0 ? d[d.length - 1].matches.push(b) : c.matches.push(b);}
								}c.matches.length > 0 && f.regexTokens.push(c);
							}(), k.splice(d, 0, b), i = k.join("");for (var o = 0; o < f.regexTokens.length; o++) {
								var p = f.regexTokens[o];if (m = h(p, p.isGroup)) break;
							}return m;
						}, cardinality: 1 } } } }), b;
	});
}, function (a, b, c) {
	"use strict";
	var d,
	    e,
	    f,
	    g = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (a) {
		return typeof a === "undefined" ? "undefined" : _typeof(a);
	} : function (a) {
		return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a === "undefined" ? "undefined" : _typeof(a);
	};!function (g) {
		e = [c(2), c(1)], d = g, void 0 !== (f = "function" == typeof d ? d.apply(b, e) : d) && (a.exports = f);
	}(function (a, b) {
		return void 0 === a.fn.inputmask && (a.fn.inputmask = function (c, d) {
			var e,
			    f = this[0];if (void 0 === d && (d = {}), "string" == typeof c) switch (c) {case "unmaskedvalue":
					return f && f.inputmask ? f.inputmask.unmaskedvalue() : a(f).val();case "remove":
					return this.each(function () {
						this.inputmask && this.inputmask.remove();
					});case "getemptymask":
					return f && f.inputmask ? f.inputmask.getemptymask() : "";case "hasMaskedValue":
					return !(!f || !f.inputmask) && f.inputmask.hasMaskedValue();case "isComplete":
					return !f || !f.inputmask || f.inputmask.isComplete();case "getmetadata":
					return f && f.inputmask ? f.inputmask.getmetadata() : void 0;case "setvalue":
					a(f).val(d), f && void 0 === f.inputmask && a(f).triggerHandler("setvalue");break;case "option":
					if ("string" != typeof d) return this.each(function () {
						if (void 0 !== this.inputmask) return this.inputmask.option(d);
					});if (f && void 0 !== f.inputmask) return f.inputmask.option(d);break;default:
					return d.alias = c, e = new b(d), this.each(function () {
						e.mask(this);
					});} else {
				if ("object" == (void 0 === c ? "undefined" : g(c))) return e = new b(c), void 0 === c.mask && void 0 === c.alias ? this.each(function () {
					if (void 0 !== this.inputmask) return this.inputmask.option(c);e.mask(this);
				}) : this.each(function () {
					e.mask(this);
				});if (void 0 === c) return this.each(function () {
					e = new b(d), e.mask(this);
				});
			}
		}), a.fn.inputmask;
	});
}, function (a, b, c) {
	var d = c(13);"string" == typeof d && (d = [[a.i, d, ""]]);c(15)(d, {});d.locals && (a.exports = d.locals);
}, function (a, b, c) {
	"use strict";
	function d(a) {
		return a && a.__esModule ? a : { default: a };
	}c(9), c(3), c(4), c(5), c(6), c(7);var e = c(1),
	    f = d(e),
	    g = c(0),
	    h = d(g),
	    i = c(2),
	    j = d(i);h.default === j.default && c(8), window.Inputmask = f.default;
}, function (a, b, c) {
	"use strict";
	var d;"function" == typeof Symbol && Symbol.iterator;void 0 !== (d = function () {
		return document;
	}.call(b, c, b, a)) && (a.exports = d);
}, function (a, b, c) {
	"use strict";
	var d;"function" == typeof Symbol && Symbol.iterator;void 0 !== (d = function () {
		return window;
	}.call(b, c, b, a)) && (a.exports = d);
}, function (a, b, c) {
	b = a.exports = c(14)(void 0), b.push([a.i, ".im-caret {\r\n\t-webkit-animation: 1s blink step-end infinite;\r\n\tanimation: 1s blink step-end infinite;\r\n}\r\n\r\n@keyframes blink {\r\n\tfrom, to {\r\n\t\tborder-right-color: black;\r\n\t}\r\n\t50% {\r\n\t\tborder-right-color: transparent;\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes blink {\r\n\tfrom, to {\r\n\t\tborder-right-color: black;\r\n\t}\r\n\t50% {\r\n\t\tborder-right-color: transparent;\r\n\t}\r\n}\r\n\r\n.im-static {\r\n\tcolor: grey;\r\n}\r\n", ""]);
}, function (a, b) {
	function c(a, b) {
		var c = a[1] || "",
		    e = a[3];if (!e) return c;if (b && "function" == typeof btoa) {
			var f = d(e),
			    g = e.sources.map(function (a) {
				return "/*# sourceURL=" + e.sourceRoot + a + " */";
			});return [c].concat(g).concat([f]).join("\n");
		}return [c].join("\n");
	}function d(a) {
		return "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(a)))) + " */";
	}a.exports = function (a) {
		var b = [];return b.toString = function () {
			return this.map(function (b) {
				var d = c(b, a);return b[2] ? "@media " + b[2] + "{" + d + "}" : d;
			}).join("");
		}, b.i = function (a, c) {
			"string" == typeof a && (a = [[null, a, ""]]);for (var d = {}, e = 0; e < this.length; e++) {
				var f = this[e][0];"number" == typeof f && (d[f] = !0);
			}for (e = 0; e < a.length; e++) {
				var g = a[e];"number" == typeof g[0] && d[g[0]] || (c && !g[2] ? g[2] = c : c && (g[2] = "(" + g[2] + ") and (" + c + ")"), b.push(g));
			}
		}, b;
	};
}, function (a, b, c) {
	function d(a, b) {
		for (var c = 0; c < a.length; c++) {
			var d = a[c],
			    e = o[d.id];if (e) {
				e.refs++;for (var f = 0; f < e.parts.length; f++) {
					e.parts[f](d.parts[f]);
				}for (; f < d.parts.length; f++) {
					e.parts.push(k(d.parts[f], b));
				}
			} else {
				for (var g = [], f = 0; f < d.parts.length; f++) {
					g.push(k(d.parts[f], b));
				}o[d.id] = { id: d.id, refs: 1, parts: g };
			}
		}
	}function e(a) {
		for (var b = [], c = {}, d = 0; d < a.length; d++) {
			var e = a[d],
			    f = e[0],
			    g = e[1],
			    h = e[2],
			    i = e[3],
			    j = { css: g, media: h, sourceMap: i };c[f] ? c[f].parts.push(j) : b.push(c[f] = { id: f, parts: [j] });
		}return b;
	}function f(a, b) {
		var c = q(a.insertInto);if (!c) throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var d = t[t.length - 1];if ("top" === a.insertAt) d ? d.nextSibling ? c.insertBefore(b, d.nextSibling) : c.appendChild(b) : c.insertBefore(b, c.firstChild), t.push(b);else {
			if ("bottom" !== a.insertAt) throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");c.appendChild(b);
		}
	}function g(a) {
		a.parentNode.removeChild(a);var b = t.indexOf(a);b >= 0 && t.splice(b, 1);
	}function h(a) {
		var b = document.createElement("style");return a.attrs.type = "text/css", j(b, a.attrs), f(a, b), b;
	}function i(a) {
		var b = document.createElement("link");return a.attrs.type = "text/css", a.attrs.rel = "stylesheet", j(b, a.attrs), f(a, b), b;
	}function j(a, b) {
		Object.keys(b).forEach(function (c) {
			a.setAttribute(c, b[c]);
		});
	}function k(a, b) {
		var c, d, e;if (b.singleton) {
			var f = s++;c = r || (r = h(b)), d = l.bind(null, c, f, !1), e = l.bind(null, c, f, !0);
		} else a.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (c = i(b), d = n.bind(null, c, b), e = function e() {
			g(c), c.href && URL.revokeObjectURL(c.href);
		}) : (c = h(b), d = m.bind(null, c), e = function e() {
			g(c);
		});return d(a), function (b) {
			if (b) {
				if (b.css === a.css && b.media === a.media && b.sourceMap === a.sourceMap) return;d(a = b);
			} else e();
		};
	}function l(a, b, c, d) {
		var e = c ? "" : d.css;if (a.styleSheet) a.styleSheet.cssText = v(b, e);else {
			var f = document.createTextNode(e),
			    g = a.childNodes;g[b] && a.removeChild(g[b]), g.length ? a.insertBefore(f, g[b]) : a.appendChild(f);
		}
	}function m(a, b) {
		var c = b.css,
		    d = b.media;if (d && a.setAttribute("media", d), a.styleSheet) a.styleSheet.cssText = c;else {
			for (; a.firstChild;) {
				a.removeChild(a.firstChild);
			}a.appendChild(document.createTextNode(c));
		}
	}function n(a, b, c) {
		var d = c.css,
		    e = c.sourceMap,
		    f = void 0 === b.convertToAbsoluteUrls && e;(b.convertToAbsoluteUrls || f) && (d = u(d)), e && (d += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(e)))) + " */");var g = new Blob([d], { type: "text/css" }),
		    h = a.href;a.href = URL.createObjectURL(g), h && URL.revokeObjectURL(h);
	}var o = {},
	    p = function (a) {
		var b;return function () {
			return void 0 === b && (b = a.apply(this, arguments)), b;
		};
	}(function () {
		return window && document && document.all && !window.atob;
	}),
	    q = function (a) {
		var b = {};return function (c) {
			return void 0 === b[c] && (b[c] = a.call(this, c)), b[c];
		};
	}(function (a) {
		return document.querySelector(a);
	}),
	    r = null,
	    s = 0,
	    t = [],
	    u = c(16);a.exports = function (a, b) {
		if ("undefined" != typeof DEBUG && DEBUG && "object" != (typeof document === "undefined" ? "undefined" : _typeof(document))) throw new Error("The style-loader cannot be used in a non-browser environment");b = b || {}, b.attrs = "object" == _typeof(b.attrs) ? b.attrs : {}, void 0 === b.singleton && (b.singleton = p()), void 0 === b.insertInto && (b.insertInto = "head"), void 0 === b.insertAt && (b.insertAt = "bottom");var c = e(a);return d(c, b), function (a) {
			for (var f = [], g = 0; g < c.length; g++) {
				var h = c[g],
				    i = o[h.id];i.refs--, f.push(i);
			}if (a) {
				d(e(a), b);
			}for (var g = 0; g < f.length; g++) {
				var i = f[g];if (0 === i.refs) {
					for (var j = 0; j < i.parts.length; j++) {
						i.parts[j]();
					}delete o[i.id];
				}
			}
		};
	};var v = function () {
		var a = [];return function (b, c) {
			return a[b] = c, a.filter(Boolean).join("\n");
		};
	}();
}, function (a, b) {
	a.exports = function (a) {
		var b = "undefined" != typeof window && window.location;if (!b) throw new Error("fixUrls requires window.location");if (!a || "string" != typeof a) return a;var c = b.protocol + "//" + b.host,
		    d = c + b.pathname.replace(/\/[^\/]*$/, "/");return a.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (a, b) {
			var e = b.trim().replace(/^"(.*)"$/, function (a, b) {
				return b;
			}).replace(/^'(.*)'$/, function (a, b) {
				return b;
			});if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(e)) return a;var f;return f = 0 === e.indexOf("//") ? e : 0 === e.indexOf("/") ? c + e : d + e.replace(/^\.\//, ""), "url(" + JSON.stringify(f) + ")";
		});
	};
}]);
/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.6.0
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
(function (factory) {
	'use strict';

	if (typeof define === 'function' && define.amd) {
		define(['jquery'], factory);
	} else if (typeof exports !== 'undefined') {
		module.exports = factory(require('jquery'));
	} else {
		factory(jQuery);
	}
})(function ($) {
	'use strict';

	var Slick = window.Slick || {};

	Slick = function () {

		var instanceUid = 0;

		function Slick(element, settings) {

			var _ = this,
			    dataSettings;

			_.defaults = {
				accessibility: true,
				adaptiveHeight: false,
				appendArrows: $(element),
				appendDots: $(element),
				arrows: true,
				asNavFor: null,
				prevArrow: '<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>',
				nextArrow: '<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>',
				autoplay: false,
				autoplaySpeed: 3000,
				centerMode: false,
				centerPadding: '50px',
				cssEase: 'ease',
				customPaging: function customPaging(slider, i) {
					return $('<button type="button" data-role="none" role="button" tabindex="0" />').text(i + 1);
				},
				dots: false,
				dotsClass: 'slick-dots',
				draggable: true,
				easing: 'linear',
				edgeFriction: 0.35,
				fade: false,
				focusOnSelect: false,
				infinite: true,
				initialSlide: 0,
				lazyLoad: 'ondemand',
				mobileFirst: false,
				pauseOnHover: true,
				pauseOnFocus: true,
				pauseOnDotsHover: false,
				respondTo: 'window',
				responsive: null,
				rows: 1,
				rtl: false,
				slide: '',
				slidesPerRow: 1,
				slidesToShow: 1,
				slidesToScroll: 1,
				speed: 500,
				swipe: true,
				swipeToSlide: false,
				touchMove: true,
				touchThreshold: 5,
				useCSS: true,
				useTransform: true,
				variableWidth: false,
				vertical: false,
				verticalSwiping: false,
				waitForAnimate: true,
				zIndex: 1000
			};

			_.initials = {
				animating: false,
				dragging: false,
				autoPlayTimer: null,
				currentDirection: 0,
				currentLeft: null,
				currentSlide: 0,
				direction: 1,
				$dots: null,
				listWidth: null,
				listHeight: null,
				loadIndex: 0,
				$nextArrow: null,
				$prevArrow: null,
				slideCount: null,
				slideWidth: null,
				$slideTrack: null,
				$slides: null,
				sliding: false,
				slideOffset: 0,
				swipeLeft: null,
				$list: null,
				touchObject: {},
				transformsEnabled: false,
				unslicked: false
			};

			$.extend(_, _.initials);

			_.activeBreakpoint = null;
			_.animType = null;
			_.animProp = null;
			_.breakpoints = [];
			_.breakpointSettings = [];
			_.cssTransitions = false;
			_.focussed = false;
			_.interrupted = false;
			_.hidden = 'hidden';
			_.paused = true;
			_.positionProp = null;
			_.respondTo = null;
			_.rowCount = 1;
			_.shouldClick = true;
			_.$slider = $(element);
			_.$slidesCache = null;
			_.transformType = null;
			_.transitionType = null;
			_.visibilityChange = 'visibilitychange';
			_.windowWidth = 0;
			_.windowTimer = null;

			dataSettings = $(element).data('slick') || {};

			_.options = $.extend({}, _.defaults, settings, dataSettings);

			_.currentSlide = _.options.initialSlide;

			_.originalSettings = _.options;

			if (typeof document.mozHidden !== 'undefined') {
				_.hidden = 'mozHidden';
				_.visibilityChange = 'mozvisibilitychange';
			} else if (typeof document.webkitHidden !== 'undefined') {
				_.hidden = 'webkitHidden';
				_.visibilityChange = 'webkitvisibilitychange';
			}

			_.autoPlay = $.proxy(_.autoPlay, _);
			_.autoPlayClear = $.proxy(_.autoPlayClear, _);
			_.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
			_.changeSlide = $.proxy(_.changeSlide, _);
			_.clickHandler = $.proxy(_.clickHandler, _);
			_.selectHandler = $.proxy(_.selectHandler, _);
			_.setPosition = $.proxy(_.setPosition, _);
			_.swipeHandler = $.proxy(_.swipeHandler, _);
			_.dragHandler = $.proxy(_.dragHandler, _);
			_.keyHandler = $.proxy(_.keyHandler, _);

			_.instanceUid = instanceUid++;

			// A simple way to check for HTML strings
			// Strict HTML recognition (must start with <)
			// Extracted from jQuery v1.11 source
			_.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;

			_.registerBreakpoints();
			_.init(true);
		}

		return Slick;
	}();

	Slick.prototype.activateADA = function () {
		var _ = this;

		_.$slideTrack.find('.slick-active').attr({
			'aria-hidden': 'false'
		}).find('a, input, button, select').attr({
			'tabindex': '0'
		});
	};

	Slick.prototype.addSlide = Slick.prototype.slickAdd = function (markup, index, addBefore) {

		var _ = this;

		if (typeof index === 'boolean') {
			addBefore = index;
			index = null;
		} else if (index < 0 || index >= _.slideCount) {
			return false;
		}

		_.unload();

		if (typeof index === 'number') {
			if (index === 0 && _.$slides.length === 0) {
				$(markup).appendTo(_.$slideTrack);
			} else if (addBefore) {
				$(markup).insertBefore(_.$slides.eq(index));
			} else {
				$(markup).insertAfter(_.$slides.eq(index));
			}
		} else {
			if (addBefore === true) {
				$(markup).prependTo(_.$slideTrack);
			} else {
				$(markup).appendTo(_.$slideTrack);
			}
		}

		_.$slides = _.$slideTrack.children(this.options.slide);

		_.$slideTrack.children(this.options.slide).detach();

		_.$slideTrack.append(_.$slides);

		_.$slides.each(function (index, element) {
			$(element).attr('data-slick-index', index);
		});

		_.$slidesCache = _.$slides;

		_.reinit();
	};

	Slick.prototype.animateHeight = function () {
		var _ = this;
		if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
			var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
			_.$list.animate({
				height: targetHeight
			}, _.options.speed);
		}
	};

	Slick.prototype.animateSlide = function (targetLeft, callback) {

		var animProps = {},
		    _ = this;

		_.animateHeight();

		if (_.options.rtl === true && _.options.vertical === false) {
			targetLeft = -targetLeft;
		}
		if (_.transformsEnabled === false) {
			if (_.options.vertical === false) {
				_.$slideTrack.animate({
					left: targetLeft
				}, _.options.speed, _.options.easing, callback);
			} else {
				_.$slideTrack.animate({
					top: targetLeft
				}, _.options.speed, _.options.easing, callback);
			}
		} else {

			if (_.cssTransitions === false) {
				if (_.options.rtl === true) {
					_.currentLeft = -_.currentLeft;
				}
				$({
					animStart: _.currentLeft
				}).animate({
					animStart: targetLeft
				}, {
					duration: _.options.speed,
					easing: _.options.easing,
					step: function step(now) {
						now = Math.ceil(now);
						if (_.options.vertical === false) {
							animProps[_.animType] = 'translate(' + now + 'px, 0px)';
							_.$slideTrack.css(animProps);
						} else {
							animProps[_.animType] = 'translate(0px,' + now + 'px)';
							_.$slideTrack.css(animProps);
						}
					},
					complete: function complete() {
						if (callback) {
							callback.call();
						}
					}
				});
			} else {

				_.applyTransition();
				targetLeft = Math.ceil(targetLeft);

				if (_.options.vertical === false) {
					animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
				} else {
					animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
				}
				_.$slideTrack.css(animProps);

				if (callback) {
					setTimeout(function () {

						_.disableTransition();

						callback.call();
					}, _.options.speed);
				}
			}
		}
	};

	Slick.prototype.getNavTarget = function () {

		var _ = this,
		    asNavFor = _.options.asNavFor;

		if (asNavFor && asNavFor !== null) {
			asNavFor = $(asNavFor).not(_.$slider);
		}

		return asNavFor;
	};

	Slick.prototype.asNavFor = function (index) {

		var _ = this,
		    asNavFor = _.getNavTarget();

		if (asNavFor !== null && (typeof asNavFor === "undefined" ? "undefined" : _typeof(asNavFor)) === 'object') {
			asNavFor.each(function () {
				var target = $(this).slick('getSlick');
				if (!target.unslicked) {
					target.slideHandler(index, true);
				}
			});
		}
	};

	Slick.prototype.applyTransition = function (slide) {

		var _ = this,
		    transition = {};

		if (_.options.fade === false) {
			transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
		} else {
			transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
		}

		if (_.options.fade === false) {
			_.$slideTrack.css(transition);
		} else {
			_.$slides.eq(slide).css(transition);
		}
	};

	Slick.prototype.autoPlay = function () {

		var _ = this;

		_.autoPlayClear();

		if (_.slideCount > _.options.slidesToShow) {
			_.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed);
		}
	};

	Slick.prototype.autoPlayClear = function () {

		var _ = this;

		if (_.autoPlayTimer) {
			clearInterval(_.autoPlayTimer);
		}
	};

	Slick.prototype.autoPlayIterator = function () {

		var _ = this,
		    slideTo = _.currentSlide + _.options.slidesToScroll;

		if (!_.paused && !_.interrupted && !_.focussed) {

			if (_.options.infinite === false) {

				if (_.direction === 1 && _.currentSlide + 1 === _.slideCount - 1) {
					_.direction = 0;
				} else if (_.direction === 0) {

					slideTo = _.currentSlide - _.options.slidesToScroll;

					if (_.currentSlide - 1 === 0) {
						_.direction = 1;
					}
				}
			}

			_.slideHandler(slideTo);
		}
	};

	Slick.prototype.buildArrows = function () {

		var _ = this;

		if (_.options.arrows === true) {

			_.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
			_.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

			if (_.slideCount > _.options.slidesToShow) {

				_.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
				_.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

				if (_.htmlExpr.test(_.options.prevArrow)) {
					_.$prevArrow.prependTo(_.options.appendArrows);
				}

				if (_.htmlExpr.test(_.options.nextArrow)) {
					_.$nextArrow.appendTo(_.options.appendArrows);
				}

				if (_.options.infinite !== true) {
					_.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
				}
			} else {

				_.$prevArrow.add(_.$nextArrow).addClass('slick-hidden').attr({
					'aria-disabled': 'true',
					'tabindex': '-1'
				});
			}
		}
	};

	Slick.prototype.buildDots = function () {

		var _ = this,
		    i,
		    dot;

		if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

			_.$slider.addClass('slick-dotted');

			dot = $('<ul />').addClass(_.options.dotsClass);

			for (i = 0; i <= _.getDotCount(); i += 1) {
				dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
			}

			_.$dots = dot.appendTo(_.options.appendDots);

			_.$dots.find('li').first().addClass('slick-active').attr('aria-hidden', 'false');
		}
	};

	Slick.prototype.buildOut = function () {

		var _ = this;

		_.$slides = _.$slider.children(_.options.slide + ':not(.slick-cloned)').addClass('slick-slide');

		_.slideCount = _.$slides.length;

		_.$slides.each(function (index, element) {
			$(element).attr('data-slick-index', index).data('originalStyling', $(element).attr('style') || '');
		});

		_.$slider.addClass('slick-slider');

		_.$slideTrack = _.slideCount === 0 ? $('<div class="slick-track"/>').appendTo(_.$slider) : _.$slides.wrapAll('<div class="slick-track"/>').parent();

		_.$list = _.$slideTrack.wrap('<div aria-live="polite" class="slick-list"/>').parent();
		_.$slideTrack.css('opacity', 0);

		if (_.options.centerMode === true || _.options.swipeToSlide === true) {
			_.options.slidesToScroll = 1;
		}

		$('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

		_.setupInfinite();

		_.buildArrows();

		_.buildDots();

		_.updateDots();

		_.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

		if (_.options.draggable === true) {
			_.$list.addClass('draggable');
		}
	};

	Slick.prototype.buildRows = function () {

		var _ = this,
		    a,
		    b,
		    c,
		    newSlides,
		    numOfSlides,
		    originalSlides,
		    slidesPerSection;

		newSlides = document.createDocumentFragment();
		originalSlides = _.$slider.children();

		if (_.options.rows > 1) {

			slidesPerSection = _.options.slidesPerRow * _.options.rows;
			numOfSlides = Math.ceil(originalSlides.length / slidesPerSection);

			for (a = 0; a < numOfSlides; a++) {
				var slide = document.createElement('div');
				for (b = 0; b < _.options.rows; b++) {
					var row = document.createElement('div');
					for (c = 0; c < _.options.slidesPerRow; c++) {
						var target = a * slidesPerSection + (b * _.options.slidesPerRow + c);
						if (originalSlides.get(target)) {
							row.appendChild(originalSlides.get(target));
						}
					}
					slide.appendChild(row);
				}
				newSlides.appendChild(slide);
			}

			_.$slider.empty().append(newSlides);
			_.$slider.children().children().children().css({
				'width': 100 / _.options.slidesPerRow + '%',
				'display': 'inline-block'
			});
		}
	};

	Slick.prototype.checkResponsive = function (initial, forceUpdate) {

		var _ = this,
		    breakpoint,
		    targetBreakpoint,
		    respondToWidth,
		    triggerBreakpoint = false;
		var sliderWidth = _.$slider.width();
		var windowWidth = window.innerWidth || $(window).width();

		if (_.respondTo === 'window') {
			respondToWidth = windowWidth;
		} else if (_.respondTo === 'slider') {
			respondToWidth = sliderWidth;
		} else if (_.respondTo === 'min') {
			respondToWidth = Math.min(windowWidth, sliderWidth);
		}

		if (_.options.responsive && _.options.responsive.length && _.options.responsive !== null) {

			targetBreakpoint = null;

			for (breakpoint in _.breakpoints) {
				if (_.breakpoints.hasOwnProperty(breakpoint)) {
					if (_.originalSettings.mobileFirst === false) {
						if (respondToWidth < _.breakpoints[breakpoint]) {
							targetBreakpoint = _.breakpoints[breakpoint];
						}
					} else {
						if (respondToWidth > _.breakpoints[breakpoint]) {
							targetBreakpoint = _.breakpoints[breakpoint];
						}
					}
				}
			}

			if (targetBreakpoint !== null) {
				if (_.activeBreakpoint !== null) {
					if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
						_.activeBreakpoint = targetBreakpoint;
						if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
							_.unslick(targetBreakpoint);
						} else {
							_.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
							if (initial === true) {
								_.currentSlide = _.options.initialSlide;
							}
							_.refresh(initial);
						}
						triggerBreakpoint = targetBreakpoint;
					}
				} else {
					_.activeBreakpoint = targetBreakpoint;
					if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
						_.unslick(targetBreakpoint);
					} else {
						_.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
						if (initial === true) {
							_.currentSlide = _.options.initialSlide;
						}
						_.refresh(initial);
					}
					triggerBreakpoint = targetBreakpoint;
				}
			} else {
				if (_.activeBreakpoint !== null) {
					_.activeBreakpoint = null;
					_.options = _.originalSettings;
					if (initial === true) {
						_.currentSlide = _.options.initialSlide;
					}
					_.refresh(initial);
					triggerBreakpoint = targetBreakpoint;
				}
			}

			// only trigger breakpoints during an actual break. not on initialize.
			if (!initial && triggerBreakpoint !== false) {
				_.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
			}
		}
	};

	Slick.prototype.changeSlide = function (event, dontAnimate) {

		var _ = this,
		    $target = $(event.currentTarget),
		    indexOffset,
		    slideOffset,
		    unevenOffset;

		// If target is a link, prevent default action.
		if ($target.is('a')) {
			event.preventDefault();
		}

		// If target is not the <li> element (ie: a child), find the <li>.
		if (!$target.is('li')) {
			$target = $target.closest('li');
		}

		unevenOffset = _.slideCount % _.options.slidesToScroll !== 0;
		indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

		switch (event.data.message) {

			case 'previous':
				slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
				if (_.slideCount > _.options.slidesToShow) {
					_.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
				}
				break;

			case 'next':
				slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
				if (_.slideCount > _.options.slidesToShow) {
					_.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
				}
				break;

			case 'index':
				var index = event.data.index === 0 ? 0 : event.data.index || $target.index() * _.options.slidesToScroll;

				_.slideHandler(_.checkNavigable(index), false, dontAnimate);
				$target.children().trigger('focus');
				break;

			default:
				return;
		}
	};

	Slick.prototype.checkNavigable = function (index) {

		var _ = this,
		    navigables,
		    prevNavigable;

		navigables = _.getNavigableIndexes();
		prevNavigable = 0;
		if (index > navigables[navigables.length - 1]) {
			index = navigables[navigables.length - 1];
		} else {
			for (var n in navigables) {
				if (index < navigables[n]) {
					index = prevNavigable;
					break;
				}
				prevNavigable = navigables[n];
			}
		}

		return index;
	};

	Slick.prototype.cleanUpEvents = function () {

		var _ = this;

		if (_.options.dots && _.$dots !== null) {

			$('li', _.$dots).off('click.slick', _.changeSlide).off('mouseenter.slick', $.proxy(_.interrupt, _, true)).off('mouseleave.slick', $.proxy(_.interrupt, _, false));
		}

		_.$slider.off('focus.slick blur.slick');

		if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
			_.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
			_.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);
		}

		_.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
		_.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
		_.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
		_.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

		_.$list.off('click.slick', _.clickHandler);

		$(document).off(_.visibilityChange, _.visibility);

		_.cleanUpSlideEvents();

		if (_.options.accessibility === true) {
			_.$list.off('keydown.slick', _.keyHandler);
		}

		if (_.options.focusOnSelect === true) {
			$(_.$slideTrack).children().off('click.slick', _.selectHandler);
		}

		$(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

		$(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

		$('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

		$(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);
		$(document).off('ready.slick.slick-' + _.instanceUid, _.setPosition);
	};

	Slick.prototype.cleanUpSlideEvents = function () {

		var _ = this;

		_.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
		_.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));
	};

	Slick.prototype.cleanUpRows = function () {

		var _ = this,
		    originalSlides;

		if (_.options.rows > 1) {
			originalSlides = _.$slides.children().children();
			originalSlides.removeAttr('style');
			_.$slider.empty().append(originalSlides);
		}
	};

	Slick.prototype.clickHandler = function (event) {

		var _ = this;

		if (_.shouldClick === false) {
			event.stopImmediatePropagation();
			event.stopPropagation();
			event.preventDefault();
		}
	};

	Slick.prototype.destroy = function (refresh) {

		var _ = this;

		_.autoPlayClear();

		_.touchObject = {};

		_.cleanUpEvents();

		$('.slick-cloned', _.$slider).detach();

		if (_.$dots) {
			_.$dots.remove();
		}

		if (_.$prevArrow && _.$prevArrow.length) {

			_.$prevArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');

			if (_.htmlExpr.test(_.options.prevArrow)) {
				_.$prevArrow.remove();
			}
		}

		if (_.$nextArrow && _.$nextArrow.length) {

			_.$nextArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');

			if (_.htmlExpr.test(_.options.nextArrow)) {
				_.$nextArrow.remove();
			}
		}

		if (_.$slides) {

			_.$slides.removeClass('slick-slide slick-active slick-center slick-visible slick-current').removeAttr('aria-hidden').removeAttr('data-slick-index').each(function () {
				$(this).attr('style', $(this).data('originalStyling'));
			});

			_.$slideTrack.children(this.options.slide).detach();

			_.$slideTrack.detach();

			_.$list.detach();

			_.$slider.append(_.$slides);
		}

		_.cleanUpRows();

		_.$slider.removeClass('slick-slider');
		_.$slider.removeClass('slick-initialized');
		_.$slider.removeClass('slick-dotted');

		_.unslicked = true;

		if (!refresh) {
			_.$slider.trigger('destroy', [_]);
		}
	};

	Slick.prototype.disableTransition = function (slide) {

		var _ = this,
		    transition = {};

		transition[_.transitionType] = '';

		if (_.options.fade === false) {
			_.$slideTrack.css(transition);
		} else {
			_.$slides.eq(slide).css(transition);
		}
	};

	Slick.prototype.fadeSlide = function (slideIndex, callback) {

		var _ = this;

		if (_.cssTransitions === false) {

			_.$slides.eq(slideIndex).css({
				zIndex: _.options.zIndex
			});

			_.$slides.eq(slideIndex).animate({
				opacity: 1
			}, _.options.speed, _.options.easing, callback);
		} else {

			_.applyTransition(slideIndex);

			_.$slides.eq(slideIndex).css({
				opacity: 1,
				zIndex: _.options.zIndex
			});

			if (callback) {
				setTimeout(function () {

					_.disableTransition(slideIndex);

					callback.call();
				}, _.options.speed);
			}
		}
	};

	Slick.prototype.fadeSlideOut = function (slideIndex) {

		var _ = this;

		if (_.cssTransitions === false) {

			_.$slides.eq(slideIndex).animate({
				opacity: 0,
				zIndex: _.options.zIndex - 2
			}, _.options.speed, _.options.easing);
		} else {

			_.applyTransition(slideIndex);

			_.$slides.eq(slideIndex).css({
				opacity: 0,
				zIndex: _.options.zIndex - 2
			});
		}
	};

	Slick.prototype.filterSlides = Slick.prototype.slickFilter = function (filter) {

		var _ = this;

		if (filter !== null) {

			_.$slidesCache = _.$slides;

			_.unload();

			_.$slideTrack.children(this.options.slide).detach();

			_.$slidesCache.filter(filter).appendTo(_.$slideTrack);

			_.reinit();
		}
	};

	Slick.prototype.focusHandler = function () {

		var _ = this;

		_.$slider.off('focus.slick blur.slick').on('focus.slick blur.slick', '*:not(.slick-arrow)', function (event) {

			event.stopImmediatePropagation();
			var $sf = $(this);

			setTimeout(function () {

				if (_.options.pauseOnFocus) {
					_.focussed = $sf.is(':focus');
					_.autoPlay();
				}
			}, 0);
		});
	};

	Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function () {

		var _ = this;
		return _.currentSlide;
	};

	Slick.prototype.getDotCount = function () {

		var _ = this;

		var breakPoint = 0;
		var counter = 0;
		var pagerQty = 0;

		if (_.options.infinite === true) {
			while (breakPoint < _.slideCount) {
				++pagerQty;
				breakPoint = counter + _.options.slidesToScroll;
				counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
			}
		} else if (_.options.centerMode === true) {
			pagerQty = _.slideCount;
		} else if (!_.options.asNavFor) {
			pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
		} else {
			while (breakPoint < _.slideCount) {
				++pagerQty;
				breakPoint = counter + _.options.slidesToScroll;
				counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
			}
		}

		return pagerQty - 1;
	};

	Slick.prototype.getLeft = function (slideIndex) {

		var _ = this,
		    targetLeft,
		    verticalHeight,
		    verticalOffset = 0,
		    targetSlide;

		_.slideOffset = 0;
		verticalHeight = _.$slides.first().outerHeight(true);

		if (_.options.infinite === true) {
			if (_.slideCount > _.options.slidesToShow) {
				_.slideOffset = _.slideWidth * _.options.slidesToShow * -1;
				verticalOffset = verticalHeight * _.options.slidesToShow * -1;
			}
			if (_.slideCount % _.options.slidesToScroll !== 0) {
				if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
					if (slideIndex > _.slideCount) {
						_.slideOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth * -1;
						verticalOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight * -1;
					} else {
						_.slideOffset = _.slideCount % _.options.slidesToScroll * _.slideWidth * -1;
						verticalOffset = _.slideCount % _.options.slidesToScroll * verticalHeight * -1;
					}
				}
			}
		} else {
			if (slideIndex + _.options.slidesToShow > _.slideCount) {
				_.slideOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * _.slideWidth;
				verticalOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * verticalHeight;
			}
		}

		if (_.slideCount <= _.options.slidesToShow) {
			_.slideOffset = 0;
			verticalOffset = 0;
		}

		if (_.options.centerMode === true && _.options.infinite === true) {
			_.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
		} else if (_.options.centerMode === true) {
			_.slideOffset = 0;
			_.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
		}

		if (_.options.vertical === false) {
			targetLeft = slideIndex * _.slideWidth * -1 + _.slideOffset;
		} else {
			targetLeft = slideIndex * verticalHeight * -1 + verticalOffset;
		}

		if (_.options.variableWidth === true) {

			if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
				targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
			} else {
				targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
			}

			if (_.options.rtl === true) {
				if (targetSlide[0]) {
					targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
				} else {
					targetLeft = 0;
				}
			} else {
				targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
			}

			if (_.options.centerMode === true) {
				if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
					targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
				} else {
					targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
				}

				if (_.options.rtl === true) {
					if (targetSlide[0]) {
						targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
					} else {
						targetLeft = 0;
					}
				} else {
					targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
				}

				targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
			}
		}

		return targetLeft;
	};

	Slick.prototype.getOption = Slick.prototype.slickGetOption = function (option) {

		var _ = this;

		return _.options[option];
	};

	Slick.prototype.getNavigableIndexes = function () {

		var _ = this,
		    breakPoint = 0,
		    counter = 0,
		    indexes = [],
		    max;

		if (_.options.infinite === false) {
			max = _.slideCount;
		} else {
			breakPoint = _.options.slidesToScroll * -1;
			counter = _.options.slidesToScroll * -1;
			max = _.slideCount * 2;
		}

		while (breakPoint < max) {
			indexes.push(breakPoint);
			breakPoint = counter + _.options.slidesToScroll;
			counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
		}

		return indexes;
	};

	Slick.prototype.getSlick = function () {

		return this;
	};

	Slick.prototype.getSlideCount = function () {

		var _ = this,
		    slidesTraversed,
		    swipedSlide,
		    centerOffset;

		centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

		if (_.options.swipeToSlide === true) {
			_.$slideTrack.find('.slick-slide').each(function (index, slide) {
				if (slide.offsetLeft - centerOffset + $(slide).outerWidth() / 2 > _.swipeLeft * -1) {
					swipedSlide = slide;
					return false;
				}
			});

			slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

			return slidesTraversed;
		} else {
			return _.options.slidesToScroll;
		}
	};

	Slick.prototype.goTo = Slick.prototype.slickGoTo = function (slide, dontAnimate) {

		var _ = this;

		_.changeSlide({
			data: {
				message: 'index',
				index: parseInt(slide)
			}
		}, dontAnimate);
	};

	Slick.prototype.init = function (creation) {

		var _ = this;

		if (!$(_.$slider).hasClass('slick-initialized')) {

			$(_.$slider).addClass('slick-initialized');

			_.buildRows();
			_.buildOut();
			_.setProps();
			_.startLoad();
			_.loadSlider();
			_.initializeEvents();
			_.updateArrows();
			_.updateDots();
			_.checkResponsive(true);
			_.focusHandler();
		}

		if (creation) {
			_.$slider.trigger('init', [_]);
		}

		if (_.options.accessibility === true) {
			_.initADA();
		}

		if (_.options.autoplay) {

			_.paused = false;
			_.autoPlay();
		}
	};

	Slick.prototype.initADA = function () {
		var _ = this;
		_.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
			'aria-hidden': 'true',
			'tabindex': '-1'
		}).find('a, input, button, select').attr({
			'tabindex': '-1'
		});

		_.$slideTrack.attr('role', 'listbox');

		_.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function (i) {
			$(this).attr({
				'role': 'option',
				'aria-describedby': 'slick-slide' + _.instanceUid + i + ''
			});
		});

		if (_.$dots !== null) {
			_.$dots.attr('role', 'tablist').find('li').each(function (i) {
				$(this).attr({
					'role': 'presentation',
					'aria-selected': 'false',
					'aria-controls': 'navigation' + _.instanceUid + i + '',
					'id': 'slick-slide' + _.instanceUid + i + ''
				});
			}).first().attr('aria-selected', 'true').end().find('button').attr('role', 'button').end().closest('div').attr('role', 'toolbar');
		}
		_.activateADA();
	};

	Slick.prototype.initArrowEvents = function () {

		var _ = this;

		if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
			_.$prevArrow.off('click.slick').on('click.slick', {
				message: 'previous'
			}, _.changeSlide);
			_.$nextArrow.off('click.slick').on('click.slick', {
				message: 'next'
			}, _.changeSlide);
		}
	};

	Slick.prototype.initDotEvents = function () {

		var _ = this;

		if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
			$('li', _.$dots).on('click.slick', {
				message: 'index'
			}, _.changeSlide);
		}

		if (_.options.dots === true && _.options.pauseOnDotsHover === true) {

			$('li', _.$dots).on('mouseenter.slick', $.proxy(_.interrupt, _, true)).on('mouseleave.slick', $.proxy(_.interrupt, _, false));
		}
	};

	Slick.prototype.initSlideEvents = function () {

		var _ = this;

		if (_.options.pauseOnHover) {

			_.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
			_.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));
		}
	};

	Slick.prototype.initializeEvents = function () {

		var _ = this;

		_.initArrowEvents();

		_.initDotEvents();
		_.initSlideEvents();

		_.$list.on('touchstart.slick mousedown.slick', {
			action: 'start'
		}, _.swipeHandler);
		_.$list.on('touchmove.slick mousemove.slick', {
			action: 'move'
		}, _.swipeHandler);
		_.$list.on('touchend.slick mouseup.slick', {
			action: 'end'
		}, _.swipeHandler);
		_.$list.on('touchcancel.slick mouseleave.slick', {
			action: 'end'
		}, _.swipeHandler);

		_.$list.on('click.slick', _.clickHandler);

		$(document).on(_.visibilityChange, $.proxy(_.visibility, _));

		if (_.options.accessibility === true) {
			_.$list.on('keydown.slick', _.keyHandler);
		}

		if (_.options.focusOnSelect === true) {
			$(_.$slideTrack).children().on('click.slick', _.selectHandler);
		}

		$(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

		$(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

		$('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

		$(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
		$(document).on('ready.slick.slick-' + _.instanceUid, _.setPosition);
	};

	Slick.prototype.initUI = function () {

		var _ = this;

		if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

			_.$prevArrow.show();
			_.$nextArrow.show();
		}

		if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

			_.$dots.show();
		}
	};

	Slick.prototype.keyHandler = function (event) {

		var _ = this;
		//Dont slide if the cursor is inside the form fields and arrow keys are pressed
		if (!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
			if (event.keyCode === 37 && _.options.accessibility === true) {
				_.changeSlide({
					data: {
						message: _.options.rtl === true ? 'next' : 'previous'
					}
				});
			} else if (event.keyCode === 39 && _.options.accessibility === true) {
				_.changeSlide({
					data: {
						message: _.options.rtl === true ? 'previous' : 'next'
					}
				});
			}
		}
	};

	Slick.prototype.lazyLoad = function () {

		var _ = this,
		    loadRange,
		    cloneRange,
		    rangeStart,
		    rangeEnd;

		function loadImages(imagesScope) {

			$('img[data-lazy]', imagesScope).each(function () {

				var image = $(this),
				    imageSource = $(this).attr('data-lazy'),
				    imageToLoad = document.createElement('img');

				imageToLoad.onload = function () {

					image.animate({ opacity: 0 }, 100, function () {
						image.attr('src', imageSource).animate({ opacity: 1 }, 200, function () {
							image.removeAttr('data-lazy').removeClass('slick-loading');
						});
						_.$slider.trigger('lazyLoaded', [_, image, imageSource]);
					});
				};

				imageToLoad.onerror = function () {

					image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');

					_.$slider.trigger('lazyLoadError', [_, image, imageSource]);
				};

				imageToLoad.src = imageSource;
			});
		}

		if (_.options.centerMode === true) {
			if (_.options.infinite === true) {
				rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
				rangeEnd = rangeStart + _.options.slidesToShow + 2;
			} else {
				rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
				rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
			}
		} else {
			rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
			rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
			if (_.options.fade === true) {
				if (rangeStart > 0) rangeStart--;
				if (rangeEnd <= _.slideCount) rangeEnd++;
			}
		}

		loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);
		loadImages(loadRange);

		if (_.slideCount <= _.options.slidesToShow) {
			cloneRange = _.$slider.find('.slick-slide');
			loadImages(cloneRange);
		} else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
			cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
			loadImages(cloneRange);
		} else if (_.currentSlide === 0) {
			cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
			loadImages(cloneRange);
		}
	};

	Slick.prototype.loadSlider = function () {

		var _ = this;

		_.setPosition();

		_.$slideTrack.css({
			opacity: 1
		});

		_.$slider.removeClass('slick-loading');

		_.initUI();

		if (_.options.lazyLoad === 'progressive') {
			_.progressiveLazyLoad();
		}
	};

	Slick.prototype.next = Slick.prototype.slickNext = function () {

		var _ = this;

		_.changeSlide({
			data: {
				message: 'next'
			}
		});
	};

	Slick.prototype.orientationChange = function () {

		var _ = this;

		_.checkResponsive();
		_.setPosition();
	};

	Slick.prototype.pause = Slick.prototype.slickPause = function () {

		var _ = this;

		_.autoPlayClear();
		_.paused = true;
	};

	Slick.prototype.play = Slick.prototype.slickPlay = function () {

		var _ = this;

		_.autoPlay();
		_.options.autoplay = true;
		_.paused = false;
		_.focussed = false;
		_.interrupted = false;
	};

	Slick.prototype.postSlide = function (index) {

		var _ = this;

		if (!_.unslicked) {

			_.$slider.trigger('afterChange', [_, index]);

			_.animating = false;

			_.setPosition();

			_.swipeLeft = null;

			if (_.options.autoplay) {
				_.autoPlay();
			}

			if (_.options.accessibility === true) {
				_.initADA();
			}
		}
	};

	Slick.prototype.prev = Slick.prototype.slickPrev = function () {

		var _ = this;

		_.changeSlide({
			data: {
				message: 'previous'
			}
		});
	};

	Slick.prototype.preventDefault = function (event) {

		event.preventDefault();
	};

	Slick.prototype.progressiveLazyLoad = function (tryCount) {

		tryCount = tryCount || 1;

		var _ = this,
		    $imgsToLoad = $('img[data-lazy]', _.$slider),
		    image,
		    imageSource,
		    imageToLoad;

		if ($imgsToLoad.length) {

			image = $imgsToLoad.first();
			imageSource = image.attr('data-lazy');
			imageToLoad = document.createElement('img');

			imageToLoad.onload = function () {

				image.attr('src', imageSource).removeAttr('data-lazy').removeClass('slick-loading');

				if (_.options.adaptiveHeight === true) {
					_.setPosition();
				}

				_.$slider.trigger('lazyLoaded', [_, image, imageSource]);
				_.progressiveLazyLoad();
			};

			imageToLoad.onerror = function () {

				if (tryCount < 3) {

					/**
      * try to load the image 3 times,
      * leave a slight delay so we don't get
      * servers blocking the request.
      */
					setTimeout(function () {
						_.progressiveLazyLoad(tryCount + 1);
					}, 500);
				} else {

					image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');

					_.$slider.trigger('lazyLoadError', [_, image, imageSource]);

					_.progressiveLazyLoad();
				}
			};

			imageToLoad.src = imageSource;
		} else {

			_.$slider.trigger('allImagesLoaded', [_]);
		}
	};

	Slick.prototype.refresh = function (initializing) {

		var _ = this,
		    currentSlide,
		    lastVisibleIndex;

		lastVisibleIndex = _.slideCount - _.options.slidesToShow;

		// in non-infinite sliders, we don't want to go past the
		// last visible index.
		if (!_.options.infinite && _.currentSlide > lastVisibleIndex) {
			_.currentSlide = lastVisibleIndex;
		}

		// if less slides than to show, go to start.
		if (_.slideCount <= _.options.slidesToShow) {
			_.currentSlide = 0;
		}

		currentSlide = _.currentSlide;

		_.destroy(true);

		$.extend(_, _.initials, { currentSlide: currentSlide });

		_.init();

		if (!initializing) {

			_.changeSlide({
				data: {
					message: 'index',
					index: currentSlide
				}
			}, false);
		}
	};

	Slick.prototype.registerBreakpoints = function () {

		var _ = this,
		    breakpoint,
		    currentBreakpoint,
		    l,
		    responsiveSettings = _.options.responsive || null;

		if ($.type(responsiveSettings) === 'array' && responsiveSettings.length) {

			_.respondTo = _.options.respondTo || 'window';

			for (breakpoint in responsiveSettings) {

				l = _.breakpoints.length - 1;
				currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

				if (responsiveSettings.hasOwnProperty(breakpoint)) {

					// loop through the breakpoints and cut out any existing
					// ones with the same breakpoint number, we don't want dupes.
					while (l >= 0) {
						if (_.breakpoints[l] && _.breakpoints[l] === currentBreakpoint) {
							_.breakpoints.splice(l, 1);
						}
						l--;
					}

					_.breakpoints.push(currentBreakpoint);
					_.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;
				}
			}

			_.breakpoints.sort(function (a, b) {
				return _.options.mobileFirst ? a - b : b - a;
			});
		}
	};

	Slick.prototype.reinit = function () {

		var _ = this;

		_.$slides = _.$slideTrack.children(_.options.slide).addClass('slick-slide');

		_.slideCount = _.$slides.length;

		if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
			_.currentSlide = _.currentSlide - _.options.slidesToScroll;
		}

		if (_.slideCount <= _.options.slidesToShow) {
			_.currentSlide = 0;
		}

		_.registerBreakpoints();

		_.setProps();
		_.setupInfinite();
		_.buildArrows();
		_.updateArrows();
		_.initArrowEvents();
		_.buildDots();
		_.updateDots();
		_.initDotEvents();
		_.cleanUpSlideEvents();
		_.initSlideEvents();

		_.checkResponsive(false, true);

		if (_.options.focusOnSelect === true) {
			$(_.$slideTrack).children().on('click.slick', _.selectHandler);
		}

		_.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

		_.setPosition();
		_.focusHandler();

		_.paused = !_.options.autoplay;
		_.autoPlay();

		_.$slider.trigger('reInit', [_]);
	};

	Slick.prototype.resize = function () {

		var _ = this;

		if ($(window).width() !== _.windowWidth) {
			clearTimeout(_.windowDelay);
			_.windowDelay = window.setTimeout(function () {
				_.windowWidth = $(window).width();
				_.checkResponsive();
				if (!_.unslicked) {
					_.setPosition();
				}
			}, 50);
		}
	};

	Slick.prototype.removeSlide = Slick.prototype.slickRemove = function (index, removeBefore, removeAll) {

		var _ = this;

		if (typeof index === 'boolean') {
			removeBefore = index;
			index = removeBefore === true ? 0 : _.slideCount - 1;
		} else {
			index = removeBefore === true ? --index : index;
		}

		if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
			return false;
		}

		_.unload();

		if (removeAll === true) {
			_.$slideTrack.children().remove();
		} else {
			_.$slideTrack.children(this.options.slide).eq(index).remove();
		}

		_.$slides = _.$slideTrack.children(this.options.slide);

		_.$slideTrack.children(this.options.slide).detach();

		_.$slideTrack.append(_.$slides);

		_.$slidesCache = _.$slides;

		_.reinit();
	};

	Slick.prototype.setCSS = function (position) {

		var _ = this,
		    positionProps = {},
		    x,
		    y;

		if (_.options.rtl === true) {
			position = -position;
		}
		x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
		y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

		positionProps[_.positionProp] = position;

		if (_.transformsEnabled === false) {
			_.$slideTrack.css(positionProps);
		} else {
			positionProps = {};
			if (_.cssTransitions === false) {
				positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
				_.$slideTrack.css(positionProps);
			} else {
				positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
				_.$slideTrack.css(positionProps);
			}
		}
	};

	Slick.prototype.setDimensions = function () {

		var _ = this;

		if (_.options.vertical === false) {
			if (_.options.centerMode === true) {
				_.$list.css({
					padding: '0px ' + _.options.centerPadding
				});
			}
		} else {
			_.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
			if (_.options.centerMode === true) {
				_.$list.css({
					padding: _.options.centerPadding + ' 0px'
				});
			}
		}

		_.listWidth = _.$list.width();
		_.listHeight = _.$list.height();

		if (_.options.vertical === false && _.options.variableWidth === false) {
			_.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
			_.$slideTrack.width(Math.ceil(_.slideWidth * _.$slideTrack.children('.slick-slide').length));
		} else if (_.options.variableWidth === true) {
			_.$slideTrack.width(5000 * _.slideCount);
		} else {
			_.slideWidth = Math.ceil(_.listWidth);
			_.$slideTrack.height(Math.ceil(_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length));
		}

		var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
		if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);
	};

	Slick.prototype.setFade = function () {

		var _ = this,
		    targetLeft;

		_.$slides.each(function (index, element) {
			targetLeft = _.slideWidth * index * -1;
			if (_.options.rtl === true) {
				$(element).css({
					position: 'relative',
					right: targetLeft,
					top: 0,
					zIndex: _.options.zIndex - 2,
					opacity: 0
				});
			} else {
				$(element).css({
					position: 'relative',
					left: targetLeft,
					top: 0,
					zIndex: _.options.zIndex - 2,
					opacity: 0
				});
			}
		});

		_.$slides.eq(_.currentSlide).css({
			zIndex: _.options.zIndex - 1,
			opacity: 1
		});
	};

	Slick.prototype.setHeight = function () {

		var _ = this;

		if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
			var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
			_.$list.css('height', targetHeight);
		}
	};

	Slick.prototype.setOption = Slick.prototype.slickSetOption = function () {

		/**
   * accepts arguments in format of:
   *
   *  - for changing a single option's value:
   *     .slick("setOption", option, value, refresh )
   *
   *  - for changing a set of responsive options:
   *     .slick("setOption", 'responsive', [{}, ...], refresh )
   *
   *  - for updating multiple values at once (not responsive)
   *     .slick("setOption", { 'option': value, ... }, refresh )
   */

		var _ = this,
		    l,
		    item,
		    option,
		    value,
		    refresh = false,
		    type;

		if ($.type(arguments[0]) === 'object') {

			option = arguments[0];
			refresh = arguments[1];
			type = 'multiple';
		} else if ($.type(arguments[0]) === 'string') {

			option = arguments[0];
			value = arguments[1];
			refresh = arguments[2];

			if (arguments[0] === 'responsive' && $.type(arguments[1]) === 'array') {

				type = 'responsive';
			} else if (typeof arguments[1] !== 'undefined') {

				type = 'single';
			}
		}

		if (type === 'single') {

			_.options[option] = value;
		} else if (type === 'multiple') {

			$.each(option, function (opt, val) {

				_.options[opt] = val;
			});
		} else if (type === 'responsive') {

			for (item in value) {

				if ($.type(_.options.responsive) !== 'array') {

					_.options.responsive = [value[item]];
				} else {

					l = _.options.responsive.length - 1;

					// loop through the responsive object and splice out duplicates.
					while (l >= 0) {

						if (_.options.responsive[l].breakpoint === value[item].breakpoint) {

							_.options.responsive.splice(l, 1);
						}

						l--;
					}

					_.options.responsive.push(value[item]);
				}
			}
		}

		if (refresh) {

			_.unload();
			_.reinit();
		}
	};

	Slick.prototype.setPosition = function () {

		var _ = this;

		_.setDimensions();

		_.setHeight();

		if (_.options.fade === false) {
			_.setCSS(_.getLeft(_.currentSlide));
		} else {
			_.setFade();
		}

		_.$slider.trigger('setPosition', [_]);
	};

	Slick.prototype.setProps = function () {

		var _ = this,
		    bodyStyle = document.body.style;

		_.positionProp = _.options.vertical === true ? 'top' : 'left';

		if (_.positionProp === 'top') {
			_.$slider.addClass('slick-vertical');
		} else {
			_.$slider.removeClass('slick-vertical');
		}

		if (bodyStyle.WebkitTransition !== undefined || bodyStyle.MozTransition !== undefined || bodyStyle.msTransition !== undefined) {
			if (_.options.useCSS === true) {
				_.cssTransitions = true;
			}
		}

		if (_.options.fade) {
			if (typeof _.options.zIndex === 'number') {
				if (_.options.zIndex < 3) {
					_.options.zIndex = 3;
				}
			} else {
				_.options.zIndex = _.defaults.zIndex;
			}
		}

		if (bodyStyle.OTransform !== undefined) {
			_.animType = 'OTransform';
			_.transformType = '-o-transform';
			_.transitionType = 'OTransition';
			if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
		}
		if (bodyStyle.MozTransform !== undefined) {
			_.animType = 'MozTransform';
			_.transformType = '-moz-transform';
			_.transitionType = 'MozTransition';
			if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
		}
		if (bodyStyle.webkitTransform !== undefined) {
			_.animType = 'webkitTransform';
			_.transformType = '-webkit-transform';
			_.transitionType = 'webkitTransition';
			if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
		}
		if (bodyStyle.msTransform !== undefined) {
			_.animType = 'msTransform';
			_.transformType = '-ms-transform';
			_.transitionType = 'msTransition';
			if (bodyStyle.msTransform === undefined) _.animType = false;
		}
		if (bodyStyle.transform !== undefined && _.animType !== false) {
			_.animType = 'transform';
			_.transformType = 'transform';
			_.transitionType = 'transition';
		}
		_.transformsEnabled = _.options.useTransform && _.animType !== null && _.animType !== false;
	};

	Slick.prototype.setSlideClasses = function (index) {

		var _ = this,
		    centerOffset,
		    allSlides,
		    indexOffset,
		    remainder;

		allSlides = _.$slider.find('.slick-slide').removeClass('slick-active slick-center slick-current').attr('aria-hidden', 'true');

		_.$slides.eq(index).addClass('slick-current');

		if (_.options.centerMode === true) {

			centerOffset = Math.floor(_.options.slidesToShow / 2);

			if (_.options.infinite === true) {

				if (index >= centerOffset && index <= _.slideCount - 1 - centerOffset) {

					_.$slides.slice(index - centerOffset, index + centerOffset + 1).addClass('slick-active').attr('aria-hidden', 'false');
				} else {

					indexOffset = _.options.slidesToShow + index;
					allSlides.slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2).addClass('slick-active').attr('aria-hidden', 'false');
				}

				if (index === 0) {

					allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass('slick-center');
				} else if (index === _.slideCount - 1) {

					allSlides.eq(_.options.slidesToShow).addClass('slick-center');
				}
			}

			_.$slides.eq(index).addClass('slick-center');
		} else {

			if (index >= 0 && index <= _.slideCount - _.options.slidesToShow) {

				_.$slides.slice(index, index + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
			} else if (allSlides.length <= _.options.slidesToShow) {

				allSlides.addClass('slick-active').attr('aria-hidden', 'false');
			} else {

				remainder = _.slideCount % _.options.slidesToShow;
				indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

				if (_.options.slidesToShow == _.options.slidesToScroll && _.slideCount - index < _.options.slidesToShow) {

					allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass('slick-active').attr('aria-hidden', 'false');
				} else {

					allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
				}
			}
		}

		if (_.options.lazyLoad === 'ondemand') {
			_.lazyLoad();
		}
	};

	Slick.prototype.setupInfinite = function () {

		var _ = this,
		    i,
		    slideIndex,
		    infiniteCount;

		if (_.options.fade === true) {
			_.options.centerMode = false;
		}

		if (_.options.infinite === true && _.options.fade === false) {

			slideIndex = null;

			if (_.slideCount > _.options.slidesToShow) {

				if (_.options.centerMode === true) {
					infiniteCount = _.options.slidesToShow + 1;
				} else {
					infiniteCount = _.options.slidesToShow;
				}

				for (i = _.slideCount; i > _.slideCount - infiniteCount; i -= 1) {
					slideIndex = i - 1;
					$(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex - _.slideCount).prependTo(_.$slideTrack).addClass('slick-cloned');
				}
				for (i = 0; i < infiniteCount; i += 1) {
					slideIndex = i;
					$(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex + _.slideCount).appendTo(_.$slideTrack).addClass('slick-cloned');
				}
				_.$slideTrack.find('.slick-cloned').find('[id]').each(function () {
					$(this).attr('id', '');
				});
			}
		}
	};

	Slick.prototype.interrupt = function (toggle) {

		var _ = this;

		if (!toggle) {
			_.autoPlay();
		}
		_.interrupted = toggle;
	};

	Slick.prototype.selectHandler = function (event) {

		var _ = this;

		var targetElement = $(event.target).is('.slick-slide') ? $(event.target) : $(event.target).parents('.slick-slide');

		var index = parseInt(targetElement.attr('data-slick-index'));

		if (!index) index = 0;

		if (_.slideCount <= _.options.slidesToShow) {

			_.setSlideClasses(index);
			_.asNavFor(index);
			return;
		}

		_.slideHandler(index);
	};

	Slick.prototype.slideHandler = function (index, sync, dontAnimate) {

		var targetSlide,
		    animSlide,
		    oldSlide,
		    slideLeft,
		    targetLeft = null,
		    _ = this,
		    navTarget;

		sync = sync || false;

		if (_.animating === true && _.options.waitForAnimate === true) {
			return;
		}

		if (_.options.fade === true && _.currentSlide === index) {
			return;
		}

		if (_.slideCount <= _.options.slidesToShow) {
			return;
		}

		if (sync === false) {
			_.asNavFor(index);
		}

		targetSlide = index;
		targetLeft = _.getLeft(targetSlide);
		slideLeft = _.getLeft(_.currentSlide);

		_.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

		if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
			if (_.options.fade === false) {
				targetSlide = _.currentSlide;
				if (dontAnimate !== true) {
					_.animateSlide(slideLeft, function () {
						_.postSlide(targetSlide);
					});
				} else {
					_.postSlide(targetSlide);
				}
			}
			return;
		} else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > _.slideCount - _.options.slidesToScroll)) {
			if (_.options.fade === false) {
				targetSlide = _.currentSlide;
				if (dontAnimate !== true) {
					_.animateSlide(slideLeft, function () {
						_.postSlide(targetSlide);
					});
				} else {
					_.postSlide(targetSlide);
				}
			}
			return;
		}

		if (_.options.autoplay) {
			clearInterval(_.autoPlayTimer);
		}

		if (targetSlide < 0) {
			if (_.slideCount % _.options.slidesToScroll !== 0) {
				animSlide = _.slideCount - _.slideCount % _.options.slidesToScroll;
			} else {
				animSlide = _.slideCount + targetSlide;
			}
		} else if (targetSlide >= _.slideCount) {
			if (_.slideCount % _.options.slidesToScroll !== 0) {
				animSlide = 0;
			} else {
				animSlide = targetSlide - _.slideCount;
			}
		} else {
			animSlide = targetSlide;
		}

		_.animating = true;

		_.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

		oldSlide = _.currentSlide;
		_.currentSlide = animSlide;

		_.setSlideClasses(_.currentSlide);

		if (_.options.asNavFor) {

			navTarget = _.getNavTarget();
			navTarget = navTarget.slick('getSlick');

			if (navTarget.slideCount <= navTarget.options.slidesToShow) {
				navTarget.setSlideClasses(_.currentSlide);
			}
		}

		_.updateDots();
		_.updateArrows();

		if (_.options.fade === true) {
			if (dontAnimate !== true) {

				_.fadeSlideOut(oldSlide);

				_.fadeSlide(animSlide, function () {
					_.postSlide(animSlide);
				});
			} else {
				_.postSlide(animSlide);
			}
			_.animateHeight();
			return;
		}

		if (dontAnimate !== true) {
			_.animateSlide(targetLeft, function () {
				_.postSlide(animSlide);
			});
		} else {
			_.postSlide(animSlide);
		}
	};

	Slick.prototype.startLoad = function () {

		var _ = this;

		if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

			_.$prevArrow.hide();
			_.$nextArrow.hide();
		}

		if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

			_.$dots.hide();
		}

		_.$slider.addClass('slick-loading');
	};

	Slick.prototype.swipeDirection = function () {

		var xDist,
		    yDist,
		    r,
		    swipeAngle,
		    _ = this;

		xDist = _.touchObject.startX - _.touchObject.curX;
		yDist = _.touchObject.startY - _.touchObject.curY;
		r = Math.atan2(yDist, xDist);

		swipeAngle = Math.round(r * 180 / Math.PI);
		if (swipeAngle < 0) {
			swipeAngle = 360 - Math.abs(swipeAngle);
		}

		if (swipeAngle <= 45 && swipeAngle >= 0) {
			return _.options.rtl === false ? 'left' : 'right';
		}
		if (swipeAngle <= 360 && swipeAngle >= 315) {
			return _.options.rtl === false ? 'left' : 'right';
		}
		if (swipeAngle >= 135 && swipeAngle <= 225) {
			return _.options.rtl === false ? 'right' : 'left';
		}
		if (_.options.verticalSwiping === true) {
			if (swipeAngle >= 35 && swipeAngle <= 135) {
				return 'down';
			} else {
				return 'up';
			}
		}

		return 'vertical';
	};

	Slick.prototype.swipeEnd = function (event) {

		var _ = this,
		    slideCount,
		    direction;

		_.dragging = false;
		_.interrupted = false;
		_.shouldClick = _.touchObject.swipeLength > 10 ? false : true;

		if (_.touchObject.curX === undefined) {
			return false;
		}

		if (_.touchObject.edgeHit === true) {
			_.$slider.trigger('edge', [_, _.swipeDirection()]);
		}

		if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {

			direction = _.swipeDirection();

			switch (direction) {

				case 'left':
				case 'down':

					slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide + _.getSlideCount()) : _.currentSlide + _.getSlideCount();

					_.currentDirection = 0;

					break;

				case 'right':
				case 'up':

					slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide - _.getSlideCount()) : _.currentSlide - _.getSlideCount();

					_.currentDirection = 1;

					break;

				default:

			}

			if (direction != 'vertical') {

				_.slideHandler(slideCount);
				_.touchObject = {};
				_.$slider.trigger('swipe', [_, direction]);
			}
		} else {

			if (_.touchObject.startX !== _.touchObject.curX) {

				_.slideHandler(_.currentSlide);
				_.touchObject = {};
			}
		}
	};

	Slick.prototype.swipeHandler = function (event) {

		var _ = this;

		if (_.options.swipe === false || 'ontouchend' in document && _.options.swipe === false) {
			return;
		} else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
			return;
		}

		_.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ? event.originalEvent.touches.length : 1;

		_.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;

		if (_.options.verticalSwiping === true) {
			_.touchObject.minSwipe = _.listHeight / _.options.touchThreshold;
		}

		switch (event.data.action) {

			case 'start':
				_.swipeStart(event);
				break;

			case 'move':
				_.swipeMove(event);
				break;

			case 'end':
				_.swipeEnd(event);
				break;

		}
	};

	Slick.prototype.swipeMove = function (event) {

		var _ = this,
		    edgeWasHit = false,
		    curLeft,
		    swipeDirection,
		    swipeLength,
		    positionOffset,
		    touches;

		touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

		if (!_.dragging || touches && touches.length !== 1) {
			return false;
		}

		curLeft = _.getLeft(_.currentSlide);

		_.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
		_.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

		_.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

		if (_.options.verticalSwiping === true) {
			_.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));
		}

		swipeDirection = _.swipeDirection();

		if (swipeDirection === 'vertical') {
			return;
		}

		if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
			event.preventDefault();
		}

		positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
		if (_.options.verticalSwiping === true) {
			positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
		}

		swipeLength = _.touchObject.swipeLength;

		_.touchObject.edgeHit = false;

		if (_.options.infinite === false) {
			if (_.currentSlide === 0 && swipeDirection === 'right' || _.currentSlide >= _.getDotCount() && swipeDirection === 'left') {
				swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
				_.touchObject.edgeHit = true;
			}
		}

		if (_.options.vertical === false) {
			_.swipeLeft = curLeft + swipeLength * positionOffset;
		} else {
			_.swipeLeft = curLeft + swipeLength * (_.$list.height() / _.listWidth) * positionOffset;
		}
		if (_.options.verticalSwiping === true) {
			_.swipeLeft = curLeft + swipeLength * positionOffset;
		}

		if (_.options.fade === true || _.options.touchMove === false) {
			return false;
		}

		if (_.animating === true) {
			_.swipeLeft = null;
			return false;
		}

		_.setCSS(_.swipeLeft);
	};

	Slick.prototype.swipeStart = function (event) {

		var _ = this,
		    touches;

		_.interrupted = true;

		if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
			_.touchObject = {};
			return false;
		}

		if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
			touches = event.originalEvent.touches[0];
		}

		_.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
		_.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

		_.dragging = true;
	};

	Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function () {

		var _ = this;

		if (_.$slidesCache !== null) {

			_.unload();

			_.$slideTrack.children(this.options.slide).detach();

			_.$slidesCache.appendTo(_.$slideTrack);

			_.reinit();
		}
	};

	Slick.prototype.unload = function () {

		var _ = this;

		$('.slick-cloned', _.$slider).remove();

		if (_.$dots) {
			_.$dots.remove();
		}

		if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
			_.$prevArrow.remove();
		}

		if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
			_.$nextArrow.remove();
		}

		_.$slides.removeClass('slick-slide slick-active slick-visible slick-current').attr('aria-hidden', 'true').css('width', '');
	};

	Slick.prototype.unslick = function (fromBreakpoint) {

		var _ = this;
		_.$slider.trigger('unslick', [_, fromBreakpoint]);
		_.destroy();
	};

	Slick.prototype.updateArrows = function () {

		var _ = this,
		    centerOffset;

		centerOffset = Math.floor(_.options.slidesToShow / 2);

		if (_.options.arrows === true && _.slideCount > _.options.slidesToShow && !_.options.infinite) {

			_.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
			_.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

			if (_.currentSlide === 0) {

				_.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
				_.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
			} else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

				_.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
				_.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
			} else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

				_.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
				_.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
			}
		}
	};

	Slick.prototype.updateDots = function () {

		var _ = this;

		if (_.$dots !== null) {

			_.$dots.find('li').removeClass('slick-active').attr('aria-hidden', 'true');

			_.$dots.find('li').eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).addClass('slick-active').attr('aria-hidden', 'false');
		}
	};

	Slick.prototype.visibility = function () {

		var _ = this;

		if (_.options.autoplay) {

			if (document[_.hidden]) {

				_.interrupted = true;
			} else {

				_.interrupted = false;
			}
		}
	};

	$.fn.slick = function () {
		var _ = this,
		    opt = arguments[0],
		    args = Array.prototype.slice.call(arguments, 1),
		    l = _.length,
		    i,
		    ret;
		for (i = 0; i < l; i++) {
			if ((typeof opt === "undefined" ? "undefined" : _typeof(opt)) == 'object' || typeof opt == 'undefined') _[i].slick = new Slick(_[i], opt);else ret = _[i].slick[opt].apply(_[i].slick, args);
			if (typeof ret != 'undefined') return ret;
		}
		return _;
	};
});
/*****
* rateYo - v2.1.1
* http://prrashi.github.io/rateyo/
* Copyright (c) 2014 Prashanth Pamidi; Licensed MIT
*****/

;(function ($) {
	"use strict";

	// The basic svg string required to generate stars

	var BASICSTAR = "<?xml version=\"1.0\" encoding=\"utf-8\"?>" + "<svg version=\"1.1\"" + "xmlns=\"http://www.w3.org/2000/svg\"" + "viewBox=\"0 12.705 512 486.59\"" + "x=\"0px\" y=\"0px\"" + "xml:space=\"preserve\">" + "<polygon " + "points=\"256.814,12.705 317.205,198.566" + " 512.631,198.566 354.529,313.435 " + "414.918,499.295 256.814,384.427 " + "98.713,499.295 159.102,313.435 " + "1,198.566 196.426,198.566 \"/>" + "</svg>";

	// The Default values of different options available in the Plugin
	var DEFAULTS = {

		starWidth: "32px",
		normalFill: "gray",
		ratedFill: "#f39c12",
		numStars: 5,
		maxValue: 5,
		precision: 1,
		rating: 0,
		fullStar: false,
		halfStar: false,
		readOnly: false,
		spacing: "0px",
		multiColor: null,
		onInit: null,
		onChange: null,
		onSet: null
	};

	//Default colors for multi-color rating
	var MULTICOLOR_OPTIONS = {

		startColor: "#c0392b", //red
		endColor: "#f1c40f" //yellow
	};

	function checkPrecision(value, minValue, maxValue) {

		/* 
   * This function removes the unnecessary precision, at Min and Max Values
   */

		// Its like comparing 0.0 with 0, which is true
		if (value === minValue) {

			value = minValue;
		} else if (value === maxValue) {

			value = maxValue;
		}

		return value;
	}

	function checkBounds(value, minValue, maxValue) {

		/*
   * Check if the value is between min and max values, if not, throw an error
   */

		var isValid = value >= minValue && value <= maxValue;

		if (!isValid) {

			throw Error("Invalid Rating, expected value between " + minValue + " and " + maxValue);
		}

		return value;
	}

	function isDefined(value) {

		// Better way to check if a variable is defined or not
		return typeof value !== "undefined";
	}

	// Regex to match Colors in Hex Format like #FF00FF
	var hexRegex = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i;

	var hexToRGB = function hexToRGB(hex) {

		/*
   * Extracts and returns the Red, Blue, Green Channel values,
   * in the form of decimals
   */

		if (!hexRegex.test(hex)) {

			return null;
		}

		var hexValues = hexRegex.exec(hex),
		    r = parseInt(hexValues[1], 16),
		    g = parseInt(hexValues[2], 16),
		    b = parseInt(hexValues[3], 16);

		return { r: r, g: g, b: b };
	};

	function getChannelValue(startVal, endVal, percent) {

		/*
   * Returns a value between `startVal` and `endVal` based on the percent 
   */

		var newVal = (endVal - startVal) * (percent / 100);

		newVal = Math.round(startVal + newVal).toString(16);

		if (newVal.length === 1) {

			newVal = "0" + newVal;
		}

		return newVal;
	}

	function getColor(startColor, endColor, percent) {

		/*
   * Given the percentage( `percent` ) of `endColor` to be mixed
   * with the `startColor`, returns the mixed color.
   * Colors should be only in Hex Format
   */

		if (!startColor || !endColor) {

			return null;
		}

		percent = isDefined(percent) ? percent : 0;

		startColor = hexToRGB(startColor);
		endColor = hexToRGB(endColor);

		var r = getChannelValue(startColor.r, endColor.r, percent),
		    b = getChannelValue(startColor.b, endColor.b, percent),
		    g = getChannelValue(startColor.g, endColor.g, percent);

		return "#" + r + g + b;
	}

	function RateYo($node, options) {

		/*
   * The Contructor, whose instances are used by plugin itself
   */

		// Storing the HTML element as a property, for future access
		this.node = $node.get(0);

		var that = this;

		// Remove any stuff that is present inside the container, and add the plugin class 
		$node.empty().addClass("jq-ry-container");

		/*
   * Basically the plugin displays the rating using two rows of stars lying one above
   * the other, the row that is on the top represents the actual rating, and the one
   * behind acts just like a background.
   *
   * `$groupWrapper`: is an element that wraps both the rows
   * `$normalGroup`: is the container for row of stars thats behind and
   *                 acts as background
   * `$ratedGroup`: is the container for row of stars that display the actual rating.
   *
   * The rating is displayed by adjusting the width of `$ratedGroup`
   */
		var $groupWrapper = $("<div/>").addClass("jq-ry-group-wrapper").appendTo($node);

		var $normalGroup = $("<div/>").addClass("jq-ry-normal-group").addClass("jq-ry-group").appendTo($groupWrapper);

		var $ratedGroup = $("<div/>").addClass("jq-ry-rated-group").addClass("jq-ry-group").appendTo($groupWrapper);

		/*
   * Variable `step`: store the value of the rating for each star
   *                  eg: if `maxValue` is 5 and `numStars` is 5, value of each star
   *                      is 1.
   * Variable `starWidth`: stores the decimal value of width of star in units of px
   * Variable `percentOfStar`: stores the percentage of width each star takes w.r.t
   *                           the container
   * Variable `spacing`: stores the decimal value of the spacing between stars
   *                     in the units of px
   * Variable `percentOfSpacing`: stores the percentage of width of the spacing
   *                              between stars w.r.t the container
   */
		var step,
		    starWidth,
		    percentOfStar,
		    spacing,
		    percentOfSpacing,
		    containerWidth,
		    minValue = 0;

		/*
   * `currentRating` contains rating that is being displayed at the latest point of
   * time.
   *
   * When ever you hover over the plugin UI, the rating value changes
   * according to the place where you point the cursor, currentRating contains
   * the current value of rating that is being shown in the UI
   */
		var currentRating = options.rating;

		// A flag to store if the plugin is already being displayed in the UI
		var isInitialized = false;

		function showRating(ratingVal) {

			/*
    * The function is responsible for displaying the rating by changing
    * the width of `$ratedGroup`
    */

			if (!isDefined(ratingVal)) {

				ratingVal = options.rating;
			}

			// Storing the value that is being shown in `currentRating`.
			currentRating = ratingVal;

			var numStarsToShow = ratingVal / step;

			// calculating the percentage of width of $ratedGroup with respect to its parent
			var percent = numStarsToShow * percentOfStar;

			if (numStarsToShow > 1) {

				// adding the percentage of space that is taken by the gap the stars
				percent += (Math.ceil(numStarsToShow) - 1) * percentOfSpacing;
			}

			setRatedFill(options.ratedFill);

			$ratedGroup.css("width", percent + "%");
		}

		function setContainerWidth() {

			/*
    * Set the width of the `this.node` based on the width of each star and
    * the space between them 
    */

			containerWidth = starWidth * options.numStars + spacing * (options.numStars - 1);

			percentOfStar = starWidth / containerWidth * 100;

			percentOfSpacing = spacing / containerWidth * 100;

			$node.width(containerWidth);

			showRating();
		}

		function setStarWidth(newWidth) {

			/*
    * Set the width and height of each SVG star, called whenever one changes the
    * `starWidth` option
    */

			// The width and height of the star should be the same
			var starHeight = options.starWidth = newWidth;

			starWidth = window.parseFloat(options.starWidth.replace("px", ""));

			$normalGroup.find("svg").attr({ width: options.starWidth,
				height: starHeight });

			$ratedGroup.find("svg").attr({ width: options.starWidth,
				height: starHeight });

			setContainerWidth();

			return $node;
		}

		function setSpacing(newSpacing) {

			/*
    * Set spacing between the SVG stars, called whenever one changes
    * the `spacing` option
    */

			options.spacing = newSpacing;

			spacing = parseFloat(options.spacing.replace("px", ""));

			$normalGroup.find("svg:not(:first-child)").css({ "margin-left": newSpacing });

			$ratedGroup.find("svg:not(:first-child)").css({ "margin-left": newSpacing });

			setContainerWidth();

			return $node;
		}

		function setNormalFill(newFill) {

			/*
    * Set the background fill of the Stars, called whenever one changes the
    * `normalFill` option
    */

			options.normalFill = newFill;

			$normalGroup.find("svg").attr({ fill: options.normalFill });

			return $node;
		}

		/*
   * Store the recent `ratedFill` option in a variable
   * so that if multiColor is unset, we can use the perviously set `ratedFill`
   * from this variable
   */
		var ratedFill = options.ratedFill;

		function setRatedFill(newFill) {

			/*
    * Set ratedFill of the stars, called when one changes the `ratedFill` option
    */

			/*
    * If `multiColor` option is set, `newFill` variable is dynamically set
    * based on the rating, what ever set as parameter will be discarded
    */
			if (options.multiColor) {

				var ratingDiff = currentRating - minValue,
				    percentCovered = ratingDiff / options.maxValue * 100;

				var colorOpts = options.multiColor || {},
				    startColor = colorOpts.startColor || MULTICOLOR_OPTIONS.startColor,
				    endColor = colorOpts.endColor || MULTICOLOR_OPTIONS.endColor;

				newFill = getColor(startColor, endColor, percentCovered);
			} else {

				ratedFill = newFill;
			}

			options.ratedFill = newFill;

			$ratedGroup.find("svg").attr({ fill: options.ratedFill });

			return $node;
		}

		function setMultiColor(colorOptions) {

			/*
    * called whenever one changes the `multiColor` option
    */

			options.multiColor = colorOptions;

			// set the recently set `ratedFill` option, if multiColor Options are unset
			setRatedFill(colorOptions ? colorOptions : ratedFill);
		}

		function setNumStars(newValue) {

			/*
    * Set the number of stars to use to display the rating, called whenever one
    * changes the `numStars` option
    */

			options.numStars = newValue;

			step = options.maxValue / options.numStars;

			$normalGroup.empty();
			$ratedGroup.empty();

			for (var i = 0; i < options.numStars; i++) {

				$normalGroup.append($(BASICSTAR));
				$ratedGroup.append($(BASICSTAR));
			}

			setStarWidth(options.starWidth);
			setNormalFill(options.normalFill);
			setSpacing(options.spacing);

			showRating();

			return $node;
		}

		function setMaxValue(newValue) {

			/*
    * set the Maximum Value of rating to be allowed, called whenever
    * one changes the `maxValue` option
    */

			options.maxValue = newValue;

			step = options.maxValue / options.numStars;

			if (options.rating > newValue) {

				setRating(newValue);
			}

			showRating();

			return $node;
		}

		function setPrecision(newValue) {

			/*
    * Set the precision of the rating value, called if one changes the
    * `precision` option
    */

			options.precision = newValue;

			setRating(options.rating);

			return $node;
		}

		function setHalfStar(newValue) {

			/*
    * This function will be called if one changes the `halfStar` option
    */

			options.halfStar = newValue;

			return $node;
		}

		function setFullStar(newValue) {

			/*
    * This function will be called if one changes the `fullStar` option
    */

			options.fullStar = newValue;

			return $node;
		}

		function round(value) {

			/*
    * Rounds the value of rating if `halfStar` or `fullStar` options are chosen
    */

			var remainder = value % step,
			    halfStep = step / 2,
			    isHalfStar = options.halfStar,
			    isFullStar = options.fullStar;

			if (!isFullStar && !isHalfStar) {

				return value;
			}

			if (isFullStar || isHalfStar && remainder > halfStep) {

				value += step - remainder;
			} else {

				value = value - remainder;

				if (remainder > 0) {

					value += halfStep;
				}
			}

			return value;
		}

		function calculateRating(e) {

			/*
    * Calculates and returns the rating based on the position of cursor w.r.t the
    * plugin container
    */

			var position = $normalGroup.offset(),
			    nodeStartX = position.left,
			    nodeEndX = nodeStartX + $normalGroup.width();

			var maxValue = options.maxValue;

			// The x-coordinate(position) of the mouse pointer w.r.t page
			var pageX = e.pageX;

			var calculatedRating = 0;

			// If the mouse pointer is to the left of the container
			if (pageX < nodeStartX) {

				calculatedRating = minValue;
			} else if (pageX > nodeEndX) {
				// If the mouse pointer is right of the container

				calculatedRating = maxValue;
			} else {
				// If the mouse pointer is inside the continer

				/*
     * The fraction of width covered by the pointer w.r.t to the total width
     * of the container.
     */
				var calcPrcnt = (pageX - nodeStartX) / (nodeEndX - nodeStartX);

				if (spacing > 0) {

					/*
             * If there is spacing between stars, take the percentage of width covered
             * and subtract the percentage of width covered by stars and spacing, to find
             * how many stars are covered, the number of stars covered is the rating
             *
             * TODO: I strongly feel that this logic can be improved!, Please help!
             */
					calcPrcnt *= 100;

					var remPrcnt = calcPrcnt;

					while (remPrcnt > 0) {

						if (remPrcnt > percentOfStar) {

							calculatedRating += step;
							remPrcnt -= percentOfStar + percentOfSpacing;
						} else {

							calculatedRating += remPrcnt / percentOfStar * step;
							remPrcnt = 0;
						}
					}
				} else {

					/*
      * If there is not spacing between stars, the fraction of width covered per
      * `maxValue` is the rating
      */
					calculatedRating = calcPrcnt * options.maxValue;
				}

				// Round the rating if `halfStar` or `fullStar` options are chosen
				calculatedRating = round(calculatedRating);
			}

			return calculatedRating;
		}

		function setReadOnly(newValue) {

			/*
    * UnBinds mouse event handlers, called when whenever one changes the
    * `readOnly` option
    */

			options.readOnly = newValue;

			$node.attr("readonly", true);

			unbindEvents();

			if (!newValue) {

				$node.removeAttr("readonly");

				bindEvents();
			}

			return $node;
		}

		function setRating(newValue) {

			/*
    * Sets the rating of the Plugin, Called when option `rating` is changed
    * or, when `rating` method is called
    */

			var rating = newValue;

			var maxValue = options.maxValue;

			if (typeof rating === "string") {

				// If rating is given in percentage, maxValue should be 100
				if (rating[rating.length - 1] === "%") {

					rating = rating.substr(0, rating.length - 1);
					maxValue = 100;

					setMaxValue(maxValue);
				}

				rating = parseFloat(rating);
			}

			checkBounds(rating, minValue, maxValue);

			rating = parseFloat(rating.toFixed(options.precision));

			checkPrecision(parseFloat(rating), minValue, maxValue);

			options.rating = rating;

			showRating();

			if (isInitialized) {

				$node.trigger("rateyo.set", { rating: rating });
			}

			return $node;
		}

		function setOnInit(method) {

			/*
    * set what method to be called on Initialization
    */

			options.onInit = method;

			return $node;
		}

		function setOnSet(method) {

			/*
    * set what method to be called when rating is set
    */

			options.onSet = method;

			return $node;
		}

		function setOnChange(method) {

			/*
    * set what method to be called rating in the UI is changed
    */

			options.onChange = method;

			return $node;
		}

		this.rating = function (newValue) {

			/*
    * rating getter/setter
    */

			if (!isDefined(newValue)) {

				return options.rating;
			}

			setRating(newValue);

			return $node;
		};

		this.destroy = function () {

			/*
    * Removes the Rating UI by clearing the content, and removing the custom classes
    */

			if (!options.readOnly) {

				unbindEvents();
			}

			RateYo.prototype.collection = deleteInstance($node.get(0), this.collection);

			$node.removeClass("jq-ry-container").children().remove();

			return $node;
		};

		this.method = function (methodName) {

			/*
    * Method to call the methods of RateYo Instance
    */

			if (!methodName) {

				throw Error("Method name not specified!");
			}

			if (!isDefined(this[methodName])) {

				throw Error("Method " + methodName + " doesn't exist!");
			}

			var args = Array.prototype.slice.apply(arguments, []),
			    params = args.slice(1),
			    method = this[methodName];

			return method.apply(this, params);
		};

		this.option = function (optionName, param) {

			/*
    * Method to get/set Options
    */

			if (!isDefined(optionName)) {

				return options;
			}

			var method;

			switch (optionName) {

				case "starWidth":

					method = setStarWidth;
					break;
				case "numStars":

					method = setNumStars;
					break;
				case "normalFill":

					method = setNormalFill;
					break;
				case "ratedFill":

					method = setRatedFill;
					break;
				case "multiColor":

					method = setMultiColor;
					break;
				case "maxValue":

					method = setMaxValue;
					break;
				case "precision":

					method = setPrecision;
					break;
				case "rating":

					method = setRating;
					break;
				case "halfStar":

					method = setHalfStar;
					break;
				case "fullStar":

					method = setFullStar;
					break;
				case "readOnly":

					method = setReadOnly;
					break;
				case "spacing":

					method = setSpacing;
					break;
				case "onInit":

					method = setOnInit;
					break;
				case "onSet":

					method = setOnSet;
					break;
				case "onChange":

					method = setOnChange;
					break;
				default:

					throw Error("No such option as " + optionName);
			}

			return isDefined(param) ? method(param) : options[optionName];
		};

		function onMouseEnter(e) {

			/*
    * If the Mouse Pointer is inside the container, calculate and show the rating
    * in UI
    */

			var rating = calculateRating(e).toFixed(options.precision);

			var maxValue = options.maxValue;

			rating = checkPrecision(parseFloat(rating), minValue, maxValue);

			showRating(rating);

			$node.trigger("rateyo.change", { rating: rating });
		}

		function onMouseLeave() {

			/*
    * If mouse leaves, revert the rating in UI to previously set rating,
    * when empty value is passed to showRating, it will take the previously set
    * rating
    */

			showRating();

			$node.trigger("rateyo.change", { rating: options.rating });
		}

		function onMouseClick(e) {

			/*
    * On clicking the mouse inside the container, calculate and set the rating
    */

			var resultantRating = calculateRating(e).toFixed(options.precision);
			resultantRating = parseFloat(resultantRating);

			that.rating(resultantRating);
		}

		function onInit(e, data) {

			if (options.onInit && typeof options.onInit === "function") {

				/* jshint validthis:true */
				options.onInit.apply(this, [data.rating, that]);
			}
		}

		function onChange(e, data) {

			if (options.onChange && typeof options.onChange === "function") {

				/* jshint validthis:true */
				options.onChange.apply(this, [data.rating, that]);
			}
		}

		function onSet(e, data) {

			if (options.onSet && typeof options.onSet === "function") {

				/* jshint validthis:true */
				options.onSet.apply(this, [data.rating, that]);
			}
		}

		function bindEvents() {

			$node.on("mousemove", onMouseEnter).on("mouseenter", onMouseEnter).on("mouseleave", onMouseLeave).on("click", onMouseClick).on("rateyo.init", onInit).on("rateyo.change", onChange).on("rateyo.set", onSet);
		}

		function unbindEvents() {

			$node.off("mousemove", onMouseEnter).off("mouseenter", onMouseEnter).off("mouseleave", onMouseLeave).off("click", onMouseClick).off("rateyo.init", onInit).off("rateyo.change", onChange).off("rateyo.set", onSet);
		}

		setNumStars(options.numStars);
		setReadOnly(options.readOnly);

		this.collection.push(this);
		this.rating(options.rating, true);

		isInitialized = true;
		$node.trigger("rateyo.init", { rating: options.rating });
	}

	RateYo.prototype.collection = [];

	function getInstance(node, collection) {

		/* 
   * Given a HTML element (node) and a collection of RateYo instances,
   * this function will search through the collection and return the matched
   * instance having the node
   */

		var instance;

		$.each(collection, function () {

			if (node === this.node) {

				instance = this;
				return false;
			}
		});

		return instance;
	}

	function deleteInstance(node, collection) {

		/* 
   * Given a HTML element (node) and a collection of RateYo instances,
   * this function will search through the collection and delete the
   * instance having the node, and return the modified collection
   */

		$.each(collection, function (index) {

			if (node === this.node) {

				var firstPart = collection.slice(0, index),
				    secondPart = collection.slice(index + 1, collection.length);

				collection = firstPart.concat(secondPart);

				return false;
			}
		});

		return collection;
	}

	function _rateYo(options) {

		var rateYoInstances = RateYo.prototype.collection;

		/* jshint validthis:true */
		var $nodes = $(this);

		if ($nodes.length === 0) {

			return $nodes;
		}

		var args = Array.prototype.slice.apply(arguments, []);

		if (args.length === 0) {

			//If args length is 0, Initialize the UI with default settings
			options = args[0] = {};
		} else if (args.length === 1 && _typeof(args[0]) === "object") {

			//If an Object is specified as first argument, it is considered as options
			options = args[0];
		} else if (args.length >= 1 && typeof args[0] === "string") {

			/*
    * if there is only one argument, and if its a string, it is supposed to be a
    * method name, if more than one argument is specified, the remaining arguments
    * except the first argument, will be passed as a params to the specified method
    */

			var methodName = args[0],
			    params = args.slice(1);

			var result = [];

			$.each($nodes, function (i, node) {

				var existingInstance = getInstance(node, rateYoInstances);

				if (!existingInstance) {

					throw Error("Trying to set options before even initialization");
				}

				var method = existingInstance[methodName];

				if (!method) {

					throw Error("Method " + methodName + " does not exist!");
				}

				var returnVal = method.apply(existingInstance, params);

				result.push(returnVal);
			});

			/*
    * If the plugin in being called on only one jQuery Element, return only the
    * first value, to support chaining.
    */
			result = result.length === 1 ? result[0] : result;

			return result;
		} else {

			throw Error("Invalid Arguments");
		}

		/*
   * if only options are passed, extend default options, and if the plugin is not
   * initialized on a particular jQuery element, initalize RateYo on it
   */
		options = $.extend({}, DEFAULTS, options);

		return $.each($nodes, function () {

			var existingInstance = getInstance(this, rateYoInstances);

			if (!existingInstance) {

				return new RateYo($(this), $.extend({}, options));
			}
		});
	}

	function rateYo() {

		/* jshint validthis:true */
		return _rateYo.apply(this, Array.prototype.slice.apply(arguments, []));
	}

	window.RateYo = RateYo;
	$.fn.rateYo = rateYo;
})(window.jQuery);
/*!
 * jQuery.PositionCalculator
 * https://github.com/tlindig/position-calculator
 *
 * v1.1.2 - 2014-07-01
 *
 * Copyright (c) 2014 Tobias Lindig
 * http://tlindig.de
 *
 * License: MIT
 *
 * Author: Tobias Lindig <dev@tlindig.de>
 */
/*!
 * class PositionCalculator
 * https://github.com/tlindig/position-calculator
 *
 * Copyright (c) 2014 Tobias Lindig
 * Licensed under the MIT license.
 */

/*global define:false*/
(function (factory) {
	// make it public
	if (typeof define === 'function' && define.amd) {
		// as __named__ AMD module
		define("position-calculator", ["jquery"], factory);
	} else {
		// as Browser globals
		jQuery.PositionCalculator = factory(jQuery);
	}
})(function ($) {
	"use strict"; //enable ECMAScript 5 Strict Mode

	// //////////
	// private

	var __window = window;
	var __document = document;
	var __docElement = __document.documentElement;

	var __rgx_vertical = /top|middle|bottom/;
	var __rgx_horizontal = /left|center|right/;
	var __rgx_percent = /%$/;

	var __mirror = {
		left: "right",
		center: "center",
		right: "left",
		top: "bottom",
		middle: "middle",
		bottom: "top"
	};

	/**
  * prepare selector, because jQuery do not return "window" and "document"
  *
  * @param  {selector|DOM|jQuery|null} selector value given in options
  * @return {selector|DOM|jQuery|null}  if "selector" was a string and match "window" or
  *                                     "document", than the native object will be returned.
  */
	function __normalizeSlector(selector) {
		if (typeof selector === "string") {
			if (selector === "window") {
				selector = __window;
			} else if (selector === "document") {
				selector = __document;
			}
		}
		return selector;
	}

	/**
  * Normalize the given "at" specification.
  * Use default value ('top left'), if syntax is not correct.
  *
  * @param  {string} ref     syntax: <vertical> + " " + <horizontal>
  *                          vertical: "top" | "middle" | "bottom"
  *                          horizontal: "left" | "center" | "right"
  * @return {NormAt}         Object with {y:string, x:string}
  */
	function __normalizeAt(ref) {
		var values = ref.split(" ");
		return {
			y: __rgx_vertical.test(values[0]) ? values[0] : "top",
			x: __rgx_horizontal.test(values[1]) ? values[1] : "left"
		};
	}

	/**
  * compare to NormPos with {top:number, left:number, height:number, width:number}
  *
  * @param  {NormPos} normPos1
  * @param  {NormPos} normPos2
  * @return {boolean}          true, if values are equal
  */
	function __isEqualNormPos(normPos1, normPos2) {
		if (normPos1 === normPos2) {
			return true;
		}
		if (!normPos1 || !normPos2) {
			return false;
		}
		return normPos1.top === normPos2.top && normPos1.left === normPos2.left && normPos1.height === normPos2.height && normPos1.width === normPos2.width;
	}

	/**
  * read the correct value for top, left, width and height from the given $el.
  * Can handle "window", "document", "event" and "DOM node"
  * resulting "top" and "left" are relative to document top-left corner
  *
  * @param  {jQuery} $el     input to calculate the position
  * @return {NormPos}        Object with {top:number, left:number, height:number, width:number}
  *
  **/
	function __nomrmalizePosition($el) {
		var raw = $el[0];
		if (raw.nodeType === 9) {
			// is document node
			return {
				width: $el.outerWidth(),
				height: $el.outerHeight(),
				top: 0,
				left: 0
			};
		}
		if ($.isWindow(raw)) {
			return {
				width: $el.outerWidth(),
				height: $el.outerHeight(),
				top: $el.scrollTop(),
				left: $el.scrollLeft()
			};
		}
		if (raw.preventDefault) {
			// is event
			return {
				width: 0,
				height: 0,
				top: raw.pageY,
				left: raw.pageX
			};
		}
		var offset = $el.offset();
		return {
			width: $el.outerWidth(),
			height: $el.outerHeight(),
			top: offset.top,
			left: offset.left
		};
	}

	function __refreshPosition($el, normPos) {
		var raw = $el[0];
		if (raw.nodeType === 9) {
			// is document node, top and left are always 0
			return;
		}
		if ($.isWindow(raw)) {
			normPos.top = $el.scrollTop();
			normPos.left = $el.scrollLeft();
		}
		if (raw.preventDefault) {
			// is event
			normPos.top = raw.pageY;
			normPos.left = raw.pageX;
			return;
		}

		var offset = $el.offset();
		normPos.top = offset.top;
		normPos.left = offset.left;
		return;
	}

	/**
  * get the inner boundary box of given element. Take care of scrollbars, borders, padding and so on.
  * Can handle "window", "document" and "DOM node"
  * resulting "top" and "left" are relative to document top-left corner
  *
  * @param  {jQuery} $el [description]
  * @return {NormPos}    Object with {top:number, left:number, height:number, width:number}
  */
	function __normalizeBounding($el) {
		var domElm = $el[0];
		var offset;
		if (domElm.nodeType === 9) {
			// is document node
			domElm = __docElement;
			offset = {
				top: 0,
				left: 0
			};
		} else if ($.isWindow(domElm)) {
			domElm = __docElement;
			offset = {
				top: $el.scrollTop(),
				left: $el.scrollLeft()
			};
		} else {
			offset = $el.offset();
		}

		return {
			width: domElm.clientWidth,
			height: domElm.clientHeight,
			top: offset.top + domElm.clientTop,
			left: offset.left + domElm.clientLeft
		};
	}

	function __refreshBounding($el, normPos) {
		var domElm = $el[0];
		var offset;
		if (domElm.nodeType === 9) {
			// is document node
			domElm = __docElement;
			offset = {
				top: 0,
				left: 0
			};
		} else if ($.isWindow(domElm)) {
			domElm = __docElement;
			offset = {
				top: $el.scrollTop(),
				left: $el.scrollLeft()
			};
		} else {
			offset = $el.offset();
		}

		normPos.top = offset.top + domElm.clientTop;
		normPos.left = offset.left + domElm.clientLeft;
		return;
	}

	/**
  * normalize given offset, convert percent values in pixel values.
  *
  * @param  {Object} offset      offset object with property x:{number}, y:{number}, mirror:{boolean}
  * @param  {Object} size        with properties width:{number} and height:{number} }
  * @return {Object}             offset object
  */
	function __normalizeExtraOffset(offset, size) {
		return {
			y: parseFloat(offset.y) * (__rgx_percent.test(offset.y) ? size.height / 100 : 1),
			x: parseFloat(offset.x) * (__rgx_percent.test(offset.x) ? size.width / 100 : 1),
			mirror: offset.mirror
		};
	}

	/**
  * Calculate the relative offset from top-left corner to the reference points
  *
  * @param  {NormPos} pos          Object with normalized position
  * @param  {{x:number, y:number}} extraOffsets    [description]
  * @param  {{x:string, y:string}} initialRefpoint [description]
  * @return {RefPoints}            Object with offset for reference points
  *                                { top:number, left:number, middle:number,
  *                                  center:number, bottom:number, right:number }
  */
	function __calculateRefpointOffsets(pos, extraOffsets, initialRefpoint) {
		var result = {
			top: 0,
			left: 0,
			middle: pos.height * 0.5,
			center: pos.width * 0.5,
			bottom: pos.height,
			right: pos.width
		};

		//add extra offset
		if (extraOffsets.y !== 0) {
			result.middle += extraOffsets.y;
			if (extraOffsets.mirror) {
				result.top += "top" !== initialRefpoint.y ? extraOffsets.y * -1 : extraOffsets.y;
				result.bottom += "bottom" !== initialRefpoint.y ? extraOffsets.y * -1 : extraOffsets.y;
			} else {
				result.top += extraOffsets.y;
				result.bottom += extraOffsets.y;
			}
		}
		if (extraOffsets.x !== 0) {
			result.center += extraOffsets.x;
			if (extraOffsets.mirror) {
				result.left += "left" !== initialRefpoint.x ? extraOffsets.x * -1 : extraOffsets.x;
				result.right += "right" !== initialRefpoint.x ? extraOffsets.x * -1 : extraOffsets.x;
			} else {
				result.left += extraOffsets.x;
				result.right += extraOffsets.x;
			}
		}

		return result;
	}

	/**
  * collect all edges that have overflow between boundary and item.
  *
  * @param  {Distance} distance  Distance Object
  * @return {Distance}           Object with
  *                              { top:number, left:number, bottom:number, right:number,
  *                                overflow:{Array.<string>|null} }
  */
	function __updateOverflow(distance) {
		var overflow = [];
		distance.top > 0 && overflow.push("top");
		distance.left > 0 && overflow.push("left");
		distance.bottom < 0 && overflow.push("bottom");
		distance.right < 0 && overflow.push("right");

		if (overflow.length) {
			distance.overflow = overflow;
		} else {
			distance.overflow = null;
		}

		return distance;
	}

	/**
  * calculate distance / overflow between boundary and item.
  *
  * @param  {NormPos} bou_Pos    NormPos of boundary
  * @param  {NormPos} item_Pos   NormPos of item
  * @return {Distance}           Object with
  *                              { top:number, left:number, bottom:number, right:number,
  *                                overflow:{Array.<string>|null} }
  */
	function __calulateDistance(bou_Pos, item_Pos) {
		var result = {
			top: bou_Pos.top - item_Pos.top,
			left: bou_Pos.left - item_Pos.left,
			bottom: bou_Pos.top + bou_Pos.height - (item_Pos.top + item_Pos.height),
			right: bou_Pos.left + bou_Pos.width - (item_Pos.left + item_Pos.width),
			overflow: []
		};

		return __updateOverflow(result);
	}

	/**
  * calculate the new fliped placement.
  *
  * {NormAt} is Object with {x:string, y:string}
  *
  * @param  {string} flip    - flip option, "item", "target", "both", "none"
  * @param  {NormAt} itemAt  - NormAt of item
  * @param  {NormAt} tarAt   - NormAt of target
  * @param  {Distance}       - current calculated distance, needed to find out, which edge have overflow
  * @return {Object|null}    - Object with placement
  *                          {
  *                              item_at:NormAt,
  *                              tar_at:NormAt
  *                          }
  *                          - null, if no overflow or if overflow on all edges
  */
	function __flipPlacement(flip, itemAt, tarAt, distance) {
		var y_overflowEdge, x_overflowEdge, flipBits;
		var item_flipedAt = {
			y: itemAt.y,
			x: itemAt.x
		};
		var tar_flipedAt = {
			y: tarAt.y,
			x: tarAt.x
		};

		if (distance.overflow.indexOf("top") !== -1) {
			y_overflowEdge = "top";
		}
		if (distance.overflow.indexOf("bottom") !== -1) {
			if (y_overflowEdge) {
				//overflow in both sides, so item is larger than boundary. Can't be resolved
				y_overflowEdge = null;
			} else {
				y_overflowEdge = "bottom";
			}
		}

		if (distance.overflow.indexOf("left") !== -1) {
			x_overflowEdge = "left";
		}
		if (distance.overflow.indexOf("right") !== -1) {
			if (x_overflowEdge) {
				//overflow in both sides, so item is larger than boundary. Can't be resolved
				x_overflowEdge = null;
			} else {
				x_overflowEdge = "right";
			}
		}

		if (!y_overflowEdge && !x_overflowEdge) {
			return null;
		}

		flip = flip === true ? "both" : flip;
		flipBits = 0;
		switch (flip) {
			case "item":
				flipBits = 1;
				break;
			case "target":
				flipBits = 2;
				break;
			case "both":
				flipBits = 3;
				break;
		}

		if (flipBits & 1) {
			y_overflowEdge && (item_flipedAt.y = __mirror[item_flipedAt.y]);
			x_overflowEdge && (item_flipedAt.x = __mirror[item_flipedAt.x]);
		}
		if (flipBits & 2) {
			y_overflowEdge && (tar_flipedAt.y = __mirror[tar_flipedAt.y]);
			x_overflowEdge && (tar_flipedAt.x = __mirror[tar_flipedAt.x]);
		}

		return {
			item_at: item_flipedAt,
			tar_at: tar_flipedAt
		};
	}

	/**
  * compare overflow in distancaA with overflow in distanceB.
  *
  * @param  {Distance}  distanceA  distance object, with top, right, bottom, left
  * @param  {Distance}  distanceB  distance object, with top, right, bottom, left
  * @param  {boolean} isY        axis
  * @return {boolean}            return true, if overflow of A is less than overflow of B,
  *                                         otherwise false
  */
	function __overflowLT(distanceA, distanceB, isY) {
		var a1, a2, b1, b2, edges;

		if (isY) {
			edges = ["top", "bottom"];
		} else {
			edges = ["left", "right"];
		}
		a1 = distanceA[edges[0]];
		b1 = distanceB[edges[0]];
		a2 = distanceA[edges[1]] * -1; // * -1 to get positive values for overflow
		b2 = distanceB[edges[1]] * -1;

		// set values without overflow to zero
		a1 < 0 && (a1 = 0);
		a2 < 0 && (a2 = 0);
		b1 < 0 && (b1 = 0);
		b2 < 0 && (b2 = 0);

		if (a1 < 0 && a2 < 0) {
			//take a
			return true;
		}

		if (b1 < 0 && b2 < 0) {
			// take b
			return false;
		}

		return a1 + a2 < b1 + b2;
	}

	function __adaptSticking(data, edges) {
		if (edges === "all") {
			edges = true;
		}
		var overflow = data.distance.overflow;

		if (!overflow.length) {
			return data;
		}

		//to prevent handling overflow in both directions of on axis
		var skipX = false;
		var skipY = false;

		var edge, diff;
		for (var i = overflow.length - 1; i >= 0; i--) {
			edge = overflow[i];
			switch (edge) {
				case "top":
				case "bottom":
					if (!skipY && edges === true || edges.indexOf(edge) !== -1) {
						diff = data.distance[edge];
						data.moveBy.y += diff;
						data.distance.top -= diff;
						data.distance.bottom -= diff;
						skipY = true;
					}
					break;

				case "left":
				case "right":
					if (!skipX && edges === true || edges.indexOf(edge) !== -1) {
						diff = data.distance[edge];
						data.moveBy.x += diff;
						data.distance.left -= diff;
						data.distance.right -= diff;
						skipX = true;
					}
					break;
			}
		}

		__updateOverflow(data.distance);

		return data;
	}

	/**
  * Class PositionCalculator
  *
  * @param {Object} options
  *
  * {selector|DOM|jQuery} item       -required- the element being positioned
  * {selector|DOM|jQuery} target     -required- the element align the positioned item against
  * {selector|DOM|jQuery|null} boundary -optional- constraints the position of item
  *                                      default: window
  *
  * {string} itemAt          -optional- placement of reference point on the item
  *                                   syntax: <vertical> + " " + <horizontal>
  *                                   vertical: "top" | "middle" | "bottom"
  *                                   horizontal: "left" | "center" | "right"
  *                          default: "top left"
  * {string} targetAt        -optional- placement of reference point on the target
  *                                     same as for "itemAt"
  *                          default: "top left"
  * {Object} itemOffset      -optional- Object with {
  *                                         y:number,      // vertical offset
  *                                         x:number,      // horizontal offset
  *                                         mirror:boolean // if offset should mirror for flip
  *                                    }
  *                          default: { y:0, x:0, mirror:true }
  *
  * {Object} targetOffset    -optional- same as for "itemOffset"
  *                          default: { y:0, x:0, mirror:true }
  *
  * {string|boolean} flip    -optional- specify the strategy to prevent that "item"
  *                                    overflows the boundary.
  *                                    "item": Only change the itemAt
  *                                    "target": Only change the targetAt
  *                                    "both"|true: Change both the itemAt and targetAt at the same time
  *                                          (to 'flip' the item to the other side of the target)
  *                                    "none"|false: Don't change placement of reference point
  *                          default: "none"
  *
  * {string|boolean} stick   -optional- will keep the item within it's boundary by sticking it to
  *                                     the edges if it normally would overflow.
  *                                     Specify sides you'd like to control (space separated) or
  *                                     "none"|false or "all"|true.
  *                          default: "none"
  *
  *
  *  Main method is calculate()
  *
  */
	function PositionCalculator(options) {
		//ensure it called with 'new'
		if (!(this instanceof PositionCalculator)) {
			return new PositionCalculator(options);
		}

		this.options = this.$itm = this.$trg = this.$bnd = this.itmAt = this.trgAt = this.itmPos = this.trgPos = this.bndPos = this.itmOffset = this.trgOffset = null;

		this._init(options);
	}
	PositionCalculator.prototype._init = function (options) {
		var o = this.options = $.extend({}, PositionCalculator.defaults, options);

		if (!o.item) {
			return null;
		}
		this.$itm = o.item.jquery ? o.item : $(o.item);
		if (this.$itm.length === 0) {
			return null;
		}

		this.$trg = o.target && o.target.jquery ? o.target : $(__normalizeSlector(o.target));
		this.$bnd = o.boundary && o.boundary.jquery ? o.boundary : $(__normalizeSlector(o.boundary));

		this.itmAt = __normalizeAt(o.itemAt);
		this.trgAt = __normalizeAt(o.targetAt);

		this.resize();

		return this; // to allow chaining
	};

	/**
  * Update intern stored values depending on size and position of elements (item, target, boundary).
  * Should be called if dimensions of an element changed.
  *
  * @return {this} allow chaining
  */
	PositionCalculator.prototype.resize = function () {
		var o = this.options;

		var item_pos = __nomrmalizePosition(this.$itm);
		var targ_pos = this.$trg.length ? __nomrmalizePosition(this.$trg) : null;
		this.bndPos = this.$bnd.length ? __normalizeBounding(this.$bnd) : null;

		if (!this.itmPos || !__isEqualNormPos(item_pos, this.itmPos)) {
			this.itmPos = item_pos;
			var item_extraOffset = __normalizeExtraOffset(o.itemOffset, item_pos);
			// negate values, because it shall be defined relative to the item reference point
			// and not relative to the corner.
			item_extraOffset.x = item_extraOffset.x * -1;
			item_extraOffset.y = item_extraOffset.y * -1;

			this.itmOffset = __calculateRefpointOffsets(item_pos, item_extraOffset, this.itmAt);
		}
		if (!this.trgPos || !__isEqualNormPos(targ_pos, this.trgPos)) {
			this.trgPos = targ_pos;
			if (targ_pos) {
				this.trgOffset = __calculateRefpointOffsets(targ_pos, __normalizeExtraOffset(o.targetOffset, targ_pos), this.trgAt);
			}
		}

		return this; // to allow chaining
	};

	/**
  * Calculate the resulting position and boundary distance for the given placement.
  * That will not handle flip and fit.
  *
  * If target was not specified, only boundary distance will be calculated.
  * If not "item_at" or "tar_at", only boundary distance will be calculated.
  * If boundary was set to null, only new position will be calculated.
  *
  * Current position of elements (item, target, boundary) will be read from DOM.
  *
  * @param  {{x:string, y:string}|null} item_at Placement for reference point on item
  * @param  {{x:string, y:string}|null} tar_at  Placement for reference point on target
  * @return {Object}         CalculationResult, see method calculate()
  */
	PositionCalculator.prototype.calcVariant = function (item_at, tar_at) {
		var result = {
			moveBy: null,
			distance: null,
			itemAt: null,
			targetAt: null
		};

		if (this.trgPos && item_at && tar_at) {
			var tar_refpoint = {
				top: this.trgPos.top + this.trgOffset[tar_at.y],
				left: this.trgPos.left + this.trgOffset[tar_at.x]
			};
			var item_newPos = {
				top: tar_refpoint.top - this.itmOffset[item_at.y],
				left: tar_refpoint.left - this.itmOffset[item_at.x],
				height: this.itmPos.height,
				width: this.itmPos.width
			};

			result.moveBy = {
				y: item_newPos.top - this.itmPos.top,
				x: item_newPos.left - this.itmPos.left
			};
			result.distance = this.bndPos ? __calulateDistance(this.bndPos, item_newPos) : null;
			result.itemAt = item_at.y + " " + item_at.x;
			result.targetAt = tar_at.y + " " + tar_at.x;
		} else {
			result.moveBy = { y: 0, x: 0 };
			result.distance = this.bndPos ? __calulateDistance(this.bndPos, this.itmPos) : null;
		}

		return result;
	};

	/**
  * Calculate the distance between reference point of item and reference point of target and
  * handle overflow in the specified matter.
  *
  * @return {Object}   with:
  *     moveBy: {{y:number, x:number}} - distance between target and item as pixel values
  *     distance: {Distance|null}    - distance between item and boundary
  *                                      null, if boundary was not given
  *                                  Distance is Object with: {
  *                                      top:number, left:number,
  *                                      bottom:number, right:number,
  *                                      overflow:{Array.<string>|null}
  *                                  }
  *                                  - top, left, buttom, right - distance/overflow for this edge
  *                                  - overflow - Array with edges has overflow
  *                                             - null for no collision detected
  *     itemAt: {string|null}        - used placement of reference point at item
  *                                    syntax: <vertical> + " " + <horizontal>
  *                                    vertical: "top" | "middle" | "bottom"
  *                                    horizontal: "left" | "center" | "right"
  *                                  - null, if target was not given
  *     targetAt: {string|null}      - used placement of reference point at target
  *                                    syntax: <vertical> + " " + <horizontal>
  *                                    vertical: "top" | "middle" | "bottom"
  *                                    horizontal: "left" | "center" | "right"
  *                                  - null, if target was not given
  */
	PositionCalculator.prototype.calculate = function () {
		if (this.itmPos === null) {
			return null; // init failed
		}

		var o = this.options;

		// refresh
		// only update the position off elements and scroll offsets, but not the width or height
		__refreshPosition(this.$itm, this.itmPos);
		this.trgPos && __refreshPosition(this.$trg, this.trgPos);
		this.bndPos && __refreshBounding(this.$bnd, this.bndPos);

		var result = this.calcVariant(this.itmAt, this.trgAt);
		if (!result.distance || !result.distance.overflow) {
			//finish, because no collision
			return result;
		}

		// ////////////////////
		// collision handling: flip
		if (o.flip && o.flip !== "none" && this.trgPos) {
			var newResult;
			var flipedPlacement = __flipPlacement(o.flip, this.itmAt, this.trgAt, result.distance);

			if (flipedPlacement) {
				newResult = this.calcVariant(flipedPlacement.item_at, flipedPlacement.tar_at);

				if (!newResult.distance.overflow) {
					//finish, because found placement without collision
					return newResult;
				}

				// look for combination with fewest overflow
				var useNew = {
					y: false,
					x: false
				};
				useNew.y = __overflowLT(newResult.distance, result.distance, true);
				useNew.x = __overflowLT(newResult.distance, result.distance, false);

				if (useNew.y !== useNew.x) {
					//need new distance calculation
					result = this.calcVariant({
						y: useNew.y ? flipedPlacement.item_at.y : this.itmAt.y,
						x: useNew.x ? flipedPlacement.item_at.x : this.itmAt.x
					}, {
						y: useNew.y ? flipedPlacement.tar_at.y : this.trgAt.y,
						x: useNew.x ? flipedPlacement.tar_at.x : this.trgAt.x
					});
					if (!result.distance.overflow) {
						//finish, because found position without collision
						return result;
					}
				} else if (useNew.y && useNew.x) {
					result = newResult;
				} // else use "old" result
			}
		}

		// ////////////////////
		// collision handling: stick
		if (o.stick && o.stick !== "none") {
			return __adaptSticking(result, o.stick);
		} else {
			return result;
		}
	};

	// default options
	PositionCalculator.defaults = {
		item: null,
		target: null,
		boundary: window,
		itemAt: "top left",
		targetAt: "top left",
		itemOffset: {
			y: 0,
			x: 0,
			mirror: true
		},
		targetOffset: {
			y: 0,
			x: 0,
			mirror: true
		},
		flip: "none",
		stick: "none"
	};

	// export
	return PositionCalculator;
});
/*!
  hey, [be]Lazy.js - v1.7.0 - 2016.10.10
  A fast, small and dependency free lazy load script (https://github.com/dinbror/blazy)
  (c) Bjoern Klinggaard - @bklinggaard - http://dinbror.dk/blazy
*/
;
(function (root, blazy) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register bLazy as an anonymous module
		define(blazy);
	} else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = blazy();
	} else {
		// Browser globals. Register bLazy on window
		root.Blazy = blazy();
	}
})(this, function () {
	'use strict';

	//private vars

	var _source,
	    _viewport,
	    _isRetina,
	    _attrSrc = 'src',
	    _attrSrcset = 'srcset';

	// constructor
	return function Blazy(options) {
		//IE7- fallback for missing querySelectorAll support
		if (!document.querySelectorAll) {
			var s = document.createStyleSheet();
			document.querySelectorAll = function (r, c, i, j, a) {
				a = document.all, c = [], r = r.replace(/\[for\b/gi, '[htmlFor').split(',');
				for (i = r.length; i--;) {
					s.addRule(r[i], 'k:v');
					for (j = a.length; j--;) {
						a[j].currentStyle.k && c.push(a[j]);
					}s.removeRule(0);
				}
				return c;
			};
		}

		//options and helper vars
		var scope = this;
		var util = scope._util = {};
		util.elements = [];
		util.destroyed = true;
		scope.options = options || {};
		scope.options.error = scope.options.error || false;
		scope.options.offset = scope.options.offset || 100;
		scope.options.root = scope.options.root || document;
		scope.options.success = scope.options.success || false;
		scope.options.selector = scope.options.selector || '.b-lazy';
		scope.options.separator = scope.options.separator || '|';
		scope.options.container = scope.options.container ? document.querySelectorAll(scope.options.container) : false;
		scope.options.errorClass = scope.options.errorClass || 'b-error';
		scope.options.breakpoints = scope.options.breakpoints || false; // obsolete
		scope.options.loadInvisible = scope.options.loadInvisible || false;
		scope.options.successClass = scope.options.successClass || 'b-loaded';
		scope.options.validateDelay = scope.options.validateDelay || 25;
		scope.options.saveViewportOffsetDelay = scope.options.saveViewportOffsetDelay || 50;
		scope.options.srcset = scope.options.srcset || 'data-srcset';
		scope.options.src = _source = scope.options.src || 'data-src';
		_isRetina = window.devicePixelRatio > 1;
		_viewport = {};
		_viewport.top = 0 - scope.options.offset;
		_viewport.left = 0 - scope.options.offset;

		/* public functions
   ************************************/
		scope.revalidate = function () {
			initialize(this);
		};
		scope.load = function (elements, force) {
			var opt = this.options;
			if (elements.length === undefined) {
				loadElement(elements, force, opt);
			} else {
				each(elements, function (element) {
					loadElement(element, force, opt);
				});
			}
		};
		scope.destroy = function () {
			var self = this;
			var util = self._util;
			if (self.options.container) {
				each(self.options.container, function (object) {
					unbindEvent(object, 'scroll', util.validateT);
				});
			}
			unbindEvent(window, 'scroll', util.validateT);
			unbindEvent(window, 'resize', util.validateT);
			unbindEvent(window, 'resize', util.saveViewportOffsetT);
			util.count = 0;
			util.elements.length = 0;
			util.destroyed = true;
		};

		//throttle, ensures that we don't call the functions too often
		util.validateT = throttle(function () {
			validate(scope);
		}, scope.options.validateDelay, scope);
		util.saveViewportOffsetT = throttle(function () {
			saveViewportOffset(scope.options.offset);
		}, scope.options.saveViewportOffsetDelay, scope);
		saveViewportOffset(scope.options.offset);

		//handle multi-served image src (obsolete)
		each(scope.options.breakpoints, function (object) {
			if (object.width >= window.screen.width) {
				_source = object.src;
				return false;
			}
		});

		// start lazy load
		setTimeout(function () {
			initialize(scope);
		}); // "dom ready" fix
	};

	/* Private helper functions
  ************************************/
	function initialize(self) {
		var util = self._util;
		// First we create an array of elements to lazy load
		util.elements = toArray(self.options);
		util.count = util.elements.length;
		// Then we bind resize and scroll events if not already binded
		if (util.destroyed) {
			util.destroyed = false;
			if (self.options.container) {
				each(self.options.container, function (object) {
					bindEvent(object, 'scroll', util.validateT);
				});
			}
			bindEvent(window, 'resize', util.saveViewportOffsetT);
			bindEvent(window, 'resize', util.validateT);
			bindEvent(window, 'scroll', util.validateT);
		}
		// And finally, we start to lazy load.
		validate(self);
	}

	function validate(self) {
		var util = self._util;
		for (var i = 0; i < util.count; i++) {
			var element = util.elements[i];
			if (elementInView(element) || hasClass(element, self.options.successClass)) {
				self.load(element);
				util.elements.splice(i, 1);
				util.count--;
				i--;
			}
		}
		if (util.count === 0) {
			self.destroy();
		}
	}

	function elementInView(ele) {
		var rect = ele.getBoundingClientRect();
		return (
			// Intersection
			rect.right >= _viewport.left && rect.bottom >= _viewport.top && rect.left <= _viewport.right && rect.top <= _viewport.bottom
		);
	}

	function loadElement(ele, force, options) {
		// if element is visible, not loaded or forced
		if (!hasClass(ele, options.successClass) && (force || options.loadInvisible || ele.offsetWidth > 0 && ele.offsetHeight > 0)) {
			var dataSrc = ele.getAttribute(_source) || ele.getAttribute(options.src); // fallback to default 'data-src'
			if (dataSrc) {
				var dataSrcSplitted = dataSrc.split(options.separator);
				var src = dataSrcSplitted[_isRetina && dataSrcSplitted.length > 1 ? 1 : 0];
				var srcset = ele.getAttribute(options.srcset);
				var isImage = equal(ele, 'img');
				var parent = ele.parentNode;
				var isPicture = parent && equal(parent, 'picture');
				// Image or background image
				if (isImage || ele.src === undefined) {
					var img = new Image();
					// using EventListener instead of onerror and onload
					// due to bug introduced in chrome v50 
					// (https://productforums.google.com/forum/#!topic/chrome/p51Lk7vnP2o)
					var onErrorHandler = function onErrorHandler() {
						if (options.error) options.error(ele, "invalid");
						addClass(ele, options.errorClass);
						unbindEvent(img, 'error', onErrorHandler);
						unbindEvent(img, 'load', onLoadHandler);
					};
					var onLoadHandler = function onLoadHandler() {
						// Is element an image
						if (isImage) {
							if (!isPicture) {
								handleSources(ele, src, srcset);
							}
							// or background-image
						} else {
							ele.style.backgroundImage = 'url("' + src + '")';
						}
						itemLoaded(ele, options);
						unbindEvent(img, 'load', onLoadHandler);
						unbindEvent(img, 'error', onErrorHandler);
					};

					// Picture element
					if (isPicture) {
						img = ele; // Image tag inside picture element wont get preloaded
						each(parent.getElementsByTagName('source'), function (source) {
							handleSource(source, _attrSrcset, options.srcset);
						});
					}
					bindEvent(img, 'error', onErrorHandler);
					bindEvent(img, 'load', onLoadHandler);
					handleSources(img, src, srcset); // Preload
				} else {
					// An item with src like iframe, unity, simpelvideo etc
					setSrc(ele, src);
					itemLoaded(ele, options);
				}
			} else {
				// video with child source
				if (equal(ele, 'video')) {
					each(ele.getElementsByTagName('source'), function (source) {
						handleSource(source, _attrSrc, options.src);
					});
					ele.load();
					itemLoaded(ele, options);
				} else {
					if (options.error) options.error(ele, "missing");
					addClass(ele, options.errorClass);
				}
			}
		}
	}

	function itemLoaded(ele, options) {
		addClass(ele, options.successClass);
		if (options.success) options.success(ele);
		// cleanup markup, remove data source attributes
		ele.removeAttribute(options.src);
		ele.removeAttribute(options.srcset);
		each(options.breakpoints, function (object) {
			ele.removeAttribute(object.src);
		});
	}

	function setSrc(ele, src) {
		ele[_attrSrc] = src;
	}

	function handleSource(ele, attr, dataAttr) {
		var dataSrc = ele.getAttribute(dataAttr);
		if (dataSrc) {
			ele[attr] = dataSrc;
			ele.removeAttribute(dataAttr);
		}
	}

	function handleSources(ele, src, srcset) {
		if (srcset) {
			ele[_attrSrcset] = srcset; //srcset
		}
		setSrc(ele, src); //src 
	}

	function equal(ele, str) {
		return ele.nodeName.toLowerCase() === str;
	}

	function hasClass(ele, className) {
		return (' ' + ele.className + ' ').indexOf(' ' + className + ' ') !== -1;
	}

	function addClass(ele, className) {
		if (!hasClass(ele, className)) {
			ele.className += ' ' + className;
		}
	}

	function toArray(options) {
		var array = [];
		var nodelist = options.root.querySelectorAll(options.selector);
		for (var i = nodelist.length; i--; array.unshift(nodelist[i])) {}
		return array;
	}

	function saveViewportOffset(offset) {
		_viewport.bottom = (window.innerHeight || document.documentElement.clientHeight) + offset;
		_viewport.right = (window.innerWidth || document.documentElement.clientWidth) + offset;
	}

	function bindEvent(ele, type, fn) {
		if (ele.attachEvent) {
			ele.attachEvent && ele.attachEvent('on' + type, fn);
		} else {
			ele.addEventListener(type, fn, { capture: false, passive: true });
		}
	}

	function unbindEvent(ele, type, fn) {
		if (ele.detachEvent) {
			ele.detachEvent && ele.detachEvent('on' + type, fn);
		} else {
			ele.removeEventListener(type, fn, { capture: false, passive: true });
		}
	}

	function each(object, fn) {
		if (object && fn) {
			var l = object.length;
			for (var i = 0; i < l && fn(object[i], i) !== false; i++) {}
		}
	}

	function throttle(fn, minDelay, scope) {
		var lastCall = 0;
		return function () {
			var now = +new Date();
			if (now - lastCall < minDelay) {
				return;
			}
			lastCall = now;
			fn.apply(scope, arguments);
		};
	}
});
/*!
 * ZeroClipboard
 * The ZeroClipboard library provides an easy way to copy text to the clipboard using an invisible Adobe Flash movie and a JavaScript interface
 * Copyright (c) 2009-2016 Jon Rohan, James M. Greene
 * Licensed MIT
 * http://zeroclipboard.org/
 * v2.3.0
 */
(function (window, undefined) {
	"use strict";
	/**
 * Store references to critically important global functions that may be
 * overridden on certain web pages.
 */

	var _window = window,
	    _document = _window.document,
	    _navigator = _window.navigator,
	    _setTimeout = _window.setTimeout,
	    _clearTimeout = _window.clearTimeout,
	    _setInterval = _window.setInterval,
	    _clearInterval = _window.clearInterval,
	    _getComputedStyle = _window.getComputedStyle,
	    _encodeURIComponent = _window.encodeURIComponent,
	    _ActiveXObject = _window.ActiveXObject,
	    _Error = _window.Error,
	    _parseInt = _window.Number.parseInt || _window.parseInt,
	    _parseFloat = _window.Number.parseFloat || _window.parseFloat,
	    _isNaN = _window.Number.isNaN || _window.isNaN,
	    _now = _window.Date.now,
	    _keys = _window.Object.keys,
	    _hasOwn = _window.Object.prototype.hasOwnProperty,
	    _slice = _window.Array.prototype.slice,
	    _unwrap = function () {
		var unwrapper = function unwrapper(el) {
			return el;
		};
		if (typeof _window.wrap === "function" && typeof _window.unwrap === "function") {
			try {
				var div = _document.createElement("div");
				var unwrappedDiv = _window.unwrap(div);
				if (div.nodeType === 1 && unwrappedDiv && unwrappedDiv.nodeType === 1) {
					unwrapper = _window.unwrap;
				}
			} catch (e) {}
		}
		return unwrapper;
	}();
	/**
 * Convert an `arguments` object into an Array.
 *
 * @returns The arguments as an Array
 * @private
 */
	var _args = function _args(argumentsObj) {
		return _slice.call(argumentsObj, 0);
	};
	/**
 * Shallow-copy the owned, enumerable properties of one object over to another, similar to jQuery's `$.extend`.
 *
 * @returns The target object, augmented
 * @private
 */
	var _extend = function _extend() {
		var i,
		    len,
		    arg,
		    prop,
		    src,
		    copy,
		    args = _args(arguments),
		    target = args[0] || {};
		for (i = 1, len = args.length; i < len; i++) {
			if ((arg = args[i]) != null) {
				for (prop in arg) {
					if (_hasOwn.call(arg, prop)) {
						src = target[prop];
						copy = arg[prop];
						if (target !== copy && copy !== undefined) {
							target[prop] = copy;
						}
					}
				}
			}
		}
		return target;
	};
	/**
 * Return a deep copy of the source object or array.
 *
 * @returns Object or Array
 * @private
 */
	var _deepCopy = function _deepCopy(source) {
		var copy, i, len, prop;
		if ((typeof source === "undefined" ? "undefined" : _typeof(source)) !== "object" || source == null || typeof source.nodeType === "number") {
			copy = source;
		} else if (typeof source.length === "number") {
			copy = [];
			for (i = 0, len = source.length; i < len; i++) {
				if (_hasOwn.call(source, i)) {
					copy[i] = _deepCopy(source[i]);
				}
			}
		} else {
			copy = {};
			for (prop in source) {
				if (_hasOwn.call(source, prop)) {
					copy[prop] = _deepCopy(source[prop]);
				}
			}
		}
		return copy;
	};
	/**
 * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to keep.
 * The inverse of `_omit`, mostly. The big difference is that these properties do NOT need to be enumerable to
 * be kept.
 *
 * @returns A new filtered object.
 * @private
 */
	var _pick = function _pick(obj, keys) {
		var newObj = {};
		for (var i = 0, len = keys.length; i < len; i++) {
			if (keys[i] in obj) {
				newObj[keys[i]] = obj[keys[i]];
			}
		}
		return newObj;
	};
	/**
 * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to omit.
 * The inverse of `_pick`.
 *
 * @returns A new filtered object.
 * @private
 */
	var _omit = function _omit(obj, keys) {
		var newObj = {};
		for (var prop in obj) {
			if (keys.indexOf(prop) === -1) {
				newObj[prop] = obj[prop];
			}
		}
		return newObj;
	};
	/**
 * Remove all owned, enumerable properties from an object.
 *
 * @returns The original object without its owned, enumerable properties.
 * @private
 */
	var _deleteOwnProperties = function _deleteOwnProperties(obj) {
		if (obj) {
			for (var prop in obj) {
				if (_hasOwn.call(obj, prop)) {
					delete obj[prop];
				}
			}
		}
		return obj;
	};
	/**
 * Determine if an element is contained within another element.
 *
 * @returns Boolean
 * @private
 */
	var _containedBy = function _containedBy(el, ancestorEl) {
		if (el && el.nodeType === 1 && el.ownerDocument && ancestorEl && (ancestorEl.nodeType === 1 && ancestorEl.ownerDocument && ancestorEl.ownerDocument === el.ownerDocument || ancestorEl.nodeType === 9 && !ancestorEl.ownerDocument && ancestorEl === el.ownerDocument)) {
			do {
				if (el === ancestorEl) {
					return true;
				}
				el = el.parentNode;
			} while (el);
		}
		return false;
	};
	/**
 * Get the URL path's parent directory.
 *
 * @returns String or `undefined`
 * @private
 */
	var _getDirPathOfUrl = function _getDirPathOfUrl(url) {
		var dir;
		if (typeof url === "string" && url) {
			dir = url.split("#")[0].split("?")[0];
			dir = url.slice(0, url.lastIndexOf("/") + 1);
		}
		return dir;
	};
	/**
 * Get the current script's URL by throwing an `Error` and analyzing it.
 *
 * @returns String or `undefined`
 * @private
 */
	var _getCurrentScriptUrlFromErrorStack = function _getCurrentScriptUrlFromErrorStack(stack) {
		var url, matches;
		if (typeof stack === "string" && stack) {
			matches = stack.match(/^(?:|[^:@]*@|.+\)@(?=http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
			if (matches && matches[1]) {
				url = matches[1];
			} else {
				matches = stack.match(/\)@((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
				if (matches && matches[1]) {
					url = matches[1];
				}
			}
		}
		return url;
	};
	/**
 * Get the current script's URL by throwing an `Error` and analyzing it.
 *
 * @returns String or `undefined`
 * @private
 */
	var _getCurrentScriptUrlFromError = function _getCurrentScriptUrlFromError() {
		var url, err;
		try {
			throw new _Error();
		} catch (e) {
			err = e;
		}
		if (err) {
			url = err.sourceURL || err.fileName || _getCurrentScriptUrlFromErrorStack(err.stack);
		}
		return url;
	};
	/**
 * Get the current script's URL.
 *
 * @returns String or `undefined`
 * @private
 */
	var _getCurrentScriptUrl = function _getCurrentScriptUrl() {
		var jsPath, scripts, i;
		if (_document.currentScript && (jsPath = _document.currentScript.src)) {
			return jsPath;
		}
		scripts = _document.getElementsByTagName("script");
		if (scripts.length === 1) {
			return scripts[0].src || undefined;
		}
		if ("readyState" in (scripts[0] || document.createElement("script"))) {
			for (i = scripts.length; i--;) {
				if (scripts[i].readyState === "interactive" && (jsPath = scripts[i].src)) {
					return jsPath;
				}
			}
		}
		if (_document.readyState === "loading" && (jsPath = scripts[scripts.length - 1].src)) {
			return jsPath;
		}
		if (jsPath = _getCurrentScriptUrlFromError()) {
			return jsPath;
		}
		return undefined;
	};
	/**
 * Get the unanimous parent directory of ALL script tags.
 * If any script tags are either (a) inline or (b) from differing parent
 * directories, this method must return `undefined`.
 *
 * @returns String or `undefined`
 * @private
 */
	var _getUnanimousScriptParentDir = function _getUnanimousScriptParentDir() {
		var i,
		    jsDir,
		    jsPath,
		    scripts = _document.getElementsByTagName("script");
		for (i = scripts.length; i--;) {
			if (!(jsPath = scripts[i].src)) {
				jsDir = null;
				break;
			}
			jsPath = _getDirPathOfUrl(jsPath);
			if (jsDir == null) {
				jsDir = jsPath;
			} else if (jsDir !== jsPath) {
				jsDir = null;
				break;
			}
		}
		return jsDir || undefined;
	};
	/**
 * Get the presumed location of the "ZeroClipboard.swf" file, based on the location
 * of the executing JavaScript file (e.g. "ZeroClipboard.js", etc.).
 *
 * @returns String
 * @private
 */
	var _getDefaultSwfPath = function _getDefaultSwfPath() {
		var jsDir = _getDirPathOfUrl(_getCurrentScriptUrl()) || _getUnanimousScriptParentDir() || "";
		return jsDir + "ZeroClipboard.swf";
	};
	/**
 * Is the client's operating system some version of Windows?
 *
 * @returns Boolean
 * @private
 */
	var _isWindows = function _isWindows() {
		var isWindowsRegex = /win(dows|[\s]?(nt|me|ce|xp|vista|[\d]+))/i;
		return !!_navigator && (isWindowsRegex.test(_navigator.appVersion || "") || isWindowsRegex.test(_navigator.platform || "") || (_navigator.userAgent || "").indexOf("Windows") !== -1);
	};
	/**
 * Keep track of if the page is framed (in an `iframe`). This can never change.
 * @private
 */
	var _pageIsFramed = function () {
		return _window.opener == null && (!!_window.top && _window != _window.top || !!_window.parent && _window != _window.parent);
	}();
	/**
 * Keep track of if the page is XHTML (vs. HTML), which requires that everything
 * be rendering in XML mode.
 * @private
 */
	var _pageIsXhtml = _document.documentElement.nodeName === "html";
	/**
 * Keep track of the state of the Flash object.
 * @private
 */
	var _flashState = {
		bridge: null,
		version: "0.0.0",
		pluginType: "unknown",
		sandboxed: null,
		disabled: null,
		outdated: null,
		insecure: null,
		unavailable: null,
		degraded: null,
		deactivated: null,
		overdue: null,
		ready: null
	};
	/**
 * The minimum Flash Player version required to use ZeroClipboard completely.
 * @readonly
 * @private
 */
	var _minimumFlashVersion = "11.0.0";
	/**
 * The ZeroClipboard library version number, as reported by Flash, at the time the SWF was compiled.
 */
	var _zcSwfVersion;
	/**
 * Keep track of all event listener registrations.
 * @private
 */
	var _handlers = {};
	/**
 * Keep track of the currently activated element.
 * @private
 */
	var _currentElement;
	/**
 * Keep track of the element that was activated when a `copy` process started.
 * @private
 */
	var _copyTarget;
	/**
 * Keep track of data for the pending clipboard transaction.
 * @private
 */
	var _clipData = {};
	/**
 * Keep track of data formats for the pending clipboard transaction.
 * @private
 */
	var _clipDataFormatMap = null;
	/**
 * Keep track of the Flash availability check timeout.
 * @private
 */
	var _flashCheckTimeout = 0;
	/**
 * Keep track of SWF network errors interval polling.
 * @private
 */
	var _swfFallbackCheckInterval = 0;
	/**
 * The `message` store for events
 * @private
 */
	var _eventMessages = {
		ready: "Flash communication is established",
		error: {
			"flash-sandboxed": "Attempting to run Flash in a sandboxed iframe, which is impossible",
			"flash-disabled": "Flash is disabled or not installed. May also be attempting to run Flash in a sandboxed iframe, which is impossible.",
			"flash-outdated": "Flash is too outdated to support ZeroClipboard",
			"flash-insecure": "Flash will be unable to communicate due to a protocol mismatch between your `swfPath` configuration and the page",
			"flash-unavailable": "Flash is unable to communicate bidirectionally with JavaScript",
			"flash-degraded": "Flash is unable to preserve data fidelity when communicating with JavaScript",
			"flash-deactivated": "Flash is too outdated for your browser and/or is configured as click-to-activate.\nThis may also mean that the ZeroClipboard SWF object could not be loaded, so please check your `swfPath` configuration and/or network connectivity.\nMay also be attempting to run Flash in a sandboxed iframe, which is impossible.",
			"flash-overdue": "Flash communication was established but NOT within the acceptable time limit",
			"version-mismatch": "ZeroClipboard JS version number does not match ZeroClipboard SWF version number",
			"clipboard-error": "At least one error was thrown while ZeroClipboard was attempting to inject your data into the clipboard",
			"config-mismatch": "ZeroClipboard configuration does not match Flash's reality",
			"swf-not-found": "The ZeroClipboard SWF object could not be loaded, so please check your `swfPath` configuration and/or network connectivity",
			"browser-unsupported": "The browser does not support the required HTML DOM and JavaScript features"
		}
	};
	/**
 * The `name`s of `error` events that can only occur is Flash has at least
 * been able to load the SWF successfully.
 * @private
 */
	var _errorsThatOnlyOccurAfterFlashLoads = ["flash-unavailable", "flash-degraded", "flash-overdue", "version-mismatch", "config-mismatch", "clipboard-error"];
	/**
 * The `name`s of `error` events that should likely result in the `_flashState`
 * variable's property values being updated.
 * @private
 */
	var _flashStateErrorNames = ["flash-sandboxed", "flash-disabled", "flash-outdated", "flash-insecure", "flash-unavailable", "flash-degraded", "flash-deactivated", "flash-overdue"];
	/**
 * A RegExp to match the `name` property of `error` events related to Flash.
 * @private
 */
	var _flashStateErrorNameMatchingRegex = new RegExp("^flash-(" + _flashStateErrorNames.map(function (errorName) {
		return errorName.replace(/^flash-/, "");
	}).join("|") + ")$");
	/**
 * A RegExp to match the `name` property of `error` events related to Flash,
 * which is enabled.
 * @private
 */
	var _flashStateEnabledErrorNameMatchingRegex = new RegExp("^flash-(" + _flashStateErrorNames.filter(function (errorName) {
		return errorName !== "flash-disabled";
	}).map(function (errorName) {
		return errorName.replace(/^flash-/, "");
	}).join("|") + ")$");
	/**
 * ZeroClipboard configuration defaults for the Core module.
 * @private
 */
	var _globalConfig = {
		swfPath: _getDefaultSwfPath(),
		trustedDomains: _window.location.host ? [_window.location.host] : [],
		cacheBust: true,
		forceEnhancedClipboard: false,
		flashLoadTimeout: 3e4,
		autoActivate: true,
		bubbleEvents: true,
		fixLineEndings: true,
		containerId: "global-zeroclipboard-html-bridge",
		containerClass: "global-zeroclipboard-container",
		swfObjectId: "global-zeroclipboard-flash-bridge",
		hoverClass: "zeroclipboard-is-hover",
		activeClass: "zeroclipboard-is-active",
		forceHandCursor: false,
		title: null,
		zIndex: 999999999
	};
	/**
 * The underlying implementation of `ZeroClipboard.config`.
 * @private
 */
	var _config = function _config(options) {
		if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object" && options && !("length" in options)) {
			_keys(options).forEach(function (prop) {
				if (/^(?:forceHandCursor|title|zIndex|bubbleEvents|fixLineEndings)$/.test(prop)) {
					_globalConfig[prop] = options[prop];
				} else if (_flashState.bridge == null) {
					if (prop === "containerId" || prop === "swfObjectId") {
						if (_isValidHtml4Id(options[prop])) {
							_globalConfig[prop] = options[prop];
						} else {
							throw new Error("The specified `" + prop + "` value is not valid as an HTML4 Element ID");
						}
					} else {
						_globalConfig[prop] = options[prop];
					}
				}
			});
		}
		if (typeof options === "string" && options) {
			if (_hasOwn.call(_globalConfig, options)) {
				return _globalConfig[options];
			}
			return;
		}
		return _deepCopy(_globalConfig);
	};
	/**
 * The underlying implementation of `ZeroClipboard.state`.
 * @private
 */
	var _state = function _state() {
		_detectSandbox();
		return {
			browser: _extend(_pick(_navigator, ["userAgent", "platform", "appName", "appVersion"]), {
				isSupported: _isBrowserSupported()
			}),
			flash: _omit(_flashState, ["bridge"]),
			zeroclipboard: {
				version: ZeroClipboard.version,
				config: ZeroClipboard.config()
			}
		};
	};
	/**
 * Does this browser support all of the necessary DOM and JS features necessary?
 * @private
 */
	var _isBrowserSupported = function _isBrowserSupported() {
		return !!(_document.addEventListener && _window.Object.keys && _window.Array.prototype.map);
	};
	/**
 * The underlying implementation of `ZeroClipboard.isFlashUnusable`.
 * @private
 */
	var _isFlashUnusable = function _isFlashUnusable() {
		return !!(_flashState.sandboxed || _flashState.disabled || _flashState.outdated || _flashState.unavailable || _flashState.degraded || _flashState.deactivated);
	};
	/**
 * The underlying implementation of `ZeroClipboard.on`.
 * @private
 */
	var _on = function _on(eventType, listener) {
		var i,
		    len,
		    events,
		    added = {};
		if (typeof eventType === "string" && eventType) {
			events = eventType.toLowerCase().split(/\s+/);
		} else if ((typeof eventType === "undefined" ? "undefined" : _typeof(eventType)) === "object" && eventType && !("length" in eventType) && typeof listener === "undefined") {
			_keys(eventType).forEach(function (key) {
				var listener = eventType[key];
				if (typeof listener === "function") {
					ZeroClipboard.on(key, listener);
				}
			});
		}
		if (events && events.length && listener) {
			for (i = 0, len = events.length; i < len; i++) {
				eventType = events[i].replace(/^on/, "");
				added[eventType] = true;
				if (!_handlers[eventType]) {
					_handlers[eventType] = [];
				}
				_handlers[eventType].push(listener);
			}
			if (added.ready && _flashState.ready) {
				ZeroClipboard.emit({
					type: "ready"
				});
			}
			if (added.error) {
				if (!_isBrowserSupported()) {
					ZeroClipboard.emit({
						type: "error",
						name: "browser-unsupported"
					});
				}
				for (i = 0, len = _flashStateErrorNames.length; i < len; i++) {
					if (_flashState[_flashStateErrorNames[i].replace(/^flash-/, "")] === true) {
						ZeroClipboard.emit({
							type: "error",
							name: _flashStateErrorNames[i]
						});
						break;
					}
				}
				if (_zcSwfVersion !== undefined && ZeroClipboard.version !== _zcSwfVersion) {
					ZeroClipboard.emit({
						type: "error",
						name: "version-mismatch",
						jsVersion: ZeroClipboard.version,
						swfVersion: _zcSwfVersion
					});
				}
			}
		}
		return ZeroClipboard;
	};
	/**
 * The underlying implementation of `ZeroClipboard.off`.
 * @private
 */
	var _off = function _off(eventType, listener) {
		var i, len, foundIndex, events, perEventHandlers;
		if (arguments.length === 0) {
			events = _keys(_handlers);
		} else if (typeof eventType === "string" && eventType) {
			events = eventType.toLowerCase().split(/\s+/);
		} else if ((typeof eventType === "undefined" ? "undefined" : _typeof(eventType)) === "object" && eventType && !("length" in eventType) && typeof listener === "undefined") {
			_keys(eventType).forEach(function (key) {
				var listener = eventType[key];
				if (typeof listener === "function") {
					ZeroClipboard.off(key, listener);
				}
			});
		}
		if (events && events.length) {
			for (i = 0, len = events.length; i < len; i++) {
				eventType = events[i].replace(/^on/, "");
				perEventHandlers = _handlers[eventType];
				if (perEventHandlers && perEventHandlers.length) {
					if (listener) {
						foundIndex = perEventHandlers.indexOf(listener);
						while (foundIndex !== -1) {
							perEventHandlers.splice(foundIndex, 1);
							foundIndex = perEventHandlers.indexOf(listener, foundIndex);
						}
					} else {
						perEventHandlers.length = 0;
					}
				}
			}
		}
		return ZeroClipboard;
	};
	/**
 * The underlying implementation of `ZeroClipboard.handlers`.
 * @private
 */
	var _listeners = function _listeners(eventType) {
		var copy;
		if (typeof eventType === "string" && eventType) {
			copy = _deepCopy(_handlers[eventType]) || null;
		} else {
			copy = _deepCopy(_handlers);
		}
		return copy;
	};
	/**
 * The underlying implementation of `ZeroClipboard.emit`.
 * @private
 */
	var _emit = function _emit(event) {
		var eventCopy, returnVal, tmp;
		event = _createEvent(event);
		if (!event) {
			return;
		}
		if (_preprocessEvent(event)) {
			return;
		}
		if (event.type === "ready" && _flashState.overdue === true) {
			return ZeroClipboard.emit({
				type: "error",
				name: "flash-overdue"
			});
		}
		eventCopy = _extend({}, event);
		_dispatchCallbacks.call(this, eventCopy);
		if (event.type === "copy") {
			tmp = _mapClipDataToFlash(_clipData);
			returnVal = tmp.data;
			_clipDataFormatMap = tmp.formatMap;
		}
		return returnVal;
	};
	/**
 * Get the protocol of the configured SWF path.
 * @private
 */
	var _getSwfPathProtocol = function _getSwfPathProtocol() {
		var swfPath = _globalConfig.swfPath || "",
		    swfPathFirstTwoChars = swfPath.slice(0, 2),
		    swfProtocol = swfPath.slice(0, swfPath.indexOf("://") + 1);
		return swfPathFirstTwoChars === "\\\\" ? "file:" : swfPathFirstTwoChars === "//" || swfProtocol === "" ? _window.location.protocol : swfProtocol;
	};
	/**
 * The underlying implementation of `ZeroClipboard.create`.
 * @private
 */
	var _create = function _create() {
		var maxWait,
		    swfProtocol,
		    previousState = _flashState.sandboxed;
		if (!_isBrowserSupported()) {
			_flashState.ready = false;
			ZeroClipboard.emit({
				type: "error",
				name: "browser-unsupported"
			});
			return;
		}
		_detectSandbox();
		if (typeof _flashState.ready !== "boolean") {
			_flashState.ready = false;
		}
		if (_flashState.sandboxed !== previousState && _flashState.sandboxed === true) {
			_flashState.ready = false;
			ZeroClipboard.emit({
				type: "error",
				name: "flash-sandboxed"
			});
		} else if (!ZeroClipboard.isFlashUnusable() && _flashState.bridge === null) {
			swfProtocol = _getSwfPathProtocol();
			if (swfProtocol && swfProtocol !== _window.location.protocol) {
				ZeroClipboard.emit({
					type: "error",
					name: "flash-insecure"
				});
			} else {
				maxWait = _globalConfig.flashLoadTimeout;
				if (typeof maxWait === "number" && maxWait >= 0) {
					_flashCheckTimeout = _setTimeout(function () {
						if (typeof _flashState.deactivated !== "boolean") {
							_flashState.deactivated = true;
						}
						if (_flashState.deactivated === true) {
							ZeroClipboard.emit({
								type: "error",
								name: "flash-deactivated"
							});
						}
					}, maxWait);
				}
				_flashState.overdue = false;
				_embedSwf();
			}
		}
	};
	/**
 * The underlying implementation of `ZeroClipboard.destroy`.
 * @private
 */
	var _destroy = function _destroy() {
		ZeroClipboard.clearData();
		ZeroClipboard.blur();
		ZeroClipboard.emit("destroy");
		_unembedSwf();
		ZeroClipboard.off();
	};
	/**
 * The underlying implementation of `ZeroClipboard.setData`.
 * @private
 */
	var _setData = function _setData(format, data) {
		var dataObj;
		if ((typeof format === "undefined" ? "undefined" : _typeof(format)) === "object" && format && typeof data === "undefined") {
			dataObj = format;
			ZeroClipboard.clearData();
		} else if (typeof format === "string" && format) {
			dataObj = {};
			dataObj[format] = data;
		} else {
			return;
		}
		for (var dataFormat in dataObj) {
			if (typeof dataFormat === "string" && dataFormat && _hasOwn.call(dataObj, dataFormat) && typeof dataObj[dataFormat] === "string" && dataObj[dataFormat]) {
				_clipData[dataFormat] = _fixLineEndings(dataObj[dataFormat]);
			}
		}
	};
	/**
 * The underlying implementation of `ZeroClipboard.clearData`.
 * @private
 */
	var _clearData = function _clearData(format) {
		if (typeof format === "undefined") {
			_deleteOwnProperties(_clipData);
			_clipDataFormatMap = null;
		} else if (typeof format === "string" && _hasOwn.call(_clipData, format)) {
			delete _clipData[format];
		}
	};
	/**
 * The underlying implementation of `ZeroClipboard.getData`.
 * @private
 */
	var _getData = function _getData(format) {
		if (typeof format === "undefined") {
			return _deepCopy(_clipData);
		} else if (typeof format === "string" && _hasOwn.call(_clipData, format)) {
			return _clipData[format];
		}
	};
	/**
 * The underlying implementation of `ZeroClipboard.focus`/`ZeroClipboard.activate`.
 * @private
 */
	var _focus = function _focus(element) {
		if (!(element && element.nodeType === 1)) {
			return;
		}
		if (_currentElement) {
			_removeClass(_currentElement, _globalConfig.activeClass);
			if (_currentElement !== element) {
				_removeClass(_currentElement, _globalConfig.hoverClass);
			}
		}
		_currentElement = element;
		_addClass(element, _globalConfig.hoverClass);
		var newTitle = element.getAttribute("title") || _globalConfig.title;
		if (typeof newTitle === "string" && newTitle) {
			var htmlBridge = _getHtmlBridge(_flashState.bridge);
			if (htmlBridge) {
				htmlBridge.setAttribute("title", newTitle);
			}
		}
		var useHandCursor = _globalConfig.forceHandCursor === true || _getStyle(element, "cursor") === "pointer";
		_setHandCursor(useHandCursor);
		_reposition();
	};
	/**
 * The underlying implementation of `ZeroClipboard.blur`/`ZeroClipboard.deactivate`.
 * @private
 */
	var _blur = function _blur() {
		var htmlBridge = _getHtmlBridge(_flashState.bridge);
		if (htmlBridge) {
			htmlBridge.removeAttribute("title");
			htmlBridge.style.left = "0px";
			htmlBridge.style.top = "-9999px";
			htmlBridge.style.width = "1px";
			htmlBridge.style.height = "1px";
		}
		if (_currentElement) {
			_removeClass(_currentElement, _globalConfig.hoverClass);
			_removeClass(_currentElement, _globalConfig.activeClass);
			_currentElement = null;
		}
	};
	/**
 * The underlying implementation of `ZeroClipboard.activeElement`.
 * @private
 */
	var _activeElement = function _activeElement() {
		return _currentElement || null;
	};
	/**
 * Check if a value is a valid HTML4 `ID` or `Name` token.
 * @private
 */
	var _isValidHtml4Id = function _isValidHtml4Id(id) {
		return typeof id === "string" && id && /^[A-Za-z][A-Za-z0-9_:\-\.]*$/.test(id);
	};
	/**
 * Create or update an `event` object, based on the `eventType`.
 * @private
 */
	var _createEvent = function _createEvent(event) {
		var eventType;
		if (typeof event === "string" && event) {
			eventType = event;
			event = {};
		} else if ((typeof event === "undefined" ? "undefined" : _typeof(event)) === "object" && event && typeof event.type === "string" && event.type) {
			eventType = event.type;
		}
		if (!eventType) {
			return;
		}
		eventType = eventType.toLowerCase();
		if (!event.target && (/^(copy|aftercopy|_click)$/.test(eventType) || eventType === "error" && event.name === "clipboard-error")) {
			event.target = _copyTarget;
		}
		_extend(event, {
			type: eventType,
			target: event.target || _currentElement || null,
			relatedTarget: event.relatedTarget || null,
			currentTarget: _flashState && _flashState.bridge || null,
			timeStamp: event.timeStamp || _now() || null
		});
		var msg = _eventMessages[event.type];
		if (event.type === "error" && event.name && msg) {
			msg = msg[event.name];
		}
		if (msg) {
			event.message = msg;
		}
		if (event.type === "ready") {
			_extend(event, {
				target: null,
				version: _flashState.version
			});
		}
		if (event.type === "error") {
			if (_flashStateErrorNameMatchingRegex.test(event.name)) {
				_extend(event, {
					target: null,
					minimumVersion: _minimumFlashVersion
				});
			}
			if (_flashStateEnabledErrorNameMatchingRegex.test(event.name)) {
				_extend(event, {
					version: _flashState.version
				});
			}
			if (event.name === "flash-insecure") {
				_extend(event, {
					pageProtocol: _window.location.protocol,
					swfProtocol: _getSwfPathProtocol()
				});
			}
		}
		if (event.type === "copy") {
			event.clipboardData = {
				setData: ZeroClipboard.setData,
				clearData: ZeroClipboard.clearData
			};
		}
		if (event.type === "aftercopy") {
			event = _mapClipResultsFromFlash(event, _clipDataFormatMap);
		}
		if (event.target && !event.relatedTarget) {
			event.relatedTarget = _getRelatedTarget(event.target);
		}
		return _addMouseData(event);
	};
	/**
 * Get a relatedTarget from the target's `data-clipboard-target` attribute
 * @private
 */
	var _getRelatedTarget = function _getRelatedTarget(targetEl) {
		var relatedTargetId = targetEl && targetEl.getAttribute && targetEl.getAttribute("data-clipboard-target");
		return relatedTargetId ? _document.getElementById(relatedTargetId) : null;
	};
	/**
 * Add element and position data to `MouseEvent` instances
 * @private
 */
	var _addMouseData = function _addMouseData(event) {
		if (event && /^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) {
			var srcElement = event.target;
			var fromElement = event.type === "_mouseover" && event.relatedTarget ? event.relatedTarget : undefined;
			var toElement = event.type === "_mouseout" && event.relatedTarget ? event.relatedTarget : undefined;
			var pos = _getElementPosition(srcElement);
			var screenLeft = _window.screenLeft || _window.screenX || 0;
			var screenTop = _window.screenTop || _window.screenY || 0;
			var scrollLeft = _document.body.scrollLeft + _document.documentElement.scrollLeft;
			var scrollTop = _document.body.scrollTop + _document.documentElement.scrollTop;
			var pageX = pos.left + (typeof event._stageX === "number" ? event._stageX : 0);
			var pageY = pos.top + (typeof event._stageY === "number" ? event._stageY : 0);
			var clientX = pageX - scrollLeft;
			var clientY = pageY - scrollTop;
			var screenX = screenLeft + clientX;
			var screenY = screenTop + clientY;
			var moveX = typeof event.movementX === "number" ? event.movementX : 0;
			var moveY = typeof event.movementY === "number" ? event.movementY : 0;
			delete event._stageX;
			delete event._stageY;
			_extend(event, {
				srcElement: srcElement,
				fromElement: fromElement,
				toElement: toElement,
				screenX: screenX,
				screenY: screenY,
				pageX: pageX,
				pageY: pageY,
				clientX: clientX,
				clientY: clientY,
				x: clientX,
				y: clientY,
				movementX: moveX,
				movementY: moveY,
				offsetX: 0,
				offsetY: 0,
				layerX: 0,
				layerY: 0
			});
		}
		return event;
	};
	/**
 * Determine if an event's registered handlers should be execute synchronously or asynchronously.
 *
 * @returns {boolean}
 * @private
 */
	var _shouldPerformAsync = function _shouldPerformAsync(event) {
		var eventType = event && typeof event.type === "string" && event.type || "";
		return !/^(?:(?:before)?copy|destroy)$/.test(eventType);
	};
	/**
 * Control if a callback should be executed asynchronously or not.
 *
 * @returns `undefined`
 * @private
 */
	var _dispatchCallback = function _dispatchCallback(func, context, args, async) {
		if (async) {
			_setTimeout(function () {
				func.apply(context, args);
			}, 0);
		} else {
			func.apply(context, args);
		}
	};
	/**
 * Handle the actual dispatching of events to client instances.
 *
 * @returns `undefined`
 * @private
 */
	var _dispatchCallbacks = function _dispatchCallbacks(event) {
		if (!((typeof event === "undefined" ? "undefined" : _typeof(event)) === "object" && event && event.type)) {
			return;
		}
		var async = _shouldPerformAsync(event);
		var wildcardTypeHandlers = _handlers["*"] || [];
		var specificTypeHandlers = _handlers[event.type] || [];
		var handlers = wildcardTypeHandlers.concat(specificTypeHandlers);
		if (handlers && handlers.length) {
			var i,
			    len,
			    func,
			    context,
			    eventCopy,
			    originalContext = this;
			for (i = 0, len = handlers.length; i < len; i++) {
				func = handlers[i];
				context = originalContext;
				if (typeof func === "string" && typeof _window[func] === "function") {
					func = _window[func];
				}
				if ((typeof func === "undefined" ? "undefined" : _typeof(func)) === "object" && func && typeof func.handleEvent === "function") {
					context = func;
					func = func.handleEvent;
				}
				if (typeof func === "function") {
					eventCopy = _extend({}, event);
					_dispatchCallback(func, context, [eventCopy], async);
				}
			}
		}
		return this;
	};
	/**
 * Check an `error` event's `name` property to see if Flash has
 * already loaded, which rules out possible `iframe` sandboxing.
 * @private
 */
	var _getSandboxStatusFromErrorEvent = function _getSandboxStatusFromErrorEvent(event) {
		var isSandboxed = null;
		if (_pageIsFramed === false || event && event.type === "error" && event.name && _errorsThatOnlyOccurAfterFlashLoads.indexOf(event.name) !== -1) {
			isSandboxed = false;
		}
		return isSandboxed;
	};
	/**
 * Preprocess any special behaviors, reactions, or state changes after receiving this event.
 * Executes only once per event emitted, NOT once per client.
 * @private
 */
	var _preprocessEvent = function _preprocessEvent(event) {
		var element = event.target || _currentElement || null;
		var sourceIsSwf = event._source === "swf";
		delete event._source;
		switch (event.type) {
			case "error":
				var isSandboxed = event.name === "flash-sandboxed" || _getSandboxStatusFromErrorEvent(event);
				if (typeof isSandboxed === "boolean") {
					_flashState.sandboxed = isSandboxed;
				}
				if (event.name === "browser-unsupported") {
					_extend(_flashState, {
						disabled: false,
						outdated: false,
						unavailable: false,
						degraded: false,
						deactivated: false,
						overdue: false,
						ready: false
					});
				} else if (_flashStateErrorNames.indexOf(event.name) !== -1) {
					_extend(_flashState, {
						disabled: event.name === "flash-disabled",
						outdated: event.name === "flash-outdated",
						insecure: event.name === "flash-insecure",
						unavailable: event.name === "flash-unavailable",
						degraded: event.name === "flash-degraded",
						deactivated: event.name === "flash-deactivated",
						overdue: event.name === "flash-overdue",
						ready: false
					});
				} else if (event.name === "version-mismatch") {
					_zcSwfVersion = event.swfVersion;
					_extend(_flashState, {
						disabled: false,
						outdated: false,
						insecure: false,
						unavailable: false,
						degraded: false,
						deactivated: false,
						overdue: false,
						ready: false
					});
				}
				_clearTimeoutsAndPolling();
				break;

			case "ready":
				_zcSwfVersion = event.swfVersion;
				var wasDeactivated = _flashState.deactivated === true;
				_extend(_flashState, {
					sandboxed: false,
					disabled: false,
					outdated: false,
					insecure: false,
					unavailable: false,
					degraded: false,
					deactivated: false,
					overdue: wasDeactivated,
					ready: !wasDeactivated
				});
				_clearTimeoutsAndPolling();
				break;

			case "beforecopy":
				_copyTarget = element;
				break;

			case "copy":
				var textContent,
				    htmlContent,
				    targetEl = event.relatedTarget;
				if (!(_clipData["text/html"] || _clipData["text/plain"]) && targetEl && (htmlContent = targetEl.value || targetEl.outerHTML || targetEl.innerHTML) && (textContent = targetEl.value || targetEl.textContent || targetEl.innerText)) {
					event.clipboardData.clearData();
					event.clipboardData.setData("text/plain", textContent);
					if (htmlContent !== textContent) {
						event.clipboardData.setData("text/html", htmlContent);
					}
				} else if (!_clipData["text/plain"] && event.target && (textContent = event.target.getAttribute("data-clipboard-text"))) {
					event.clipboardData.clearData();
					event.clipboardData.setData("text/plain", textContent);
				}
				break;

			case "aftercopy":
				_queueEmitClipboardErrors(event);
				ZeroClipboard.clearData();
				if (element && element !== _safeActiveElement() && element.focus) {
					element.focus();
				}
				break;

			case "_mouseover":
				ZeroClipboard.focus(element);
				if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
					if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) {
						_fireMouseEvent(_extend({}, event, {
							type: "mouseenter",
							bubbles: false,
							cancelable: false
						}));
					}
					_fireMouseEvent(_extend({}, event, {
						type: "mouseover"
					}));
				}
				break;

			case "_mouseout":
				ZeroClipboard.blur();
				if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
					if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) {
						_fireMouseEvent(_extend({}, event, {
							type: "mouseleave",
							bubbles: false,
							cancelable: false
						}));
					}
					_fireMouseEvent(_extend({}, event, {
						type: "mouseout"
					}));
				}
				break;

			case "_mousedown":
				_addClass(element, _globalConfig.activeClass);
				if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
					_fireMouseEvent(_extend({}, event, {
						type: event.type.slice(1)
					}));
				}
				break;

			case "_mouseup":
				_removeClass(element, _globalConfig.activeClass);
				if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
					_fireMouseEvent(_extend({}, event, {
						type: event.type.slice(1)
					}));
				}
				break;

			case "_click":
				_copyTarget = null;
				if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
					_fireMouseEvent(_extend({}, event, {
						type: event.type.slice(1)
					}));
				}
				break;

			case "_mousemove":
				if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
					_fireMouseEvent(_extend({}, event, {
						type: event.type.slice(1)
					}));
				}
				break;
		}
		if (/^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) {
			return true;
		}
	};
	/**
 * Check an "aftercopy" event for clipboard errors and emit a corresponding "error" event.
 * @private
 */
	var _queueEmitClipboardErrors = function _queueEmitClipboardErrors(aftercopyEvent) {
		if (aftercopyEvent.errors && aftercopyEvent.errors.length > 0) {
			var errorEvent = _deepCopy(aftercopyEvent);
			_extend(errorEvent, {
				type: "error",
				name: "clipboard-error"
			});
			delete errorEvent.success;
			_setTimeout(function () {
				ZeroClipboard.emit(errorEvent);
			}, 0);
		}
	};
	/**
 * Dispatch a synthetic MouseEvent.
 *
 * @returns `undefined`
 * @private
 */
	var _fireMouseEvent = function _fireMouseEvent(event) {
		if (!(event && typeof event.type === "string" && event)) {
			return;
		}
		var e,
		    target = event.target || null,
		    doc = target && target.ownerDocument || _document,
		    defaults = {
			view: doc.defaultView || _window,
			canBubble: true,
			cancelable: true,
			detail: event.type === "click" ? 1 : 0,
			button: typeof event.which === "number" ? event.which - 1 : typeof event.button === "number" ? event.button : doc.createEvent ? 0 : 1
		},
		    args = _extend(defaults, event);
		if (!target) {
			return;
		}
		if (doc.createEvent && target.dispatchEvent) {
			args = [args.type, args.canBubble, args.cancelable, args.view, args.detail, args.screenX, args.screenY, args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey, args.button, args.relatedTarget];
			e = doc.createEvent("MouseEvents");
			if (e.initMouseEvent) {
				e.initMouseEvent.apply(e, args);
				e._source = "js";
				target.dispatchEvent(e);
			}
		}
	};
	/**
 * Continuously poll the DOM until either:
 *  (a) the fallback content becomes visible, or
 *  (b) we receive an event from SWF (handled elsewhere)
 *
 * IMPORTANT:
 * This is NOT a necessary check but it can result in significantly faster
 * detection of bad `swfPath` configuration and/or network/server issues [in
 * supported browsers] than waiting for the entire `flashLoadTimeout` duration
 * to elapse before detecting that the SWF cannot be loaded. The detection
 * duration can be anywhere from 10-30 times faster [in supported browsers] by
 * using this approach.
 *
 * @returns `undefined`
 * @private
 */
	var _watchForSwfFallbackContent = function _watchForSwfFallbackContent() {
		var maxWait = _globalConfig.flashLoadTimeout;
		if (typeof maxWait === "number" && maxWait >= 0) {
			var pollWait = Math.min(1e3, maxWait / 10);
			var fallbackContentId = _globalConfig.swfObjectId + "_fallbackContent";
			_swfFallbackCheckInterval = _setInterval(function () {
				var el = _document.getElementById(fallbackContentId);
				if (_isElementVisible(el)) {
					_clearTimeoutsAndPolling();
					_flashState.deactivated = null;
					ZeroClipboard.emit({
						type: "error",
						name: "swf-not-found"
					});
				}
			}, pollWait);
		}
	};
	/**
 * Create the HTML bridge element to embed the Flash object into.
 * @private
 */
	var _createHtmlBridge = function _createHtmlBridge() {
		var container = _document.createElement("div");
		container.id = _globalConfig.containerId;
		container.className = _globalConfig.containerClass;
		container.style.position = "absolute";
		container.style.left = "0px";
		container.style.top = "-9999px";
		container.style.width = "1px";
		container.style.height = "1px";
		container.style.zIndex = "" + _getSafeZIndex(_globalConfig.zIndex);
		return container;
	};
	/**
 * Get the HTML element container that wraps the Flash bridge object/element.
 * @private
 */
	var _getHtmlBridge = function _getHtmlBridge(flashBridge) {
		var htmlBridge = flashBridge && flashBridge.parentNode;
		while (htmlBridge && htmlBridge.nodeName === "OBJECT" && htmlBridge.parentNode) {
			htmlBridge = htmlBridge.parentNode;
		}
		return htmlBridge || null;
	};
	/**
 *
 * @private
 */
	var _escapeXmlValue = function _escapeXmlValue(val) {
		if (typeof val !== "string" || !val) {
			return val;
		}
		return val.replace(/["&'<>]/g, function (chr) {
			switch (chr) {
				case '"':
					return "&quot;";

				case "&":
					return "&amp;";

				case "'":
					return "&apos;";

				case "<":
					return "&lt;";

				case ">":
					return "&gt;";

				default:
					return chr;
			}
		});
	};
	/**
 * Create the SWF object.
 *
 * @returns The SWF object reference.
 * @private
 */
	var _embedSwf = function _embedSwf() {
		var len,
		    flashBridge = _flashState.bridge,
		    container = _getHtmlBridge(flashBridge);
		if (!flashBridge) {
			var allowScriptAccess = _determineScriptAccess(_window.location.host, _globalConfig);
			var allowNetworking = allowScriptAccess === "never" ? "none" : "all";
			var flashvars = _vars(_extend({
				jsVersion: ZeroClipboard.version
			}, _globalConfig));
			var swfUrl = _globalConfig.swfPath + _cacheBust(_globalConfig.swfPath, _globalConfig);
			if (_pageIsXhtml) {
				swfUrl = _escapeXmlValue(swfUrl);
			}
			container = _createHtmlBridge();
			var divToBeReplaced = _document.createElement("div");
			container.appendChild(divToBeReplaced);
			_document.body.appendChild(container);
			var tmpDiv = _document.createElement("div");
			var usingActiveX = _flashState.pluginType === "activex";
			tmpDiv.innerHTML = '<object id="' + _globalConfig.swfObjectId + '" name="' + _globalConfig.swfObjectId + '" ' + 'width="100%" height="100%" ' + (usingActiveX ? 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"' : 'type="application/x-shockwave-flash" data="' + swfUrl + '"') + ">" + (usingActiveX ? '<param name="movie" value="' + swfUrl + '"/>' : "") + '<param name="allowScriptAccess" value="' + allowScriptAccess + '"/>' + '<param name="allowNetworking" value="' + allowNetworking + '"/>' + '<param name="menu" value="false"/>' + '<param name="wmode" value="transparent"/>' + '<param name="flashvars" value="' + flashvars + '"/>' + '<div id="' + _globalConfig.swfObjectId + '_fallbackContent">&nbsp;</div>' + "</object>";
			flashBridge = tmpDiv.firstChild;
			tmpDiv = null;
			_unwrap(flashBridge).ZeroClipboard = ZeroClipboard;
			container.replaceChild(flashBridge, divToBeReplaced);
			_watchForSwfFallbackContent();
		}
		if (!flashBridge) {
			flashBridge = _document[_globalConfig.swfObjectId];
			if (flashBridge && (len = flashBridge.length)) {
				flashBridge = flashBridge[len - 1];
			}
			if (!flashBridge && container) {
				flashBridge = container.firstChild;
			}
		}
		_flashState.bridge = flashBridge || null;
		return flashBridge;
	};
	/**
 * Destroy the SWF object.
 * @private
 */
	var _unembedSwf = function _unembedSwf() {
		var flashBridge = _flashState.bridge;
		if (flashBridge) {
			var htmlBridge = _getHtmlBridge(flashBridge);
			if (htmlBridge) {
				if (_flashState.pluginType === "activex" && "readyState" in flashBridge) {
					flashBridge.style.display = "none";
					(function removeSwfFromIE() {
						if (flashBridge.readyState === 4) {
							for (var prop in flashBridge) {
								if (typeof flashBridge[prop] === "function") {
									flashBridge[prop] = null;
								}
							}
							if (flashBridge.parentNode) {
								flashBridge.parentNode.removeChild(flashBridge);
							}
							if (htmlBridge.parentNode) {
								htmlBridge.parentNode.removeChild(htmlBridge);
							}
						} else {
							_setTimeout(removeSwfFromIE, 10);
						}
					})();
				} else {
					if (flashBridge.parentNode) {
						flashBridge.parentNode.removeChild(flashBridge);
					}
					if (htmlBridge.parentNode) {
						htmlBridge.parentNode.removeChild(htmlBridge);
					}
				}
			}
			_clearTimeoutsAndPolling();
			_flashState.ready = null;
			_flashState.bridge = null;
			_flashState.deactivated = null;
			_flashState.insecure = null;
			_zcSwfVersion = undefined;
		}
	};
	/**
 * Map the data format names of the "clipData" to Flash-friendly names.
 *
 * @returns A new transformed object.
 * @private
 */
	var _mapClipDataToFlash = function _mapClipDataToFlash(clipData) {
		var newClipData = {},
		    formatMap = {};
		if (!((typeof clipData === "undefined" ? "undefined" : _typeof(clipData)) === "object" && clipData)) {
			return;
		}
		for (var dataFormat in clipData) {
			if (dataFormat && _hasOwn.call(clipData, dataFormat) && typeof clipData[dataFormat] === "string" && clipData[dataFormat]) {
				switch (dataFormat.toLowerCase()) {
					case "text/plain":
					case "text":
					case "air:text":
					case "flash:text":
						newClipData.text = clipData[dataFormat];
						formatMap.text = dataFormat;
						break;

					case "text/html":
					case "html":
					case "air:html":
					case "flash:html":
						newClipData.html = clipData[dataFormat];
						formatMap.html = dataFormat;
						break;

					case "application/rtf":
					case "text/rtf":
					case "rtf":
					case "richtext":
					case "air:rtf":
					case "flash:rtf":
						newClipData.rtf = clipData[dataFormat];
						formatMap.rtf = dataFormat;
						break;

					default:
						break;
				}
			}
		}
		return {
			data: newClipData,
			formatMap: formatMap
		};
	};
	/**
 * Map the data format names from Flash-friendly names back to their original "clipData" names (via a format mapping).
 *
 * @returns A new transformed object.
 * @private
 */
	var _mapClipResultsFromFlash = function _mapClipResultsFromFlash(clipResults, formatMap) {
		if (!((typeof clipResults === "undefined" ? "undefined" : _typeof(clipResults)) === "object" && clipResults && (typeof formatMap === "undefined" ? "undefined" : _typeof(formatMap)) === "object" && formatMap)) {
			return clipResults;
		}
		var newResults = {};
		for (var prop in clipResults) {
			if (_hasOwn.call(clipResults, prop)) {
				if (prop === "errors") {
					newResults[prop] = clipResults[prop] ? clipResults[prop].slice() : [];
					for (var i = 0, len = newResults[prop].length; i < len; i++) {
						newResults[prop][i].format = formatMap[newResults[prop][i].format];
					}
				} else if (prop !== "success" && prop !== "data") {
					newResults[prop] = clipResults[prop];
				} else {
					newResults[prop] = {};
					var tmpHash = clipResults[prop];
					for (var dataFormat in tmpHash) {
						if (dataFormat && _hasOwn.call(tmpHash, dataFormat) && _hasOwn.call(formatMap, dataFormat)) {
							newResults[prop][formatMap[dataFormat]] = tmpHash[dataFormat];
						}
					}
				}
			}
		}
		return newResults;
	};
	/**
 * Will look at a path, and will create a "?noCache={time}" or "&noCache={time}"
 * query param string to return. Does NOT append that string to the original path.
 * This is useful because ExternalInterface often breaks when a Flash SWF is cached.
 *
 * @returns The `noCache` query param with necessary "?"/"&" prefix.
 * @private
 */
	var _cacheBust = function _cacheBust(path, options) {
		var cacheBust = options == null || options && options.cacheBust === true;
		if (cacheBust) {
			return (path.indexOf("?") === -1 ? "?" : "&") + "noCache=" + _now();
		} else {
			return "";
		}
	};
	/**
 * Creates a query string for the FlashVars param.
 * Does NOT include the cache-busting query param.
 *
 * @returns FlashVars query string
 * @private
 */
	var _vars = function _vars(options) {
		var i,
		    len,
		    domain,
		    domains,
		    str = "",
		    trustedOriginsExpanded = [];
		if (options.trustedDomains) {
			if (typeof options.trustedDomains === "string") {
				domains = [options.trustedDomains];
			} else if (_typeof(options.trustedDomains) === "object" && "length" in options.trustedDomains) {
				domains = options.trustedDomains;
			}
		}
		if (domains && domains.length) {
			for (i = 0, len = domains.length; i < len; i++) {
				if (_hasOwn.call(domains, i) && domains[i] && typeof domains[i] === "string") {
					domain = _extractDomain(domains[i]);
					if (!domain) {
						continue;
					}
					if (domain === "*") {
						trustedOriginsExpanded.length = 0;
						trustedOriginsExpanded.push(domain);
						break;
					}
					trustedOriginsExpanded.push.apply(trustedOriginsExpanded, [domain, "//" + domain, _window.location.protocol + "//" + domain]);
				}
			}
		}
		if (trustedOriginsExpanded.length) {
			str += "trustedOrigins=" + _encodeURIComponent(trustedOriginsExpanded.join(","));
		}
		if (options.forceEnhancedClipboard === true) {
			str += (str ? "&" : "") + "forceEnhancedClipboard=true";
		}
		if (typeof options.swfObjectId === "string" && options.swfObjectId) {
			str += (str ? "&" : "") + "swfObjectId=" + _encodeURIComponent(options.swfObjectId);
		}
		if (typeof options.jsVersion === "string" && options.jsVersion) {
			str += (str ? "&" : "") + "jsVersion=" + _encodeURIComponent(options.jsVersion);
		}
		return str;
	};
	/**
 * Extract the domain (e.g. "github.com") from an origin (e.g. "https://github.com") or
 * URL (e.g. "https://github.com/zeroclipboard/zeroclipboard/").
 *
 * @returns the domain
 * @private
 */
	var _extractDomain = function _extractDomain(originOrUrl) {
		if (originOrUrl == null || originOrUrl === "") {
			return null;
		}
		originOrUrl = originOrUrl.replace(/^\s+|\s+$/g, "");
		if (originOrUrl === "") {
			return null;
		}
		var protocolIndex = originOrUrl.indexOf("//");
		originOrUrl = protocolIndex === -1 ? originOrUrl : originOrUrl.slice(protocolIndex + 2);
		var pathIndex = originOrUrl.indexOf("/");
		originOrUrl = pathIndex === -1 ? originOrUrl : protocolIndex === -1 || pathIndex === 0 ? null : originOrUrl.slice(0, pathIndex);
		if (originOrUrl && originOrUrl.slice(-4).toLowerCase() === ".swf") {
			return null;
		}
		return originOrUrl || null;
	};
	/**
 * Set `allowScriptAccess` based on `trustedDomains` and `window.location.host` vs. `swfPath`.
 *
 * @returns The appropriate script access level.
 * @private
 */
	var _determineScriptAccess = function () {
		var _extractAllDomains = function _extractAllDomains(origins) {
			var i,
			    len,
			    tmp,
			    resultsArray = [];
			if (typeof origins === "string") {
				origins = [origins];
			}
			if (!((typeof origins === "undefined" ? "undefined" : _typeof(origins)) === "object" && origins && typeof origins.length === "number")) {
				return resultsArray;
			}
			for (i = 0, len = origins.length; i < len; i++) {
				if (_hasOwn.call(origins, i) && (tmp = _extractDomain(origins[i]))) {
					if (tmp === "*") {
						resultsArray.length = 0;
						resultsArray.push("*");
						break;
					}
					if (resultsArray.indexOf(tmp) === -1) {
						resultsArray.push(tmp);
					}
				}
			}
			return resultsArray;
		};
		return function (currentDomain, configOptions) {
			var swfDomain = _extractDomain(configOptions.swfPath);
			if (swfDomain === null) {
				swfDomain = currentDomain;
			}
			var trustedDomains = _extractAllDomains(configOptions.trustedDomains);
			var len = trustedDomains.length;
			if (len > 0) {
				if (len === 1 && trustedDomains[0] === "*") {
					return "always";
				}
				if (trustedDomains.indexOf(currentDomain) !== -1) {
					if (len === 1 && currentDomain === swfDomain) {
						return "sameDomain";
					}
					return "always";
				}
			}
			return "never";
		};
	}();
	/**
 * Get the currently active/focused DOM element.
 *
 * @returns the currently active/focused element, or `null`
 * @private
 */
	var _safeActiveElement = function _safeActiveElement() {
		try {
			return _document.activeElement;
		} catch (err) {
			return null;
		}
	};
	/**
 * Add a class to an element, if it doesn't already have it.
 *
 * @returns The element, with its new class added.
 * @private
 */
	var _addClass = function _addClass(element, value) {
		var c,
		    cl,
		    className,
		    classNames = [];
		if (typeof value === "string" && value) {
			classNames = value.split(/\s+/);
		}
		if (element && element.nodeType === 1 && classNames.length > 0) {
			className = (" " + (element.className || "") + " ").replace(/[\t\r\n\f]/g, " ");
			for (c = 0, cl = classNames.length; c < cl; c++) {
				if (className.indexOf(" " + classNames[c] + " ") === -1) {
					className += classNames[c] + " ";
				}
			}
			className = className.replace(/^\s+|\s+$/g, "");
			if (className !== element.className) {
				element.className = className;
			}
		}
		return element;
	};
	/**
 * Remove a class from an element, if it has it.
 *
 * @returns The element, with its class removed.
 * @private
 */
	var _removeClass = function _removeClass(element, value) {
		var c,
		    cl,
		    className,
		    classNames = [];
		if (typeof value === "string" && value) {
			classNames = value.split(/\s+/);
		}
		if (element && element.nodeType === 1 && classNames.length > 0) {
			if (element.className) {
				className = (" " + element.className + " ").replace(/[\t\r\n\f]/g, " ");
				for (c = 0, cl = classNames.length; c < cl; c++) {
					className = className.replace(" " + classNames[c] + " ", " ");
				}
				className = className.replace(/^\s+|\s+$/g, "");
				if (className !== element.className) {
					element.className = className;
				}
			}
		}
		return element;
	};
	/**
 * Attempt to interpret the element's CSS styling. If `prop` is `"cursor"`,
 * then we assume that it should be a hand ("pointer") cursor if the element
 * is an anchor element ("a" tag).
 *
 * @returns The computed style property.
 * @private
 */
	var _getStyle = function _getStyle(el, prop) {
		var value = _getComputedStyle(el, null).getPropertyValue(prop);
		if (prop === "cursor") {
			if (!value || value === "auto") {
				if (el.nodeName === "A") {
					return "pointer";
				}
			}
		}
		return value;
	};
	/**
 * Get the absolutely positioned coordinates of a DOM element.
 *
 * @returns Object containing the element's position, width, and height.
 * @private
 */
	var _getElementPosition = function _getElementPosition(el) {
		var pos = {
			left: 0,
			top: 0,
			width: 0,
			height: 0
		};
		if (el.getBoundingClientRect) {
			var elRect = el.getBoundingClientRect();
			var pageXOffset = _window.pageXOffset;
			var pageYOffset = _window.pageYOffset;
			var leftBorderWidth = _document.documentElement.clientLeft || 0;
			var topBorderWidth = _document.documentElement.clientTop || 0;
			var leftBodyOffset = 0;
			var topBodyOffset = 0;
			if (_getStyle(_document.body, "position") === "relative") {
				var bodyRect = _document.body.getBoundingClientRect();
				var htmlRect = _document.documentElement.getBoundingClientRect();
				leftBodyOffset = bodyRect.left - htmlRect.left || 0;
				topBodyOffset = bodyRect.top - htmlRect.top || 0;
			}
			pos.left = elRect.left + pageXOffset - leftBorderWidth - leftBodyOffset;
			pos.top = elRect.top + pageYOffset - topBorderWidth - topBodyOffset;
			pos.width = "width" in elRect ? elRect.width : elRect.right - elRect.left;
			pos.height = "height" in elRect ? elRect.height : elRect.bottom - elRect.top;
		}
		return pos;
	};
	/**
 * Determine is an element is visible somewhere within the document (page).
 *
 * @returns Boolean
 * @private
 */
	var _isElementVisible = function _isElementVisible(el) {
		if (!el) {
			return false;
		}
		var styles = _getComputedStyle(el, null);
		if (!styles) {
			return false;
		}
		var hasCssHeight = _parseFloat(styles.height) > 0;
		var hasCssWidth = _parseFloat(styles.width) > 0;
		var hasCssTop = _parseFloat(styles.top) >= 0;
		var hasCssLeft = _parseFloat(styles.left) >= 0;
		var cssKnows = hasCssHeight && hasCssWidth && hasCssTop && hasCssLeft;
		var rect = cssKnows ? null : _getElementPosition(el);
		var isVisible = styles.display !== "none" && styles.visibility !== "collapse" && (cssKnows || !!rect && (hasCssHeight || rect.height > 0) && (hasCssWidth || rect.width > 0) && (hasCssTop || rect.top >= 0) && (hasCssLeft || rect.left >= 0));
		return isVisible;
	};
	/**
 * Clear all existing timeouts and interval polling delegates.
 *
 * @returns `undefined`
 * @private
 */
	var _clearTimeoutsAndPolling = function _clearTimeoutsAndPolling() {
		_clearTimeout(_flashCheckTimeout);
		_flashCheckTimeout = 0;
		_clearInterval(_swfFallbackCheckInterval);
		_swfFallbackCheckInterval = 0;
	};
	/**
 * Reposition the Flash object to cover the currently activated element.
 *
 * @returns `undefined`
 * @private
 */
	var _reposition = function _reposition() {
		var htmlBridge;
		if (_currentElement && (htmlBridge = _getHtmlBridge(_flashState.bridge))) {
			var pos = _getElementPosition(_currentElement);
			_extend(htmlBridge.style, {
				width: pos.width + "px",
				height: pos.height + "px",
				top: pos.top + "px",
				left: pos.left + "px",
				zIndex: "" + _getSafeZIndex(_globalConfig.zIndex)
			});
		}
	};
	/**
 * Sends a signal to the Flash object to display the hand cursor if `true`.
 *
 * @returns `undefined`
 * @private
 */
	var _setHandCursor = function _setHandCursor(enabled) {
		if (_flashState.ready === true) {
			if (_flashState.bridge && typeof _flashState.bridge.setHandCursor === "function") {
				_flashState.bridge.setHandCursor(enabled);
			} else {
				_flashState.ready = false;
			}
		}
	};
	/**
 * Get a safe value for `zIndex`
 *
 * @returns an integer, or "auto"
 * @private
 */
	var _getSafeZIndex = function _getSafeZIndex(val) {
		if (/^(?:auto|inherit)$/.test(val)) {
			return val;
		}
		var zIndex;
		if (typeof val === "number" && !_isNaN(val)) {
			zIndex = val;
		} else if (typeof val === "string") {
			zIndex = _getSafeZIndex(_parseInt(val, 10));
		}
		return typeof zIndex === "number" ? zIndex : "auto";
	};
	/**
 * Ensure OS-compliant line endings, i.e. "\r\n" on Windows, "\n" elsewhere
 *
 * @returns string
 * @private
 */
	var _fixLineEndings = function _fixLineEndings(content) {
		var replaceRegex = /(\r\n|\r|\n)/g;
		if (typeof content === "string" && _globalConfig.fixLineEndings === true) {
			if (_isWindows()) {
				if (/((^|[^\r])\n|\r([^\n]|$))/.test(content)) {
					content = content.replace(replaceRegex, "\r\n");
				}
			} else if (/\r/.test(content)) {
				content = content.replace(replaceRegex, "\n");
			}
		}
		return content;
	};
	/**
 * Attempt to detect if ZeroClipboard is executing inside of a sandboxed iframe.
 * If it is, Flash Player cannot be used, so ZeroClipboard is dead in the water.
 *
 * @see {@link http://lists.w3.org/Archives/Public/public-whatwg-archive/2014Dec/0002.html}
 * @see {@link https://github.com/zeroclipboard/zeroclipboard/issues/511}
 * @see {@link http://zeroclipboard.org/test-iframes.html}
 *
 * @returns `true` (is sandboxed), `false` (is not sandboxed), or `null` (uncertain)
 * @private
 */
	var _detectSandbox = function _detectSandbox(doNotReassessFlashSupport) {
		var effectiveScriptOrigin,
		    frame,
		    frameError,
		    previousState = _flashState.sandboxed,
		    isSandboxed = null;
		doNotReassessFlashSupport = doNotReassessFlashSupport === true;
		if (_pageIsFramed === false) {
			isSandboxed = false;
		} else {
			try {
				frame = window.frameElement || null;
			} catch (e) {
				frameError = {
					name: e.name,
					message: e.message
				};
			}
			if (frame && frame.nodeType === 1 && frame.nodeName === "IFRAME") {
				try {
					isSandboxed = frame.hasAttribute("sandbox");
				} catch (e) {
					isSandboxed = null;
				}
			} else {
				try {
					effectiveScriptOrigin = document.domain || null;
				} catch (e) {
					effectiveScriptOrigin = null;
				}
				if (effectiveScriptOrigin === null || frameError && frameError.name === "SecurityError" && /(^|[\s\(\[@])sandbox(es|ed|ing|[\s\.,!\)\]@]|$)/.test(frameError.message.toLowerCase())) {
					isSandboxed = true;
				}
			}
		}
		_flashState.sandboxed = isSandboxed;
		if (previousState !== isSandboxed && !doNotReassessFlashSupport) {
			_detectFlashSupport(_ActiveXObject);
		}
		return isSandboxed;
	};
	/**
 * Detect the Flash Player status, version, and plugin type.
 *
 * @see {@link https://code.google.com/p/doctype-mirror/wiki/ArticleDetectFlash#The_code}
 * @see {@link http://stackoverflow.com/questions/12866060/detecting-pepper-ppapi-flash-with-javascript}
 *
 * @returns `undefined`
 * @private
 */
	var _detectFlashSupport = function _detectFlashSupport(ActiveXObject) {
		var plugin,
		    ax,
		    mimeType,
		    hasFlash = false,
		    isActiveX = false,
		    isPPAPI = false,
		    flashVersion = "";
		/**
  * Derived from Apple's suggested sniffer.
  * @param {String} desc e.g. "Shockwave Flash 7.0 r61"
  * @returns {String} "7.0.61"
  * @private
  */
		function parseFlashVersion(desc) {
			var matches = desc.match(/[\d]+/g);
			matches.length = 3;
			return matches.join(".");
		}
		function isPepperFlash(flashPlayerFileName) {
			return !!flashPlayerFileName && (flashPlayerFileName = flashPlayerFileName.toLowerCase()) && (/^(pepflashplayer\.dll|libpepflashplayer\.so|pepperflashplayer\.plugin)$/.test(flashPlayerFileName) || flashPlayerFileName.slice(-13) === "chrome.plugin");
		}
		function inspectPlugin(plugin) {
			if (plugin) {
				hasFlash = true;
				if (plugin.version) {
					flashVersion = parseFlashVersion(plugin.version);
				}
				if (!flashVersion && plugin.description) {
					flashVersion = parseFlashVersion(plugin.description);
				}
				if (plugin.filename) {
					isPPAPI = isPepperFlash(plugin.filename);
				}
			}
		}
		if (_navigator.plugins && _navigator.plugins.length) {
			plugin = _navigator.plugins["Shockwave Flash"];
			inspectPlugin(plugin);
			if (_navigator.plugins["Shockwave Flash 2.0"]) {
				hasFlash = true;
				flashVersion = "2.0.0.11";
			}
		} else if (_navigator.mimeTypes && _navigator.mimeTypes.length) {
			mimeType = _navigator.mimeTypes["application/x-shockwave-flash"];
			plugin = mimeType && mimeType.enabledPlugin;
			inspectPlugin(plugin);
		} else if (typeof ActiveXObject !== "undefined") {
			isActiveX = true;
			try {
				ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
				hasFlash = true;
				flashVersion = parseFlashVersion(ax.GetVariable("$version"));
			} catch (e1) {
				try {
					ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");
					hasFlash = true;
					flashVersion = "6.0.21";
				} catch (e2) {
					try {
						ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
						hasFlash = true;
						flashVersion = parseFlashVersion(ax.GetVariable("$version"));
					} catch (e3) {
						isActiveX = false;
					}
				}
			}
		}
		_flashState.disabled = hasFlash !== true;
		_flashState.outdated = flashVersion && _parseFloat(flashVersion) < _parseFloat(_minimumFlashVersion);
		_flashState.version = flashVersion || "0.0.0";
		_flashState.pluginType = isPPAPI ? "pepper" : isActiveX ? "activex" : hasFlash ? "netscape" : "unknown";
	};
	/**
 * Invoke the Flash detection algorithms immediately upon inclusion so we're not waiting later.
 */
	_detectFlashSupport(_ActiveXObject);
	/**
 * Always assess the `sandboxed` state of the page at important Flash-related moments.
 */
	_detectSandbox(true);
	/**
 * A shell constructor for `ZeroClipboard` client instances.
 *
 * @constructor
 */
	var ZeroClipboard = function ZeroClipboard() {
		if (!(this instanceof ZeroClipboard)) {
			return new ZeroClipboard();
		}
		if (typeof ZeroClipboard._createClient === "function") {
			ZeroClipboard._createClient.apply(this, _args(arguments));
		}
	};
	/**
 * The ZeroClipboard library's version number.
 *
 * @static
 * @readonly
 * @property {string}
 */
	ZeroClipboard.version = "2.3.0";
	/**
 * Update or get a copy of the ZeroClipboard global configuration.
 * Returns a copy of the current/updated configuration.
 *
 * @returns Object
 * @static
 */
	ZeroClipboard.config = function () {
		return _config.apply(this, _args(arguments));
	};
	/**
 * Diagnostic method that describes the state of the browser, Flash Player, and ZeroClipboard.
 *
 * @returns Object
 * @static
 */
	ZeroClipboard.state = function () {
		return _state.apply(this, _args(arguments));
	};
	/**
 * Check if Flash is unusable for any reason: disabled, outdated, deactivated, etc.
 *
 * @returns Boolean
 * @static
 */
	ZeroClipboard.isFlashUnusable = function () {
		return _isFlashUnusable.apply(this, _args(arguments));
	};
	/**
 * Register an event listener.
 *
 * @returns `ZeroClipboard`
 * @static
 */
	ZeroClipboard.on = function () {
		return _on.apply(this, _args(arguments));
	};
	/**
 * Unregister an event listener.
 * If no `listener` function/object is provided, it will unregister all listeners for the provided `eventType`.
 * If no `eventType` is provided, it will unregister all listeners for every event type.
 *
 * @returns `ZeroClipboard`
 * @static
 */
	ZeroClipboard.off = function () {
		return _off.apply(this, _args(arguments));
	};
	/**
 * Retrieve event listeners for an `eventType`.
 * If no `eventType` is provided, it will retrieve all listeners for every event type.
 *
 * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null`
 */
	ZeroClipboard.handlers = function () {
		return _listeners.apply(this, _args(arguments));
	};
	/**
 * Event emission receiver from the Flash object, forwarding to any registered JavaScript event listeners.
 *
 * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`.
 * @static
 */
	ZeroClipboard.emit = function () {
		return _emit.apply(this, _args(arguments));
	};
	/**
 * Create and embed the Flash object.
 *
 * @returns The Flash object
 * @static
 */
	ZeroClipboard.create = function () {
		return _create.apply(this, _args(arguments));
	};
	/**
 * Self-destruct and clean up everything, including the embedded Flash object.
 *
 * @returns `undefined`
 * @static
 */
	ZeroClipboard.destroy = function () {
		return _destroy.apply(this, _args(arguments));
	};
	/**
 * Set the pending data for clipboard injection.
 *
 * @returns `undefined`
 * @static
 */
	ZeroClipboard.setData = function () {
		return _setData.apply(this, _args(arguments));
	};
	/**
 * Clear the pending data for clipboard injection.
 * If no `format` is provided, all pending data formats will be cleared.
 *
 * @returns `undefined`
 * @static
 */
	ZeroClipboard.clearData = function () {
		return _clearData.apply(this, _args(arguments));
	};
	/**
 * Get a copy of the pending data for clipboard injection.
 * If no `format` is provided, a copy of ALL pending data formats will be returned.
 *
 * @returns `String` or `Object`
 * @static
 */
	ZeroClipboard.getData = function () {
		return _getData.apply(this, _args(arguments));
	};
	/**
 * Sets the current HTML object that the Flash object should overlay. This will put the global
 * Flash object on top of the current element; depending on the setup, this may also set the
 * pending clipboard text data as well as the Flash object's wrapping element's title attribute
 * based on the underlying HTML element and ZeroClipboard configuration.
 *
 * @returns `undefined`
 * @static
 */
	ZeroClipboard.focus = ZeroClipboard.activate = function () {
		return _focus.apply(this, _args(arguments));
	};
	/**
 * Un-overlays the Flash object. This will put the global Flash object off-screen; depending on
 * the setup, this may also unset the Flash object's wrapping element's title attribute based on
 * the underlying HTML element and ZeroClipboard configuration.
 *
 * @returns `undefined`
 * @static
 */
	ZeroClipboard.blur = ZeroClipboard.deactivate = function () {
		return _blur.apply(this, _args(arguments));
	};
	/**
 * Returns the currently focused/"activated" HTML element that the Flash object is wrapping.
 *
 * @returns `HTMLElement` or `null`
 * @static
 */
	ZeroClipboard.activeElement = function () {
		return _activeElement.apply(this, _args(arguments));
	};
	/**
 * Keep track of the ZeroClipboard client instance counter.
 */
	var _clientIdCounter = 0;
	/**
 * Keep track of the state of the client instances.
 *
 * Entry structure:
 *   _clientMeta[client.id] = {
 *     instance: client,
 *     elements: [],
 *     handlers: {},
 *     coreWildcardHandler: function(event) { return client.emit(event); }
 *   };
 */
	var _clientMeta = {};
	/**
 * Keep track of the ZeroClipboard clipped elements counter.
 */
	var _elementIdCounter = 0;
	/**
 * Keep track of the state of the clipped element relationships to clients.
 *
 * Entry structure:
 *   _elementMeta[element.zcClippingId] = [client1.id, client2.id];
 */
	var _elementMeta = {};
	/**
 * Keep track of the state of the mouse event handlers for clipped elements.
 *
 * Entry structure:
 *   _mouseHandlers[element.zcClippingId] = {
 *     mouseover:  function(event) {},
 *     mouseout:   function(event) {},
 *     mouseenter: function(event) {},
 *     mouseleave: function(event) {},
 *     mousemove:  function(event) {}
 *   };
 */
	var _mouseHandlers = {};
	/**
 * Extending the ZeroClipboard configuration defaults for the Client module.
 */
	_extend(_globalConfig, {
		autoActivate: true
	});
	/**
 * The real constructor for `ZeroClipboard` client instances.
 * @private
 */
	var _clientConstructor = function _clientConstructor(elements) {
		var meta,
		    client = this;
		client.id = "" + _clientIdCounter++;
		meta = {
			instance: client,
			elements: [],
			handlers: {},
			coreWildcardHandler: function coreWildcardHandler(event) {
				return client.emit(event);
			}
		};
		_clientMeta[client.id] = meta;
		if (elements) {
			client.clip(elements);
		}
		ZeroClipboard.on("*", meta.coreWildcardHandler);
		ZeroClipboard.on("destroy", function () {
			client.destroy();
		});
		ZeroClipboard.create();
	};
	/**
 * The underlying implementation of `ZeroClipboard.Client.prototype.on`.
 * @private
 */
	var _clientOn = function _clientOn(eventType, listener) {
		var i,
		    len,
		    events,
		    added = {},
		    client = this,
		    meta = _clientMeta[client.id],
		    handlers = meta && meta.handlers;
		if (!meta) {
			throw new Error("Attempted to add new listener(s) to a destroyed ZeroClipboard client instance");
		}
		if (typeof eventType === "string" && eventType) {
			events = eventType.toLowerCase().split(/\s+/);
		} else if ((typeof eventType === "undefined" ? "undefined" : _typeof(eventType)) === "object" && eventType && !("length" in eventType) && typeof listener === "undefined") {
			_keys(eventType).forEach(function (key) {
				var listener = eventType[key];
				if (typeof listener === "function") {
					client.on(key, listener);
				}
			});
		}
		if (events && events.length && listener) {
			for (i = 0, len = events.length; i < len; i++) {
				eventType = events[i].replace(/^on/, "");
				added[eventType] = true;
				if (!handlers[eventType]) {
					handlers[eventType] = [];
				}
				handlers[eventType].push(listener);
			}
			if (added.ready && _flashState.ready) {
				this.emit({
					type: "ready",
					client: this
				});
			}
			if (added.error) {
				for (i = 0, len = _flashStateErrorNames.length; i < len; i++) {
					if (_flashState[_flashStateErrorNames[i].replace(/^flash-/, "")]) {
						this.emit({
							type: "error",
							name: _flashStateErrorNames[i],
							client: this
						});
						break;
					}
				}
				if (_zcSwfVersion !== undefined && ZeroClipboard.version !== _zcSwfVersion) {
					this.emit({
						type: "error",
						name: "version-mismatch",
						jsVersion: ZeroClipboard.version,
						swfVersion: _zcSwfVersion
					});
				}
			}
		}
		return client;
	};
	/**
 * The underlying implementation of `ZeroClipboard.Client.prototype.off`.
 * @private
 */
	var _clientOff = function _clientOff(eventType, listener) {
		var i,
		    len,
		    foundIndex,
		    events,
		    perEventHandlers,
		    client = this,
		    meta = _clientMeta[client.id],
		    handlers = meta && meta.handlers;
		if (!handlers) {
			return client;
		}
		if (arguments.length === 0) {
			events = _keys(handlers);
		} else if (typeof eventType === "string" && eventType) {
			events = eventType.split(/\s+/);
		} else if ((typeof eventType === "undefined" ? "undefined" : _typeof(eventType)) === "object" && eventType && !("length" in eventType) && typeof listener === "undefined") {
			_keys(eventType).forEach(function (key) {
				var listener = eventType[key];
				if (typeof listener === "function") {
					client.off(key, listener);
				}
			});
		}
		if (events && events.length) {
			for (i = 0, len = events.length; i < len; i++) {
				eventType = events[i].toLowerCase().replace(/^on/, "");
				perEventHandlers = handlers[eventType];
				if (perEventHandlers && perEventHandlers.length) {
					if (listener) {
						foundIndex = perEventHandlers.indexOf(listener);
						while (foundIndex !== -1) {
							perEventHandlers.splice(foundIndex, 1);
							foundIndex = perEventHandlers.indexOf(listener, foundIndex);
						}
					} else {
						perEventHandlers.length = 0;
					}
				}
			}
		}
		return client;
	};
	/**
 * The underlying implementation of `ZeroClipboard.Client.prototype.handlers`.
 * @private
 */
	var _clientListeners = function _clientListeners(eventType) {
		var copy = null,
		    handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers;
		if (handlers) {
			if (typeof eventType === "string" && eventType) {
				copy = handlers[eventType] ? handlers[eventType].slice(0) : [];
			} else {
				copy = _deepCopy(handlers);
			}
		}
		return copy;
	};
	/**
 * The underlying implementation of `ZeroClipboard.Client.prototype.emit`.
 * @private
 */
	var _clientEmit = function _clientEmit(event) {
		var eventCopy,
		    client = this;
		if (_clientShouldEmit.call(client, event)) {
			if ((typeof event === "undefined" ? "undefined" : _typeof(event)) === "object" && event && typeof event.type === "string" && event.type) {
				event = _extend({}, event);
			}
			eventCopy = _extend({}, _createEvent(event), {
				client: client
			});
			_clientDispatchCallbacks.call(client, eventCopy);
		}
		return client;
	};
	/**
 * The underlying implementation of `ZeroClipboard.Client.prototype.clip`.
 * @private
 */
	var _clientClip = function _clientClip(elements) {
		if (!_clientMeta[this.id]) {
			throw new Error("Attempted to clip element(s) to a destroyed ZeroClipboard client instance");
		}
		elements = _prepClip(elements);
		for (var i = 0; i < elements.length; i++) {
			if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) {
				if (!elements[i].zcClippingId) {
					elements[i].zcClippingId = "zcClippingId_" + _elementIdCounter++;
					_elementMeta[elements[i].zcClippingId] = [this.id];
					if (_globalConfig.autoActivate === true) {
						_addMouseHandlers(elements[i]);
					}
				} else if (_elementMeta[elements[i].zcClippingId].indexOf(this.id) === -1) {
					_elementMeta[elements[i].zcClippingId].push(this.id);
				}
				var clippedElements = _clientMeta[this.id] && _clientMeta[this.id].elements;
				if (clippedElements.indexOf(elements[i]) === -1) {
					clippedElements.push(elements[i]);
				}
			}
		}
		return this;
	};
	/**
 * The underlying implementation of `ZeroClipboard.Client.prototype.unclip`.
 * @private
 */
	var _clientUnclip = function _clientUnclip(elements) {
		var meta = _clientMeta[this.id];
		if (!meta) {
			return this;
		}
		var clippedElements = meta.elements;
		var arrayIndex;
		if (typeof elements === "undefined") {
			elements = clippedElements.slice(0);
		} else {
			elements = _prepClip(elements);
		}
		for (var i = elements.length; i--;) {
			if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) {
				arrayIndex = 0;
				while ((arrayIndex = clippedElements.indexOf(elements[i], arrayIndex)) !== -1) {
					clippedElements.splice(arrayIndex, 1);
				}
				var clientIds = _elementMeta[elements[i].zcClippingId];
				if (clientIds) {
					arrayIndex = 0;
					while ((arrayIndex = clientIds.indexOf(this.id, arrayIndex)) !== -1) {
						clientIds.splice(arrayIndex, 1);
					}
					if (clientIds.length === 0) {
						if (_globalConfig.autoActivate === true) {
							_removeMouseHandlers(elements[i]);
						}
						delete elements[i].zcClippingId;
					}
				}
			}
		}
		return this;
	};
	/**
 * The underlying implementation of `ZeroClipboard.Client.prototype.elements`.
 * @private
 */
	var _clientElements = function _clientElements() {
		var meta = _clientMeta[this.id];
		return meta && meta.elements ? meta.elements.slice(0) : [];
	};
	/**
 * The underlying implementation of `ZeroClipboard.Client.prototype.destroy`.
 * @private
 */
	var _clientDestroy = function _clientDestroy() {
		var meta = _clientMeta[this.id];
		if (!meta) {
			return;
		}
		this.unclip();
		this.off();
		ZeroClipboard.off("*", meta.coreWildcardHandler);
		delete _clientMeta[this.id];
	};
	/**
 * Inspect an Event to see if the Client (`this`) should honor it for emission.
 * @private
 */
	var _clientShouldEmit = function _clientShouldEmit(event) {
		if (!(event && event.type)) {
			return false;
		}
		if (event.client && event.client !== this) {
			return false;
		}
		var meta = _clientMeta[this.id];
		var clippedEls = meta && meta.elements;
		var hasClippedEls = !!clippedEls && clippedEls.length > 0;
		var goodTarget = !event.target || hasClippedEls && clippedEls.indexOf(event.target) !== -1;
		var goodRelTarget = event.relatedTarget && hasClippedEls && clippedEls.indexOf(event.relatedTarget) !== -1;
		var goodClient = event.client && event.client === this;
		if (!meta || !(goodTarget || goodRelTarget || goodClient)) {
			return false;
		}
		return true;
	};
	/**
 * Handle the actual dispatching of events to a client instance.
 *
 * @returns `undefined`
 * @private
 */
	var _clientDispatchCallbacks = function _clientDispatchCallbacks(event) {
		var meta = _clientMeta[this.id];
		if (!((typeof event === "undefined" ? "undefined" : _typeof(event)) === "object" && event && event.type && meta)) {
			return;
		}
		var async = _shouldPerformAsync(event);
		var wildcardTypeHandlers = meta && meta.handlers["*"] || [];
		var specificTypeHandlers = meta && meta.handlers[event.type] || [];
		var handlers = wildcardTypeHandlers.concat(specificTypeHandlers);
		if (handlers && handlers.length) {
			var i,
			    len,
			    func,
			    context,
			    eventCopy,
			    originalContext = this;
			for (i = 0, len = handlers.length; i < len; i++) {
				func = handlers[i];
				context = originalContext;
				if (typeof func === "string" && typeof _window[func] === "function") {
					func = _window[func];
				}
				if ((typeof func === "undefined" ? "undefined" : _typeof(func)) === "object" && func && typeof func.handleEvent === "function") {
					context = func;
					func = func.handleEvent;
				}
				if (typeof func === "function") {
					eventCopy = _extend({}, event);
					_dispatchCallback(func, context, [eventCopy], async);
				}
			}
		}
	};
	/**
 * Prepares the elements for clipping/unclipping.
 *
 * @returns An Array of elements.
 * @private
 */
	var _prepClip = function _prepClip(elements) {
		if (typeof elements === "string") {
			elements = [];
		}
		return typeof elements.length !== "number" ? [elements] : elements;
	};
	/**
 * Add a `mouseover` handler function for a clipped element.
 *
 * @returns `undefined`
 * @private
 */
	var _addMouseHandlers = function _addMouseHandlers(element) {
		if (!(element && element.nodeType === 1)) {
			return;
		}
		var _suppressMouseEvents = function _suppressMouseEvents(event) {
			if (!(event || (event = _window.event))) {
				return;
			}
			if (event._source !== "js") {
				event.stopImmediatePropagation();
				event.preventDefault();
			}
			delete event._source;
		};
		var _elementMouseOver = function _elementMouseOver(event) {
			if (!(event || (event = _window.event))) {
				return;
			}
			_suppressMouseEvents(event);
			ZeroClipboard.focus(element);
		};
		element.addEventListener("mouseover", _elementMouseOver, false);
		element.addEventListener("mouseout", _suppressMouseEvents, false);
		element.addEventListener("mouseenter", _suppressMouseEvents, false);
		element.addEventListener("mouseleave", _suppressMouseEvents, false);
		element.addEventListener("mousemove", _suppressMouseEvents, false);
		_mouseHandlers[element.zcClippingId] = {
			mouseover: _elementMouseOver,
			mouseout: _suppressMouseEvents,
			mouseenter: _suppressMouseEvents,
			mouseleave: _suppressMouseEvents,
			mousemove: _suppressMouseEvents
		};
	};
	/**
 * Remove a `mouseover` handler function for a clipped element.
 *
 * @returns `undefined`
 * @private
 */
	var _removeMouseHandlers = function _removeMouseHandlers(element) {
		if (!(element && element.nodeType === 1)) {
			return;
		}
		var mouseHandlers = _mouseHandlers[element.zcClippingId];
		if (!((typeof mouseHandlers === "undefined" ? "undefined" : _typeof(mouseHandlers)) === "object" && mouseHandlers)) {
			return;
		}
		var key,
		    val,
		    mouseEvents = ["move", "leave", "enter", "out", "over"];
		for (var i = 0, len = mouseEvents.length; i < len; i++) {
			key = "mouse" + mouseEvents[i];
			val = mouseHandlers[key];
			if (typeof val === "function") {
				element.removeEventListener(key, val, false);
			}
		}
		delete _mouseHandlers[element.zcClippingId];
	};
	/**
 * Creates a new ZeroClipboard client instance.
 * Optionally, auto-`clip` an element or collection of elements.
 *
 * @constructor
 */
	ZeroClipboard._createClient = function () {
		_clientConstructor.apply(this, _args(arguments));
	};
	/**
 * Register an event listener to the client.
 *
 * @returns `this`
 */
	ZeroClipboard.prototype.on = function () {
		return _clientOn.apply(this, _args(arguments));
	};
	/**
 * Unregister an event handler from the client.
 * If no `listener` function/object is provided, it will unregister all handlers for the provided `eventType`.
 * If no `eventType` is provided, it will unregister all handlers for every event type.
 *
 * @returns `this`
 */
	ZeroClipboard.prototype.off = function () {
		return _clientOff.apply(this, _args(arguments));
	};
	/**
 * Retrieve event listeners for an `eventType` from the client.
 * If no `eventType` is provided, it will retrieve all listeners for every event type.
 *
 * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null`
 */
	ZeroClipboard.prototype.handlers = function () {
		return _clientListeners.apply(this, _args(arguments));
	};
	/**
 * Event emission receiver from the Flash object for this client's registered JavaScript event listeners.
 *
 * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`.
 */
	ZeroClipboard.prototype.emit = function () {
		return _clientEmit.apply(this, _args(arguments));
	};
	/**
 * Register clipboard actions for new element(s) to the client.
 *
 * @returns `this`
 */
	ZeroClipboard.prototype.clip = function () {
		return _clientClip.apply(this, _args(arguments));
	};
	/**
 * Unregister the clipboard actions of previously registered element(s) on the page.
 * If no elements are provided, ALL registered elements will be unregistered.
 *
 * @returns `this`
 */
	ZeroClipboard.prototype.unclip = function () {
		return _clientUnclip.apply(this, _args(arguments));
	};
	/**
 * Get all of the elements to which this client is clipped.
 *
 * @returns array of clipped elements
 */
	ZeroClipboard.prototype.elements = function () {
		return _clientElements.apply(this, _args(arguments));
	};
	/**
 * Self-destruct and clean up everything for a single client.
 * This will NOT destroy the embedded Flash object.
 *
 * @returns `undefined`
 */
	ZeroClipboard.prototype.destroy = function () {
		return _clientDestroy.apply(this, _args(arguments));
	};
	/**
 * Stores the pending plain text to inject into the clipboard.
 *
 * @returns `this`
 */
	ZeroClipboard.prototype.setText = function (text) {
		if (!_clientMeta[this.id]) {
			throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance");
		}
		ZeroClipboard.setData("text/plain", text);
		return this;
	};
	/**
 * Stores the pending HTML text to inject into the clipboard.
 *
 * @returns `this`
 */
	ZeroClipboard.prototype.setHtml = function (html) {
		if (!_clientMeta[this.id]) {
			throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance");
		}
		ZeroClipboard.setData("text/html", html);
		return this;
	};
	/**
 * Stores the pending rich text (RTF) to inject into the clipboard.
 *
 * @returns `this`
 */
	ZeroClipboard.prototype.setRichText = function (richText) {
		if (!_clientMeta[this.id]) {
			throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance");
		}
		ZeroClipboard.setData("application/rtf", richText);
		return this;
	};
	/**
 * Stores the pending data to inject into the clipboard.
 *
 * @returns `this`
 */
	ZeroClipboard.prototype.setData = function () {
		if (!_clientMeta[this.id]) {
			throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance");
		}
		ZeroClipboard.setData.apply(this, _args(arguments));
		return this;
	};
	/**
 * Clears the pending data to inject into the clipboard.
 * If no `format` is provided, all pending data formats will be cleared.
 *
 * @returns `this`
 */
	ZeroClipboard.prototype.clearData = function () {
		if (!_clientMeta[this.id]) {
			throw new Error("Attempted to clear pending clipboard data from a destroyed ZeroClipboard client instance");
		}
		ZeroClipboard.clearData.apply(this, _args(arguments));
		return this;
	};
	/**
 * Gets a copy of the pending data to inject into the clipboard.
 * If no `format` is provided, a copy of ALL pending data formats will be returned.
 *
 * @returns `String` or `Object`
 */
	ZeroClipboard.prototype.getData = function () {
		if (!_clientMeta[this.id]) {
			throw new Error("Attempted to get pending clipboard data from a destroyed ZeroClipboard client instance");
		}
		return ZeroClipboard.getData.apply(this, _args(arguments));
	};
	if (typeof define === "function" && define.amd) {
		define(function () {
			return ZeroClipboard;
		});
	} else if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module && _typeof(module.exports) === "object" && module.exports) {
		module.exports = ZeroClipboard;
	} else {
		window.ZeroClipboard = ZeroClipboard;
	}
})(function () {
	return this || window;
}());
/*
 * jQuery Iframe Transport Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* global define, require, window, document, JSON */

;(function (factory) {
	'use strict';

	if (typeof define === 'function' && define.amd) {
		// Register as an anonymous AMD module:
		define(['jquery'], factory);
	} else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
		// Node/CommonJS:
		factory(require('jquery'));
	} else {
		// Browser globals:
		factory(window.jQuery);
	}
})(function ($) {
	'use strict';

	// Helper variable to create unique names for the transport iframes:

	var counter = 0,
	    jsonAPI = $,
	    jsonParse = 'parseJSON';

	if ('JSON' in window && 'parse' in JSON) {
		jsonAPI = JSON;
		jsonParse = 'parse';
	}

	// The iframe transport accepts four additional options:
	// options.fileInput: a jQuery collection of file input fields
	// options.paramName: the parameter name for the file form data,
	//  overrides the name property of the file input field(s),
	//  can be a string or an array of strings.
	// options.formData: an array of objects with name and value properties,
	//  equivalent to the return data of .serializeArray(), e.g.:
	//  [{name: 'a', value: 1}, {name: 'b', value: 2}]
	// options.initialIframeSrc: the URL of the initial iframe src,
	//  by default set to "javascript:false;"
	$.ajaxTransport('iframe', function (options) {
		if (options.async) {
			// javascript:false as initial iframe src
			// prevents warning popups on HTTPS in IE6:
			/*jshint scripturl: true */
			var initialIframeSrc = options.initialIframeSrc || 'javascript:false;',

			/*jshint scripturl: false */
			form,
			    iframe,
			    addParamChar;
			return {
				send: function send(_, completeCallback) {
					form = $('<form style="display:none;"></form>');
					form.attr('accept-charset', options.formAcceptCharset);
					addParamChar = /\?/.test(options.url) ? '&' : '?';
					// XDomainRequest only supports GET and POST:
					if (options.type === 'DELETE') {
						options.url = options.url + addParamChar + '_method=DELETE';
						options.type = 'POST';
					} else if (options.type === 'PUT') {
						options.url = options.url + addParamChar + '_method=PUT';
						options.type = 'POST';
					} else if (options.type === 'PATCH') {
						options.url = options.url + addParamChar + '_method=PATCH';
						options.type = 'POST';
					}
					// IE versions below IE8 cannot set the name property of
					// elements that have already been added to the DOM,
					// so we set the name along with the iframe HTML markup:
					counter += 1;
					iframe = $('<iframe src="' + initialIframeSrc + '" name="iframe-transport-' + counter + '"></iframe>').bind('load', function () {
						var fileInputClones,
						    paramNames = $.isArray(options.paramName) ? options.paramName : [options.paramName];
						iframe.unbind('load').bind('load', function () {
							var response;
							// Wrap in a try/catch block to catch exceptions thrown
							// when trying to access cross-domain iframe contents:
							try {
								response = iframe.contents();
								// Google Chrome and Firefox do not throw an
								// exception when calling iframe.contents() on
								// cross-domain requests, so we unify the response:
								if (!response.length || !response[0].firstChild) {
									throw new Error();
								}
							} catch (e) {
								response = undefined;
							}
							// The complete callback returns the
							// iframe content document as response object:
							completeCallback(200, 'success', { 'iframe': response });
							// Fix for IE endless progress bar activity bug
							// (happens on form submits to iframe targets):
							$('<iframe src="' + initialIframeSrc + '"></iframe>').appendTo(form);
							window.setTimeout(function () {
								// Removing the form in a setTimeout call
								// allows Chrome's developer tools to display
								// the response result
								form.remove();
							}, 0);
						});
						form.prop('target', iframe.prop('name')).prop('action', options.url).prop('method', options.type);
						if (options.formData) {
							$.each(options.formData, function (index, field) {
								$('<input type="hidden"/>').prop('name', field.name).val(field.value).appendTo(form);
							});
						}
						if (options.fileInput && options.fileInput.length && options.type === 'POST') {
							fileInputClones = options.fileInput.clone();
							// Insert a clone for each file input field:
							options.fileInput.after(function (index) {
								return fileInputClones[index];
							});
							if (options.paramName) {
								options.fileInput.each(function (index) {
									$(this).prop('name', paramNames[index] || options.paramName);
								});
							}
							// Appending the file input fields to the hidden form
							// removes them from their original location:
							form.append(options.fileInput).prop('enctype', 'multipart/form-data')
							// enctype must be set as encoding for IE:
							.prop('encoding', 'multipart/form-data');
							// Remove the HTML5 form attribute from the input(s):
							options.fileInput.removeAttr('form');
						}
						form.submit();
						// Insert the file input fields at their original location
						// by replacing the clones with the originals:
						if (fileInputClones && fileInputClones.length) {
							options.fileInput.each(function (index, input) {
								var clone = $(fileInputClones[index]);
								// Restore the original name and form properties:
								$(input).prop('name', clone.prop('name')).attr('form', clone.attr('form'));
								clone.replaceWith(input);
							});
						}
					});
					form.append(iframe).appendTo(document.body);
				},
				abort: function abort() {
					if (iframe) {
						// javascript:false as iframe src aborts the request
						// and prevents warning popups on HTTPS in IE6.
						// concat is used to avoid the "Script URL" JSLint error:
						iframe.unbind('load').prop('src', initialIframeSrc);
					}
					if (form) {
						form.remove();
					}
				}
			};
		}
	});

	// The iframe transport returns the iframe content document as response.
	// The following adds converters from iframe to text, json, html, xml
	// and script.
	// Please note that the Content-Type for JSON responses has to be text/plain
	// or text/html, if the browser doesn't include application/json in the
	// Accept header, else IE will show a download dialog.
	// The Content-Type for XML responses on the other hand has to be always
	// application/xml or text/xml, so IE properly parses the XML response.
	// See also
	// https://github.com/blueimp/jQuery-File-Upload/wiki/Setup#content-type-negotiation
	$.ajaxSetup({
		converters: {
			'iframe text': function iframeText(iframe) {
				return iframe && $(iframe[0].body).text();
			},
			'iframe json': function iframeJson(iframe) {
				return iframe && jsonAPI[jsonParse]($(iframe[0].body).text());
			},
			'iframe html': function iframeHtml(iframe) {
				return iframe && $(iframe[0].body).html();
			},
			'iframe xml': function iframeXml(iframe) {
				var xmlDoc = iframe && iframe[0];
				return xmlDoc && $.isXMLDoc(xmlDoc) ? xmlDoc : $.parseXML(xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml || $(xmlDoc.body).html());
			},
			'iframe script': function iframeScript(iframe) {
				return iframe && $.globalEval($(iframe[0].body).text());
			}
		}
	});
});
/*! jQuery UI - v1.12.1+CommonJS - 2018-02-10
 * http://jqueryui.com
 * Includes: widget.js
 * Copyright jQuery Foundation and other contributors; Licensed MIT */

(function (factory) {
	if (typeof define === "function" && define.amd) {

		// AMD. Register as an anonymous module.
		define(["jquery"], factory);
	} else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object") {

		// Node/CommonJS
		factory(require("jquery"));
	} else {

		// Browser globals
		factory(jQuery);
	}
})(function ($) {

	$.ui = $.ui || {};

	var version = $.ui.version = "1.12.1";

	/*!
  * jQuery UI Widget 1.12.1
  * http://jqueryui.com
  *
  * Copyright jQuery Foundation and other contributors
  * Released under the MIT license.
  * http://jquery.org/license
  */

	//>>label: Widget
	//>>group: Core
	//>>description: Provides a factory for creating stateful widgets with a common API.
	//>>docs: http://api.jqueryui.com/jQuery.widget/
	//>>demos: http://jqueryui.com/widget/


	var widgetUuid = 0;
	var widgetSlice = Array.prototype.slice;

	$.cleanData = function (orig) {
		return function (elems) {
			var events, elem, i;
			for (i = 0; (elem = elems[i]) != null; i++) {
				try {

					// Only trigger remove when necessary to save time
					events = $._data(elem, "events");
					if (events && events.remove) {
						$(elem).triggerHandler("remove");
					}

					// Http://bugs.jquery.com/ticket/8235
				} catch (e) {}
			}
			orig(elems);
		};
	}($.cleanData);

	$.widget = function (name, base, prototype) {
		var existingConstructor, constructor, basePrototype;

		// ProxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		var proxiedPrototype = {};

		var namespace = name.split(".")[0];
		name = name.split(".")[1];
		var fullName = namespace + "-" + name;

		if (!prototype) {
			prototype = base;
			base = $.Widget;
		}

		if ($.isArray(prototype)) {
			prototype = $.extend.apply(null, [{}].concat(prototype));
		}

		// Create selector for plugin
		$.expr[":"][fullName.toLowerCase()] = function (elem) {
			return !!$.data(elem, fullName);
		};

		$[namespace] = $[namespace] || {};
		existingConstructor = $[namespace][name];
		constructor = $[namespace][name] = function (options, element) {

			// Allow instantiation without "new" keyword
			if (!this._createWidget) {
				return new constructor(options, element);
			}

			// Allow instantiation without initializing for simple inheritance
			// must use "new" keyword (the code above always passes args)
			if (arguments.length) {
				this._createWidget(options, element);
			}
		};

		// Extend with the existing constructor to carry over any static properties
		$.extend(constructor, existingConstructor, {
			version: prototype.version,

			// Copy the object used to create the prototype in case we need to
			// redefine the widget later
			_proto: $.extend({}, prototype),

			// Track widgets that inherit from this widget in case this widget is
			// redefined after a widget inherits from it
			_childConstructors: []
		});

		basePrototype = new base();

		// We need to make the options hash a property directly on the new instance
		// otherwise we'll modify the options hash on the prototype that we're
		// inheriting from
		basePrototype.options = $.widget.extend({}, basePrototype.options);
		$.each(prototype, function (prop, value) {
			if (!$.isFunction(value)) {
				proxiedPrototype[prop] = value;
				return;
			}
			proxiedPrototype[prop] = function () {
				function _super() {
					return base.prototype[prop].apply(this, arguments);
				}

				function _superApply(args) {
					return base.prototype[prop].apply(this, args);
				}

				return function () {
					var __super = this._super;
					var __superApply = this._superApply;
					var returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply(this, arguments);

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			}();
		});
		constructor.prototype = $.widget.extend(basePrototype, {

			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name
		}, proxiedPrototype, {
			constructor: constructor,
			namespace: namespace,
			widgetName: name,
			widgetFullName: fullName
		});

		// If this widget is being redefined then we need to find all widgets that
		// are inheriting from it and redefine all of them so that they inherit from
		// the new version of this widget. We're essentially trying to replace one
		// level in the prototype chain.
		if (existingConstructor) {
			$.each(existingConstructor._childConstructors, function (i, child) {
				var childPrototype = child.prototype;

				// Redefine the child widget using the same prototype that was
				// originally used, but inherit from the new version of the base
				$.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
			});

			// Remove the list of existing child constructors from the old constructor
			// so the old child constructors can be garbage collected
			delete existingConstructor._childConstructors;
		} else {
			base._childConstructors.push(constructor);
		}

		$.widget.bridge(name, constructor);

		return constructor;
	};

	$.widget.extend = function (target) {
		var input = widgetSlice.call(arguments, 1);
		var inputIndex = 0;
		var inputLength = input.length;
		var key;
		var value;

		for (; inputIndex < inputLength; inputIndex++) {
			for (key in input[inputIndex]) {
				value = input[inputIndex][key];
				if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {

					// Clone objects
					if ($.isPlainObject(value)) {
						target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend({}, value);

						// Copy everything else by reference
					} else {
						target[key] = value;
					}
				}
			}
		}
		return target;
	};

	$.widget.bridge = function (name, object) {
		var fullName = object.prototype.widgetFullName || name;
		$.fn[name] = function (options) {
			var isMethodCall = typeof options === "string";
			var args = widgetSlice.call(arguments, 1);
			var returnValue = this;

			if (isMethodCall) {

				// If this is an empty collection, we need to have the instance method
				// return undefined instead of the jQuery instance
				if (!this.length && options === "instance") {
					returnValue = undefined;
				} else {
					this.each(function () {
						var methodValue;
						var instance = $.data(this, fullName);

						if (options === "instance") {
							returnValue = instance;
							return false;
						}

						if (!instance) {
							return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
						}

						if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
							return $.error("no such method '" + options + "' for " + name + " widget instance");
						}

						methodValue = instance[options].apply(instance, args);

						if (methodValue !== instance && methodValue !== undefined) {
							returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
							return false;
						}
					});
				}
			} else {

				// Allow multiple hashes to be passed on init
				if (args.length) {
					options = $.widget.extend.apply(null, [options].concat(args));
				}

				this.each(function () {
					var instance = $.data(this, fullName);
					if (instance) {
						instance.option(options || {});
						if (instance._init) {
							instance._init();
						}
					} else {
						$.data(this, fullName, new object(options, this));
					}
				});
			}

			return returnValue;
		};
	};

	$.Widget = function () /* options, element */{};
	$.Widget._childConstructors = [];

	$.Widget.prototype = {
		widgetName: "widget",
		widgetEventPrefix: "",
		defaultElement: "<div>",

		options: {
			classes: {},
			disabled: false,

			// Callbacks
			create: null
		},

		_createWidget: function _createWidget(options, element) {
			element = $(element || this.defaultElement || this)[0];
			this.element = $(element);
			this.uuid = widgetUuid++;
			this.eventNamespace = "." + this.widgetName + this.uuid;

			this.bindings = $();
			this.hoverable = $();
			this.focusable = $();
			this.classesElementLookup = {};

			if (element !== this) {
				$.data(element, this.widgetFullName, this);
				this._on(true, this.element, {
					remove: function remove(event) {
						if (event.target === element) {
							this.destroy();
						}
					}
				});
				this.document = $(element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element);
				this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
			}

			this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);

			this._create();

			if (this.options.disabled) {
				this._setOptionDisabled(this.options.disabled);
			}

			this._trigger("create", null, this._getCreateEventData());
			this._init();
		},

		_getCreateOptions: function _getCreateOptions() {
			return {};
		},

		_getCreateEventData: $.noop,

		_create: $.noop,

		_init: $.noop,

		destroy: function destroy() {
			var that = this;

			this._destroy();
			$.each(this.classesElementLookup, function (key, value) {
				that._removeClass(value, key);
			});

			// We can probably remove the unbind calls in 2.0
			// all event bindings should go through this._on()
			this.element.off(this.eventNamespace).removeData(this.widgetFullName);
			this.widget().off(this.eventNamespace).removeAttr("aria-disabled");

			// Clean up events and states
			this.bindings.off(this.eventNamespace);
		},

		_destroy: $.noop,

		widget: function widget() {
			return this.element;
		},

		option: function option(key, value) {
			var options = key;
			var parts;
			var curOption;
			var i;

			if (arguments.length === 0) {

				// Don't return a reference to the internal hash
				return $.widget.extend({}, this.options);
			}

			if (typeof key === "string") {

				// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
				options = {};
				parts = key.split(".");
				key = parts.shift();
				if (parts.length) {
					curOption = options[key] = $.widget.extend({}, this.options[key]);
					for (i = 0; i < parts.length - 1; i++) {
						curOption[parts[i]] = curOption[parts[i]] || {};
						curOption = curOption[parts[i]];
					}
					key = parts.pop();
					if (arguments.length === 1) {
						return curOption[key] === undefined ? null : curOption[key];
					}
					curOption[key] = value;
				} else {
					if (arguments.length === 1) {
						return this.options[key] === undefined ? null : this.options[key];
					}
					options[key] = value;
				}
			}

			this._setOptions(options);

			return this;
		},

		_setOptions: function _setOptions(options) {
			var key;

			for (key in options) {
				this._setOption(key, options[key]);
			}

			return this;
		},

		_setOption: function _setOption(key, value) {
			if (key === "classes") {
				this._setOptionClasses(value);
			}

			this.options[key] = value;

			if (key === "disabled") {
				this._setOptionDisabled(value);
			}

			return this;
		},

		_setOptionClasses: function _setOptionClasses(value) {
			var classKey, elements, currentElements;

			for (classKey in value) {
				currentElements = this.classesElementLookup[classKey];
				if (value[classKey] === this.options.classes[classKey] || !currentElements || !currentElements.length) {
					continue;
				}

				// We are doing this to create a new jQuery object because the _removeClass() call
				// on the next line is going to destroy the reference to the current elements being
				// tracked. We need to save a copy of this collection so that we can add the new classes
				// below.
				elements = $(currentElements.get());
				this._removeClass(currentElements, classKey);

				// We don't use _addClass() here, because that uses this.options.classes
				// for generating the string of classes. We want to use the value passed in from
				// _setOption(), this is the new value of the classes option which was passed to
				// _setOption(). We pass this value directly to _classes().
				elements.addClass(this._classes({
					element: elements,
					keys: classKey,
					classes: value,
					add: true
				}));
			}
		},

		_setOptionDisabled: function _setOptionDisabled(value) {
			this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!value);

			// If the widget is becoming disabled, then nothing is interactive
			if (value) {
				this._removeClass(this.hoverable, null, "ui-state-hover");
				this._removeClass(this.focusable, null, "ui-state-focus");
			}
		},

		enable: function enable() {
			return this._setOptions({ disabled: false });
		},

		disable: function disable() {
			return this._setOptions({ disabled: true });
		},

		_classes: function _classes(options) {
			var full = [];
			var that = this;

			options = $.extend({
				element: this.element,
				classes: this.options.classes || {}
			}, options);

			function processClassString(classes, checkOption) {
				var current, i;
				for (i = 0; i < classes.length; i++) {
					current = that.classesElementLookup[classes[i]] || $();
					if (options.add) {
						current = $($.unique(current.get().concat(options.element.get())));
					} else {
						current = $(current.not(options.element).get());
					}
					that.classesElementLookup[classes[i]] = current;
					full.push(classes[i]);
					if (checkOption && options.classes[classes[i]]) {
						full.push(options.classes[classes[i]]);
					}
				}
			}

			this._on(options.element, {
				"remove": "_untrackClassesElement"
			});

			if (options.keys) {
				processClassString(options.keys.match(/\S+/g) || [], true);
			}
			if (options.extra) {
				processClassString(options.extra.match(/\S+/g) || []);
			}

			return full.join(" ");
		},

		_untrackClassesElement: function _untrackClassesElement(event) {
			var that = this;
			$.each(that.classesElementLookup, function (key, value) {
				if ($.inArray(event.target, value) !== -1) {
					that.classesElementLookup[key] = $(value.not(event.target).get());
				}
			});
		},

		_removeClass: function _removeClass(element, keys, extra) {
			return this._toggleClass(element, keys, extra, false);
		},

		_addClass: function _addClass(element, keys, extra) {
			return this._toggleClass(element, keys, extra, true);
		},

		_toggleClass: function _toggleClass(element, keys, extra, add) {
			add = typeof add === "boolean" ? add : extra;
			var shift = typeof element === "string" || element === null,
			    options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
			options.element.toggleClass(this._classes(options), add);
			return this;
		},

		_on: function _on(suppressDisabledCheck, element, handlers) {
			var delegateElement;
			var instance = this;

			// No suppressDisabledCheck flag, shuffle arguments
			if (typeof suppressDisabledCheck !== "boolean") {
				handlers = element;
				element = suppressDisabledCheck;
				suppressDisabledCheck = false;
			}

			// No element argument, shuffle and use this.element
			if (!handlers) {
				handlers = element;
				element = this.element;
				delegateElement = this.widget();
			} else {
				element = delegateElement = $(element);
				this.bindings = this.bindings.add(element);
			}

			$.each(handlers, function (event, handler) {
				function handlerProxy() {

					// Allow widgets to customize the disabled handling
					// - disabled as an array instead of boolean
					// - disabled class as method for disabling individual parts
					if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
						return;
					}
					return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
				}

				// Copy the guid so direct unbinding works
				if (typeof handler !== "string") {
					handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
				}

				var match = event.match(/^([\w:-]*)\s*(.*)$/);
				var eventName = match[1] + instance.eventNamespace;
				var selector = match[2];

				if (selector) {
					delegateElement.on(eventName, selector, handlerProxy);
				} else {
					element.on(eventName, handlerProxy);
				}
			});
		},

		_off: function _off(element, eventName) {
			eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
			element.off(eventName).off(eventName);

			// Clear the stack to avoid memory leaks (#10056)
			this.bindings = $(this.bindings.not(element).get());
			this.focusable = $(this.focusable.not(element).get());
			this.hoverable = $(this.hoverable.not(element).get());
		},

		_delay: function _delay(handler, delay) {
			function handlerProxy() {
				return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
			}
			var instance = this;
			return setTimeout(handlerProxy, delay || 0);
		},

		_hoverable: function _hoverable(element) {
			this.hoverable = this.hoverable.add(element);
			this._on(element, {
				mouseenter: function mouseenter(event) {
					this._addClass($(event.currentTarget), null, "ui-state-hover");
				},
				mouseleave: function mouseleave(event) {
					this._removeClass($(event.currentTarget), null, "ui-state-hover");
				}
			});
		},

		_focusable: function _focusable(element) {
			this.focusable = this.focusable.add(element);
			this._on(element, {
				focusin: function focusin(event) {
					this._addClass($(event.currentTarget), null, "ui-state-focus");
				},
				focusout: function focusout(event) {
					this._removeClass($(event.currentTarget), null, "ui-state-focus");
				}
			});
		},

		_trigger: function _trigger(type, event, data) {
			var prop, orig;
			var callback = this.options[type];

			data = data || {};
			event = $.Event(event);
			event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();

			// The original event may come from any element
			// so we need to reset the target on the new event
			event.target = this.element[0];

			// Copy original event properties over to the new event
			orig = event.originalEvent;
			if (orig) {
				for (prop in orig) {
					if (!(prop in event)) {
						event[prop] = orig[prop];
					}
				}
			}

			this.element.trigger(event, data);
			return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
		}
	};

	$.each({ show: "fadeIn", hide: "fadeOut" }, function (method, defaultEffect) {
		$.Widget.prototype["_" + method] = function (element, options, callback) {
			if (typeof options === "string") {
				options = { effect: options };
			}

			var hasOptions;
			var effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;

			options = options || {};
			if (typeof options === "number") {
				options = { duration: options };
			}

			hasOptions = !$.isEmptyObject(options);
			options.complete = callback;

			if (options.delay) {
				element.delay(options.delay);
			}

			if (hasOptions && $.effects && $.effects.effect[effectName]) {
				element[method](options);
			} else if (effectName !== method && element[effectName]) {
				element[effectName](options.duration, options.easing, callback);
			} else {
				element.queue(function (next) {
					$(this)[method]();
					if (callback) {
						callback.call(element[0]);
					}
					next();
				});
			}
		};
	});

	var widget = $.widget;
});
/*
 * jQuery File Upload Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* jshint nomen:false */
/* global define, require, window, document, location, Blob, FormData */

;(function (factory) {
	'use strict';

	if (typeof define === 'function' && define.amd) {
		// Register as an anonymous AMD module:
		define(['jquery', 'jquery-ui/ui/widget'], factory);
	} else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
		// Node/CommonJS:
		factory(require('jquery'), require('./vendor/jquery.ui.widget'));
	} else {
		// Browser globals:
		factory(window.jQuery);
	}
})(function ($) {
	'use strict';

	// Detect file input support, based on
	// http://viljamis.com/blog/2012/file-upload-support-on-mobile/

	$.support.fileInput = !(new RegExp(
	// Handle devices which give false positives for the feature detection:
	'(Android (1\\.[0156]|2\\.[01]))' + '|(Windows Phone (OS 7|8\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' + '|(w(eb)?OSBrowser)|(webOS)' + '|(Kindle/(1\\.0|2\\.[05]|3\\.0))').test(window.navigator.userAgent) ||
	// Feature detection for all other devices:
	$('<input type="file"/>').prop('disabled'));

	// The FileReader API is not actually used, but works as feature detection,
	// as some Safari versions (5?) support XHR file uploads via the FormData API,
	// but not non-multipart XHR file uploads.
	// window.XMLHttpRequestUpload is not available on IE10, so we check for
	// window.ProgressEvent instead to detect XHR2 file upload capability:
	$.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);
	$.support.xhrFormDataFileUpload = !!window.FormData;

	// Detect support for Blob slicing (required for chunked uploads):
	$.support.blobSlice = window.Blob && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);

	// Helper function to create drag handlers for dragover/dragenter/dragleave:
	function getDragHandler(type) {
		var isDragOver = type === 'dragover';
		return function (e) {
			e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
			var dataTransfer = e.dataTransfer;
			if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1 && this._trigger(type, $.Event(type, { delegatedEvent: e })) !== false) {
				e.preventDefault();
				if (isDragOver) {
					dataTransfer.dropEffect = 'copy';
				}
			}
		};
	}

	// The fileupload widget listens for change events on file input fields defined
	// via fileInput setting and paste or drop events of the given dropZone.
	// In addition to the default jQuery Widget methods, the fileupload widget
	// exposes the "add" and "send" methods, to add or directly send files using
	// the fileupload API.
	// By default, files added via file input selection, paste, drag & drop or
	// "add" method are uploaded immediately, but it is possible to override
	// the "add" callback option to queue file uploads.
	$.widget('blueimp.fileupload', {

		options: {
			// The drop target element(s), by the default the complete document.
			// Set to null to disable drag & drop support:
			dropZone: $(document),
			// The paste target element(s), by the default undefined.
			// Set to a DOM node or jQuery object to enable file pasting:
			pasteZone: undefined,
			// The file input field(s), that are listened to for change events.
			// If undefined, it is set to the file input fields inside
			// of the widget element on plugin initialization.
			// Set to null to disable the change listener.
			fileInput: undefined,
			// By default, the file input field is replaced with a clone after
			// each input field change event. This is required for iframe transport
			// queues and allows change events to be fired for the same file
			// selection, but can be disabled by setting the following option to false:
			replaceFileInput: true,
			// The parameter name for the file form data (the request argument name).
			// If undefined or empty, the name property of the file input field is
			// used, or "files[]" if the file input name property is also empty,
			// can be a string or an array of strings:
			paramName: undefined,
			// By default, each file of a selection is uploaded using an individual
			// request for XHR type uploads. Set to false to upload file
			// selections in one request each:
			singleFileUploads: true,
			// To limit the number of files uploaded with one XHR request,
			// set the following option to an integer greater than 0:
			limitMultiFileUploads: undefined,
			// The following option limits the number of files uploaded with one
			// XHR request to keep the request size under or equal to the defined
			// limit in bytes:
			limitMultiFileUploadSize: undefined,
			// Multipart file uploads add a number of bytes to each uploaded file,
			// therefore the following option adds an overhead for each file used
			// in the limitMultiFileUploadSize configuration:
			limitMultiFileUploadSizeOverhead: 512,
			// Set the following option to true to issue all file upload requests
			// in a sequential order:
			sequentialUploads: false,
			// To limit the number of concurrent uploads,
			// set the following option to an integer greater than 0:
			limitConcurrentUploads: undefined,
			// Set the following option to true to force iframe transport uploads:
			forceIframeTransport: false,
			// Set the following option to the location of a redirect url on the
			// origin server, for cross-domain iframe transport uploads:
			redirect: undefined,
			// The parameter name for the redirect url, sent as part of the form
			// data and set to 'redirect' if this option is empty:
			redirectParamName: undefined,
			// Set the following option to the location of a postMessage window,
			// to enable postMessage transport uploads:
			postMessage: undefined,
			// By default, XHR file uploads are sent as multipart/form-data.
			// The iframe transport is always using multipart/form-data.
			// Set to false to enable non-multipart XHR uploads:
			multipart: true,
			// To upload large files in smaller chunks, set the following option
			// to a preferred maximum chunk size. If set to 0, null or undefined,
			// or the browser does not support the required Blob API, files will
			// be uploaded as a whole.
			maxChunkSize: undefined,
			// When a non-multipart upload or a chunked multipart upload has been
			// aborted, this option can be used to resume the upload by setting
			// it to the size of the already uploaded bytes. This option is most
			// useful when modifying the options object inside of the "add" or
			// "send" callbacks, as the options are cloned for each file upload.
			uploadedBytes: undefined,
			// By default, failed (abort or error) file uploads are removed from the
			// global progress calculation. Set the following option to false to
			// prevent recalculating the global progress data:
			recalculateProgress: true,
			// Interval in milliseconds to calculate and trigger progress events:
			progressInterval: 100,
			// Interval in milliseconds to calculate progress bitrate:
			bitrateInterval: 500,
			// By default, uploads are started automatically when adding files:
			autoUpload: true,

			// Error and info messages:
			messages: {
				uploadedBytes: 'Uploaded bytes exceed file size'
			},

			// Translation function, gets the message key to be translated
			// and an object with context specific data as arguments:
			i18n: function i18n(message, context) {
				message = this.messages[message] || message.toString();
				if (context) {
					$.each(context, function (key, value) {
						message = message.replace('{' + key + '}', value);
					});
				}
				return message;
			},

			// Additional form data to be sent along with the file uploads can be set
			// using this option, which accepts an array of objects with name and
			// value properties, a function returning such an array, a FormData
			// object (for XHR file uploads), or a simple object.
			// The form of the first fileInput is given as parameter to the function:
			formData: function formData(form) {
				return form.serializeArray();
			},

			// The add callback is invoked as soon as files are added to the fileupload
			// widget (via file input selection, drag & drop, paste or add API call).
			// If the singleFileUploads option is enabled, this callback will be
			// called once for each file in the selection for XHR file uploads, else
			// once for each file selection.
			//
			// The upload starts when the submit method is invoked on the data parameter.
			// The data object contains a files property holding the added files
			// and allows you to override plugin options as well as define ajax settings.
			//
			// Listeners for this callback can also be bound the following way:
			// .bind('fileuploadadd', func);
			//
			// data.submit() returns a Promise object and allows to attach additional
			// handlers using jQuery's Deferred callbacks:
			// data.submit().done(func).fail(func).always(func);
			add: function add(e, data) {
				if (e.isDefaultPrevented()) {
					return false;
				}
				if (data.autoUpload || data.autoUpload !== false && $(this).fileupload('option', 'autoUpload')) {
					data.process().done(function () {
						data.submit();
					});
				}
			},

			// Other callbacks:

			// Callback for the submit event of each file upload:
			// submit: function (e, data) {}, // .bind('fileuploadsubmit', func);

			// Callback for the start of each file upload request:
			// send: function (e, data) {}, // .bind('fileuploadsend', func);

			// Callback for successful uploads:
			// done: function (e, data) {}, // .bind('fileuploaddone', func);

			// Callback for failed (abort or error) uploads:
			// fail: function (e, data) {}, // .bind('fileuploadfail', func);

			// Callback for completed (success, abort or error) requests:
			// always: function (e, data) {}, // .bind('fileuploadalways', func);

			// Callback for upload progress events:
			// progress: function (e, data) {}, // .bind('fileuploadprogress', func);

			// Callback for global upload progress events:
			// progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);

			// Callback for uploads start, equivalent to the global ajaxStart event:
			// start: function (e) {}, // .bind('fileuploadstart', func);

			// Callback for uploads stop, equivalent to the global ajaxStop event:
			// stop: function (e) {}, // .bind('fileuploadstop', func);

			// Callback for change events of the fileInput(s):
			// change: function (e, data) {}, // .bind('fileuploadchange', func);

			// Callback for paste events to the pasteZone(s):
			// paste: function (e, data) {}, // .bind('fileuploadpaste', func);

			// Callback for drop events of the dropZone(s):
			// drop: function (e, data) {}, // .bind('fileuploaddrop', func);

			// Callback for dragover events of the dropZone(s):
			// dragover: function (e) {}, // .bind('fileuploaddragover', func);

			// Callback before the start of each chunk upload request (before form data initialization):
			// chunkbeforesend: function (e, data) {}, // .bind('fileuploadchunkbeforesend', func);

			// Callback for the start of each chunk upload request:
			// chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);

			// Callback for successful chunk uploads:
			// chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);

			// Callback for failed (abort or error) chunk uploads:
			// chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);

			// Callback for completed (success, abort or error) chunk upload requests:
			// chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);

			// The plugin options are used as settings object for the ajax calls.
			// The following are jQuery ajax settings required for the file uploads:
			processData: false,
			contentType: false,
			cache: false,
			timeout: 0
		},

		// A list of options that require reinitializing event listeners and/or
		// special initialization code:
		_specialOptions: ['fileInput', 'dropZone', 'pasteZone', 'multipart', 'forceIframeTransport'],

		_blobSlice: $.support.blobSlice && function () {
			var slice = this.slice || this.webkitSlice || this.mozSlice;
			return slice.apply(this, arguments);
		},

		_BitrateTimer: function _BitrateTimer() {
			this.timestamp = Date.now ? Date.now() : new Date().getTime();
			this.loaded = 0;
			this.bitrate = 0;
			this.getBitrate = function (now, loaded, interval) {
				var timeDiff = now - this.timestamp;
				if (!this.bitrate || !interval || timeDiff > interval) {
					this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
					this.loaded = loaded;
					this.timestamp = now;
				}
				return this.bitrate;
			};
		},

		_isXHRUpload: function _isXHRUpload(options) {
			return !options.forceIframeTransport && (!options.multipart && $.support.xhrFileUpload || $.support.xhrFormDataFileUpload);
		},

		_getFormData: function _getFormData(options) {
			var formData;
			if ($.type(options.formData) === 'function') {
				return options.formData(options.form);
			}
			if ($.isArray(options.formData)) {
				return options.formData;
			}
			if ($.type(options.formData) === 'object') {
				formData = [];
				$.each(options.formData, function (name, value) {
					formData.push({ name: name, value: value });
				});
				return formData;
			}
			return [];
		},

		_getTotal: function _getTotal(files) {
			var total = 0;
			$.each(files, function (index, file) {
				total += file.size || 1;
			});
			return total;
		},

		_initProgressObject: function _initProgressObject(obj) {
			var progress = {
				loaded: 0,
				total: 0,
				bitrate: 0
			};
			if (obj._progress) {
				$.extend(obj._progress, progress);
			} else {
				obj._progress = progress;
			}
		},

		_initResponseObject: function _initResponseObject(obj) {
			var prop;
			if (obj._response) {
				for (prop in obj._response) {
					if (obj._response.hasOwnProperty(prop)) {
						delete obj._response[prop];
					}
				}
			} else {
				obj._response = {};
			}
		},

		_onProgress: function _onProgress(e, data) {
			if (e.lengthComputable) {
				var now = Date.now ? Date.now() : new Date().getTime(),
				    loaded;
				if (data._time && data.progressInterval && now - data._time < data.progressInterval && e.loaded !== e.total) {
					return;
				}
				data._time = now;
				loaded = Math.floor(e.loaded / e.total * (data.chunkSize || data._progress.total)) + (data.uploadedBytes || 0);
				// Add the difference from the previously loaded state
				// to the global loaded counter:
				this._progress.loaded += loaded - data._progress.loaded;
				this._progress.bitrate = this._bitrateTimer.getBitrate(now, this._progress.loaded, data.bitrateInterval);
				data._progress.loaded = data.loaded = loaded;
				data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(now, loaded, data.bitrateInterval);
				// Trigger a custom progress event with a total data property set
				// to the file size(s) of the current upload and a loaded data
				// property calculated accordingly:
				this._trigger('progress', $.Event('progress', { delegatedEvent: e }), data);
				// Trigger a global progress event for all current file uploads,
				// including ajax calls queued for sequential file uploads:
				this._trigger('progressall', $.Event('progressall', { delegatedEvent: e }), this._progress);
			}
		},

		_initProgressListener: function _initProgressListener(options) {
			var that = this,
			    xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
			// Accesss to the native XHR object is required to add event listeners
			// for the upload progress event:
			if (xhr.upload) {
				$(xhr.upload).bind('progress', function (e) {
					var oe = e.originalEvent;
					// Make sure the progress event properties get copied over:
					e.lengthComputable = oe.lengthComputable;
					e.loaded = oe.loaded;
					e.total = oe.total;
					that._onProgress(e, options);
				});
				options.xhr = function () {
					return xhr;
				};
			}
		},

		_deinitProgressListener: function _deinitProgressListener(options) {
			var xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
			if (xhr.upload) {
				$(xhr.upload).unbind('progress');
			}
		},

		_isInstanceOf: function _isInstanceOf(type, obj) {
			// Cross-frame instanceof check
			return Object.prototype.toString.call(obj) === '[object ' + type + ']';
		},

		_initXHRData: function _initXHRData(options) {
			var that = this,
			    formData,
			    file = options.files[0],

			// Ignore non-multipart setting if not supported:
			multipart = options.multipart || !$.support.xhrFileUpload,
			    paramName = $.type(options.paramName) === 'array' ? options.paramName[0] : options.paramName;
			options.headers = $.extend({}, options.headers);
			if (options.contentRange) {
				options.headers['Content-Range'] = options.contentRange;
			}
			if (!multipart || options.blob || !this._isInstanceOf('File', file)) {
				options.headers['Content-Disposition'] = 'attachment; filename="' + encodeURI(file.uploadName || file.name) + '"';
			}
			if (!multipart) {
				options.contentType = file.type || 'application/octet-stream';
				options.data = options.blob || file;
			} else if ($.support.xhrFormDataFileUpload) {
				if (options.postMessage) {
					// window.postMessage does not allow sending FormData
					// objects, so we just add the File/Blob objects to
					// the formData array and let the postMessage window
					// create the FormData object out of this array:
					formData = this._getFormData(options);
					if (options.blob) {
						formData.push({
							name: paramName,
							value: options.blob
						});
					} else {
						$.each(options.files, function (index, file) {
							formData.push({
								name: $.type(options.paramName) === 'array' && options.paramName[index] || paramName,
								value: file
							});
						});
					}
				} else {
					if (that._isInstanceOf('FormData', options.formData)) {
						formData = options.formData;
					} else {
						formData = new FormData();
						$.each(this._getFormData(options), function (index, field) {
							formData.append(field.name, field.value);
						});
					}
					if (options.blob) {
						formData.append(paramName, options.blob, file.uploadName || file.name);
					} else {
						$.each(options.files, function (index, file) {
							// This check allows the tests to run with
							// dummy objects:
							if (that._isInstanceOf('File', file) || that._isInstanceOf('Blob', file)) {
								formData.append($.type(options.paramName) === 'array' && options.paramName[index] || paramName, file, file.uploadName || file.name);
							}
						});
					}
				}
				options.data = formData;
			}
			// Blob reference is not needed anymore, free memory:
			options.blob = null;
		},

		_initIframeSettings: function _initIframeSettings(options) {
			var targetHost = $('<a></a>').prop('href', options.url).prop('host');
			// Setting the dataType to iframe enables the iframe transport:
			options.dataType = 'iframe ' + (options.dataType || '');
			// The iframe transport accepts a serialized array as form data:
			options.formData = this._getFormData(options);
			// Add redirect url to form data on cross-domain uploads:
			if (options.redirect && targetHost && targetHost !== location.host) {
				options.formData.push({
					name: options.redirectParamName || 'redirect',
					value: options.redirect
				});
			}
		},

		_initDataSettings: function _initDataSettings(options) {
			if (this._isXHRUpload(options)) {
				if (!this._chunkedUpload(options, true)) {
					if (!options.data) {
						this._initXHRData(options);
					}
					this._initProgressListener(options);
				}
				if (options.postMessage) {
					// Setting the dataType to postmessage enables the
					// postMessage transport:
					options.dataType = 'postmessage ' + (options.dataType || '');
				}
			} else {
				this._initIframeSettings(options);
			}
		},

		_getParamName: function _getParamName(options) {
			var fileInput = $(options.fileInput),
			    paramName = options.paramName;
			if (!paramName) {
				paramName = [];
				fileInput.each(function () {
					var input = $(this),
					    name = input.prop('name') || 'files[]',
					    i = (input.prop('files') || [1]).length;
					while (i) {
						paramName.push(name);
						i -= 1;
					}
				});
				if (!paramName.length) {
					paramName = [fileInput.prop('name') || 'files[]'];
				}
			} else if (!$.isArray(paramName)) {
				paramName = [paramName];
			}
			return paramName;
		},

		_initFormSettings: function _initFormSettings(options) {
			// Retrieve missing options from the input field and the
			// associated form, if available:
			if (!options.form || !options.form.length) {
				options.form = $(options.fileInput.prop('form'));
				// If the given file input doesn't have an associated form,
				// use the default widget file input's form:
				if (!options.form.length) {
					options.form = $(this.options.fileInput.prop('form'));
				}
			}
			options.paramName = this._getParamName(options);
			if (!options.url) {
				options.url = options.form.prop('action') || location.href;
			}
			// The HTTP request method must be "POST" or "PUT":
			options.type = (options.type || $.type(options.form.prop('method')) === 'string' && options.form.prop('method') || '').toUpperCase();
			if (options.type !== 'POST' && options.type !== 'PUT' && options.type !== 'PATCH') {
				options.type = 'POST';
			}
			if (!options.formAcceptCharset) {
				options.formAcceptCharset = options.form.attr('accept-charset');
			}
		},

		_getAJAXSettings: function _getAJAXSettings(data) {
			var options = $.extend({}, this.options, data);
			this._initFormSettings(options);
			this._initDataSettings(options);
			return options;
		},

		// jQuery 1.6 doesn't provide .state(),
		// while jQuery 1.8+ removed .isRejected() and .isResolved():
		_getDeferredState: function _getDeferredState(deferred) {
			if (deferred.state) {
				return deferred.state();
			}
			if (deferred.isResolved()) {
				return 'resolved';
			}
			if (deferred.isRejected()) {
				return 'rejected';
			}
			return 'pending';
		},

		// Maps jqXHR callbacks to the equivalent
		// methods of the given Promise object:
		_enhancePromise: function _enhancePromise(promise) {
			promise.success = promise.done;
			promise.error = promise.fail;
			promise.complete = promise.always;
			return promise;
		},

		// Creates and returns a Promise object enhanced with
		// the jqXHR methods abort, success, error and complete:
		_getXHRPromise: function _getXHRPromise(resolveOrReject, context, args) {
			var dfd = $.Deferred(),
			    promise = dfd.promise();
			context = context || this.options.context || promise;
			if (resolveOrReject === true) {
				dfd.resolveWith(context, args);
			} else if (resolveOrReject === false) {
				dfd.rejectWith(context, args);
			}
			promise.abort = dfd.promise;
			return this._enhancePromise(promise);
		},

		// Adds convenience methods to the data callback argument:
		_addConvenienceMethods: function _addConvenienceMethods(e, data) {
			var that = this,
			    getPromise = function getPromise(args) {
				return $.Deferred().resolveWith(that, args).promise();
			};
			data.process = function (resolveFunc, rejectFunc) {
				if (resolveFunc || rejectFunc) {
					data._processQueue = this._processQueue = (this._processQueue || getPromise([this])).then(function () {
						if (data.errorThrown) {
							return $.Deferred().rejectWith(that, [data]).promise();
						}
						return getPromise(arguments);
					}).then(resolveFunc, rejectFunc);
				}
				return this._processQueue || getPromise([this]);
			};
			data.submit = function () {
				if (this.state() !== 'pending') {
					data.jqXHR = this.jqXHR = that._trigger('submit', $.Event('submit', { delegatedEvent: e }), this) !== false && that._onSend(e, this);
				}
				return this.jqXHR || that._getXHRPromise();
			};
			data.abort = function () {
				if (this.jqXHR) {
					return this.jqXHR.abort();
				}
				this.errorThrown = 'abort';
				that._trigger('fail', null, this);
				return that._getXHRPromise(false);
			};
			data.state = function () {
				if (this.jqXHR) {
					return that._getDeferredState(this.jqXHR);
				}
				if (this._processQueue) {
					return that._getDeferredState(this._processQueue);
				}
			};
			data.processing = function () {
				return !this.jqXHR && this._processQueue && that._getDeferredState(this._processQueue) === 'pending';
			};
			data.progress = function () {
				return this._progress;
			};
			data.response = function () {
				return this._response;
			};
		},

		// Parses the Range header from the server response
		// and returns the uploaded bytes:
		_getUploadedBytes: function _getUploadedBytes(jqXHR) {
			var range = jqXHR.getResponseHeader('Range'),
			    parts = range && range.split('-'),
			    upperBytesPos = parts && parts.length > 1 && parseInt(parts[1], 10);
			return upperBytesPos && upperBytesPos + 1;
		},

		// Uploads a file in multiple, sequential requests
		// by splitting the file up in multiple blob chunks.
		// If the second parameter is true, only tests if the file
		// should be uploaded in chunks, but does not invoke any
		// upload requests:
		_chunkedUpload: function _chunkedUpload(options, testOnly) {
			options.uploadedBytes = options.uploadedBytes || 0;
			var that = this,
			    file = options.files[0],
			    fs = file.size,
			    ub = options.uploadedBytes,
			    mcs = options.maxChunkSize || fs,
			    slice = this._blobSlice,
			    dfd = $.Deferred(),
			    promise = dfd.promise(),
			    jqXHR,
			    _upload;
			if (!(this._isXHRUpload(options) && slice && (ub || ($.type(mcs) === 'function' ? mcs(options) : mcs) < fs)) || options.data) {
				return false;
			}
			if (testOnly) {
				return true;
			}
			if (ub >= fs) {
				file.error = options.i18n('uploadedBytes');
				return this._getXHRPromise(false, options.context, [null, 'error', file.error]);
			}
			// The chunk upload method:
			_upload = function upload() {
				// Clone the options object for each chunk upload:
				var o = $.extend({}, options),
				    currentLoaded = o._progress.loaded;
				o.blob = slice.call(file, ub, ub + ($.type(mcs) === 'function' ? mcs(o) : mcs), file.type);
				// Store the current chunk size, as the blob itself
				// will be dereferenced after data processing:
				o.chunkSize = o.blob.size;
				// Expose the chunk bytes position range:
				o.contentRange = 'bytes ' + ub + '-' + (ub + o.chunkSize - 1) + '/' + fs;
				// Trigger chunkbeforesend to allow form data to be updated for this chunk
				that._trigger('chunkbeforesend', null, o);
				// Process the upload data (the blob and potential form data):
				that._initXHRData(o);
				// Add progress listeners for this chunk upload:
				that._initProgressListener(o);
				jqXHR = (that._trigger('chunksend', null, o) !== false && $.ajax(o) || that._getXHRPromise(false, o.context)).done(function (result, textStatus, jqXHR) {
					ub = that._getUploadedBytes(jqXHR) || ub + o.chunkSize;
					// Create a progress event if no final progress event
					// with loaded equaling total has been triggered
					// for this chunk:
					if (currentLoaded + o.chunkSize - o._progress.loaded) {
						that._onProgress($.Event('progress', {
							lengthComputable: true,
							loaded: ub - o.uploadedBytes,
							total: ub - o.uploadedBytes
						}), o);
					}
					options.uploadedBytes = o.uploadedBytes = ub;
					o.result = result;
					o.textStatus = textStatus;
					o.jqXHR = jqXHR;
					that._trigger('chunkdone', null, o);
					that._trigger('chunkalways', null, o);
					if (ub < fs) {
						// File upload not yet complete,
						// continue with the next chunk:
						_upload();
					} else {
						dfd.resolveWith(o.context, [result, textStatus, jqXHR]);
					}
				}).fail(function (jqXHR, textStatus, errorThrown) {
					o.jqXHR = jqXHR;
					o.textStatus = textStatus;
					o.errorThrown = errorThrown;
					that._trigger('chunkfail', null, o);
					that._trigger('chunkalways', null, o);
					dfd.rejectWith(o.context, [jqXHR, textStatus, errorThrown]);
				}).always(function () {
					that._deinitProgressListener(o);
				});
			};
			this._enhancePromise(promise);
			promise.abort = function () {
				return jqXHR.abort();
			};
			_upload();
			return promise;
		},

		_beforeSend: function _beforeSend(e, data) {
			if (this._active === 0) {
				// the start callback is triggered when an upload starts
				// and no other uploads are currently running,
				// equivalent to the global ajaxStart event:
				this._trigger('start');
				// Set timer for global bitrate progress calculation:
				this._bitrateTimer = new this._BitrateTimer();
				// Reset the global progress values:
				this._progress.loaded = this._progress.total = 0;
				this._progress.bitrate = 0;
			}
			// Make sure the container objects for the .response() and
			// .progress() methods on the data object are available
			// and reset to their initial state:
			this._initResponseObject(data);
			this._initProgressObject(data);
			data._progress.loaded = data.loaded = data.uploadedBytes || 0;
			data._progress.total = data.total = this._getTotal(data.files) || 1;
			data._progress.bitrate = data.bitrate = 0;
			this._active += 1;
			// Initialize the global progress values:
			this._progress.loaded += data.loaded;
			this._progress.total += data.total;
		},

		_onDone: function _onDone(result, textStatus, jqXHR, options) {
			var total = options._progress.total,
			    response = options._response;
			if (options._progress.loaded < total) {
				// Create a progress event if no final progress event
				// with loaded equaling total has been triggered:
				this._onProgress($.Event('progress', {
					lengthComputable: true,
					loaded: total,
					total: total
				}), options);
			}
			response.result = options.result = result;
			response.textStatus = options.textStatus = textStatus;
			response.jqXHR = options.jqXHR = jqXHR;
			this._trigger('done', null, options);
		},

		_onFail: function _onFail(jqXHR, textStatus, errorThrown, options) {
			var response = options._response;
			if (options.recalculateProgress) {
				// Remove the failed (error or abort) file upload from
				// the global progress calculation:
				this._progress.loaded -= options._progress.loaded;
				this._progress.total -= options._progress.total;
			}
			response.jqXHR = options.jqXHR = jqXHR;
			response.textStatus = options.textStatus = textStatus;
			response.errorThrown = options.errorThrown = errorThrown;
			this._trigger('fail', null, options);
		},

		_onAlways: function _onAlways(jqXHRorResult, textStatus, jqXHRorError, options) {
			// jqXHRorResult, textStatus and jqXHRorError are added to the
			// options object via done and fail callbacks
			this._trigger('always', null, options);
		},

		_onSend: function _onSend(e, data) {
			if (!data.submit) {
				this._addConvenienceMethods(e, data);
			}
			var that = this,
			    jqXHR,
			    aborted,
			    slot,
			    pipe,
			    options = that._getAJAXSettings(data),
			    send = function send() {
				that._sending += 1;
				// Set timer for bitrate progress calculation:
				options._bitrateTimer = new that._BitrateTimer();
				jqXHR = jqXHR || ((aborted || that._trigger('send', $.Event('send', { delegatedEvent: e }), options) === false) && that._getXHRPromise(false, options.context, aborted) || that._chunkedUpload(options) || $.ajax(options)).done(function (result, textStatus, jqXHR) {
					that._onDone(result, textStatus, jqXHR, options);
				}).fail(function (jqXHR, textStatus, errorThrown) {
					that._onFail(jqXHR, textStatus, errorThrown, options);
				}).always(function (jqXHRorResult, textStatus, jqXHRorError) {
					that._deinitProgressListener(options);
					that._onAlways(jqXHRorResult, textStatus, jqXHRorError, options);
					that._sending -= 1;
					that._active -= 1;
					if (options.limitConcurrentUploads && options.limitConcurrentUploads > that._sending) {
						// Start the next queued upload,
						// that has not been aborted:
						var nextSlot = that._slots.shift();
						while (nextSlot) {
							if (that._getDeferredState(nextSlot) === 'pending') {
								nextSlot.resolve();
								break;
							}
							nextSlot = that._slots.shift();
						}
					}
					if (that._active === 0) {
						// The stop callback is triggered when all uploads have
						// been completed, equivalent to the global ajaxStop event:
						that._trigger('stop');
					}
				});
				return jqXHR;
			};
			this._beforeSend(e, options);
			if (this.options.sequentialUploads || this.options.limitConcurrentUploads && this.options.limitConcurrentUploads <= this._sending) {
				if (this.options.limitConcurrentUploads > 1) {
					slot = $.Deferred();
					this._slots.push(slot);
					pipe = slot.then(send);
				} else {
					this._sequence = this._sequence.then(send, send);
					pipe = this._sequence;
				}
				// Return the piped Promise object, enhanced with an abort method,
				// which is delegated to the jqXHR object of the current upload,
				// and jqXHR callbacks mapped to the equivalent Promise methods:
				pipe.abort = function () {
					aborted = [undefined, 'abort', 'abort'];
					if (!jqXHR) {
						if (slot) {
							slot.rejectWith(options.context, aborted);
						}
						return send();
					}
					return jqXHR.abort();
				};
				return this._enhancePromise(pipe);
			}
			return send();
		},

		_onAdd: function _onAdd(e, data) {
			var that = this,
			    result = true,
			    options = $.extend({}, this.options, data),
			    files = data.files,
			    filesLength = files.length,
			    limit = options.limitMultiFileUploads,
			    limitSize = options.limitMultiFileUploadSize,
			    overhead = options.limitMultiFileUploadSizeOverhead,
			    batchSize = 0,
			    paramName = this._getParamName(options),
			    paramNameSet,
			    paramNameSlice,
			    fileSet,
			    i,
			    j = 0;
			if (!filesLength) {
				return false;
			}
			if (limitSize && files[0].size === undefined) {
				limitSize = undefined;
			}
			if (!(options.singleFileUploads || limit || limitSize) || !this._isXHRUpload(options)) {
				fileSet = [files];
				paramNameSet = [paramName];
			} else if (!(options.singleFileUploads || limitSize) && limit) {
				fileSet = [];
				paramNameSet = [];
				for (i = 0; i < filesLength; i += limit) {
					fileSet.push(files.slice(i, i + limit));
					paramNameSlice = paramName.slice(i, i + limit);
					if (!paramNameSlice.length) {
						paramNameSlice = paramName;
					}
					paramNameSet.push(paramNameSlice);
				}
			} else if (!options.singleFileUploads && limitSize) {
				fileSet = [];
				paramNameSet = [];
				for (i = 0; i < filesLength; i = i + 1) {
					batchSize += files[i].size + overhead;
					if (i + 1 === filesLength || batchSize + files[i + 1].size + overhead > limitSize || limit && i + 1 - j >= limit) {
						fileSet.push(files.slice(j, i + 1));
						paramNameSlice = paramName.slice(j, i + 1);
						if (!paramNameSlice.length) {
							paramNameSlice = paramName;
						}
						paramNameSet.push(paramNameSlice);
						j = i + 1;
						batchSize = 0;
					}
				}
			} else {
				paramNameSet = paramName;
			}
			data.originalFiles = files;
			$.each(fileSet || files, function (index, element) {
				var newData = $.extend({}, data);
				newData.files = fileSet ? element : [element];
				newData.paramName = paramNameSet[index];
				that._initResponseObject(newData);
				that._initProgressObject(newData);
				that._addConvenienceMethods(e, newData);
				result = that._trigger('add', $.Event('add', { delegatedEvent: e }), newData);
				return result;
			});
			return result;
		},

		_replaceFileInput: function _replaceFileInput(data) {
			var input = data.fileInput,
			    inputClone = input.clone(true),
			    restoreFocus = input.is(document.activeElement);
			// Add a reference for the new cloned file input to the data argument:
			data.fileInputClone = inputClone;
			$('<form></form>').append(inputClone)[0].reset();
			// Detaching allows to insert the fileInput on another form
			// without loosing the file input value:
			input.after(inputClone).detach();
			// If the fileInput had focus before it was detached,
			// restore focus to the inputClone.
			if (restoreFocus) {
				inputClone.focus();
			}
			// Avoid memory leaks with the detached file input:
			$.cleanData(input.unbind('remove'));
			// Replace the original file input element in the fileInput
			// elements set with the clone, which has been copied including
			// event handlers:
			this.options.fileInput = this.options.fileInput.map(function (i, el) {
				if (el === input[0]) {
					return inputClone[0];
				}
				return el;
			});
			// If the widget has been initialized on the file input itself,
			// override this.element with the file input clone:
			if (input[0] === this.element[0]) {
				this.element = inputClone;
			}
		},

		_handleFileTreeEntry: function _handleFileTreeEntry(entry, path) {
			var that = this,
			    dfd = $.Deferred(),
			    entries = [],
			    dirReader,
			    errorHandler = function errorHandler(e) {
				if (e && !e.entry) {
					e.entry = entry;
				}
				// Since $.when returns immediately if one
				// Deferred is rejected, we use resolve instead.
				// This allows valid files and invalid items
				// to be returned together in one set:
				dfd.resolve([e]);
			},
			    successHandler = function successHandler(entries) {
				that._handleFileTreeEntries(entries, path + entry.name + '/').done(function (files) {
					dfd.resolve(files);
				}).fail(errorHandler);
			},
			    readEntries = function readEntries() {
				dirReader.readEntries(function (results) {
					if (!results.length) {
						successHandler(entries);
					} else {
						entries = entries.concat(results);
						readEntries();
					}
				}, errorHandler);
			};
			path = path || '';
			if (entry.isFile) {
				if (entry._file) {
					// Workaround for Chrome bug #149735
					entry._file.relativePath = path;
					dfd.resolve(entry._file);
				} else {
					entry.file(function (file) {
						file.relativePath = path;
						dfd.resolve(file);
					}, errorHandler);
				}
			} else if (entry.isDirectory) {
				dirReader = entry.createReader();
				readEntries();
			} else {
				// Return an empty list for file system items
				// other than files or directories:
				dfd.resolve([]);
			}
			return dfd.promise();
		},

		_handleFileTreeEntries: function _handleFileTreeEntries(entries, path) {
			var that = this;
			return $.when.apply($, $.map(entries, function (entry) {
				return that._handleFileTreeEntry(entry, path);
			})).then(function () {
				return Array.prototype.concat.apply([], arguments);
			});
		},

		_getDroppedFiles: function _getDroppedFiles(dataTransfer) {
			dataTransfer = dataTransfer || {};
			var items = dataTransfer.items;
			if (items && items.length && (items[0].webkitGetAsEntry || items[0].getAsEntry)) {
				return this._handleFileTreeEntries($.map(items, function (item) {
					var entry;
					if (item.webkitGetAsEntry) {
						entry = item.webkitGetAsEntry();
						if (entry) {
							// Workaround for Chrome bug #149735:
							entry._file = item.getAsFile();
						}
						return entry;
					}
					return item.getAsEntry();
				}));
			}
			return $.Deferred().resolve($.makeArray(dataTransfer.files)).promise();
		},

		_getSingleFileInputFiles: function _getSingleFileInputFiles(fileInput) {
			fileInput = $(fileInput);
			var entries = fileInput.prop('webkitEntries') || fileInput.prop('entries'),
			    files,
			    value;
			if (entries && entries.length) {
				return this._handleFileTreeEntries(entries);
			}
			files = $.makeArray(fileInput.prop('files'));
			if (!files.length) {
				value = fileInput.prop('value');
				if (!value) {
					return $.Deferred().resolve([]).promise();
				}
				// If the files property is not available, the browser does not
				// support the File API and we add a pseudo File object with
				// the input value as name with path information removed:
				files = [{ name: value.replace(/^.*\\/, '') }];
			} else if (files[0].name === undefined && files[0].fileName) {
				// File normalization for Safari 4 and Firefox 3:
				$.each(files, function (index, file) {
					file.name = file.fileName;
					file.size = file.fileSize;
				});
			}
			return $.Deferred().resolve(files).promise();
		},

		_getFileInputFiles: function _getFileInputFiles(fileInput) {
			if (!(fileInput instanceof $) || fileInput.length === 1) {
				return this._getSingleFileInputFiles(fileInput);
			}
			return $.when.apply($, $.map(fileInput, this._getSingleFileInputFiles)).then(function () {
				return Array.prototype.concat.apply([], arguments);
			});
		},

		_onChange: function _onChange(e) {
			var that = this,
			    data = {
				fileInput: $(e.target),
				form: $(e.target.form)
			};
			this._getFileInputFiles(data.fileInput).always(function (files) {
				data.files = files;
				if (that.options.replaceFileInput) {
					that._replaceFileInput(data);
				}
				if (that._trigger('change', $.Event('change', { delegatedEvent: e }), data) !== false) {
					that._onAdd(e, data);
				}
			});
		},

		_onPaste: function _onPaste(e) {
			var items = e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.items,
			    data = { files: [] };
			if (items && items.length) {
				$.each(items, function (index, item) {
					var file = item.getAsFile && item.getAsFile();
					if (file) {
						data.files.push(file);
					}
				});
				if (this._trigger('paste', $.Event('paste', { delegatedEvent: e }), data) !== false) {
					this._onAdd(e, data);
				}
			}
		},

		_onDrop: function _onDrop(e) {
			e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
			var that = this,
			    dataTransfer = e.dataTransfer,
			    data = {};
			if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
				e.preventDefault();
				this._getDroppedFiles(dataTransfer).always(function (files) {
					data.files = files;
					if (that._trigger('drop', $.Event('drop', { delegatedEvent: e }), data) !== false) {
						that._onAdd(e, data);
					}
				});
			}
		},

		_onDragOver: getDragHandler('dragover'),

		_onDragEnter: getDragHandler('dragenter'),

		_onDragLeave: getDragHandler('dragleave'),

		_initEventHandlers: function _initEventHandlers() {
			if (this._isXHRUpload(this.options)) {
				this._on(this.options.dropZone, {
					dragover: this._onDragOver,
					drop: this._onDrop,
					// event.preventDefault() on dragenter is required for IE10+:
					dragenter: this._onDragEnter,
					// dragleave is not required, but added for completeness:
					dragleave: this._onDragLeave
				});
				this._on(this.options.pasteZone, {
					paste: this._onPaste
				});
			}
			if ($.support.fileInput) {
				this._on(this.options.fileInput, {
					change: this._onChange
				});
			}
		},

		_destroyEventHandlers: function _destroyEventHandlers() {
			this._off(this.options.dropZone, 'dragenter dragleave dragover drop');
			this._off(this.options.pasteZone, 'paste');
			this._off(this.options.fileInput, 'change');
		},

		_destroy: function _destroy() {
			this._destroyEventHandlers();
		},

		_setOption: function _setOption(key, value) {
			var reinit = $.inArray(key, this._specialOptions) !== -1;
			if (reinit) {
				this._destroyEventHandlers();
			}
			this._super(key, value);
			if (reinit) {
				this._initSpecialOptions();
				this._initEventHandlers();
			}
		},

		_initSpecialOptions: function _initSpecialOptions() {
			var options = this.options;
			if (options.fileInput === undefined) {
				options.fileInput = this.element.is('input[type="file"]') ? this.element : this.element.find('input[type="file"]');
			} else if (!(options.fileInput instanceof $)) {
				options.fileInput = $(options.fileInput);
			}
			if (!(options.dropZone instanceof $)) {
				options.dropZone = $(options.dropZone);
			}
			if (!(options.pasteZone instanceof $)) {
				options.pasteZone = $(options.pasteZone);
			}
		},

		_getRegExp: function _getRegExp(str) {
			var parts = str.split('/'),
			    modifiers = parts.pop();
			parts.shift();
			return new RegExp(parts.join('/'), modifiers);
		},

		_isRegExpOption: function _isRegExpOption(key, value) {
			return key !== 'url' && $.type(value) === 'string' && /^\/.*\/[igm]{0,3}$/.test(value);
		},

		_initDataAttributes: function _initDataAttributes() {
			var that = this,
			    options = this.options,
			    data = this.element.data();
			// Initialize options set via HTML5 data-attributes:
			$.each(this.element[0].attributes, function (index, attr) {
				var key = attr.name.toLowerCase(),
				    value;
				if (/^data-/.test(key)) {
					// Convert hyphen-ated key to camelCase:
					key = key.slice(5).replace(/-[a-z]/g, function (str) {
						return str.charAt(1).toUpperCase();
					});
					value = data[key];
					if (that._isRegExpOption(key, value)) {
						value = that._getRegExp(value);
					}
					options[key] = value;
				}
			});
		},

		_create: function _create() {
			this._initDataAttributes();
			this._initSpecialOptions();
			this._slots = [];
			this._sequence = this._getXHRPromise(true);
			this._sending = this._active = 0;
			this._initProgressObject(this);
			this._initEventHandlers();
		},

		// This method is exposed to the widget API and allows to query
		// the number of active uploads:
		active: function active() {
			return this._active;
		},

		// This method is exposed to the widget API and allows to query
		// the widget upload progress.
		// It returns an object with loaded, total and bitrate properties
		// for the running uploads:
		progress: function progress() {
			return this._progress;
		},

		// This method is exposed to the widget API and allows adding files
		// using the fileupload API. The data parameter accepts an object which
		// must have a files property and can contain additional options:
		// .fileupload('add', {files: filesList});
		add: function add(data) {
			var that = this;
			if (!data || this.options.disabled) {
				return;
			}
			if (data.fileInput && !data.files) {
				this._getFileInputFiles(data.fileInput).always(function (files) {
					data.files = files;
					that._onAdd(null, data);
				});
			} else {
				data.files = $.makeArray(data.files);
				this._onAdd(null, data);
			}
		},

		// This method is exposed to the widget API and allows sending files
		// using the fileupload API. The data parameter accepts an object which
		// must have a files or fileInput property and can contain additional options:
		// .fileupload('send', {files: filesList});
		// The method returns a Promise object for the file upload call.
		send: function send(data) {
			if (data && !this.options.disabled) {
				if (data.fileInput && !data.files) {
					var that = this,
					    dfd = $.Deferred(),
					    promise = dfd.promise(),
					    jqXHR,
					    aborted;
					promise.abort = function () {
						aborted = true;
						if (jqXHR) {
							return jqXHR.abort();
						}
						dfd.reject(null, 'abort', 'abort');
						return promise;
					};
					this._getFileInputFiles(data.fileInput).always(function (files) {
						if (aborted) {
							return;
						}
						if (!files.length) {
							dfd.reject();
							return;
						}
						data.files = files;
						jqXHR = that._onSend(null, data);
						jqXHR.then(function (result, textStatus, jqXHR) {
							dfd.resolve(result, textStatus, jqXHR);
						}, function (jqXHR, textStatus, errorThrown) {
							dfd.reject(jqXHR, textStatus, errorThrown);
						});
					});
					return this._enhancePromise(promise);
				}
				data.files = $.makeArray(data.files);
				if (data.files.length) {
					return this._onSend(null, data);
				}
			}
			return this._getXHRPromise(false, data && data.context);
		}

	});
});
/* epub stuff */
/*!

JSZip - A Javascript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
!function (a) {
	if ("object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module) module.exports = a();else if ("function" == typeof define && define.amd) define([], a);else {
		var b;"undefined" != typeof window ? b = window : "undefined" != typeof global ? b = global : "undefined" != typeof self && (b = self), b.JSZip = a();
	}
}(function () {
	return function a(b, c, d) {
		function e(g, h) {
			if (!c[g]) {
				if (!b[g]) {
					var i = "function" == typeof require && require;if (!h && i) return i(g, !0);if (f) return f(g, !0);throw new Error("Cannot find module '" + g + "'");
				}var j = c[g] = { exports: {} };b[g][0].call(j.exports, function (a) {
					var c = b[g][1][a];return e(c ? c : a);
				}, j, j.exports, a, b, c, d);
			}return c[g].exports;
		}for (var f = "function" == typeof require && require, g = 0; g < d.length; g++) {
			e(d[g]);
		}return e;
	}({ 1: [function (a, b, c) {
			"use strict";
			var d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";c.encode = function (a) {
				for (var b, c, e, f, g, h, i, j = "", k = 0; k < a.length;) {
					b = a.charCodeAt(k++), c = a.charCodeAt(k++), e = a.charCodeAt(k++), f = b >> 2, g = (3 & b) << 4 | c >> 4, h = (15 & c) << 2 | e >> 6, i = 63 & e, isNaN(c) ? h = i = 64 : isNaN(e) && (i = 64), j = j + d.charAt(f) + d.charAt(g) + d.charAt(h) + d.charAt(i);
				}return j;
			}, c.decode = function (a) {
				var b,
				    c,
				    e,
				    f,
				    g,
				    h,
				    i,
				    j = "",
				    k = 0;for (a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""); k < a.length;) {
					f = d.indexOf(a.charAt(k++)), g = d.indexOf(a.charAt(k++)), h = d.indexOf(a.charAt(k++)), i = d.indexOf(a.charAt(k++)), b = f << 2 | g >> 4, c = (15 & g) << 4 | h >> 2, e = (3 & h) << 6 | i, j += String.fromCharCode(b), 64 != h && (j += String.fromCharCode(c)), 64 != i && (j += String.fromCharCode(e));
				}return j;
			};
		}, {}], 2: [function (a, b) {
			"use strict";
			function c() {
				this.compressedSize = 0, this.uncompressedSize = 0, this.crc32 = 0, this.compressionMethod = null, this.compressedContent = null;
			}c.prototype = { getContent: function getContent() {
					return null;
				}, getCompressedContent: function getCompressedContent() {
					return null;
				} }, b.exports = c;
		}, {}], 3: [function (a, b, c) {
			"use strict";
			c.STORE = { magic: "\x00\x00", compress: function compress(a) {
					return a;
				}, uncompress: function uncompress(a) {
					return a;
				}, compressInputType: null, uncompressInputType: null }, c.DEFLATE = a("./flate");
		}, { "./flate": 8 }], 4: [function (a, b) {
			"use strict";
			var c = a("./utils"),
			    d = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];b.exports = function (a, b) {
				if ("undefined" == typeof a || !a.length) return 0;var e = "string" !== c.getTypeOf(a);"undefined" == typeof b && (b = 0);var f = 0,
				    g = 0,
				    h = 0;b = -1 ^ b;for (var i = 0, j = a.length; j > i; i++) {
					h = e ? a[i] : a.charCodeAt(i), g = 255 & (b ^ h), f = d[g], b = b >>> 8 ^ f;
				}return -1 ^ b;
			};
		}, { "./utils": 21 }], 5: [function (a, b) {
			"use strict";
			function c() {
				this.data = null, this.length = 0, this.index = 0;
			}var d = a("./utils");c.prototype = { checkOffset: function checkOffset(a) {
					this.checkIndex(this.index + a);
				}, checkIndex: function checkIndex(a) {
					if (this.length < a || 0 > a) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
				}, setIndex: function setIndex(a) {
					this.checkIndex(a), this.index = a;
				}, skip: function skip(a) {
					this.setIndex(this.index + a);
				}, byteAt: function byteAt() {}, readInt: function readInt(a) {
					var b,
					    c = 0;for (this.checkOffset(a), b = this.index + a - 1; b >= this.index; b--) {
						c = (c << 8) + this.byteAt(b);
					}return this.index += a, c;
				}, readString: function readString(a) {
					return d.transformTo("string", this.readData(a));
				}, readData: function readData() {}, lastIndexOfSignature: function lastIndexOfSignature() {}, readDate: function readDate() {
					var a = this.readInt(4);return new Date((a >> 25 & 127) + 1980, (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1);
				} }, b.exports = c;
		}, { "./utils": 21 }], 6: [function (a, b, c) {
			"use strict";
			c.base64 = !1, c.binary = !1, c.dir = !1, c.createFolders = !1, c.date = null, c.compression = null, c.compressionOptions = null, c.comment = null, c.unixPermissions = null, c.dosPermissions = null;
		}, {}], 7: [function (a, b, c) {
			"use strict";
			var d = a("./utils");c.string2binary = function (a) {
				return d.string2binary(a);
			}, c.string2Uint8Array = function (a) {
				return d.transformTo("uint8array", a);
			}, c.uint8Array2String = function (a) {
				return d.transformTo("string", a);
			}, c.string2Blob = function (a) {
				var b = d.transformTo("arraybuffer", a);return d.arrayBuffer2Blob(b);
			}, c.arrayBuffer2Blob = function (a) {
				return d.arrayBuffer2Blob(a);
			}, c.transformTo = function (a, b) {
				return d.transformTo(a, b);
			}, c.getTypeOf = function (a) {
				return d.getTypeOf(a);
			}, c.checkSupport = function (a) {
				return d.checkSupport(a);
			}, c.MAX_VALUE_16BITS = d.MAX_VALUE_16BITS, c.MAX_VALUE_32BITS = d.MAX_VALUE_32BITS, c.pretty = function (a) {
				return d.pretty(a);
			}, c.findCompression = function (a) {
				return d.findCompression(a);
			}, c.isRegExp = function (a) {
				return d.isRegExp(a);
			};
		}, { "./utils": 21 }], 8: [function (a, b, c) {
			"use strict";
			var d = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array,
			    e = a("pako");c.uncompressInputType = d ? "uint8array" : "array", c.compressInputType = d ? "uint8array" : "array", c.magic = "\b\x00", c.compress = function (a, b) {
				return e.deflateRaw(a, { level: b.level || -1 });
			}, c.uncompress = function (a) {
				return e.inflateRaw(a);
			};
		}, { pako: 24 }], 9: [function (a, b) {
			"use strict";
			function c(a, b) {
				return this instanceof c ? (this.files = {}, this.comment = null, this.root = "", a && this.load(a, b), void (this.clone = function () {
					var a = new c();for (var b in this) {
						"function" != typeof this[b] && (a[b] = this[b]);
					}return a;
				})) : new c(a, b);
			}var d = a("./base64");c.prototype = a("./object"), c.prototype.load = a("./load"), c.support = a("./support"), c.defaults = a("./defaults"), c.utils = a("./deprecatedPublicUtils"), c.base64 = { encode: function encode(a) {
					return d.encode(a);
				}, decode: function decode(a) {
					return d.decode(a);
				} }, c.compressions = a("./compressions"), b.exports = c;
		}, { "./base64": 1, "./compressions": 3, "./defaults": 6, "./deprecatedPublicUtils": 7, "./load": 10, "./object": 13, "./support": 17 }], 10: [function (a, b) {
			"use strict";
			var c = a("./base64"),
			    d = a("./zipEntries");b.exports = function (a, b) {
				var e, f, g, h;for (b = b || {}, b.base64 && (a = c.decode(a)), f = new d(a, b), e = f.files, g = 0; g < e.length; g++) {
					h = e[g], this.file(h.fileName, h.decompressed, { binary: !0, optimizedBinaryString: !0, date: h.date, dir: h.dir, comment: h.fileComment.length ? h.fileComment : null, unixPermissions: h.unixPermissions, dosPermissions: h.dosPermissions, createFolders: b.createFolders });
				}return f.zipComment.length && (this.comment = f.zipComment), this;
			};
		}, { "./base64": 1, "./zipEntries": 22 }], 11: [function (a, b) {
			(function (a) {
				"use strict";
				b.exports = function (b, c) {
					return new a(b, c);
				}, b.exports.test = function (b) {
					return a.isBuffer(b);
				};
			}).call(this, "undefined" != typeof Buffer ? Buffer : void 0);
		}, {}], 12: [function (a, b) {
			"use strict";
			function c(a) {
				this.data = a, this.length = this.data.length, this.index = 0;
			}var d = a("./uint8ArrayReader");c.prototype = new d(), c.prototype.readData = function (a) {
				this.checkOffset(a);var b = this.data.slice(this.index, this.index + a);return this.index += a, b;
			}, b.exports = c;
		}, { "./uint8ArrayReader": 18 }], 13: [function (a, b) {
			"use strict";
			var c = a("./support"),
			    d = a("./utils"),
			    e = a("./crc32"),
			    f = a("./signature"),
			    g = a("./defaults"),
			    h = a("./base64"),
			    i = a("./compressions"),
			    j = a("./compressedObject"),
			    k = a("./nodeBuffer"),
			    l = a("./utf8"),
			    m = a("./stringWriter"),
			    n = a("./uint8ArrayWriter"),
			    o = function o(a) {
				if (a._data instanceof j && (a._data = a._data.getContent(), a.options.binary = !0, a.options.base64 = !1, "uint8array" === d.getTypeOf(a._data))) {
					var b = a._data;a._data = new Uint8Array(b.length), 0 !== b.length && a._data.set(b, 0);
				}return a._data;
			},
			    p = function p(a) {
				var b = o(a),
				    e = d.getTypeOf(b);return "string" === e ? !a.options.binary && c.nodebuffer ? k(b, "utf-8") : a.asBinary() : b;
			},
			    q = function q(a) {
				var b = o(this);return null === b || "undefined" == typeof b ? "" : (this.options.base64 && (b = h.decode(b)), b = a && this.options.binary ? D.utf8decode(b) : d.transformTo("string", b), a || this.options.binary || (b = d.transformTo("string", D.utf8encode(b))), b);
			},
			    r = function r(a, b, c) {
				this.name = a, this.dir = c.dir, this.date = c.date, this.comment = c.comment, this.unixPermissions = c.unixPermissions, this.dosPermissions = c.dosPermissions, this._data = b, this.options = c, this._initialMetadata = { dir: c.dir, date: c.date };
			};r.prototype = { asText: function asText() {
					return q.call(this, !0);
				}, asBinary: function asBinary() {
					return q.call(this, !1);
				}, asNodeBuffer: function asNodeBuffer() {
					var a = p(this);return d.transformTo("nodebuffer", a);
				}, asUint8Array: function asUint8Array() {
					var a = p(this);return d.transformTo("uint8array", a);
				}, asArrayBuffer: function asArrayBuffer() {
					return this.asUint8Array().buffer;
				} };var s = function s(a, b) {
				var c,
				    d = "";for (c = 0; b > c; c++) {
					d += String.fromCharCode(255 & a), a >>>= 8;
				}return d;
			},
			    t = function t() {
				var a,
				    b,
				    c = {};for (a = 0; a < arguments.length; a++) {
					for (b in arguments[a]) {
						arguments[a].hasOwnProperty(b) && "undefined" == typeof c[b] && (c[b] = arguments[a][b]);
					}
				}return c;
			},
			    u = function u(a) {
				return a = a || {}, a.base64 !== !0 || null !== a.binary && void 0 !== a.binary || (a.binary = !0), a = t(a, g), a.date = a.date || new Date(), null !== a.compression && (a.compression = a.compression.toUpperCase()), a;
			},
			    v = function v(a, b, c) {
				var e,
				    f = d.getTypeOf(b);if (c = u(c), "string" == typeof c.unixPermissions && (c.unixPermissions = parseInt(c.unixPermissions, 8)), c.unixPermissions && 16384 & c.unixPermissions && (c.dir = !0), c.dosPermissions && 16 & c.dosPermissions && (c.dir = !0), c.dir && (a = x(a)), c.createFolders && (e = w(a)) && y.call(this, e, !0), c.dir || null === b || "undefined" == typeof b) c.base64 = !1, c.binary = !1, b = null, f = null;else if ("string" === f) c.binary && !c.base64 && c.optimizedBinaryString !== !0 && (b = d.string2binary(b));else {
					if (c.base64 = !1, c.binary = !0, !(f || b instanceof j)) throw new Error("The data of '" + a + "' is in an unsupported format !");"arraybuffer" === f && (b = d.transformTo("uint8array", b));
				}var g = new r(a, b, c);return this.files[a] = g, g;
			},
			    w = function w(a) {
				"/" == a.slice(-1) && (a = a.substring(0, a.length - 1));var b = a.lastIndexOf("/");return b > 0 ? a.substring(0, b) : "";
			},
			    x = function x(a) {
				return "/" != a.slice(-1) && (a += "/"), a;
			},
			    y = function y(a, b) {
				return b = "undefined" != typeof b ? b : !1, a = x(a), this.files[a] || v.call(this, a, null, { dir: !0, createFolders: b }), this.files[a];
			},
			    z = function z(a, b, c) {
				var f,
				    g = new j();return a._data instanceof j ? (g.uncompressedSize = a._data.uncompressedSize, g.crc32 = a._data.crc32, 0 === g.uncompressedSize || a.dir ? (b = i.STORE, g.compressedContent = "", g.crc32 = 0) : a._data.compressionMethod === b.magic ? g.compressedContent = a._data.getCompressedContent() : (f = a._data.getContent(), g.compressedContent = b.compress(d.transformTo(b.compressInputType, f), c))) : (f = p(a), (!f || 0 === f.length || a.dir) && (b = i.STORE, f = ""), g.uncompressedSize = f.length, g.crc32 = e(f), g.compressedContent = b.compress(d.transformTo(b.compressInputType, f), c)), g.compressedSize = g.compressedContent.length, g.compressionMethod = b.magic, g;
			},
			    A = function A(a, b) {
				var c = a;return a || (c = b ? 16893 : 33204), (65535 & c) << 16;
			},
			    B = function B(a) {
				return 63 & (a || 0);
			},
			    C = function C(a, b, c, g, h) {
				var i,
				    j,
				    k,
				    m,
				    n = (c.compressedContent, d.transformTo("string", l.utf8encode(b.name))),
				    o = b.comment || "",
				    p = d.transformTo("string", l.utf8encode(o)),
				    q = n.length !== b.name.length,
				    r = p.length !== o.length,
				    t = b.options,
				    u = "",
				    v = "",
				    w = "";k = b._initialMetadata.dir !== b.dir ? b.dir : t.dir, m = b._initialMetadata.date !== b.date ? b.date : t.date;var x = 0,
				    y = 0;k && (x |= 16), "UNIX" === h ? (y = 798, x |= A(b.unixPermissions, k)) : (y = 20, x |= B(b.dosPermissions, k)), i = m.getHours(), i <<= 6, i |= m.getMinutes(), i <<= 5, i |= m.getSeconds() / 2, j = m.getFullYear() - 1980, j <<= 4, j |= m.getMonth() + 1, j <<= 5, j |= m.getDate(), q && (v = s(1, 1) + s(e(n), 4) + n, u += "up" + s(v.length, 2) + v), r && (w = s(1, 1) + s(this.crc32(p), 4) + p, u += "uc" + s(w.length, 2) + w);var z = "";z += "\n\x00", z += q || r ? "\x00\b" : "\x00\x00", z += c.compressionMethod, z += s(i, 2), z += s(j, 2), z += s(c.crc32, 4), z += s(c.compressedSize, 4), z += s(c.uncompressedSize, 4), z += s(n.length, 2), z += s(u.length, 2);var C = f.LOCAL_FILE_HEADER + z + n + u,
				    D = f.CENTRAL_FILE_HEADER + s(y, 2) + z + s(p.length, 2) + "\x00\x00\x00\x00" + s(x, 4) + s(g, 4) + n + u + p;return { fileRecord: C, dirRecord: D, compressedObject: c };
			},
			    D = { load: function load() {
					throw new Error("Load method is not defined. Is the file jszip-load.js included ?");
				}, filter: function filter(a) {
					var b,
					    c,
					    d,
					    e,
					    f = [];for (b in this.files) {
						this.files.hasOwnProperty(b) && (d = this.files[b], e = new r(d.name, d._data, t(d.options)), c = b.slice(this.root.length, b.length), b.slice(0, this.root.length) === this.root && a(c, e) && f.push(e));
					}return f;
				}, file: function file(a, b, c) {
					if (1 === arguments.length) {
						if (d.isRegExp(a)) {
							var e = a;return this.filter(function (a, b) {
								return !b.dir && e.test(a);
							});
						}return this.filter(function (b, c) {
							return !c.dir && b === a;
						})[0] || null;
					}return a = this.root + a, v.call(this, a, b, c), this;
				}, folder: function folder(a) {
					if (!a) return this;if (d.isRegExp(a)) return this.filter(function (b, c) {
						return c.dir && a.test(b);
					});var b = this.root + a,
					    c = y.call(this, b),
					    e = this.clone();return e.root = c.name, e;
				}, remove: function remove(a) {
					a = this.root + a;var b = this.files[a];if (b || ("/" != a.slice(-1) && (a += "/"), b = this.files[a]), b && !b.dir) delete this.files[a];else for (var c = this.filter(function (b, c) {
						return c.name.slice(0, a.length) === a;
					}), d = 0; d < c.length; d++) {
						delete this.files[c[d].name];
					}return this;
				}, generate: function generate(a) {
					a = t(a || {}, { base64: !0, compression: "STORE", compressionOptions: null, type: "base64", platform: "DOS", comment: null, mimeType: "application/zip" }), d.checkSupport(a.type), ("darwin" === a.platform || "freebsd" === a.platform || "linux" === a.platform || "sunos" === a.platform) && (a.platform = "UNIX"), "win32" === a.platform && (a.platform = "DOS");var b,
					    c,
					    e = [],
					    g = 0,
					    j = 0,
					    k = d.transformTo("string", this.utf8encode(a.comment || this.comment || ""));for (var l in this.files) {
						if (this.files.hasOwnProperty(l)) {
							var o = this.files[l],
							    p = o.options.compression || a.compression.toUpperCase(),
							    q = i[p];if (!q) throw new Error(p + " is not a valid compression method !");var r = o.options.compressionOptions || a.compressionOptions || {},
							    u = z.call(this, o, q, r),
							    v = C.call(this, l, o, u, g, a.platform);g += v.fileRecord.length + u.compressedSize, j += v.dirRecord.length, e.push(v);
						}
					}var w = "";w = f.CENTRAL_DIRECTORY_END + "\x00\x00\x00\x00" + s(e.length, 2) + s(e.length, 2) + s(j, 4) + s(g, 4) + s(k.length, 2) + k;var x = a.type.toLowerCase();for (b = "uint8array" === x || "arraybuffer" === x || "blob" === x || "nodebuffer" === x ? new n(g + j + w.length) : new m(g + j + w.length), c = 0; c < e.length; c++) {
						b.append(e[c].fileRecord), b.append(e[c].compressedObject.compressedContent);
					}for (c = 0; c < e.length; c++) {
						b.append(e[c].dirRecord);
					}b.append(w);var y = b.finalize();switch (a.type.toLowerCase()) {case "uint8array":case "arraybuffer":case "nodebuffer":
							return d.transformTo(a.type.toLowerCase(), y);case "blob":
							return d.arrayBuffer2Blob(d.transformTo("arraybuffer", y), a.mimeType);case "base64":
							return a.base64 ? h.encode(y) : y;default:
							return y;}
				}, crc32: function crc32(a, b) {
					return e(a, b);
				}, utf8encode: function utf8encode(a) {
					return d.transformTo("string", l.utf8encode(a));
				}, utf8decode: function utf8decode(a) {
					return l.utf8decode(a);
				} };b.exports = D;
		}, { "./base64": 1, "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./defaults": 6, "./nodeBuffer": 11, "./signature": 14, "./stringWriter": 16, "./support": 17, "./uint8ArrayWriter": 19, "./utf8": 20, "./utils": 21 }], 14: [function (a, b, c) {
			"use strict";
			c.LOCAL_FILE_HEADER = "PK", c.CENTRAL_FILE_HEADER = "PK", c.CENTRAL_DIRECTORY_END = "PK", c.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK", c.ZIP64_CENTRAL_DIRECTORY_END = "PK", c.DATA_DESCRIPTOR = "PK\b";
		}, {}], 15: [function (a, b) {
			"use strict";
			function c(a, b) {
				this.data = a, b || (this.data = e.string2binary(this.data)), this.length = this.data.length, this.index = 0;
			}var d = a("./dataReader"),
			    e = a("./utils");c.prototype = new d(), c.prototype.byteAt = function (a) {
				return this.data.charCodeAt(a);
			}, c.prototype.lastIndexOfSignature = function (a) {
				return this.data.lastIndexOf(a);
			}, c.prototype.readData = function (a) {
				this.checkOffset(a);var b = this.data.slice(this.index, this.index + a);return this.index += a, b;
			}, b.exports = c;
		}, { "./dataReader": 5, "./utils": 21 }], 16: [function (a, b) {
			"use strict";
			var c = a("./utils"),
			    d = function d() {
				this.data = [];
			};d.prototype = { append: function append(a) {
					a = c.transformTo("string", a), this.data.push(a);
				}, finalize: function finalize() {
					return this.data.join("");
				} }, b.exports = d;
		}, { "./utils": 21 }], 17: [function (a, b, c) {
			(function (a) {
				"use strict";
				if (c.base64 = !0, c.array = !0, c.string = !0, c.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, c.nodebuffer = "undefined" != typeof a, c.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) c.blob = !1;else {
					var b = new ArrayBuffer(0);try {
						c.blob = 0 === new Blob([b], { type: "application/zip" }).size;
					} catch (d) {
						try {
							var e = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder,
							    f = new e();f.append(b), c.blob = 0 === f.getBlob("application/zip").size;
						} catch (d) {
							c.blob = !1;
						}
					}
				}
			}).call(this, "undefined" != typeof Buffer ? Buffer : void 0);
		}, {}], 18: [function (a, b) {
			"use strict";
			function c(a) {
				a && (this.data = a, this.length = this.data.length, this.index = 0);
			}var d = a("./dataReader");c.prototype = new d(), c.prototype.byteAt = function (a) {
				return this.data[a];
			}, c.prototype.lastIndexOfSignature = function (a) {
				for (var b = a.charCodeAt(0), c = a.charCodeAt(1), d = a.charCodeAt(2), e = a.charCodeAt(3), f = this.length - 4; f >= 0; --f) {
					if (this.data[f] === b && this.data[f + 1] === c && this.data[f + 2] === d && this.data[f + 3] === e) return f;
				}return -1;
			}, c.prototype.readData = function (a) {
				if (this.checkOffset(a), 0 === a) return new Uint8Array(0);var b = this.data.subarray(this.index, this.index + a);return this.index += a, b;
			}, b.exports = c;
		}, { "./dataReader": 5 }], 19: [function (a, b) {
			"use strict";
			var c = a("./utils"),
			    d = function d(a) {
				this.data = new Uint8Array(a), this.index = 0;
			};d.prototype = { append: function append(a) {
					0 !== a.length && (a = c.transformTo("uint8array", a), this.data.set(a, this.index), this.index += a.length);
				}, finalize: function finalize() {
					return this.data;
				} }, b.exports = d;
		}, { "./utils": 21 }], 20: [function (a, b, c) {
			"use strict";
			for (var d = a("./utils"), e = a("./support"), f = a("./nodeBuffer"), g = new Array(256), h = 0; 256 > h; h++) {
				g[h] = h >= 252 ? 6 : h >= 248 ? 5 : h >= 240 ? 4 : h >= 224 ? 3 : h >= 192 ? 2 : 1;
			}g[254] = g[254] = 1;var i = function i(a) {
				var b,
				    c,
				    d,
				    f,
				    g,
				    h = a.length,
				    i = 0;for (f = 0; h > f; f++) {
					c = a.charCodeAt(f), 55296 === (64512 & c) && h > f + 1 && (d = a.charCodeAt(f + 1), 56320 === (64512 & d) && (c = 65536 + (c - 55296 << 10) + (d - 56320), f++)), i += 128 > c ? 1 : 2048 > c ? 2 : 65536 > c ? 3 : 4;
				}for (b = e.uint8array ? new Uint8Array(i) : new Array(i), g = 0, f = 0; i > g; f++) {
					c = a.charCodeAt(f), 55296 === (64512 & c) && h > f + 1 && (d = a.charCodeAt(f + 1), 56320 === (64512 & d) && (c = 65536 + (c - 55296 << 10) + (d - 56320), f++)), 128 > c ? b[g++] = c : 2048 > c ? (b[g++] = 192 | c >>> 6, b[g++] = 128 | 63 & c) : 65536 > c ? (b[g++] = 224 | c >>> 12, b[g++] = 128 | c >>> 6 & 63, b[g++] = 128 | 63 & c) : (b[g++] = 240 | c >>> 18, b[g++] = 128 | c >>> 12 & 63, b[g++] = 128 | c >>> 6 & 63, b[g++] = 128 | 63 & c);
				}return b;
			},
			    j = function j(a, b) {
				var c;for (b = b || a.length, b > a.length && (b = a.length), c = b - 1; c >= 0 && 128 === (192 & a[c]);) {
					c--;
				}return 0 > c ? b : 0 === c ? b : c + g[a[c]] > b ? c : b;
			},
			    k = function k(a) {
				var b,
				    c,
				    e,
				    f,
				    h = a.length,
				    i = new Array(2 * h);for (c = 0, b = 0; h > b;) {
					if (e = a[b++], 128 > e) i[c++] = e;else if (f = g[e], f > 4) i[c++] = 65533, b += f - 1;else {
						for (e &= 2 === f ? 31 : 3 === f ? 15 : 7; f > 1 && h > b;) {
							e = e << 6 | 63 & a[b++], f--;
						}f > 1 ? i[c++] = 65533 : 65536 > e ? i[c++] = e : (e -= 65536, i[c++] = 55296 | e >> 10 & 1023, i[c++] = 56320 | 1023 & e);
					}
				}return i.length !== c && (i.subarray ? i = i.subarray(0, c) : i.length = c), d.applyFromCharCode(i);
			};c.utf8encode = function (a) {
				return e.nodebuffer ? f(a, "utf-8") : i(a);
			}, c.utf8decode = function (a) {
				if (e.nodebuffer) return d.transformTo("nodebuffer", a).toString("utf-8");a = d.transformTo(e.uint8array ? "uint8array" : "array", a);for (var b = [], c = 0, f = a.length, g = 65536; f > c;) {
					var h = j(a, Math.min(c + g, f));b.push(e.uint8array ? k(a.subarray(c, h)) : k(a.slice(c, h))), c = h;
				}return b.join("");
			};
		}, { "./nodeBuffer": 11, "./support": 17, "./utils": 21 }], 21: [function (a, b, c) {
			"use strict";
			function d(a) {
				return a;
			}function e(a, b) {
				for (var c = 0; c < a.length; ++c) {
					b[c] = 255 & a.charCodeAt(c);
				}return b;
			}function f(a) {
				var b = 65536,
				    d = [],
				    e = a.length,
				    f = c.getTypeOf(a),
				    g = 0,
				    h = !0;try {
					switch (f) {case "uint8array":
							String.fromCharCode.apply(null, new Uint8Array(0));break;case "nodebuffer":
							String.fromCharCode.apply(null, j(0));}
				} catch (i) {
					h = !1;
				}if (!h) {
					for (var k = "", l = 0; l < a.length; l++) {
						k += String.fromCharCode(a[l]);
					}return k;
				}for (; e > g && b > 1;) {
					try {
						d.push("array" === f || "nodebuffer" === f ? String.fromCharCode.apply(null, a.slice(g, Math.min(g + b, e))) : String.fromCharCode.apply(null, a.subarray(g, Math.min(g + b, e)))), g += b;
					} catch (i) {
						b = Math.floor(b / 2);
					}
				}return d.join("");
			}function g(a, b) {
				for (var c = 0; c < a.length; c++) {
					b[c] = a[c];
				}return b;
			}var h = a("./support"),
			    i = a("./compressions"),
			    j = a("./nodeBuffer");c.string2binary = function (a) {
				for (var b = "", c = 0; c < a.length; c++) {
					b += String.fromCharCode(255 & a.charCodeAt(c));
				}return b;
			}, c.arrayBuffer2Blob = function (a, b) {
				c.checkSupport("blob"), b = b || "application/zip";try {
					return new Blob([a], { type: b });
				} catch (d) {
					try {
						var e = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder,
						    f = new e();return f.append(a), f.getBlob(b);
					} catch (d) {
						throw new Error("Bug : can't construct the Blob.");
					}
				}
			}, c.applyFromCharCode = f;var k = {};k.string = { string: d, array: function array(a) {
					return e(a, new Array(a.length));
				}, arraybuffer: function arraybuffer(a) {
					return k.string.uint8array(a).buffer;
				}, uint8array: function uint8array(a) {
					return e(a, new Uint8Array(a.length));
				}, nodebuffer: function nodebuffer(a) {
					return e(a, j(a.length));
				} }, k.array = { string: f, array: d, arraybuffer: function arraybuffer(a) {
					return new Uint8Array(a).buffer;
				}, uint8array: function uint8array(a) {
					return new Uint8Array(a);
				}, nodebuffer: function nodebuffer(a) {
					return j(a);
				} }, k.arraybuffer = { string: function string(a) {
					return f(new Uint8Array(a));
				}, array: function array(a) {
					return g(new Uint8Array(a), new Array(a.byteLength));
				}, arraybuffer: d, uint8array: function uint8array(a) {
					return new Uint8Array(a);
				}, nodebuffer: function nodebuffer(a) {
					return j(new Uint8Array(a));
				} }, k.uint8array = { string: f, array: function array(a) {
					return g(a, new Array(a.length));
				}, arraybuffer: function arraybuffer(a) {
					return a.buffer;
				}, uint8array: d, nodebuffer: function nodebuffer(a) {
					return j(a);
				} }, k.nodebuffer = { string: f, array: function array(a) {
					return g(a, new Array(a.length));
				}, arraybuffer: function arraybuffer(a) {
					return k.nodebuffer.uint8array(a).buffer;
				}, uint8array: function uint8array(a) {
					return g(a, new Uint8Array(a.length));
				}, nodebuffer: d }, c.transformTo = function (a, b) {
				if (b || (b = ""), !a) return b;c.checkSupport(a);var d = c.getTypeOf(b),
				    e = k[d][a](b);return e;
			}, c.getTypeOf = function (a) {
				return "string" == typeof a ? "string" : "[object Array]" === Object.prototype.toString.call(a) ? "array" : h.nodebuffer && j.test(a) ? "nodebuffer" : h.uint8array && a instanceof Uint8Array ? "uint8array" : h.arraybuffer && a instanceof ArrayBuffer ? "arraybuffer" : void 0;
			}, c.checkSupport = function (a) {
				var b = h[a.toLowerCase()];if (!b) throw new Error(a + " is not supported by this browser");
			}, c.MAX_VALUE_16BITS = 65535, c.MAX_VALUE_32BITS = -1, c.pretty = function (a) {
				var b,
				    c,
				    d = "";for (c = 0; c < (a || "").length; c++) {
					b = a.charCodeAt(c), d += "\\x" + (16 > b ? "0" : "") + b.toString(16).toUpperCase();
				}return d;
			}, c.findCompression = function (a) {
				for (var b in i) {
					if (i.hasOwnProperty(b) && i[b].magic === a) return i[b];
				}return null;
			}, c.isRegExp = function (a) {
				return "[object RegExp]" === Object.prototype.toString.call(a);
			};
		}, { "./compressions": 3, "./nodeBuffer": 11, "./support": 17 }], 22: [function (a, b) {
			"use strict";
			function c(a, b) {
				this.files = [], this.loadOptions = b, a && this.load(a);
			}var d = a("./stringReader"),
			    e = a("./nodeBufferReader"),
			    f = a("./uint8ArrayReader"),
			    g = a("./utils"),
			    h = a("./signature"),
			    i = a("./zipEntry"),
			    j = a("./support"),
			    k = a("./object");c.prototype = { checkSignature: function checkSignature(a) {
					var b = this.reader.readString(4);if (b !== a) throw new Error("Corrupted zip or bug : unexpected signature (" + g.pretty(b) + ", expected " + g.pretty(a) + ")");
				}, readBlockEndOfCentral: function readBlockEndOfCentral() {
					this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2), this.zipComment = this.reader.readString(this.zipCommentLength), this.zipComment = k.utf8decode(this.zipComment);
				}, readBlockZip64EndOfCentral: function readBlockZip64EndOfCentral() {
					this.zip64EndOfCentralSize = this.reader.readInt(8), this.versionMadeBy = this.reader.readString(2), this.versionNeeded = this.reader.readInt(2), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};for (var a, b, c, d = this.zip64EndOfCentralSize - 44, e = 0; d > e;) {
						a = this.reader.readInt(2), b = this.reader.readInt(4), c = this.reader.readString(b), this.zip64ExtensibleData[a] = { id: a, length: b, value: c };
					}
				}, readBlockZip64EndOfCentralLocator: function readBlockZip64EndOfCentralLocator() {
					if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), this.disksCount > 1) throw new Error("Multi-volumes zip are not supported");
				}, readLocalFiles: function readLocalFiles() {
					var a, b;for (a = 0; a < this.files.length; a++) {
						b = this.files[a], this.reader.setIndex(b.localHeaderOffset), this.checkSignature(h.LOCAL_FILE_HEADER), b.readLocalPart(this.reader), b.handleUTF8(), b.processAttributes();
					}
				}, readCentralDir: function readCentralDir() {
					var a;for (this.reader.setIndex(this.centralDirOffset); this.reader.readString(4) === h.CENTRAL_FILE_HEADER;) {
						a = new i({ zip64: this.zip64 }, this.loadOptions), a.readCentralPart(this.reader), this.files.push(a);
					}
				}, readEndOfCentral: function readEndOfCentral() {
					var a = this.reader.lastIndexOfSignature(h.CENTRAL_DIRECTORY_END);if (-1 === a) {
						var b = !0;try {
							this.reader.setIndex(0), this.checkSignature(h.LOCAL_FILE_HEADER), b = !1;
						} catch (c) {}throw new Error(b ? "Can't find end of central directory : is this a zip file ? If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html" : "Corrupted zip : can't find end of central directory");
					}if (this.reader.setIndex(a), this.checkSignature(h.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === g.MAX_VALUE_16BITS || this.diskWithCentralDirStart === g.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === g.MAX_VALUE_16BITS || this.centralDirRecords === g.MAX_VALUE_16BITS || this.centralDirSize === g.MAX_VALUE_32BITS || this.centralDirOffset === g.MAX_VALUE_32BITS) {
						if (this.zip64 = !0, a = this.reader.lastIndexOfSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR), -1 === a) throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");this.reader.setIndex(a), this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
					}
				}, prepareReader: function prepareReader(a) {
					var b = g.getTypeOf(a);this.reader = "string" !== b || j.uint8array ? "nodebuffer" === b ? new e(a) : new f(g.transformTo("uint8array", a)) : new d(a, this.loadOptions.optimizedBinaryString);
				}, load: function load(a) {
					this.prepareReader(a), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
				} }, b.exports = c;
		}, { "./nodeBufferReader": 12, "./object": 13, "./signature": 14, "./stringReader": 15, "./support": 17, "./uint8ArrayReader": 18, "./utils": 21, "./zipEntry": 23 }], 23: [function (a, b) {
			"use strict";
			function c(a, b) {
				this.options = a, this.loadOptions = b;
			}var d = a("./stringReader"),
			    e = a("./utils"),
			    f = a("./compressedObject"),
			    g = a("./object"),
			    h = 0,
			    i = 3;c.prototype = { isEncrypted: function isEncrypted() {
					return 1 === (1 & this.bitFlag);
				}, useUTF8: function useUTF8() {
					return 2048 === (2048 & this.bitFlag);
				}, prepareCompressedContent: function prepareCompressedContent(a, b, c) {
					return function () {
						var d = a.index;a.setIndex(b);var e = a.readData(c);return a.setIndex(d), e;
					};
				}, prepareContent: function prepareContent(a, b, c, d, f) {
					return function () {
						var a = e.transformTo(d.uncompressInputType, this.getCompressedContent()),
						    b = d.uncompress(a);if (b.length !== f) throw new Error("Bug : uncompressed data size mismatch");return b;
					};
				}, readLocalPart: function readLocalPart(a) {
					var b, c;if (a.skip(22), this.fileNameLength = a.readInt(2), c = a.readInt(2), this.fileName = a.readString(this.fileNameLength), a.skip(c), -1 == this.compressedSize || -1 == this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");if (b = e.findCompression(this.compressionMethod), null === b) throw new Error("Corrupted zip : compression " + e.pretty(this.compressionMethod) + " unknown (inner file : " + this.fileName + ")");if (this.decompressed = new f(), this.decompressed.compressedSize = this.compressedSize, this.decompressed.uncompressedSize = this.uncompressedSize, this.decompressed.crc32 = this.crc32, this.decompressed.compressionMethod = this.compressionMethod, this.decompressed.getCompressedContent = this.prepareCompressedContent(a, a.index, this.compressedSize, b), this.decompressed.getContent = this.prepareContent(a, a.index, this.compressedSize, b, this.uncompressedSize), this.loadOptions.checkCRC32 && (this.decompressed = e.transformTo("string", this.decompressed.getContent()), g.crc32(this.decompressed) !== this.crc32)) throw new Error("Corrupted zip : CRC32 mismatch");
				}, readCentralPart: function readCentralPart(a) {
					if (this.versionMadeBy = a.readInt(2), this.versionNeeded = a.readInt(2), this.bitFlag = a.readInt(2), this.compressionMethod = a.readString(2), this.date = a.readDate(), this.crc32 = a.readInt(4), this.compressedSize = a.readInt(4), this.uncompressedSize = a.readInt(4), this.fileNameLength = a.readInt(2), this.extraFieldsLength = a.readInt(2), this.fileCommentLength = a.readInt(2), this.diskNumberStart = a.readInt(2), this.internalFileAttributes = a.readInt(2), this.externalFileAttributes = a.readInt(4), this.localHeaderOffset = a.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");this.fileName = a.readString(this.fileNameLength), this.readExtraFields(a), this.parseZIP64ExtraField(a), this.fileComment = a.readString(this.fileCommentLength);
				}, processAttributes: function processAttributes() {
					this.unixPermissions = null, this.dosPermissions = null;var a = this.versionMadeBy >> 8;this.dir = 16 & this.externalFileAttributes ? !0 : !1, a === h && (this.dosPermissions = 63 & this.externalFileAttributes), a === i && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileName.slice(-1) || (this.dir = !0);
				}, parseZIP64ExtraField: function parseZIP64ExtraField() {
					if (this.extraFields[1]) {
						var a = new d(this.extraFields[1].value);this.uncompressedSize === e.MAX_VALUE_32BITS && (this.uncompressedSize = a.readInt(8)), this.compressedSize === e.MAX_VALUE_32BITS && (this.compressedSize = a.readInt(8)), this.localHeaderOffset === e.MAX_VALUE_32BITS && (this.localHeaderOffset = a.readInt(8)), this.diskNumberStart === e.MAX_VALUE_32BITS && (this.diskNumberStart = a.readInt(4));
					}
				}, readExtraFields: function readExtraFields(a) {
					var b,
					    c,
					    d,
					    e = a.index;for (this.extraFields = this.extraFields || {}; a.index < e + this.extraFieldsLength;) {
						b = a.readInt(2), c = a.readInt(2), d = a.readString(c), this.extraFields[b] = { id: b, length: c, value: d };
					}
				}, handleUTF8: function handleUTF8() {
					if (this.useUTF8()) this.fileName = g.utf8decode(this.fileName), this.fileComment = g.utf8decode(this.fileComment);else {
						var a = this.findExtraFieldUnicodePath();null !== a && (this.fileName = a);var b = this.findExtraFieldUnicodeComment();null !== b && (this.fileComment = b);
					}
				}, findExtraFieldUnicodePath: function findExtraFieldUnicodePath() {
					var a = this.extraFields[28789];if (a) {
						var b = new d(a.value);return 1 !== b.readInt(1) ? null : g.crc32(this.fileName) !== b.readInt(4) ? null : g.utf8decode(b.readString(a.length - 5));
					}return null;
				}, findExtraFieldUnicodeComment: function findExtraFieldUnicodeComment() {
					var a = this.extraFields[25461];if (a) {
						var b = new d(a.value);return 1 !== b.readInt(1) ? null : g.crc32(this.fileComment) !== b.readInt(4) ? null : g.utf8decode(b.readString(a.length - 5));
					}return null;
				} }, b.exports = c;
		}, { "./compressedObject": 2, "./object": 13, "./stringReader": 15, "./utils": 21 }], 24: [function (a, b) {
			"use strict";
			var c = a("./lib/utils/common").assign,
			    d = a("./lib/deflate"),
			    e = a("./lib/inflate"),
			    f = a("./lib/zlib/constants"),
			    g = {};c(g, d, e, f), b.exports = g;
		}, { "./lib/deflate": 25, "./lib/inflate": 26, "./lib/utils/common": 27, "./lib/zlib/constants": 30 }], 25: [function (a, b, c) {
			"use strict";
			function d(a, b) {
				var c = new s(b);if (c.push(a, !0), c.err) throw c.msg;return c.result;
			}function e(a, b) {
				return b = b || {}, b.raw = !0, d(a, b);
			}function f(a, b) {
				return b = b || {}, b.gzip = !0, d(a, b);
			}var g = a("./zlib/deflate.js"),
			    h = a("./utils/common"),
			    i = a("./utils/strings"),
			    j = a("./zlib/messages"),
			    k = a("./zlib/zstream"),
			    l = 0,
			    m = 4,
			    n = 0,
			    o = 1,
			    p = -1,
			    q = 0,
			    r = 8,
			    s = function s(a) {
				this.options = h.assign({ level: p, method: r, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: q, to: "" }, a || {});var b = this.options;b.raw && b.windowBits > 0 ? b.windowBits = -b.windowBits : b.gzip && b.windowBits > 0 && b.windowBits < 16 && (b.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new k(), this.strm.avail_out = 0;var c = g.deflateInit2(this.strm, b.level, b.method, b.windowBits, b.memLevel, b.strategy);if (c !== n) throw new Error(j[c]);b.header && g.deflateSetHeader(this.strm, b.header);
			};s.prototype.push = function (a, b) {
				var c,
				    d,
				    e = this.strm,
				    f = this.options.chunkSize;if (this.ended) return !1;d = b === ~~b ? b : b === !0 ? m : l, e.input = "string" == typeof a ? i.string2buf(a) : a, e.next_in = 0, e.avail_in = e.input.length;do {
					if (0 === e.avail_out && (e.output = new h.Buf8(f), e.next_out = 0, e.avail_out = f), c = g.deflate(e, d), c !== o && c !== n) return this.onEnd(c), this.ended = !0, !1;(0 === e.avail_out || 0 === e.avail_in && d === m) && this.onData("string" === this.options.to ? i.buf2binstring(h.shrinkBuf(e.output, e.next_out)) : h.shrinkBuf(e.output, e.next_out));
				} while ((e.avail_in > 0 || 0 === e.avail_out) && c !== o);return d === m ? (c = g.deflateEnd(this.strm), this.onEnd(c), this.ended = !0, c === n) : !0;
			}, s.prototype.onData = function (a) {
				this.chunks.push(a);
			}, s.prototype.onEnd = function (a) {
				a === n && (this.result = "string" === this.options.to ? this.chunks.join("") : h.flattenChunks(this.chunks)), this.chunks = [], this.err = a, this.msg = this.strm.msg;
			}, c.Deflate = s, c.deflate = d, c.deflateRaw = e, c.gzip = f;
		}, { "./utils/common": 27, "./utils/strings": 28, "./zlib/deflate.js": 32, "./zlib/messages": 37, "./zlib/zstream": 39 }], 26: [function (a, b, c) {
			"use strict";
			function d(a, b) {
				var c = new m(b);if (c.push(a, !0), c.err) throw c.msg;return c.result;
			}function e(a, b) {
				return b = b || {}, b.raw = !0, d(a, b);
			}var f = a("./zlib/inflate.js"),
			    g = a("./utils/common"),
			    h = a("./utils/strings"),
			    i = a("./zlib/constants"),
			    j = a("./zlib/messages"),
			    k = a("./zlib/zstream"),
			    l = a("./zlib/gzheader"),
			    m = function m(a) {
				this.options = g.assign({ chunkSize: 16384, windowBits: 0, to: "" }, a || {});var b = this.options;b.raw && b.windowBits >= 0 && b.windowBits < 16 && (b.windowBits = -b.windowBits, 0 === b.windowBits && (b.windowBits = -15)), !(b.windowBits >= 0 && b.windowBits < 16) || a && a.windowBits || (b.windowBits += 32), b.windowBits > 15 && b.windowBits < 48 && 0 === (15 & b.windowBits) && (b.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new k(), this.strm.avail_out = 0;var c = f.inflateInit2(this.strm, b.windowBits);if (c !== i.Z_OK) throw new Error(j[c]);this.header = new l(), f.inflateGetHeader(this.strm, this.header);
			};m.prototype.push = function (a, b) {
				var c,
				    d,
				    e,
				    j,
				    k,
				    l = this.strm,
				    m = this.options.chunkSize;if (this.ended) return !1;d = b === ~~b ? b : b === !0 ? i.Z_FINISH : i.Z_NO_FLUSH, l.input = "string" == typeof a ? h.binstring2buf(a) : a, l.next_in = 0, l.avail_in = l.input.length;do {
					if (0 === l.avail_out && (l.output = new g.Buf8(m), l.next_out = 0, l.avail_out = m), c = f.inflate(l, i.Z_NO_FLUSH), c !== i.Z_STREAM_END && c !== i.Z_OK) return this.onEnd(c), this.ended = !0, !1;l.next_out && (0 === l.avail_out || c === i.Z_STREAM_END || 0 === l.avail_in && d === i.Z_FINISH) && ("string" === this.options.to ? (e = h.utf8border(l.output, l.next_out), j = l.next_out - e, k = h.buf2string(l.output, e), l.next_out = j, l.avail_out = m - j, j && g.arraySet(l.output, l.output, e, j, 0), this.onData(k)) : this.onData(g.shrinkBuf(l.output, l.next_out)));
				} while (l.avail_in > 0 && c !== i.Z_STREAM_END);return c === i.Z_STREAM_END && (d = i.Z_FINISH), d === i.Z_FINISH ? (c = f.inflateEnd(this.strm), this.onEnd(c), this.ended = !0, c === i.Z_OK) : !0;
			}, m.prototype.onData = function (a) {
				this.chunks.push(a);
			}, m.prototype.onEnd = function (a) {
				a === i.Z_OK && (this.result = "string" === this.options.to ? this.chunks.join("") : g.flattenChunks(this.chunks)), this.chunks = [], this.err = a, this.msg = this.strm.msg;
			}, c.Inflate = m, c.inflate = d, c.inflateRaw = e, c.ungzip = d;
		}, { "./utils/common": 27, "./utils/strings": 28, "./zlib/constants": 30, "./zlib/gzheader": 33, "./zlib/inflate.js": 35, "./zlib/messages": 37, "./zlib/zstream": 39 }], 27: [function (a, b, c) {
			"use strict";
			var d = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;c.assign = function (a) {
				for (var b = Array.prototype.slice.call(arguments, 1); b.length;) {
					var c = b.shift();if (c) {
						if ("object" != (typeof c === "undefined" ? "undefined" : _typeof(c))) throw new TypeError(c + "must be non-object");for (var d in c) {
							c.hasOwnProperty(d) && (a[d] = c[d]);
						}
					}
				}return a;
			}, c.shrinkBuf = function (a, b) {
				return a.length === b ? a : a.subarray ? a.subarray(0, b) : (a.length = b, a);
			};var e = { arraySet: function arraySet(a, b, c, d, e) {
					if (b.subarray && a.subarray) return void a.set(b.subarray(c, c + d), e);for (var f = 0; d > f; f++) {
						a[e + f] = b[c + f];
					}
				}, flattenChunks: function flattenChunks(a) {
					var b, c, d, e, f, g;for (d = 0, b = 0, c = a.length; c > b; b++) {
						d += a[b].length;
					}for (g = new Uint8Array(d), e = 0, b = 0, c = a.length; c > b; b++) {
						f = a[b], g.set(f, e), e += f.length;
					}return g;
				} },
			    f = { arraySet: function arraySet(a, b, c, d, e) {
					for (var f = 0; d > f; f++) {
						a[e + f] = b[c + f];
					}
				}, flattenChunks: function flattenChunks(a) {
					return [].concat.apply([], a);
				} };c.setTyped = function (a) {
				a ? (c.Buf8 = Uint8Array, c.Buf16 = Uint16Array, c.Buf32 = Int32Array, c.assign(c, e)) : (c.Buf8 = Array, c.Buf16 = Array, c.Buf32 = Array, c.assign(c, f));
			}, c.setTyped(d);
		}, {}], 28: [function (a, b, c) {
			"use strict";
			function d(a, b) {
				if (65537 > b && (a.subarray && g || !a.subarray && f)) return String.fromCharCode.apply(null, e.shrinkBuf(a, b));for (var c = "", d = 0; b > d; d++) {
					c += String.fromCharCode(a[d]);
				}return c;
			}var e = a("./common"),
			    f = !0,
			    g = !0;try {
				String.fromCharCode.apply(null, [0]);
			} catch (h) {
				f = !1;
			}try {
				String.fromCharCode.apply(null, new Uint8Array(1));
			} catch (h) {
				g = !1;
			}for (var i = new e.Buf8(256), j = 0; 256 > j; j++) {
				i[j] = j >= 252 ? 6 : j >= 248 ? 5 : j >= 240 ? 4 : j >= 224 ? 3 : j >= 192 ? 2 : 1;
			}i[254] = i[254] = 1, c.string2buf = function (a) {
				var b,
				    c,
				    d,
				    f,
				    g,
				    h = a.length,
				    i = 0;for (f = 0; h > f; f++) {
					c = a.charCodeAt(f), 55296 === (64512 & c) && h > f + 1 && (d = a.charCodeAt(f + 1), 56320 === (64512 & d) && (c = 65536 + (c - 55296 << 10) + (d - 56320), f++)), i += 128 > c ? 1 : 2048 > c ? 2 : 65536 > c ? 3 : 4;
				}for (b = new e.Buf8(i), g = 0, f = 0; i > g; f++) {
					c = a.charCodeAt(f), 55296 === (64512 & c) && h > f + 1 && (d = a.charCodeAt(f + 1), 56320 === (64512 & d) && (c = 65536 + (c - 55296 << 10) + (d - 56320), f++)), 128 > c ? b[g++] = c : 2048 > c ? (b[g++] = 192 | c >>> 6, b[g++] = 128 | 63 & c) : 65536 > c ? (b[g++] = 224 | c >>> 12, b[g++] = 128 | c >>> 6 & 63, b[g++] = 128 | 63 & c) : (b[g++] = 240 | c >>> 18, b[g++] = 128 | c >>> 12 & 63, b[g++] = 128 | c >>> 6 & 63, b[g++] = 128 | 63 & c);
				}return b;
			}, c.buf2binstring = function (a) {
				return d(a, a.length);
			}, c.binstring2buf = function (a) {
				for (var b = new e.Buf8(a.length), c = 0, d = b.length; d > c; c++) {
					b[c] = a.charCodeAt(c);
				}return b;
			}, c.buf2string = function (a, b) {
				var c,
				    e,
				    f,
				    g,
				    h = b || a.length,
				    j = new Array(2 * h);for (e = 0, c = 0; h > c;) {
					if (f = a[c++], 128 > f) j[e++] = f;else if (g = i[f], g > 4) j[e++] = 65533, c += g - 1;else {
						for (f &= 2 === g ? 31 : 3 === g ? 15 : 7; g > 1 && h > c;) {
							f = f << 6 | 63 & a[c++], g--;
						}g > 1 ? j[e++] = 65533 : 65536 > f ? j[e++] = f : (f -= 65536, j[e++] = 55296 | f >> 10 & 1023, j[e++] = 56320 | 1023 & f);
					}
				}return d(j, e);
			}, c.utf8border = function (a, b) {
				var c;for (b = b || a.length, b > a.length && (b = a.length), c = b - 1; c >= 0 && 128 === (192 & a[c]);) {
					c--;
				}return 0 > c ? b : 0 === c ? b : c + i[a[c]] > b ? c : b;
			};
		}, { "./common": 27 }], 29: [function (a, b) {
			"use strict";
			function c(a, b, c, d) {
				for (var e = 65535 & a | 0, f = a >>> 16 & 65535 | 0, g = 0; 0 !== c;) {
					g = c > 2e3 ? 2e3 : c, c -= g;do {
						e = e + b[d++] | 0, f = f + e | 0;
					} while (--g);e %= 65521, f %= 65521;
				}return e | f << 16 | 0;
			}b.exports = c;
		}, {}], 30: [function (a, b) {
			b.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
		}, {}], 31: [function (a, b) {
			"use strict";
			function c() {
				for (var a, b = [], c = 0; 256 > c; c++) {
					a = c;for (var d = 0; 8 > d; d++) {
						a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
					}b[c] = a;
				}return b;
			}function d(a, b, c, d) {
				var f = e,
				    g = d + c;a = -1 ^ a;for (var h = d; g > h; h++) {
					a = a >>> 8 ^ f[255 & (a ^ b[h])];
				}return -1 ^ a;
			}var e = c();b.exports = d;
		}, {}], 32: [function (a, b, c) {
			"use strict";
			function d(a, b) {
				return a.msg = G[b], b;
			}function e(a) {
				return (a << 1) - (a > 4 ? 9 : 0);
			}function f(a) {
				for (var b = a.length; --b >= 0;) {
					a[b] = 0;
				}
			}function g(a) {
				var b = a.state,
				    c = b.pending;c > a.avail_out && (c = a.avail_out), 0 !== c && (C.arraySet(a.output, b.pending_buf, b.pending_out, c, a.next_out), a.next_out += c, b.pending_out += c, a.total_out += c, a.avail_out -= c, b.pending -= c, 0 === b.pending && (b.pending_out = 0));
			}function h(a, b) {
				D._tr_flush_block(a, a.block_start >= 0 ? a.block_start : -1, a.strstart - a.block_start, b), a.block_start = a.strstart, g(a.strm);
			}function i(a, b) {
				a.pending_buf[a.pending++] = b;
			}function j(a, b) {
				a.pending_buf[a.pending++] = b >>> 8 & 255, a.pending_buf[a.pending++] = 255 & b;
			}function k(a, b, c, d) {
				var e = a.avail_in;return e > d && (e = d), 0 === e ? 0 : (a.avail_in -= e, C.arraySet(b, a.input, a.next_in, e, c), 1 === a.state.wrap ? a.adler = E(a.adler, b, e, c) : 2 === a.state.wrap && (a.adler = F(a.adler, b, e, c)), a.next_in += e, a.total_in += e, e);
			}function l(a, b) {
				var c,
				    d,
				    e = a.max_chain_length,
				    f = a.strstart,
				    g = a.prev_length,
				    h = a.nice_match,
				    i = a.strstart > a.w_size - jb ? a.strstart - (a.w_size - jb) : 0,
				    j = a.window,
				    k = a.w_mask,
				    l = a.prev,
				    m = a.strstart + ib,
				    n = j[f + g - 1],
				    o = j[f + g];a.prev_length >= a.good_match && (e >>= 2), h > a.lookahead && (h = a.lookahead);do {
					if (c = b, j[c + g] === o && j[c + g - 1] === n && j[c] === j[f] && j[++c] === j[f + 1]) {
						f += 2, c++;do {} while (j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && m > f);if (d = ib - (m - f), f = m - ib, d > g) {
							if (a.match_start = b, g = d, d >= h) break;n = j[f + g - 1], o = j[f + g];
						}
					}
				} while ((b = l[b & k]) > i && 0 !== --e);return g <= a.lookahead ? g : a.lookahead;
			}function m(a) {
				var b,
				    c,
				    d,
				    e,
				    f,
				    g = a.w_size;do {
					if (e = a.window_size - a.lookahead - a.strstart, a.strstart >= g + (g - jb)) {
						C.arraySet(a.window, a.window, g, g, 0), a.match_start -= g, a.strstart -= g, a.block_start -= g, c = a.hash_size, b = c;do {
							d = a.head[--b], a.head[b] = d >= g ? d - g : 0;
						} while (--c);c = g, b = c;do {
							d = a.prev[--b], a.prev[b] = d >= g ? d - g : 0;
						} while (--c);e += g;
					}if (0 === a.strm.avail_in) break;if (c = k(a.strm, a.window, a.strstart + a.lookahead, e), a.lookahead += c, a.lookahead + a.insert >= hb) for (f = a.strstart - a.insert, a.ins_h = a.window[f], a.ins_h = (a.ins_h << a.hash_shift ^ a.window[f + 1]) & a.hash_mask; a.insert && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window[f + hb - 1]) & a.hash_mask, a.prev[f & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = f, f++, a.insert--, !(a.lookahead + a.insert < hb));) {}
				} while (a.lookahead < jb && 0 !== a.strm.avail_in);
			}function n(a, b) {
				var c = 65535;for (c > a.pending_buf_size - 5 && (c = a.pending_buf_size - 5);;) {
					if (a.lookahead <= 1) {
						if (m(a), 0 === a.lookahead && b === H) return sb;if (0 === a.lookahead) break;
					}a.strstart += a.lookahead, a.lookahead = 0;var d = a.block_start + c;if ((0 === a.strstart || a.strstart >= d) && (a.lookahead = a.strstart - d, a.strstart = d, h(a, !1), 0 === a.strm.avail_out)) return sb;if (a.strstart - a.block_start >= a.w_size - jb && (h(a, !1), 0 === a.strm.avail_out)) return sb;
				}return a.insert = 0, b === K ? (h(a, !0), 0 === a.strm.avail_out ? ub : vb) : a.strstart > a.block_start && (h(a, !1), 0 === a.strm.avail_out) ? sb : sb;
			}function o(a, b) {
				for (var c, d;;) {
					if (a.lookahead < jb) {
						if (m(a), a.lookahead < jb && b === H) return sb;if (0 === a.lookahead) break;
					}if (c = 0, a.lookahead >= hb && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + hb - 1]) & a.hash_mask, c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart), 0 !== c && a.strstart - c <= a.w_size - jb && (a.match_length = l(a, c)), a.match_length >= hb) {
						if (d = D._tr_tally(a, a.strstart - a.match_start, a.match_length - hb), a.lookahead -= a.match_length, a.match_length <= a.max_lazy_match && a.lookahead >= hb) {
							a.match_length--;do {
								a.strstart++, a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + hb - 1]) & a.hash_mask, c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart;
							} while (0 !== --a.match_length);a.strstart++;
						} else a.strstart += a.match_length, a.match_length = 0, a.ins_h = a.window[a.strstart], a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + 1]) & a.hash_mask;
					} else d = D._tr_tally(a, 0, a.window[a.strstart]), a.lookahead--, a.strstart++;if (d && (h(a, !1), 0 === a.strm.avail_out)) return sb;
				}return a.insert = a.strstart < hb - 1 ? a.strstart : hb - 1, b === K ? (h(a, !0), 0 === a.strm.avail_out ? ub : vb) : a.last_lit && (h(a, !1), 0 === a.strm.avail_out) ? sb : tb;
			}function p(a, b) {
				for (var c, d, e;;) {
					if (a.lookahead < jb) {
						if (m(a), a.lookahead < jb && b === H) return sb;if (0 === a.lookahead) break;
					}if (c = 0, a.lookahead >= hb && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + hb - 1]) & a.hash_mask, c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart), a.prev_length = a.match_length, a.prev_match = a.match_start, a.match_length = hb - 1, 0 !== c && a.prev_length < a.max_lazy_match && a.strstart - c <= a.w_size - jb && (a.match_length = l(a, c), a.match_length <= 5 && (a.strategy === S || a.match_length === hb && a.strstart - a.match_start > 4096) && (a.match_length = hb - 1)), a.prev_length >= hb && a.match_length <= a.prev_length) {
						e = a.strstart + a.lookahead - hb, d = D._tr_tally(a, a.strstart - 1 - a.prev_match, a.prev_length - hb), a.lookahead -= a.prev_length - 1, a.prev_length -= 2;do {
							++a.strstart <= e && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + hb - 1]) & a.hash_mask, c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart);
						} while (0 !== --a.prev_length);if (a.match_available = 0, a.match_length = hb - 1, a.strstart++, d && (h(a, !1), 0 === a.strm.avail_out)) return sb;
					} else if (a.match_available) {
						if (d = D._tr_tally(a, 0, a.window[a.strstart - 1]), d && h(a, !1), a.strstart++, a.lookahead--, 0 === a.strm.avail_out) return sb;
					} else a.match_available = 1, a.strstart++, a.lookahead--;
				}return a.match_available && (d = D._tr_tally(a, 0, a.window[a.strstart - 1]), a.match_available = 0), a.insert = a.strstart < hb - 1 ? a.strstart : hb - 1, b === K ? (h(a, !0), 0 === a.strm.avail_out ? ub : vb) : a.last_lit && (h(a, !1), 0 === a.strm.avail_out) ? sb : tb;
			}function q(a, b) {
				for (var c, d, e, f, g = a.window;;) {
					if (a.lookahead <= ib) {
						if (m(a), a.lookahead <= ib && b === H) return sb;if (0 === a.lookahead) break;
					}if (a.match_length = 0, a.lookahead >= hb && a.strstart > 0 && (e = a.strstart - 1, d = g[e], d === g[++e] && d === g[++e] && d === g[++e])) {
						f = a.strstart + ib;do {} while (d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && f > e);a.match_length = ib - (f - e), a.match_length > a.lookahead && (a.match_length = a.lookahead);
					}if (a.match_length >= hb ? (c = D._tr_tally(a, 1, a.match_length - hb), a.lookahead -= a.match_length, a.strstart += a.match_length, a.match_length = 0) : (c = D._tr_tally(a, 0, a.window[a.strstart]), a.lookahead--, a.strstart++), c && (h(a, !1), 0 === a.strm.avail_out)) return sb;
				}return a.insert = 0, b === K ? (h(a, !0), 0 === a.strm.avail_out ? ub : vb) : a.last_lit && (h(a, !1), 0 === a.strm.avail_out) ? sb : tb;
			}function r(a, b) {
				for (var c;;) {
					if (0 === a.lookahead && (m(a), 0 === a.lookahead)) {
						if (b === H) return sb;break;
					}if (a.match_length = 0, c = D._tr_tally(a, 0, a.window[a.strstart]), a.lookahead--, a.strstart++, c && (h(a, !1), 0 === a.strm.avail_out)) return sb;
				}return a.insert = 0, b === K ? (h(a, !0), 0 === a.strm.avail_out ? ub : vb) : a.last_lit && (h(a, !1), 0 === a.strm.avail_out) ? sb : tb;
			}function s(a) {
				a.window_size = 2 * a.w_size, f(a.head), a.max_lazy_match = B[a.level].max_lazy, a.good_match = B[a.level].good_length, a.nice_match = B[a.level].nice_length, a.max_chain_length = B[a.level].max_chain, a.strstart = 0, a.block_start = 0, a.lookahead = 0, a.insert = 0, a.match_length = a.prev_length = hb - 1, a.match_available = 0, a.ins_h = 0;
			}function t() {
				this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Y, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new C.Buf16(2 * fb), this.dyn_dtree = new C.Buf16(2 * (2 * db + 1)), this.bl_tree = new C.Buf16(2 * (2 * eb + 1)), f(this.dyn_ltree), f(this.dyn_dtree), f(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new C.Buf16(gb + 1), this.heap = new C.Buf16(2 * cb + 1), f(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new C.Buf16(2 * cb + 1), f(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
			}function u(a) {
				var b;return a && a.state ? (a.total_in = a.total_out = 0, a.data_type = X, b = a.state, b.pending = 0, b.pending_out = 0, b.wrap < 0 && (b.wrap = -b.wrap), b.status = b.wrap ? lb : qb, a.adler = 2 === b.wrap ? 0 : 1, b.last_flush = H, D._tr_init(b), M) : d(a, O);
			}function v(a) {
				var b = u(a);return b === M && s(a.state), b;
			}function w(a, b) {
				return a && a.state ? 2 !== a.state.wrap ? O : (a.state.gzhead = b, M) : O;
			}function x(a, b, c, e, f, g) {
				if (!a) return O;var h = 1;if (b === R && (b = 6), 0 > e ? (h = 0, e = -e) : e > 15 && (h = 2, e -= 16), 1 > f || f > Z || c !== Y || 8 > e || e > 15 || 0 > b || b > 9 || 0 > g || g > V) return d(a, O);8 === e && (e = 9);var i = new t();return a.state = i, i.strm = a, i.wrap = h, i.gzhead = null, i.w_bits = e, i.w_size = 1 << i.w_bits, i.w_mask = i.w_size - 1, i.hash_bits = f + 7, i.hash_size = 1 << i.hash_bits, i.hash_mask = i.hash_size - 1, i.hash_shift = ~~((i.hash_bits + hb - 1) / hb), i.window = new C.Buf8(2 * i.w_size), i.head = new C.Buf16(i.hash_size), i.prev = new C.Buf16(i.w_size), i.lit_bufsize = 1 << f + 6, i.pending_buf_size = 4 * i.lit_bufsize, i.pending_buf = new C.Buf8(i.pending_buf_size), i.d_buf = i.lit_bufsize >> 1, i.l_buf = 3 * i.lit_bufsize, i.level = b, i.strategy = g, i.method = c, v(a);
			}function y(a, b) {
				return x(a, b, Y, $, _, W);
			}function z(a, b) {
				var c, h, k, l;if (!a || !a.state || b > L || 0 > b) return a ? d(a, O) : O;if (h = a.state, !a.output || !a.input && 0 !== a.avail_in || h.status === rb && b !== K) return d(a, 0 === a.avail_out ? Q : O);if (h.strm = a, c = h.last_flush, h.last_flush = b, h.status === lb) if (2 === h.wrap) a.adler = 0, i(h, 31), i(h, 139), i(h, 8), h.gzhead ? (i(h, (h.gzhead.text ? 1 : 0) + (h.gzhead.hcrc ? 2 : 0) + (h.gzhead.extra ? 4 : 0) + (h.gzhead.name ? 8 : 0) + (h.gzhead.comment ? 16 : 0)), i(h, 255 & h.gzhead.time), i(h, h.gzhead.time >> 8 & 255), i(h, h.gzhead.time >> 16 & 255), i(h, h.gzhead.time >> 24 & 255), i(h, 9 === h.level ? 2 : h.strategy >= T || h.level < 2 ? 4 : 0), i(h, 255 & h.gzhead.os), h.gzhead.extra && h.gzhead.extra.length && (i(h, 255 & h.gzhead.extra.length), i(h, h.gzhead.extra.length >> 8 & 255)), h.gzhead.hcrc && (a.adler = F(a.adler, h.pending_buf, h.pending, 0)), h.gzindex = 0, h.status = mb) : (i(h, 0), i(h, 0), i(h, 0), i(h, 0), i(h, 0), i(h, 9 === h.level ? 2 : h.strategy >= T || h.level < 2 ? 4 : 0), i(h, wb), h.status = qb);else {
					var m = Y + (h.w_bits - 8 << 4) << 8,
					    n = -1;n = h.strategy >= T || h.level < 2 ? 0 : h.level < 6 ? 1 : 6 === h.level ? 2 : 3, m |= n << 6, 0 !== h.strstart && (m |= kb), m += 31 - m % 31, h.status = qb, j(h, m), 0 !== h.strstart && (j(h, a.adler >>> 16), j(h, 65535 & a.adler)), a.adler = 1;
				}if (h.status === mb) if (h.gzhead.extra) {
					for (k = h.pending; h.gzindex < (65535 & h.gzhead.extra.length) && (h.pending !== h.pending_buf_size || (h.gzhead.hcrc && h.pending > k && (a.adler = F(a.adler, h.pending_buf, h.pending - k, k)), g(a), k = h.pending, h.pending !== h.pending_buf_size));) {
						i(h, 255 & h.gzhead.extra[h.gzindex]), h.gzindex++;
					}h.gzhead.hcrc && h.pending > k && (a.adler = F(a.adler, h.pending_buf, h.pending - k, k)), h.gzindex === h.gzhead.extra.length && (h.gzindex = 0, h.status = nb);
				} else h.status = nb;if (h.status === nb) if (h.gzhead.name) {
					k = h.pending;do {
						if (h.pending === h.pending_buf_size && (h.gzhead.hcrc && h.pending > k && (a.adler = F(a.adler, h.pending_buf, h.pending - k, k)), g(a), k = h.pending, h.pending === h.pending_buf_size)) {
							l = 1;break;
						}l = h.gzindex < h.gzhead.name.length ? 255 & h.gzhead.name.charCodeAt(h.gzindex++) : 0, i(h, l);
					} while (0 !== l);h.gzhead.hcrc && h.pending > k && (a.adler = F(a.adler, h.pending_buf, h.pending - k, k)), 0 === l && (h.gzindex = 0, h.status = ob);
				} else h.status = ob;if (h.status === ob) if (h.gzhead.comment) {
					k = h.pending;do {
						if (h.pending === h.pending_buf_size && (h.gzhead.hcrc && h.pending > k && (a.adler = F(a.adler, h.pending_buf, h.pending - k, k)), g(a), k = h.pending, h.pending === h.pending_buf_size)) {
							l = 1;break;
						}l = h.gzindex < h.gzhead.comment.length ? 255 & h.gzhead.comment.charCodeAt(h.gzindex++) : 0, i(h, l);
					} while (0 !== l);h.gzhead.hcrc && h.pending > k && (a.adler = F(a.adler, h.pending_buf, h.pending - k, k)), 0 === l && (h.status = pb);
				} else h.status = pb;if (h.status === pb && (h.gzhead.hcrc ? (h.pending + 2 > h.pending_buf_size && g(a), h.pending + 2 <= h.pending_buf_size && (i(h, 255 & a.adler), i(h, a.adler >> 8 & 255), a.adler = 0, h.status = qb)) : h.status = qb), 0 !== h.pending) {
					if (g(a), 0 === a.avail_out) return h.last_flush = -1, M;
				} else if (0 === a.avail_in && e(b) <= e(c) && b !== K) return d(a, Q);if (h.status === rb && 0 !== a.avail_in) return d(a, Q);if (0 !== a.avail_in || 0 !== h.lookahead || b !== H && h.status !== rb) {
					var o = h.strategy === T ? r(h, b) : h.strategy === U ? q(h, b) : B[h.level].func(h, b);if ((o === ub || o === vb) && (h.status = rb), o === sb || o === ub) return 0 === a.avail_out && (h.last_flush = -1), M;if (o === tb && (b === I ? D._tr_align(h) : b !== L && (D._tr_stored_block(h, 0, 0, !1), b === J && (f(h.head), 0 === h.lookahead && (h.strstart = 0, h.block_start = 0, h.insert = 0))), g(a), 0 === a.avail_out)) return h.last_flush = -1, M;
				}return b !== K ? M : h.wrap <= 0 ? N : (2 === h.wrap ? (i(h, 255 & a.adler), i(h, a.adler >> 8 & 255), i(h, a.adler >> 16 & 255), i(h, a.adler >> 24 & 255), i(h, 255 & a.total_in), i(h, a.total_in >> 8 & 255), i(h, a.total_in >> 16 & 255), i(h, a.total_in >> 24 & 255)) : (j(h, a.adler >>> 16), j(h, 65535 & a.adler)), g(a), h.wrap > 0 && (h.wrap = -h.wrap), 0 !== h.pending ? M : N);
			}function A(a) {
				var b;return a && a.state ? (b = a.state.status, b !== lb && b !== mb && b !== nb && b !== ob && b !== pb && b !== qb && b !== rb ? d(a, O) : (a.state = null, b === qb ? d(a, P) : M)) : O;
			}var B,
			    C = a("../utils/common"),
			    D = a("./trees"),
			    E = a("./adler32"),
			    F = a("./crc32"),
			    G = a("./messages"),
			    H = 0,
			    I = 1,
			    J = 3,
			    K = 4,
			    L = 5,
			    M = 0,
			    N = 1,
			    O = -2,
			    P = -3,
			    Q = -5,
			    R = -1,
			    S = 1,
			    T = 2,
			    U = 3,
			    V = 4,
			    W = 0,
			    X = 2,
			    Y = 8,
			    Z = 9,
			    $ = 15,
			    _ = 8,
			    ab = 29,
			    bb = 256,
			    cb = bb + 1 + ab,
			    db = 30,
			    eb = 19,
			    fb = 2 * cb + 1,
			    gb = 15,
			    hb = 3,
			    ib = 258,
			    jb = ib + hb + 1,
			    kb = 32,
			    lb = 42,
			    mb = 69,
			    nb = 73,
			    ob = 91,
			    pb = 103,
			    qb = 113,
			    rb = 666,
			    sb = 1,
			    tb = 2,
			    ub = 3,
			    vb = 4,
			    wb = 3,
			    xb = function xb(a, b, c, d, e) {
				this.good_length = a, this.max_lazy = b, this.nice_length = c, this.max_chain = d, this.func = e;
			};B = [new xb(0, 0, 0, 0, n), new xb(4, 4, 8, 4, o), new xb(4, 5, 16, 8, o), new xb(4, 6, 32, 32, o), new xb(4, 4, 16, 16, p), new xb(8, 16, 32, 32, p), new xb(8, 16, 128, 128, p), new xb(8, 32, 128, 256, p), new xb(32, 128, 258, 1024, p), new xb(32, 258, 258, 4096, p)], c.deflateInit = y, c.deflateInit2 = x, c.deflateReset = v, c.deflateResetKeep = u, c.deflateSetHeader = w, c.deflate = z, c.deflateEnd = A, c.deflateInfo = "pako deflate (from Nodeca project)";
		}, { "../utils/common": 27, "./adler32": 29, "./crc32": 31, "./messages": 37, "./trees": 38 }], 33: [function (a, b) {
			"use strict";
			function c() {
				this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
			}b.exports = c;
		}, {}], 34: [function (a, b) {
			"use strict";
			var c = 30,
			    d = 12;b.exports = function (a, b) {
				var e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C;e = a.state, f = a.next_in, B = a.input, g = f + (a.avail_in - 5), h = a.next_out, C = a.output, i = h - (b - a.avail_out), j = h + (a.avail_out - 257), k = e.dmax, l = e.wsize, m = e.whave, n = e.wnext, o = e.window, p = e.hold, q = e.bits, r = e.lencode, s = e.distcode, t = (1 << e.lenbits) - 1, u = (1 << e.distbits) - 1;a: do {
					15 > q && (p += B[f++] << q, q += 8, p += B[f++] << q, q += 8), v = r[p & t];b: for (;;) {
						if (w = v >>> 24, p >>>= w, q -= w, w = v >>> 16 & 255, 0 === w) C[h++] = 65535 & v;else {
							if (!(16 & w)) {
								if (0 === (64 & w)) {
									v = r[(65535 & v) + (p & (1 << w) - 1)];continue b;
								}if (32 & w) {
									e.mode = d;break a;
								}a.msg = "invalid literal/length code", e.mode = c;break a;
							}x = 65535 & v, w &= 15, w && (w > q && (p += B[f++] << q, q += 8), x += p & (1 << w) - 1, p >>>= w, q -= w), 15 > q && (p += B[f++] << q, q += 8, p += B[f++] << q, q += 8), v = s[p & u];c: for (;;) {
								if (w = v >>> 24, p >>>= w, q -= w, w = v >>> 16 & 255, !(16 & w)) {
									if (0 === (64 & w)) {
										v = s[(65535 & v) + (p & (1 << w) - 1)];continue c;
									}a.msg = "invalid distance code", e.mode = c;break a;
								}if (y = 65535 & v, w &= 15, w > q && (p += B[f++] << q, q += 8, w > q && (p += B[f++] << q, q += 8)), y += p & (1 << w) - 1, y > k) {
									a.msg = "invalid distance too far back", e.mode = c;break a;
								}if (p >>>= w, q -= w, w = h - i, y > w) {
									if (w = y - w, w > m && e.sane) {
										a.msg = "invalid distance too far back", e.mode = c;break a;
									}if (z = 0, A = o, 0 === n) {
										if (z += l - w, x > w) {
											x -= w;do {
												C[h++] = o[z++];
											} while (--w);z = h - y, A = C;
										}
									} else if (w > n) {
										if (z += l + n - w, w -= n, x > w) {
											x -= w;do {
												C[h++] = o[z++];
											} while (--w);if (z = 0, x > n) {
												w = n, x -= w;do {
													C[h++] = o[z++];
												} while (--w);z = h - y, A = C;
											}
										}
									} else if (z += n - w, x > w) {
										x -= w;do {
											C[h++] = o[z++];
										} while (--w);z = h - y, A = C;
									}for (; x > 2;) {
										C[h++] = A[z++], C[h++] = A[z++], C[h++] = A[z++], x -= 3;
									}x && (C[h++] = A[z++], x > 1 && (C[h++] = A[z++]));
								} else {
									z = h - y;do {
										C[h++] = C[z++], C[h++] = C[z++], C[h++] = C[z++], x -= 3;
									} while (x > 2);x && (C[h++] = C[z++], x > 1 && (C[h++] = C[z++]));
								}break;
							}
						}break;
					}
				} while (g > f && j > h);x = q >> 3, f -= x, q -= x << 3, p &= (1 << q) - 1, a.next_in = f, a.next_out = h, a.avail_in = g > f ? 5 + (g - f) : 5 - (f - g), a.avail_out = j > h ? 257 + (j - h) : 257 - (h - j), e.hold = p, e.bits = q;
			};
		}, {}], 35: [function (a, b, c) {
			"use strict";
			function d(a) {
				return (a >>> 24 & 255) + (a >>> 8 & 65280) + ((65280 & a) << 8) + ((255 & a) << 24);
			}function e() {
				this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
			}function f(a) {
				var b;return a && a.state ? (b = a.state, a.total_in = a.total_out = b.total = 0, a.msg = "", b.wrap && (a.adler = 1 & b.wrap), b.mode = K, b.last = 0, b.havedict = 0, b.dmax = 32768, b.head = null, b.hold = 0, b.bits = 0, b.lencode = b.lendyn = new r.Buf32(ob), b.distcode = b.distdyn = new r.Buf32(pb), b.sane = 1, b.back = -1, C) : F;
			}function g(a) {
				var b;return a && a.state ? (b = a.state, b.wsize = 0, b.whave = 0, b.wnext = 0, f(a)) : F;
			}function h(a, b) {
				var c, d;return a && a.state ? (d = a.state, 0 > b ? (c = 0, b = -b) : (c = (b >> 4) + 1, 48 > b && (b &= 15)), b && (8 > b || b > 15) ? F : (null !== d.window && d.wbits !== b && (d.window = null), d.wrap = c, d.wbits = b, g(a))) : F;
			}function i(a, b) {
				var c, d;return a ? (d = new e(), a.state = d, d.window = null, c = h(a, b), c !== C && (a.state = null), c) : F;
			}function j(a) {
				return i(a, rb);
			}function k(a) {
				if (sb) {
					var b;for (p = new r.Buf32(512), q = new r.Buf32(32), b = 0; 144 > b;) {
						a.lens[b++] = 8;
					}for (; 256 > b;) {
						a.lens[b++] = 9;
					}for (; 280 > b;) {
						a.lens[b++] = 7;
					}for (; 288 > b;) {
						a.lens[b++] = 8;
					}for (v(x, a.lens, 0, 288, p, 0, a.work, { bits: 9 }), b = 0; 32 > b;) {
						a.lens[b++] = 5;
					}v(y, a.lens, 0, 32, q, 0, a.work, { bits: 5 }), sb = !1;
				}a.lencode = p, a.lenbits = 9, a.distcode = q, a.distbits = 5;
			}function l(a, b, c, d) {
				var e,
				    f = a.state;return null === f.window && (f.wsize = 1 << f.wbits, f.wnext = 0, f.whave = 0, f.window = new r.Buf8(f.wsize)), d >= f.wsize ? (r.arraySet(f.window, b, c - f.wsize, f.wsize, 0), f.wnext = 0, f.whave = f.wsize) : (e = f.wsize - f.wnext, e > d && (e = d), r.arraySet(f.window, b, c - d, e, f.wnext), d -= e, d ? (r.arraySet(f.window, b, c - d, d, 0), f.wnext = d, f.whave = f.wsize) : (f.wnext += e, f.wnext === f.wsize && (f.wnext = 0), f.whave < f.wsize && (f.whave += e))), 0;
			}function m(a, b) {
				var c,
				    e,
				    f,
				    g,
				    h,
				    i,
				    j,
				    m,
				    n,
				    o,
				    p,
				    q,
				    ob,
				    pb,
				    qb,
				    rb,
				    sb,
				    tb,
				    ub,
				    vb,
				    wb,
				    xb,
				    yb,
				    zb,
				    Ab = 0,
				    Bb = new r.Buf8(4),
				    Cb = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];if (!a || !a.state || !a.output || !a.input && 0 !== a.avail_in) return F;c = a.state, c.mode === V && (c.mode = W), h = a.next_out, f = a.output, j = a.avail_out, g = a.next_in, e = a.input, i = a.avail_in, m = c.hold, n = c.bits, o = i, p = j, xb = C;a: for (;;) {
					switch (c.mode) {case K:
							if (0 === c.wrap) {
								c.mode = W;break;
							}for (; 16 > n;) {
								if (0 === i) break a;i--, m += e[g++] << n, n += 8;
							}if (2 & c.wrap && 35615 === m) {
								c.check = 0, Bb[0] = 255 & m, Bb[1] = m >>> 8 & 255, c.check = t(c.check, Bb, 2, 0), m = 0, n = 0, c.mode = L;break;
							}if (c.flags = 0, c.head && (c.head.done = !1), !(1 & c.wrap) || (((255 & m) << 8) + (m >> 8)) % 31) {
								a.msg = "incorrect header check", c.mode = lb;break;
							}if ((15 & m) !== J) {
								a.msg = "unknown compression method", c.mode = lb;break;
							}if (m >>>= 4, n -= 4, wb = (15 & m) + 8, 0 === c.wbits) c.wbits = wb;else if (wb > c.wbits) {
								a.msg = "invalid window size", c.mode = lb;break;
							}c.dmax = 1 << wb, a.adler = c.check = 1, c.mode = 512 & m ? T : V, m = 0, n = 0;break;case L:
							for (; 16 > n;) {
								if (0 === i) break a;i--, m += e[g++] << n, n += 8;
							}if (c.flags = m, (255 & c.flags) !== J) {
								a.msg = "unknown compression method", c.mode = lb;break;
							}if (57344 & c.flags) {
								a.msg = "unknown header flags set", c.mode = lb;break;
							}c.head && (c.head.text = m >> 8 & 1), 512 & c.flags && (Bb[0] = 255 & m, Bb[1] = m >>> 8 & 255, c.check = t(c.check, Bb, 2, 0)), m = 0, n = 0, c.mode = M;case M:
							for (; 32 > n;) {
								if (0 === i) break a;i--, m += e[g++] << n, n += 8;
							}c.head && (c.head.time = m), 512 & c.flags && (Bb[0] = 255 & m, Bb[1] = m >>> 8 & 255, Bb[2] = m >>> 16 & 255, Bb[3] = m >>> 24 & 255, c.check = t(c.check, Bb, 4, 0)), m = 0, n = 0, c.mode = N;case N:
							for (; 16 > n;) {
								if (0 === i) break a;i--, m += e[g++] << n, n += 8;
							}c.head && (c.head.xflags = 255 & m, c.head.os = m >> 8), 512 & c.flags && (Bb[0] = 255 & m, Bb[1] = m >>> 8 & 255, c.check = t(c.check, Bb, 2, 0)), m = 0, n = 0, c.mode = O;case O:
							if (1024 & c.flags) {
								for (; 16 > n;) {
									if (0 === i) break a;i--, m += e[g++] << n, n += 8;
								}c.length = m, c.head && (c.head.extra_len = m), 512 & c.flags && (Bb[0] = 255 & m, Bb[1] = m >>> 8 & 255, c.check = t(c.check, Bb, 2, 0)), m = 0, n = 0;
							} else c.head && (c.head.extra = null);c.mode = P;case P:
							if (1024 & c.flags && (q = c.length, q > i && (q = i), q && (c.head && (wb = c.head.extra_len - c.length, c.head.extra || (c.head.extra = new Array(c.head.extra_len)), r.arraySet(c.head.extra, e, g, q, wb)), 512 & c.flags && (c.check = t(c.check, e, q, g)), i -= q, g += q, c.length -= q), c.length)) break a;c.length = 0, c.mode = Q;case Q:
							if (2048 & c.flags) {
								if (0 === i) break a;q = 0;do {
									wb = e[g + q++], c.head && wb && c.length < 65536 && (c.head.name += String.fromCharCode(wb));
								} while (wb && i > q);if (512 & c.flags && (c.check = t(c.check, e, q, g)), i -= q, g += q, wb) break a;
							} else c.head && (c.head.name = null);c.length = 0, c.mode = R;case R:
							if (4096 & c.flags) {
								if (0 === i) break a;q = 0;do {
									wb = e[g + q++], c.head && wb && c.length < 65536 && (c.head.comment += String.fromCharCode(wb));
								} while (wb && i > q);if (512 & c.flags && (c.check = t(c.check, e, q, g)), i -= q, g += q, wb) break a;
							} else c.head && (c.head.comment = null);c.mode = S;case S:
							if (512 & c.flags) {
								for (; 16 > n;) {
									if (0 === i) break a;i--, m += e[g++] << n, n += 8;
								}if (m !== (65535 & c.check)) {
									a.msg = "header crc mismatch", c.mode = lb;break;
								}m = 0, n = 0;
							}c.head && (c.head.hcrc = c.flags >> 9 & 1, c.head.done = !0), a.adler = c.check = 0, c.mode = V;break;case T:
							for (; 32 > n;) {
								if (0 === i) break a;i--, m += e[g++] << n, n += 8;
							}a.adler = c.check = d(m), m = 0, n = 0, c.mode = U;case U:
							if (0 === c.havedict) return a.next_out = h, a.avail_out = j, a.next_in = g, a.avail_in = i, c.hold = m, c.bits = n, E;a.adler = c.check = 1, c.mode = V;case V:
							if (b === A || b === B) break a;case W:
							if (c.last) {
								m >>>= 7 & n, n -= 7 & n, c.mode = ib;break;
							}for (; 3 > n;) {
								if (0 === i) break a;i--, m += e[g++] << n, n += 8;
							}switch (c.last = 1 & m, m >>>= 1, n -= 1, 3 & m) {case 0:
									c.mode = X;break;case 1:
									if (k(c), c.mode = bb, b === B) {
										m >>>= 2, n -= 2;break a;
									}break;case 2:
									c.mode = $;break;case 3:
									a.msg = "invalid block type", c.mode = lb;}m >>>= 2, n -= 2;break;case X:
							for (m >>>= 7 & n, n -= 7 & n; 32 > n;) {
								if (0 === i) break a;i--, m += e[g++] << n, n += 8;
							}if ((65535 & m) !== (m >>> 16 ^ 65535)) {
								a.msg = "invalid stored block lengths", c.mode = lb;break;
							}if (c.length = 65535 & m, m = 0, n = 0, c.mode = Y, b === B) break a;case Y:
							c.mode = Z;case Z:
							if (q = c.length) {
								if (q > i && (q = i), q > j && (q = j), 0 === q) break a;r.arraySet(f, e, g, q, h), i -= q, g += q, j -= q, h += q, c.length -= q;break;
							}c.mode = V;break;case $:
							for (; 14 > n;) {
								if (0 === i) break a;i--, m += e[g++] << n, n += 8;
							}if (c.nlen = (31 & m) + 257, m >>>= 5, n -= 5, c.ndist = (31 & m) + 1, m >>>= 5, n -= 5, c.ncode = (15 & m) + 4, m >>>= 4, n -= 4, c.nlen > 286 || c.ndist > 30) {
								a.msg = "too many length or distance symbols", c.mode = lb;break;
							}c.have = 0, c.mode = _;case _:
							for (; c.have < c.ncode;) {
								for (; 3 > n;) {
									if (0 === i) break a;i--, m += e[g++] << n, n += 8;
								}c.lens[Cb[c.have++]] = 7 & m, m >>>= 3, n -= 3;
							}for (; c.have < 19;) {
								c.lens[Cb[c.have++]] = 0;
							}if (c.lencode = c.lendyn, c.lenbits = 7, yb = { bits: c.lenbits }, xb = v(w, c.lens, 0, 19, c.lencode, 0, c.work, yb), c.lenbits = yb.bits, xb) {
								a.msg = "invalid code lengths set", c.mode = lb;break;
							}c.have = 0, c.mode = ab;case ab:
							for (; c.have < c.nlen + c.ndist;) {
								for (; Ab = c.lencode[m & (1 << c.lenbits) - 1], qb = Ab >>> 24, rb = Ab >>> 16 & 255, sb = 65535 & Ab, !(n >= qb);) {
									if (0 === i) break a;i--, m += e[g++] << n, n += 8;
								}if (16 > sb) m >>>= qb, n -= qb, c.lens[c.have++] = sb;else {
									if (16 === sb) {
										for (zb = qb + 2; zb > n;) {
											if (0 === i) break a;i--, m += e[g++] << n, n += 8;
										}if (m >>>= qb, n -= qb, 0 === c.have) {
											a.msg = "invalid bit length repeat", c.mode = lb;break;
										}wb = c.lens[c.have - 1], q = 3 + (3 & m), m >>>= 2, n -= 2;
									} else if (17 === sb) {
										for (zb = qb + 3; zb > n;) {
											if (0 === i) break a;i--, m += e[g++] << n, n += 8;
										}m >>>= qb, n -= qb, wb = 0, q = 3 + (7 & m), m >>>= 3, n -= 3;
									} else {
										for (zb = qb + 7; zb > n;) {
											if (0 === i) break a;i--, m += e[g++] << n, n += 8;
										}m >>>= qb, n -= qb, wb = 0, q = 11 + (127 & m), m >>>= 7, n -= 7;
									}if (c.have + q > c.nlen + c.ndist) {
										a.msg = "invalid bit length repeat", c.mode = lb;break;
									}for (; q--;) {
										c.lens[c.have++] = wb;
									}
								}
							}if (c.mode === lb) break;if (0 === c.lens[256]) {
								a.msg = "invalid code -- missing end-of-block", c.mode = lb;break;
							}if (c.lenbits = 9, yb = { bits: c.lenbits }, xb = v(x, c.lens, 0, c.nlen, c.lencode, 0, c.work, yb), c.lenbits = yb.bits, xb) {
								a.msg = "invalid literal/lengths set", c.mode = lb;break;
							}if (c.distbits = 6, c.distcode = c.distdyn, yb = { bits: c.distbits }, xb = v(y, c.lens, c.nlen, c.ndist, c.distcode, 0, c.work, yb), c.distbits = yb.bits, xb) {
								a.msg = "invalid distances set", c.mode = lb;break;
							}if (c.mode = bb, b === B) break a;case bb:
							c.mode = cb;case cb:
							if (i >= 6 && j >= 258) {
								a.next_out = h, a.avail_out = j, a.next_in = g, a.avail_in = i, c.hold = m, c.bits = n, u(a, p), h = a.next_out, f = a.output, j = a.avail_out, g = a.next_in, e = a.input, i = a.avail_in, m = c.hold, n = c.bits, c.mode === V && (c.back = -1);
								break;
							}for (c.back = 0; Ab = c.lencode[m & (1 << c.lenbits) - 1], qb = Ab >>> 24, rb = Ab >>> 16 & 255, sb = 65535 & Ab, !(n >= qb);) {
								if (0 === i) break a;i--, m += e[g++] << n, n += 8;
							}if (rb && 0 === (240 & rb)) {
								for (tb = qb, ub = rb, vb = sb; Ab = c.lencode[vb + ((m & (1 << tb + ub) - 1) >> tb)], qb = Ab >>> 24, rb = Ab >>> 16 & 255, sb = 65535 & Ab, !(n >= tb + qb);) {
									if (0 === i) break a;i--, m += e[g++] << n, n += 8;
								}m >>>= tb, n -= tb, c.back += tb;
							}if (m >>>= qb, n -= qb, c.back += qb, c.length = sb, 0 === rb) {
								c.mode = hb;break;
							}if (32 & rb) {
								c.back = -1, c.mode = V;break;
							}if (64 & rb) {
								a.msg = "invalid literal/length code", c.mode = lb;break;
							}c.extra = 15 & rb, c.mode = db;case db:
							if (c.extra) {
								for (zb = c.extra; zb > n;) {
									if (0 === i) break a;i--, m += e[g++] << n, n += 8;
								}c.length += m & (1 << c.extra) - 1, m >>>= c.extra, n -= c.extra, c.back += c.extra;
							}c.was = c.length, c.mode = eb;case eb:
							for (; Ab = c.distcode[m & (1 << c.distbits) - 1], qb = Ab >>> 24, rb = Ab >>> 16 & 255, sb = 65535 & Ab, !(n >= qb);) {
								if (0 === i) break a;i--, m += e[g++] << n, n += 8;
							}if (0 === (240 & rb)) {
								for (tb = qb, ub = rb, vb = sb; Ab = c.distcode[vb + ((m & (1 << tb + ub) - 1) >> tb)], qb = Ab >>> 24, rb = Ab >>> 16 & 255, sb = 65535 & Ab, !(n >= tb + qb);) {
									if (0 === i) break a;i--, m += e[g++] << n, n += 8;
								}m >>>= tb, n -= tb, c.back += tb;
							}if (m >>>= qb, n -= qb, c.back += qb, 64 & rb) {
								a.msg = "invalid distance code", c.mode = lb;break;
							}c.offset = sb, c.extra = 15 & rb, c.mode = fb;case fb:
							if (c.extra) {
								for (zb = c.extra; zb > n;) {
									if (0 === i) break a;i--, m += e[g++] << n, n += 8;
								}c.offset += m & (1 << c.extra) - 1, m >>>= c.extra, n -= c.extra, c.back += c.extra;
							}if (c.offset > c.dmax) {
								a.msg = "invalid distance too far back", c.mode = lb;break;
							}c.mode = gb;case gb:
							if (0 === j) break a;if (q = p - j, c.offset > q) {
								if (q = c.offset - q, q > c.whave && c.sane) {
									a.msg = "invalid distance too far back", c.mode = lb;break;
								}q > c.wnext ? (q -= c.wnext, ob = c.wsize - q) : ob = c.wnext - q, q > c.length && (q = c.length), pb = c.window;
							} else pb = f, ob = h - c.offset, q = c.length;q > j && (q = j), j -= q, c.length -= q;do {
								f[h++] = pb[ob++];
							} while (--q);0 === c.length && (c.mode = cb);break;case hb:
							if (0 === j) break a;f[h++] = c.length, j--, c.mode = cb;break;case ib:
							if (c.wrap) {
								for (; 32 > n;) {
									if (0 === i) break a;i--, m |= e[g++] << n, n += 8;
								}if (p -= j, a.total_out += p, c.total += p, p && (a.adler = c.check = c.flags ? t(c.check, f, p, h - p) : s(c.check, f, p, h - p)), p = j, (c.flags ? m : d(m)) !== c.check) {
									a.msg = "incorrect data check", c.mode = lb;break;
								}m = 0, n = 0;
							}c.mode = jb;case jb:
							if (c.wrap && c.flags) {
								for (; 32 > n;) {
									if (0 === i) break a;i--, m += e[g++] << n, n += 8;
								}if (m !== (4294967295 & c.total)) {
									a.msg = "incorrect length check", c.mode = lb;break;
								}m = 0, n = 0;
							}c.mode = kb;case kb:
							xb = D;break a;case lb:
							xb = G;break a;case mb:
							return H;case nb:default:
							return F;}
				}return a.next_out = h, a.avail_out = j, a.next_in = g, a.avail_in = i, c.hold = m, c.bits = n, (c.wsize || p !== a.avail_out && c.mode < lb && (c.mode < ib || b !== z)) && l(a, a.output, a.next_out, p - a.avail_out) ? (c.mode = mb, H) : (o -= a.avail_in, p -= a.avail_out, a.total_in += o, a.total_out += p, c.total += p, c.wrap && p && (a.adler = c.check = c.flags ? t(c.check, f, p, a.next_out - p) : s(c.check, f, p, a.next_out - p)), a.data_type = c.bits + (c.last ? 64 : 0) + (c.mode === V ? 128 : 0) + (c.mode === bb || c.mode === Y ? 256 : 0), (0 === o && 0 === p || b === z) && xb === C && (xb = I), xb);
			}function n(a) {
				if (!a || !a.state) return F;var b = a.state;return b.window && (b.window = null), a.state = null, C;
			}function o(a, b) {
				var c;return a && a.state ? (c = a.state, 0 === (2 & c.wrap) ? F : (c.head = b, b.done = !1, C)) : F;
			}var p,
			    q,
			    r = a("../utils/common"),
			    s = a("./adler32"),
			    t = a("./crc32"),
			    u = a("./inffast"),
			    v = a("./inftrees"),
			    w = 0,
			    x = 1,
			    y = 2,
			    z = 4,
			    A = 5,
			    B = 6,
			    C = 0,
			    D = 1,
			    E = 2,
			    F = -2,
			    G = -3,
			    H = -4,
			    I = -5,
			    J = 8,
			    K = 1,
			    L = 2,
			    M = 3,
			    N = 4,
			    O = 5,
			    P = 6,
			    Q = 7,
			    R = 8,
			    S = 9,
			    T = 10,
			    U = 11,
			    V = 12,
			    W = 13,
			    X = 14,
			    Y = 15,
			    Z = 16,
			    $ = 17,
			    _ = 18,
			    ab = 19,
			    bb = 20,
			    cb = 21,
			    db = 22,
			    eb = 23,
			    fb = 24,
			    gb = 25,
			    hb = 26,
			    ib = 27,
			    jb = 28,
			    kb = 29,
			    lb = 30,
			    mb = 31,
			    nb = 32,
			    ob = 852,
			    pb = 592,
			    qb = 15,
			    rb = qb,
			    sb = !0;c.inflateReset = g, c.inflateReset2 = h, c.inflateResetKeep = f, c.inflateInit = j, c.inflateInit2 = i, c.inflate = m, c.inflateEnd = n, c.inflateGetHeader = o, c.inflateInfo = "pako inflate (from Nodeca project)";
		}, { "../utils/common": 27, "./adler32": 29, "./crc32": 31, "./inffast": 34, "./inftrees": 36 }], 36: [function (a, b) {
			"use strict";
			var c = a("../utils/common"),
			    d = 15,
			    e = 852,
			    f = 592,
			    g = 0,
			    h = 1,
			    i = 2,
			    j = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],
			    k = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78],
			    l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0],
			    m = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];b.exports = function (a, b, n, o, p, q, r, s) {
				var t,
				    u,
				    v,
				    w,
				    x,
				    y,
				    z,
				    A,
				    B,
				    C = s.bits,
				    D = 0,
				    E = 0,
				    F = 0,
				    G = 0,
				    H = 0,
				    I = 0,
				    J = 0,
				    K = 0,
				    L = 0,
				    M = 0,
				    N = null,
				    O = 0,
				    P = new c.Buf16(d + 1),
				    Q = new c.Buf16(d + 1),
				    R = null,
				    S = 0;for (D = 0; d >= D; D++) {
					P[D] = 0;
				}for (E = 0; o > E; E++) {
					P[b[n + E]]++;
				}for (H = C, G = d; G >= 1 && 0 === P[G]; G--) {}if (H > G && (H = G), 0 === G) return p[q++] = 20971520, p[q++] = 20971520, s.bits = 1, 0;for (F = 1; G > F && 0 === P[F]; F++) {}for (F > H && (H = F), K = 1, D = 1; d >= D; D++) {
					if (K <<= 1, K -= P[D], 0 > K) return -1;
				}if (K > 0 && (a === g || 1 !== G)) return -1;for (Q[1] = 0, D = 1; d > D; D++) {
					Q[D + 1] = Q[D] + P[D];
				}for (E = 0; o > E; E++) {
					0 !== b[n + E] && (r[Q[b[n + E]]++] = E);
				}if (a === g ? (N = R = r, y = 19) : a === h ? (N = j, O -= 257, R = k, S -= 257, y = 256) : (N = l, R = m, y = -1), M = 0, E = 0, D = F, x = q, I = H, J = 0, v = -1, L = 1 << H, w = L - 1, a === h && L > e || a === i && L > f) return 1;for (var T = 0;;) {
					T++, z = D - J, r[E] < y ? (A = 0, B = r[E]) : r[E] > y ? (A = R[S + r[E]], B = N[O + r[E]]) : (A = 96, B = 0), t = 1 << D - J, u = 1 << I, F = u;do {
						u -= t, p[x + (M >> J) + u] = z << 24 | A << 16 | B | 0;
					} while (0 !== u);for (t = 1 << D - 1; M & t;) {
						t >>= 1;
					}if (0 !== t ? (M &= t - 1, M += t) : M = 0, E++, 0 === --P[D]) {
						if (D === G) break;D = b[n + r[E]];
					}if (D > H && (M & w) !== v) {
						for (0 === J && (J = H), x += F, I = D - J, K = 1 << I; G > I + J && (K -= P[I + J], !(0 >= K));) {
							I++, K <<= 1;
						}if (L += 1 << I, a === h && L > e || a === i && L > f) return 1;v = M & w, p[v] = H << 24 | I << 16 | x - q | 0;
					}
				}return 0 !== M && (p[x + M] = D - J << 24 | 64 << 16 | 0), s.bits = H, 0;
			};
		}, { "../utils/common": 27 }], 37: [function (a, b) {
			"use strict";
			b.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
		}, {}], 38: [function (a, b, c) {
			"use strict";
			function d(a) {
				for (var b = a.length; --b >= 0;) {
					a[b] = 0;
				}
			}function e(a) {
				return 256 > a ? gb[a] : gb[256 + (a >>> 7)];
			}function f(a, b) {
				a.pending_buf[a.pending++] = 255 & b, a.pending_buf[a.pending++] = b >>> 8 & 255;
			}function g(a, b, c) {
				a.bi_valid > V - c ? (a.bi_buf |= b << a.bi_valid & 65535, f(a, a.bi_buf), a.bi_buf = b >> V - a.bi_valid, a.bi_valid += c - V) : (a.bi_buf |= b << a.bi_valid & 65535, a.bi_valid += c);
			}function h(a, b, c) {
				g(a, c[2 * b], c[2 * b + 1]);
			}function i(a, b) {
				var c = 0;do {
					c |= 1 & a, a >>>= 1, c <<= 1;
				} while (--b > 0);return c >>> 1;
			}function j(a) {
				16 === a.bi_valid ? (f(a, a.bi_buf), a.bi_buf = 0, a.bi_valid = 0) : a.bi_valid >= 8 && (a.pending_buf[a.pending++] = 255 & a.bi_buf, a.bi_buf >>= 8, a.bi_valid -= 8);
			}function k(a, b) {
				var c,
				    d,
				    e,
				    f,
				    g,
				    h,
				    i = b.dyn_tree,
				    j = b.max_code,
				    k = b.stat_desc.static_tree,
				    l = b.stat_desc.has_stree,
				    m = b.stat_desc.extra_bits,
				    n = b.stat_desc.extra_base,
				    o = b.stat_desc.max_length,
				    p = 0;for (f = 0; U >= f; f++) {
					a.bl_count[f] = 0;
				}for (i[2 * a.heap[a.heap_max] + 1] = 0, c = a.heap_max + 1; T > c; c++) {
					d = a.heap[c], f = i[2 * i[2 * d + 1] + 1] + 1, f > o && (f = o, p++), i[2 * d + 1] = f, d > j || (a.bl_count[f]++, g = 0, d >= n && (g = m[d - n]), h = i[2 * d], a.opt_len += h * (f + g), l && (a.static_len += h * (k[2 * d + 1] + g)));
				}if (0 !== p) {
					do {
						for (f = o - 1; 0 === a.bl_count[f];) {
							f--;
						}a.bl_count[f]--, a.bl_count[f + 1] += 2, a.bl_count[o]--, p -= 2;
					} while (p > 0);for (f = o; 0 !== f; f--) {
						for (d = a.bl_count[f]; 0 !== d;) {
							e = a.heap[--c], e > j || (i[2 * e + 1] !== f && (a.opt_len += (f - i[2 * e + 1]) * i[2 * e], i[2 * e + 1] = f), d--);
						}
					}
				}
			}function l(a, b, c) {
				var d,
				    e,
				    f = new Array(U + 1),
				    g = 0;for (d = 1; U >= d; d++) {
					f[d] = g = g + c[d - 1] << 1;
				}for (e = 0; b >= e; e++) {
					var h = a[2 * e + 1];0 !== h && (a[2 * e] = i(f[h]++, h));
				}
			}function m() {
				var a,
				    b,
				    c,
				    d,
				    e,
				    f = new Array(U + 1);for (c = 0, d = 0; O - 1 > d; d++) {
					for (ib[d] = c, a = 0; a < 1 << _[d]; a++) {
						hb[c++] = d;
					}
				}for (hb[c - 1] = d, e = 0, d = 0; 16 > d; d++) {
					for (jb[d] = e, a = 0; a < 1 << ab[d]; a++) {
						gb[e++] = d;
					}
				}for (e >>= 7; R > d; d++) {
					for (jb[d] = e << 7, a = 0; a < 1 << ab[d] - 7; a++) {
						gb[256 + e++] = d;
					}
				}for (b = 0; U >= b; b++) {
					f[b] = 0;
				}for (a = 0; 143 >= a;) {
					eb[2 * a + 1] = 8, a++, f[8]++;
				}for (; 255 >= a;) {
					eb[2 * a + 1] = 9, a++, f[9]++;
				}for (; 279 >= a;) {
					eb[2 * a + 1] = 7, a++, f[7]++;
				}for (; 287 >= a;) {
					eb[2 * a + 1] = 8, a++, f[8]++;
				}for (l(eb, Q + 1, f), a = 0; R > a; a++) {
					fb[2 * a + 1] = 5, fb[2 * a] = i(a, 5);
				}kb = new nb(eb, _, P + 1, Q, U), lb = new nb(fb, ab, 0, R, U), mb = new nb(new Array(0), bb, 0, S, W);
			}function n(a) {
				var b;for (b = 0; Q > b; b++) {
					a.dyn_ltree[2 * b] = 0;
				}for (b = 0; R > b; b++) {
					a.dyn_dtree[2 * b] = 0;
				}for (b = 0; S > b; b++) {
					a.bl_tree[2 * b] = 0;
				}a.dyn_ltree[2 * X] = 1, a.opt_len = a.static_len = 0, a.last_lit = a.matches = 0;
			}function o(a) {
				a.bi_valid > 8 ? f(a, a.bi_buf) : a.bi_valid > 0 && (a.pending_buf[a.pending++] = a.bi_buf), a.bi_buf = 0, a.bi_valid = 0;
			}function p(a, b, c, d) {
				o(a), d && (f(a, c), f(a, ~c)), E.arraySet(a.pending_buf, a.window, b, c, a.pending), a.pending += c;
			}function q(a, b, c, d) {
				var e = 2 * b,
				    f = 2 * c;return a[e] < a[f] || a[e] === a[f] && d[b] <= d[c];
			}function r(a, b, c) {
				for (var d = a.heap[c], e = c << 1; e <= a.heap_len && (e < a.heap_len && q(b, a.heap[e + 1], a.heap[e], a.depth) && e++, !q(b, d, a.heap[e], a.depth));) {
					a.heap[c] = a.heap[e], c = e, e <<= 1;
				}a.heap[c] = d;
			}function s(a, b, c) {
				var d,
				    f,
				    i,
				    j,
				    k = 0;if (0 !== a.last_lit) do {
					d = a.pending_buf[a.d_buf + 2 * k] << 8 | a.pending_buf[a.d_buf + 2 * k + 1], f = a.pending_buf[a.l_buf + k], k++, 0 === d ? h(a, f, b) : (i = hb[f], h(a, i + P + 1, b), j = _[i], 0 !== j && (f -= ib[i], g(a, f, j)), d--, i = e(d), h(a, i, c), j = ab[i], 0 !== j && (d -= jb[i], g(a, d, j)));
				} while (k < a.last_lit);h(a, X, b);
			}function t(a, b) {
				var c,
				    d,
				    e,
				    f = b.dyn_tree,
				    g = b.stat_desc.static_tree,
				    h = b.stat_desc.has_stree,
				    i = b.stat_desc.elems,
				    j = -1;for (a.heap_len = 0, a.heap_max = T, c = 0; i > c; c++) {
					0 !== f[2 * c] ? (a.heap[++a.heap_len] = j = c, a.depth[c] = 0) : f[2 * c + 1] = 0;
				}for (; a.heap_len < 2;) {
					e = a.heap[++a.heap_len] = 2 > j ? ++j : 0, f[2 * e] = 1, a.depth[e] = 0, a.opt_len--, h && (a.static_len -= g[2 * e + 1]);
				}for (b.max_code = j, c = a.heap_len >> 1; c >= 1; c--) {
					r(a, f, c);
				}e = i;do {
					c = a.heap[1], a.heap[1] = a.heap[a.heap_len--], r(a, f, 1), d = a.heap[1], a.heap[--a.heap_max] = c, a.heap[--a.heap_max] = d, f[2 * e] = f[2 * c] + f[2 * d], a.depth[e] = (a.depth[c] >= a.depth[d] ? a.depth[c] : a.depth[d]) + 1, f[2 * c + 1] = f[2 * d + 1] = e, a.heap[1] = e++, r(a, f, 1);
				} while (a.heap_len >= 2);a.heap[--a.heap_max] = a.heap[1], k(a, b), l(f, j, a.bl_count);
			}function u(a, b, c) {
				var d,
				    e,
				    f = -1,
				    g = b[1],
				    h = 0,
				    i = 7,
				    j = 4;for (0 === g && (i = 138, j = 3), b[2 * (c + 1) + 1] = 65535, d = 0; c >= d; d++) {
					e = g, g = b[2 * (d + 1) + 1], ++h < i && e === g || (j > h ? a.bl_tree[2 * e] += h : 0 !== e ? (e !== f && a.bl_tree[2 * e]++, a.bl_tree[2 * Y]++) : 10 >= h ? a.bl_tree[2 * Z]++ : a.bl_tree[2 * $]++, h = 0, f = e, 0 === g ? (i = 138, j = 3) : e === g ? (i = 6, j = 3) : (i = 7, j = 4));
				}
			}function v(a, b, c) {
				var d,
				    e,
				    f = -1,
				    i = b[1],
				    j = 0,
				    k = 7,
				    l = 4;for (0 === i && (k = 138, l = 3), d = 0; c >= d; d++) {
					if (e = i, i = b[2 * (d + 1) + 1], !(++j < k && e === i)) {
						if (l > j) {
							do {
								h(a, e, a.bl_tree);
							} while (0 !== --j);
						} else 0 !== e ? (e !== f && (h(a, e, a.bl_tree), j--), h(a, Y, a.bl_tree), g(a, j - 3, 2)) : 10 >= j ? (h(a, Z, a.bl_tree), g(a, j - 3, 3)) : (h(a, $, a.bl_tree), g(a, j - 11, 7));j = 0, f = e, 0 === i ? (k = 138, l = 3) : e === i ? (k = 6, l = 3) : (k = 7, l = 4);
					}
				}
			}function w(a) {
				var b;for (u(a, a.dyn_ltree, a.l_desc.max_code), u(a, a.dyn_dtree, a.d_desc.max_code), t(a, a.bl_desc), b = S - 1; b >= 3 && 0 === a.bl_tree[2 * cb[b] + 1]; b--) {}return a.opt_len += 3 * (b + 1) + 5 + 5 + 4, b;
			}function x(a, b, c, d) {
				var e;for (g(a, b - 257, 5), g(a, c - 1, 5), g(a, d - 4, 4), e = 0; d > e; e++) {
					g(a, a.bl_tree[2 * cb[e] + 1], 3);
				}v(a, a.dyn_ltree, b - 1), v(a, a.dyn_dtree, c - 1);
			}function y(a) {
				var b,
				    c = 4093624447;for (b = 0; 31 >= b; b++, c >>>= 1) {
					if (1 & c && 0 !== a.dyn_ltree[2 * b]) return G;
				}if (0 !== a.dyn_ltree[18] || 0 !== a.dyn_ltree[20] || 0 !== a.dyn_ltree[26]) return H;for (b = 32; P > b; b++) {
					if (0 !== a.dyn_ltree[2 * b]) return H;
				}return G;
			}function z(a) {
				pb || (m(), pb = !0), a.l_desc = new ob(a.dyn_ltree, kb), a.d_desc = new ob(a.dyn_dtree, lb), a.bl_desc = new ob(a.bl_tree, mb), a.bi_buf = 0, a.bi_valid = 0, n(a);
			}function A(a, b, c, d) {
				g(a, (J << 1) + (d ? 1 : 0), 3), p(a, b, c, !0);
			}function B(a) {
				g(a, K << 1, 3), h(a, X, eb), j(a);
			}function C(a, b, c, d) {
				var e,
				    f,
				    h = 0;a.level > 0 ? (a.strm.data_type === I && (a.strm.data_type = y(a)), t(a, a.l_desc), t(a, a.d_desc), h = w(a), e = a.opt_len + 3 + 7 >>> 3, f = a.static_len + 3 + 7 >>> 3, e >= f && (e = f)) : e = f = c + 5, e >= c + 4 && -1 !== b ? A(a, b, c, d) : a.strategy === F || f === e ? (g(a, (K << 1) + (d ? 1 : 0), 3), s(a, eb, fb)) : (g(a, (L << 1) + (d ? 1 : 0), 3), x(a, a.l_desc.max_code + 1, a.d_desc.max_code + 1, h + 1), s(a, a.dyn_ltree, a.dyn_dtree)), n(a), d && o(a);
			}function D(a, b, c) {
				return a.pending_buf[a.d_buf + 2 * a.last_lit] = b >>> 8 & 255, a.pending_buf[a.d_buf + 2 * a.last_lit + 1] = 255 & b, a.pending_buf[a.l_buf + a.last_lit] = 255 & c, a.last_lit++, 0 === b ? a.dyn_ltree[2 * c]++ : (a.matches++, b--, a.dyn_ltree[2 * (hb[c] + P + 1)]++, a.dyn_dtree[2 * e(b)]++), a.last_lit === a.lit_bufsize - 1;
			}var E = a("../utils/common"),
			    F = 4,
			    G = 0,
			    H = 1,
			    I = 2,
			    J = 0,
			    K = 1,
			    L = 2,
			    M = 3,
			    N = 258,
			    O = 29,
			    P = 256,
			    Q = P + 1 + O,
			    R = 30,
			    S = 19,
			    T = 2 * Q + 1,
			    U = 15,
			    V = 16,
			    W = 7,
			    X = 256,
			    Y = 16,
			    Z = 17,
			    $ = 18,
			    _ = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
			    ab = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
			    bb = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
			    cb = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
			    db = 512,
			    eb = new Array(2 * (Q + 2));d(eb);var fb = new Array(2 * R);d(fb);var gb = new Array(db);d(gb);var hb = new Array(N - M + 1);d(hb);var ib = new Array(O);d(ib);var jb = new Array(R);d(jb);var kb,
			    lb,
			    mb,
			    nb = function nb(a, b, c, d, e) {
				this.static_tree = a, this.extra_bits = b, this.extra_base = c, this.elems = d, this.max_length = e, this.has_stree = a && a.length;
			},
			    ob = function ob(a, b) {
				this.dyn_tree = a, this.max_code = 0, this.stat_desc = b;
			},
			    pb = !1;c._tr_init = z, c._tr_stored_block = A, c._tr_flush_block = C, c._tr_tally = D, c._tr_align = B;
		}, { "../utils/common": 27 }], 39: [function (a, b) {
			"use strict";
			function c() {
				this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
			}b.exports = c;
		}, {}] }, {}, [9])(9);
});
/*!
* screenfull
* v1.1.0 - 2013-09-06
* https://github.com/sindresorhus/screenfull.js
* (c) Sindre Sorhus; MIT License
*/
!function (a, b) {
	"use strict";
	var c = "undefined" != typeof Element && "ALLOW_KEYBOARD_INPUT" in Element,
	    d = function () {
		for (var a, c, d = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"], ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenchange", "MSFullscreenerror"]], e = 0, f = d.length, g = {}; f > e; e++) {
			if (a = d[e], a && a[1] in b) {
				for (e = 0, c = a.length; c > e; e++) {
					g[d[0][e]] = a[e];
				}return g;
			}
		}return !1;
	}(),
	    e = { request: function request(a) {
			var e = d.requestFullscreen;a = a || b.documentElement, /5\.1[\.\d]* Safari/.test(navigator.userAgent) ? a[e]() : a[e](c && Element.ALLOW_KEYBOARD_INPUT);
		}, exit: function exit() {
			b[d.exitFullscreen]();
		}, toggle: function toggle(a) {
			this.isFullscreen ? this.exit() : this.request(a);
		}, onchange: function onchange() {}, onerror: function onerror() {}, raw: d };return d ? (Object.defineProperties(e, { isFullscreen: { get: function get() {
				return !!b[d.fullscreenElement];
			} }, element: { enumerable: !0, get: function get() {
				return b[d.fullscreenElement];
			} }, enabled: { enumerable: !0, get: function get() {
				return !!b[d.fullscreenEnabled];
			} } }), b.addEventListener(d.fullscreenchange, function (a) {
		e.onchange.call(e, a);
	}), b.addEventListener(d.fullscreenerror, function (a) {
		e.onerror.call(e, a);
	}), a.screenfull = e, void 0) : (a.screenfull = !1, void 0);
}(window, document);
/*!
 * @overview RSVP - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2016 Yehuda Katz, Tom Dale, Stefan Penner and contributors
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE
 * @version   3.5.0
 */
"use strict";!function (a, b) {
	"object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? b(exports) : "function" == typeof define && define.amd ? define(["exports"], b) : b(a.RSVP = a.RSVP || {});
}(this, function (a) {
	function b(a, b) {
		for (var c = 0, d = a.length; c < d; c++) {
			if (a[c] === b) return c;
		}return -1;
	}function c(a) {
		var b = a._promiseCallbacks;return b || (b = a._promiseCallbacks = {}), b;
	}function d(a, b) {
		return "onerror" === a ? void va.on("error", b) : 2 !== arguments.length ? va[a] : void (va[a] = b);
	}function e(a) {
		return "function" == typeof a || "object" == (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a;
	}function f(a) {
		return "function" == typeof a;
	}function g(a) {
		return "object" == (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a;
	}function h() {}function i() {
		setTimeout(function () {
			for (var a = 0; a < Aa.length; a++) {
				var b = Aa[a],
				    c = b.payload;c.guid = c.key + c.id, c.childGuid = c.key + c.childId, c.error && (c.stack = c.error.stack), va.trigger(b.name, b.payload);
			}Aa.length = 0;
		}, 50);
	}function j(a, b, c) {
		1 === Aa.push({ name: a, payload: { key: b._guidKey, id: b._id, eventName: a, detail: b._result, childId: c && c._id, label: b._label, timeStamp: ya(), error: va["instrument-with-stack"] ? new Error(b._label) : null } }) && i();
	}function k(a, b) {
		var c = this;if (a && "object" == (typeof a === "undefined" ? "undefined" : _typeof(a)) && a.constructor === c) return a;var d = new c(m, b);return s(d, a), d;
	}function l() {
		return new TypeError("A promises callback cannot return that same promise.");
	}function m() {}function n(a) {
		try {
			return a.then;
		} catch (a) {
			return Ea.error = a, Ea;
		}
	}function o(a, b, c, d) {
		try {
			a.call(b, c, d);
		} catch (a) {
			return a;
		}
	}function p(a, b, c) {
		va.async(function (a) {
			var d = !1,
			    e = o(c, b, function (c) {
				d || (d = !0, b !== c ? s(a, c, void 0) : u(a, c));
			}, function (b) {
				d || (d = !0, v(a, b));
			}, "Settle: " + (a._label || " unknown promise"));!d && e && (d = !0, v(a, e));
		}, a);
	}function q(a, b) {
		b._state === Ca ? u(a, b._result) : b._state === Da ? (b._onError = null, v(a, b._result)) : w(b, void 0, function (c) {
			b !== c ? s(a, c, void 0) : u(a, c);
		}, function (b) {
			return v(a, b);
		});
	}function r(a, b, c) {
		b.constructor === a.constructor && c === C && a.constructor.resolve === k ? q(a, b) : c === Ea ? (v(a, Ea.error), Ea.error = null) : void 0 === c ? u(a, b) : f(c) ? p(a, b, c) : u(a, b);
	}function s(a, b) {
		a === b ? u(a, b) : e(b) ? r(a, b, n(b)) : u(a, b);
	}function t(a) {
		a._onError && a._onError(a._result), x(a);
	}function u(a, b) {
		a._state === Ba && (a._result = b, a._state = Ca, 0 === a._subscribers.length ? va.instrument && j("fulfilled", a) : va.async(x, a));
	}function v(a, b) {
		a._state === Ba && (a._state = Da, a._result = b, va.async(t, a));
	}function w(a, b, c, d) {
		var e = a._subscribers,
		    f = e.length;a._onError = null, e[f] = b, e[f + Ca] = c, e[f + Da] = d, 0 === f && a._state && va.async(x, a);
	}function x(a) {
		var b = a._subscribers,
		    c = a._state;if (va.instrument && j(c === Ca ? "fulfilled" : "rejected", a), 0 !== b.length) {
			for (var d = void 0, e = void 0, f = a._result, g = 0; g < b.length; g += 3) {
				d = b[g], e = b[g + c], d ? A(c, d, e, f) : e(f);
			}a._subscribers.length = 0;
		}
	}function y() {
		this.error = null;
	}function z(a, b) {
		try {
			return a(b);
		} catch (a) {
			return Fa.error = a, Fa;
		}
	}function A(a, b, c, d) {
		var e = f(c),
		    g = void 0,
		    h = void 0,
		    i = void 0,
		    j = void 0;if (e) {
			if (g = z(c, d), g === Fa ? (j = !0, h = g.error, g.error = null) : i = !0, b === g) return void v(b, l());
		} else g = d, i = !0;b._state !== Ba || (e && i ? s(b, g) : j ? v(b, h) : a === Ca ? u(b, g) : a === Da && v(b, g));
	}function B(a, b) {
		var c = !1;try {
			b(function (b) {
				c || (c = !0, s(a, b));
			}, function (b) {
				c || (c = !0, v(a, b));
			});
		} catch (b) {
			v(a, b);
		}
	}function C(a, b, c) {
		var d = arguments,
		    e = this,
		    f = e._state;if (f === Ca && !a || f === Da && !b) return va.instrument && j("chained", e, e), e;e._onError = null;var g = new e.constructor(m, c),
		    h = e._result;return va.instrument && j("chained", e, g), f ? function () {
			var a = d[f - 1];va.async(function () {
				return A(f, g, a, h);
			});
		}() : w(e, g, a, b), g;
	}function D(a, b, c) {
		return a === Ca ? { state: "fulfilled", value: c } : { state: "rejected", reason: c };
	}function E(a, b, c, d) {
		this._instanceConstructor = a, this.promise = new a(m, d), this._abortOnReject = c, this._validateInput(b) ? (this._input = b, this.length = b.length, this._remaining = b.length, this._init(), 0 === this.length ? u(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(), 0 === this._remaining && u(this.promise, this._result))) : v(this.promise, this._validationError());
	}function F(a, b) {
		return new E(this, a, !0, b).promise;
	}function G(a, b) {
		var c = this,
		    d = new c(m, b);if (!xa(a)) return v(d, new TypeError("You must pass an array to race.")), d;for (var e = 0; d._state === Ba && e < a.length; e++) {
			w(c.resolve(a[e]), void 0, function (a) {
				return s(d, a);
			}, function (a) {
				return v(d, a);
			});
		}return d;
	}function H(a, b) {
		var c = this,
		    d = new c(m, b);return v(d, a), d;
	}function I() {
		throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
	}function J() {
		throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}function K(a, b) {
		this._id = Ha++, this._label = b, this._state = void 0, this._result = void 0, this._subscribers = [], va.instrument && j("created", this), m !== a && ("function" != typeof a && I(), this instanceof K ? B(this, a) : J());
	}function L() {
		this.value = void 0;
	}function M(a) {
		try {
			return a.then;
		} catch (a) {
			return Ia.value = a, Ia;
		}
	}function N(a, b, c) {
		try {
			a.apply(b, c);
		} catch (a) {
			return Ia.value = a, Ia;
		}
	}function O(a, b) {
		for (var c = {}, d = a.length, e = new Array(d), f = 0; f < d; f++) {
			e[f] = a[f];
		}for (var g = 0; g < b.length; g++) {
			c[b[g]] = e[g + 1];
		}return c;
	}function P(a) {
		for (var b = a.length, c = new Array(b - 1), d = 1; d < b; d++) {
			c[d - 1] = a[d];
		}return c;
	}function Q(a, b) {
		return { then: function then(c, d) {
				return a.call(b, c, d);
			} };
	}function R(a, b) {
		var c = function c() {
			for (var c = this, d = arguments.length, e = new Array(d + 1), f = !1, g = 0; g < d; ++g) {
				var h = arguments[g];if (!f) {
					if ((f = U(h)) === Ja) {
						var i = new K(m);return v(i, Ja.value), i;
					}f && f !== !0 && (h = Q(f, h));
				}e[g] = h;
			}var j = new K(m);return e[d] = function (a, c) {
				a ? v(j, a) : void 0 === b ? s(j, c) : b === !0 ? s(j, P(arguments)) : xa(b) ? s(j, O(arguments, b)) : s(j, c);
			}, f ? T(j, e, a, c) : S(j, e, a, c);
		};return c.__proto__ = a, c;
	}function S(a, b, c, d) {
		var e = N(c, d, b);return e === Ia && v(a, e.value), a;
	}function T(a, b, c, d) {
		return K.all(b).then(function (b) {
			var e = N(c, d, b);return e === Ia && v(a, e.value), a;
		});
	}function U(a) {
		return !(!a || "object" != (typeof a === "undefined" ? "undefined" : _typeof(a))) && (a.constructor === K || M(a));
	}function V(a, b) {
		return K.all(a, b);
	}function W(a, b, c) {
		this._superConstructor(a, b, !1, c);
	}function X(a, b) {
		return new W(K, a, b).promise;
	}function Y(a, b) {
		return K.race(a, b);
	}function Z(a, b, c) {
		this._superConstructor(a, b, !0, c);
	}function $(a, b) {
		return new Z(K, a, b).promise;
	}function _(a, b, c) {
		this._superConstructor(a, b, !1, c);
	}function aa(a, b) {
		return new _(K, a, b).promise;
	}function ba(a) {
		throw setTimeout(function () {
			throw a;
		}), a;
	}function ca(a) {
		var b = { resolve: void 0, reject: void 0 };return b.promise = new K(function (a, c) {
			b.resolve = a, b.reject = c;
		}, a), b;
	}function da(a, b, c) {
		return K.all(a, c).then(function (a) {
			if (!f(b)) throw new TypeError("You must pass a function as map's second argument.");for (var d = a.length, e = new Array(d), g = 0; g < d; g++) {
				e[g] = b(a[g]);
			}return K.all(e, c);
		});
	}function ea(a, b) {
		return K.resolve(a, b);
	}function fa(a, b) {
		return K.reject(a, b);
	}function ga(a, b) {
		return K.all(a, b);
	}function ha(a, b) {
		return K.resolve(a, b).then(function (a) {
			return ga(a, b);
		});
	}function ia(a, b, c) {
		return (xa(a) ? ga(a, c) : ha(a, c)).then(function (a) {
			if (!f(b)) throw new TypeError("You must pass a function as filter's second argument.");for (var d = a.length, e = new Array(d), g = 0; g < d; g++) {
				e[g] = b(a[g]);
			}return ga(e, c).then(function (b) {
				for (var c = new Array(d), e = 0, f = 0; f < d; f++) {
					b[f] && (c[e] = a[f], e++);
				}return c.length = e, c;
			});
		});
	}function ja(a, b) {
		Ra[Ka] = a, Ra[Ka + 1] = b, 2 === (Ka += 2) && Sa();
	}function ka() {
		var a = process.nextTick,
		    b = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);return Array.isArray(b) && "0" === b[1] && "10" === b[2] && (a = setImmediate), function () {
			return a(pa);
		};
	}function la() {
		return void 0 !== La ? function () {
			La(pa);
		} : oa();
	}function ma() {
		var a = 0,
		    b = new Oa(pa),
		    c = document.createTextNode("");return b.observe(c, { characterData: !0 }), function () {
			return c.data = a = ++a % 2;
		};
	}function na() {
		var a = new MessageChannel();return a.port1.onmessage = pa, function () {
			return a.port2.postMessage(0);
		};
	}function oa() {
		return function () {
			return setTimeout(pa, 1);
		};
	}function pa() {
		for (var a = 0; a < Ka; a += 2) {
			(0, Ra[a])(Ra[a + 1]), Ra[a] = void 0, Ra[a + 1] = void 0;
		}Ka = 0;
	}function qa() {
		try {
			var a = require,
			    b = a("vertx");return La = b.runOnLoop || b.runOnContext, la();
		} catch (a) {
			return oa();
		}
	}function ra(a, b, c) {
		return b in a ? Object.defineProperty(a, b, { value: c, enumerable: !0, configurable: !0, writable: !0 }) : a[b] = c, a;
	}function sa() {
		va.on.apply(va, arguments);
	}function ta() {
		va.off.apply(va, arguments);
	}var ua = { mixin: function mixin(a) {
			return a.on = this.on, a.off = this.off, a.trigger = this.trigger, a._promiseCallbacks = void 0, a;
		}, on: function on(a, d) {
			if ("function" != typeof d) throw new TypeError("Callback must be a function");var e = c(this),
			    f = void 0;f = e[a], f || (f = e[a] = []), b(f, d) === -1 && f.push(d);
		}, off: function off(a, d) {
			var e = c(this),
			    f = void 0,
			    g = void 0;if (!d) return void (e[a] = []);f = e[a], (g = b(f, d)) !== -1 && f.splice(g, 1);
		}, trigger: function trigger(a, b, d) {
			var e = c(this),
			    f = void 0;if (f = e[a]) for (var g = 0; g < f.length; g++) {
				(0, f[g])(b, d);
			}
		} },
	    va = { instrument: !1 };ua.mixin(va);var wa = void 0;wa = Array.isArray ? Array.isArray : function (a) {
		return "[object Array]" === Object.prototype.toString.call(a);
	};var xa = wa,
	    ya = Date.now || function () {
		return new Date().getTime();
	},
	    za = Object.create || function (a) {
		if (arguments.length > 1) throw new Error("Second argument not supported");if ("object" != (typeof a === "undefined" ? "undefined" : _typeof(a))) throw new TypeError("Argument must be an object");return h.prototype = a, new h();
	},
	    Aa = [],
	    Ba = void 0,
	    Ca = 1,
	    Da = 2,
	    Ea = new y(),
	    Fa = new y();E.prototype._validateInput = function (a) {
		return xa(a);
	}, E.prototype._validationError = function () {
		return new Error("Array Methods must be provided an Array");
	}, E.prototype._init = function () {
		this._result = new Array(this.length);
	}, E.prototype._enumerate = function () {
		for (var a = this.length, b = this.promise, c = this._input, d = 0; b._state === Ba && d < a; d++) {
			this._eachEntry(c[d], d);
		}
	}, E.prototype._settleMaybeThenable = function (a, b) {
		var c = this._instanceConstructor,
		    d = c.resolve;if (d === k) {
			var e = n(a);if (e === C && a._state !== Ba) a._onError = null, this._settledAt(a._state, b, a._result);else if ("function" != typeof e) this._remaining--, this._result[b] = this._makeResult(Ca, b, a);else if (c === K) {
				var f = new c(m);r(f, a, e), this._willSettleAt(f, b);
			} else this._willSettleAt(new c(function (b) {
				return b(a);
			}), b);
		} else this._willSettleAt(d(a), b);
	}, E.prototype._eachEntry = function (a, b) {
		g(a) ? this._settleMaybeThenable(a, b) : (this._remaining--, this._result[b] = this._makeResult(Ca, b, a));
	}, E.prototype._settledAt = function (a, b, c) {
		var d = this.promise;d._state === Ba && (this._remaining--, this._abortOnReject && a === Da ? v(d, c) : this._result[b] = this._makeResult(a, b, c)), 0 === this._remaining && u(d, this._result);
	}, E.prototype._makeResult = function (a, b, c) {
		return c;
	}, E.prototype._willSettleAt = function (a, b) {
		var c = this;w(a, void 0, function (a) {
			return c._settledAt(Ca, b, a);
		}, function (a) {
			return c._settledAt(Da, b, a);
		});
	};var Ga = "rsvp_" + ya() + "-",
	    Ha = 0;K.cast = k, K.all = F, K.race = G, K.resolve = k, K.reject = H, K.prototype = { constructor: K, _guidKey: Ga, _onError: function _onError(a) {
			var b = this;va.after(function () {
				b._onError && va.trigger("error", a, b._label);
			});
		}, then: C, catch: function _catch(a, b) {
			return this.then(void 0, a, b);
		}, finally: function _finally(a, b) {
			var c = this,
			    d = c.constructor;return c.then(function (b) {
				return d.resolve(a()).then(function () {
					return b;
				});
			}, function (b) {
				return d.resolve(a()).then(function () {
					throw b;
				});
			}, b);
		} };var Ia = new L(),
	    Ja = new L();W.prototype = za(E.prototype), W.prototype._superConstructor = E, W.prototype._makeResult = D, W.prototype._validationError = function () {
		return new Error("allSettled must be called with an array");
	}, Z.prototype = za(E.prototype), Z.prototype._superConstructor = E, Z.prototype._init = function () {
		this._result = {};
	}, Z.prototype._validateInput = function (a) {
		return a && "object" == (typeof a === "undefined" ? "undefined" : _typeof(a));
	}, Z.prototype._validationError = function () {
		return new Error("Promise.hash must be called with an object");
	}, Z.prototype._enumerate = function () {
		var a = this,
		    b = a.promise,
		    c = a._input,
		    d = [];for (var e in c) {
			b._state === Ba && Object.prototype.hasOwnProperty.call(c, e) && d.push({ position: e, entry: c[e] });
		}var f = d.length;a._remaining = f;for (var g = void 0, h = 0; b._state === Ba && h < f; h++) {
			g = d[h], a._eachEntry(g.entry, g.position);
		}
	}, _.prototype = za(Z.prototype), _.prototype._superConstructor = E, _.prototype._makeResult = D, _.prototype._validationError = function () {
		return new Error("hashSettled must be called with an object");
	};var Ka = 0,
	    La = void 0,
	    Ma = "undefined" != typeof window ? window : void 0,
	    Na = Ma || {},
	    Oa = Na.MutationObserver || Na.WebKitMutationObserver,
	    Pa = "undefined" == typeof self && "undefined" != typeof process && "[object process]" === {}.toString.call(process),
	    Qa = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel,
	    Ra = new Array(1e3),
	    Sa = void 0;Sa = Pa ? ka() : Oa ? ma() : Qa ? na() : void 0 === Ma && "function" == typeof require ? qa() : oa();if ("object" == (typeof self === "undefined" ? "undefined" : _typeof(self))) self;else {
		if ("object" != (typeof global === "undefined" ? "undefined" : _typeof(global))) throw new Error("no global: `self` or `global` found");global;
	}var Ta;va.async = ja, va.after = function (a) {
		return setTimeout(a, 0);
	};var Ua = ea,
	    Va = function Va(a, b) {
		return va.async(a, b);
	};if ("undefined" != typeof window && "object" == _typeof(window.__PROMISE_INSTRUMENTATION__)) {
		var Wa = window.__PROMISE_INSTRUMENTATION__;d("instrument", !0);for (var Xa in Wa) {
			Wa.hasOwnProperty(Xa) && sa(Xa, Wa[Xa]);
		}
	}var Ya = (Ta = { asap: ja, cast: Ua, Promise: K, EventTarget: ua, all: V, allSettled: X, race: Y, hash: $, hashSettled: aa, rethrow: ba, defer: ca, denodeify: R, configure: d, on: sa, off: ta, resolve: ea, reject: fa, map: da }, ra(Ta, "async", Va), ra(Ta, "filter", ia), Ta);a.default = Ya, a.asap = ja, a.cast = Ua, a.Promise = K, a.EventTarget = ua, a.all = V, a.allSettled = X, a.race = Y, a.hash = $, a.hashSettled = aa, a.rethrow = ba, a.defer = ca, a.denodeify = R, a.configure = d, a.on = sa, a.off = ta, a.resolve = ea, a.reject = fa, a.map = da, a.async = Va, a.filter = ia, Object.defineProperty(a, "__esModule", { value: !0 });
});var EPUBJS = EPUBJS || {};EPUBJS.VERSION = "0.2.19", EPUBJS.plugins = EPUBJS.plugins || {}, EPUBJS.filePath = EPUBJS.filePath || "/epubjs/", EPUBJS.Render = {}, function (a) {
	var b = (a.ePub, a.ePub = function () {
		var a, b;return void 0 !== arguments[0] && ("string" == typeof arguments[0] || arguments[0] instanceof ArrayBuffer) && (a = arguments[0], arguments[1] && "object" == _typeof(arguments[1]) ? (b = arguments[1], b.bookPath = a) : b = { bookPath: a }), !arguments[0] || "object" != _typeof(arguments[0]) || arguments[0] instanceof ArrayBuffer || (b = arguments[0]), new EPUBJS.Book(b);
	});"function" == typeof define && define.amd ? define(["rsvp", "jszip", "localforage"], function (a, c, d) {
		return b;
	}) : "undefined" != typeof module && module.exports && (global.RSVP = require("rsvp"), global.JSZip = require("jszip"), global.localForage = require("localforage"), module.exports = b);
}(window), EPUBJS.Book = function (a) {
	this.settings = EPUBJS.core.defaults(a || {}, { bookPath: void 0, bookKey: void 0, packageUrl: void 0, storage: !1, fromStorage: !1, saved: !1, online: !0, contained: !1, width: void 0, height: void 0, layoutOveride: void 0, orientation: void 0, minSpreadWidth: 768, gap: "auto", version: 1, restore: !1, reload: !1, goto: !1, styles: {}, classes: [], headTags: {}, withCredentials: !1, render_method: "Iframe", displayLastPage: !1 }), this.settings.EPUBJSVERSION = EPUBJS.VERSION, this.spinePos = 0, this.stored = !1, this.online = this.settings.online || navigator.onLine, this.networkListeners(), this.ready = { manifest: new RSVP.defer(), spine: new RSVP.defer(), metadata: new RSVP.defer(), cover: new RSVP.defer(), toc: new RSVP.defer(), pageList: new RSVP.defer() }, this.readyPromises = [this.ready.manifest.promise, this.ready.spine.promise, this.ready.metadata.promise, this.ready.cover.promise, this.ready.toc.promise], this.pageList = [], this.pagination = new EPUBJS.Pagination(), this.pageListReady = this.ready.pageList.promise, this.ready.all = RSVP.all(this.readyPromises), this.ready.all.then(this._ready.bind(this)), this.isRendered = !1, this._q = EPUBJS.core.queue(this), this._rendering = !1, this._displayQ = EPUBJS.core.queue(this), this._moving = !1, this._gotoQ = EPUBJS.core.queue(this), this.renderer = new EPUBJS.Renderer(this.settings.render_method), this.renderer.setMinSpreadWidth(this.settings.minSpreadWidth), this.renderer.setGap(this.settings.gap), this.listenToRenderer(this.renderer), this.defer_opened = new RSVP.defer(), this.opened = this.defer_opened.promise, this.store = !1, this.settings.storage !== !1 && this.fromStorage(!0), ("string" == typeof this.settings.bookPath || this.settings.bookPath instanceof ArrayBuffer) && this.open(this.settings.bookPath, this.settings.reload), window.addEventListener("beforeunload", this.unload.bind(this), !1);
}, EPUBJS.Book.prototype.open = function (a, b) {
	var c,
	    d = this,
	    e = new RSVP.defer();return this.settings.bookPath = a, this.settings.contained || this.isContained(a) ? (this.settings.contained = this.contained = !0, this.bookUrl = "", c = this.unarchive(a).then(function () {
		return d.loadPackage();
	})) : (this.bookUrl = this.urlFrom(a), c = this.loadPackage()), this.settings.restore && !b && localStorage ? c.then(function (a) {
		var b = d.packageIdentifier(a);d.restore(b) || d.unpack(a), e.resolve(), d.defer_opened.resolve();
	}) : c.then(function (a) {
		d.unpack(a), e.resolve(), d.defer_opened.resolve();
	}), this._registerReplacements(this.renderer), e.promise;
}, EPUBJS.Book.prototype.loadPackage = function (a) {
	var b,
	    c = this,
	    d = new EPUBJS.Parser(),
	    e = a || "META-INF/container.xml";return b = this.settings.packageUrl ? c.loadXml(c.settings.packageUrl) : c.loadXml(c.bookUrl + e).then(function (a) {
		return d.container(a);
	}).then(function (a) {
		return c.settings.contentsPath = c.bookUrl + a.basePath, c.settings.packageUrl = c.bookUrl + a.packagePath, c.settings.encoding = a.encoding, c.loadXml(c.settings.packageUrl);
	}), b.catch(function (a) {
		console.error("Could not load book at: " + e), c.trigger("book:loadFailed", e);
	}), b;
}, EPUBJS.Book.prototype.packageIdentifier = function (a) {
	return new EPUBJS.Parser().identifier(a);
}, EPUBJS.Book.prototype.unpack = function (a) {
	var b = this,
	    c = new EPUBJS.Parser();b.contents = c.packageContents(a, b.settings.contentsPath), b.manifest = b.contents.manifest, b.spine = b.contents.spine, b.spineIndexByURL = b.contents.spineIndexByURL, b.metadata = b.contents.metadata, b.settings.bookKey || (b.settings.bookKey = b.generateBookKey(b.metadata.identifier)), b.globalLayoutProperties = b.parseLayoutProperties(b.metadata), b.contents.coverPath && (b.cover = b.contents.cover = b.settings.contentsPath + b.contents.coverPath), b.spineNodeIndex = b.contents.spineNodeIndex, b.ready.manifest.resolve(b.contents.manifest), b.ready.spine.resolve(b.contents.spine), b.ready.metadata.resolve(b.contents.metadata), b.ready.cover.resolve(b.contents.cover), b.locations = new EPUBJS.Locations(b.spine, b.store, b.settings.withCredentials), b.contents.navPath ? (b.settings.navUrl = b.settings.contentsPath + b.contents.navPath, b.loadXml(b.settings.navUrl).then(function (a) {
		return c.nav(a, b.spineIndexByURL, b.spine);
	}).then(function (a) {
		b.toc = b.contents.toc = a, b.ready.toc.resolve(b.contents.toc);
	}, function (a) {
		b.ready.toc.resolve(!1);
	}), b.loadXml(b.settings.navUrl).then(function (a) {
		return c.pageList(a, b.spineIndexByURL, b.spine);
	}).then(function (a) {
		var c = new EPUBJS.EpubCFI(),
		    d = 0;0 !== a.length && (b.pageList = b.contents.pageList = a, b.pageList.forEach(function (a) {
			a.cfi || (d += 1, c.generateCfiFromHref(a.href, b).then(function (c) {
				a.cfi = c, a.packageUrl = b.settings.packageUrl, 0 === (d -= 1) && (b.pagination.process(b.pageList), b.ready.pageList.resolve(b.pageList));
			}));
		}), d || (b.pagination.process(b.pageList), b.ready.pageList.resolve(b.pageList)));
	}, function (a) {
		b.ready.pageList.resolve([]);
	})) : b.contents.tocPath ? (b.settings.tocUrl = b.settings.contentsPath + b.contents.tocPath, b.loadXml(b.settings.tocUrl).then(function (a) {
		return c.toc(a, b.spineIndexByURL, b.spine);
	}, function (a) {
		console.error(a);
	}).then(function (a) {
		b.toc = b.contents.toc = a, b.ready.toc.resolve(b.contents.toc);
	}, function (a) {
		b.ready.toc.resolve(!1);
	})) : b.ready.toc.resolve(!1);
}, EPUBJS.Book.prototype.createHiddenRender = function (a, b, c) {
	var d,
	    e,
	    f = this.element.getBoundingClientRect(),
	    g = b || this.settings.width || f.width,
	    h = c || this.settings.height || f.height;return a.setMinSpreadWidth(this.settings.minSpreadWidth), a.setGap(this.settings.gap), this._registerReplacements(a), this.settings.forceSingle && a.forceSingle(!0), d = document.createElement("div"), d.style.visibility = "hidden", d.style.overflow = "hidden", d.style.width = "0", d.style.height = "0", this.element.appendChild(d), e = document.createElement("div"), e.style.visibility = "hidden", e.style.overflow = "hidden", e.style.width = g + "px", e.style.height = h + "px", d.appendChild(e), a.initialize(e, this.settings.width, this.settings.height), d;
}, EPUBJS.Book.prototype.generatePageList = function (a, b, c) {
	var d = [],
	    e = new EPUBJS.Renderer(this.settings.render_method, !1),
	    f = this.createHiddenRender(e, a, b),
	    g = new RSVP.defer(),
	    h = -1,
	    i = this.spine.length,
	    j = 0,
	    k = function (a) {
		var b,
		    g = h + 1,
		    l = a || new RSVP.defer();if (g >= i) l.resolve();else {
			if (c && c.cancelled) return e.remove(), this.element.removeChild(f), void l.reject(new Error("User cancelled"));h = g, b = new EPUBJS.Chapter(this.spine[h], this.store), e.displayChapter(b, this.globalLayoutProperties).then(function (a) {
				e.pageMap.forEach(function (a) {
					j += 1, d.push({ cfi: a.start, page: j });
				}), e.pageMap.length % 2 > 0 && e.spreads && (j += 1, d.push({ cfi: e.pageMap[e.pageMap.length - 1].end, page: j })), setTimeout(function () {
					k(l);
				}, 1);
			});
		}return l.promise;
	}.bind(this);k().then(function () {
		e.remove(), this.element.removeChild(f), g.resolve(d);
	}.bind(this), function (a) {
		g.reject(a);
	});return g.promise;
}, EPUBJS.Book.prototype.generatePagination = function (a, b, c) {
	var d = this,
	    e = new RSVP.defer();return this.ready.spine.promise.then(function () {
		d.generatePageList(a, b, c).then(function (a) {
			d.pageList = d.contents.pageList = a, d.pagination.process(a), d.ready.pageList.resolve(d.pageList), e.resolve(d.pageList);
		}, function (a) {
			e.reject(a);
		});
	}), e.promise;
}, EPUBJS.Book.prototype.loadPagination = function (a) {
	var b;return b = "string" == typeof a ? JSON.parse(a) : a, b && b.length && (this.pageList = b, this.pagination.process(this.pageList), this.ready.pageList.resolve(this.pageList)), this.pageList;
}, EPUBJS.Book.prototype.getPageList = function () {
	return this.ready.pageList.promise;
}, EPUBJS.Book.prototype.getMetadata = function () {
	return this.ready.metadata.promise;
}, EPUBJS.Book.prototype.getToc = function () {
	return this.ready.toc.promise;
}, EPUBJS.Book.prototype.networkListeners = function () {
	var a = this;window.addEventListener("offline", function (b) {
		a.online = !1, a.settings.storage && a.fromStorage(!0), a.trigger("book:offline");
	}, !1), window.addEventListener("online", function (b) {
		a.online = !0, a.settings.storage && a.fromStorage(!1), a.trigger("book:online");
	}, !1);
}, EPUBJS.Book.prototype.listenToRenderer = function (a) {
	var b = this;a.Events.forEach(function (c) {
		a.on(c, function (a) {
			b.trigger(c, a);
		});
	}), a.on("renderer:visibleRangeChanged", function (a) {
		var b,
		    c,
		    d,
		    e = [];this.pageList.length > 0 && (b = this.pagination.pageFromCfi(a.start), d = this.pagination.percentageFromPage(b), e.push(b), a.end && (c = this.pagination.pageFromCfi(a.end), e.push(c)), this.trigger("book:pageChanged", { anchorPage: b, percentage: d, pageRange: e }));
	}.bind(this)), a.on("render:loaded", this.loadChange.bind(this));
}, EPUBJS.Book.prototype.loadChange = function (a) {
	var b,
	    c,
	    d = EPUBJS.core.uri(a),
	    e = EPUBJS.core.uri(this.currentChapter.absolute);d.path != e.path ? (console.warn("Miss Match", d.path, this.currentChapter.absolute), b = this.spineIndexByURL[d.filename], c = new EPUBJS.Chapter(this.spine[b], this.store), this.currentChapter = c, this.renderer.currentChapter = c, this.renderer.afterLoad(this.renderer.render.docEl), this.renderer.beforeDisplay(function () {
		this.renderer.afterDisplay();
	}.bind(this))) : this._rendering || this.renderer.reformat();
}, EPUBJS.Book.prototype.unlistenToRenderer = function (a) {
	a.Events.forEach(function (b) {
		a.off(b);
	});
}, EPUBJS.Book.prototype.coverUrl = function () {
	var a = this.ready.cover.promise.then(function (a) {
		return this.settings.fromStorage ? this.store.getUrl(this.contents.cover) : this.settings.contained ? this.zip.getUrl(this.contents.cover) : this.contents.cover;
	}.bind(this));return a.then(function (a) {
		this.cover = a;
	}.bind(this)), a;
}, EPUBJS.Book.prototype.loadXml = function (a) {
	return this.settings.fromStorage ? this.store.getXml(a, this.settings.encoding) : this.settings.contained ? this.zip.getXml(a, this.settings.encoding) : EPUBJS.core.request(a, "xml", this.settings.withCredentials);
}, EPUBJS.Book.prototype.urlFrom = function (a) {
	var b,
	    c = EPUBJS.core.uri(a),
	    d = c.protocol,
	    e = "/" == c.path[0],
	    f = window.location,
	    g = f.origin || f.protocol + "//" + f.host,
	    h = document.getElementsByTagName("base");return h.length && (b = h[0].href), c.protocol ? c.origin + c.path : !d && e ? (b || g) + c.path : d || e ? void 0 : EPUBJS.core.resolveUrl(b || f.pathname, c.path);
}, EPUBJS.Book.prototype.unarchive = function (a) {
	return this.zip = new EPUBJS.Unarchiver(), this.store = this.zip, this.zip.open(a);
}, EPUBJS.Book.prototype.isContained = function (a) {
	if (a instanceof ArrayBuffer) return !0;var b = EPUBJS.core.uri(a);return !(!b.extension || "epub" != b.extension && "zip" != b.extension);
}, EPUBJS.Book.prototype.isSaved = function (a) {
	var b;return !!localStorage && (b = localStorage.getItem(a), !(!localStorage || null === b));
}, EPUBJS.Book.prototype.generateBookKey = function (a) {
	return "epubjs:" + EPUBJS.VERSION + ":" + window.location.host + ":" + a;
}, EPUBJS.Book.prototype.saveContents = function () {
	if (!localStorage) return !1;localStorage.setItem(this.settings.bookKey, JSON.stringify(this.contents));
}, EPUBJS.Book.prototype.removeSavedContents = function () {
	if (!localStorage) return !1;localStorage.removeItem(this.settings.bookKey);
}, EPUBJS.Book.prototype.renderTo = function (a) {
	var b = this;if (EPUBJS.core.isElement(a)) this.element = a;else {
		if ("string" != typeof a) return void console.error("Not an Element");this.element = EPUBJS.core.getEl(a);
	}return this.opened.then(function () {
		return b.renderer.initialize(b.element, b.settings.width, b.settings.height), b.metadata.direction && b.renderer.setDirection(b.metadata.direction), b._rendered(), b.startDisplay();
	});
}, EPUBJS.Book.prototype.startDisplay = function () {
	return this.settings.goto ? this.goto(this.settings.goto) : this.settings.previousLocationCfi ? this.gotoCfi(this.settings.previousLocationCfi) : this.displayChapter(this.spinePos, this.settings.displayLastPage);
}, EPUBJS.Book.prototype.restore = function (a) {
	var b,
	    c = this,
	    d = ["manifest", "spine", "metadata", "cover", "toc", "spineNodeIndex", "spineIndexByURL", "globalLayoutProperties"],
	    e = !1,
	    f = this.generateBookKey(a),
	    g = localStorage.getItem(f),
	    h = d.length;if (this.settings.clearSaved && (e = !0), !e && "undefined" != g && null !== g) for (c.contents = JSON.parse(g), b = 0; b < h; b++) {
		var i = d[b];if (!c.contents[i]) {
			e = !0;break;
		}c[i] = c.contents[i];
	}return !(e || !g || !this.contents || !this.settings.contentsPath) && (this.settings.bookKey = f, this.ready.manifest.resolve(this.manifest), this.ready.spine.resolve(this.spine), this.ready.metadata.resolve(this.metadata), this.ready.cover.resolve(this.cover), this.ready.toc.resolve(this.toc), !0);
}, EPUBJS.Book.prototype.displayChapter = function (a, b, c) {
	var d,
	    e,
	    f,
	    g,
	    h = this,
	    i = c || new RSVP.defer();return this.isRendered ? this._rendering || this.renderer._moving ? (this._displayQ.enqueue("displayChapter", [a, b, i]), i.promise) : (EPUBJS.core.isNumber(a) ? f = a : (e = new EPUBJS.EpubCFI(a), f = e.spinePos), (f < 0 || f >= this.spine.length) && (console.warn("Not A Valid Location"), f = 0, b = !1, e = !1), g = new EPUBJS.Chapter(this.spine[f], this.store), this._rendering = !0, this._needsAssetReplacement() && g.registerHook("beforeChapterRender", [EPUBJS.replace.head, EPUBJS.replace.resources, EPUBJS.replace.posters, EPUBJS.replace.svg], !0), h.currentChapter = g, d = h.renderer.displayChapter(g, this.globalLayoutProperties), e ? h.renderer.gotoCfi(e) : b && h.renderer.lastPage(), d.then(function (a) {
		h.spinePos = f, i.resolve(h.renderer), h.settings.fromStorage === !1 && h.settings.contained === !1 && h.preloadNextChapter(), h._rendering = !1, h._displayQ.dequeue(), 0 === h._displayQ.length() && h._gotoQ.dequeue();
	}, function (a) {
		console.error("Could not load Chapter: " + g.absolute, a), h.trigger("book:chapterLoadFailed", g.absolute), h._rendering = !1, i.reject(a);
	}), i.promise) : (this._q.enqueue("displayChapter", arguments), i.reject({ message: "Rendering", stack: new Error().stack }), i.promise);
}, EPUBJS.Book.prototype.nextPage = function (a) {
	var a = a || new RSVP.defer();return this.isRendered ? this.renderer.nextPage() ? (a.resolve(!0), a.promise) : this.nextChapter(a) : (this._q.enqueue("nextPage", [a]), a.promise);
}, EPUBJS.Book.prototype.prevPage = function (a) {
	var a = a || new RSVP.defer();return this.isRendered ? this.renderer.prevPage() ? (a.resolve(!0), a.promise) : this.prevChapter(a) : (this._q.enqueue("prevPage", [a]), a.promise);
}, EPUBJS.Book.prototype.nextChapter = function (a) {
	var a = a || new RSVP.defer();if (this.spinePos < this.spine.length - 1) {
		for (var b = this.spinePos + 1; this.spine[b] && this.spine[b].linear && "no" == this.spine[b].linear;) {
			b++;
		}if (b < this.spine.length) return this.displayChapter(b, !1, a);
	}return this.trigger("book:atEnd"), a.resolve(!0), a.promise;
}, EPUBJS.Book.prototype.prevChapter = function (a) {
	var a = a || new RSVP.defer();if (this.spinePos > 0) {
		for (var b = this.spinePos - 1; this.spine[b] && this.spine[b].linear && "no" == this.spine[b].linear;) {
			b--;
		}if (b >= 0) return this.displayChapter(b, !0, a);
	}return this.trigger("book:atStart"), a.resolve(!0), a.promise;
}, EPUBJS.Book.prototype.getCurrentLocationCfi = function () {
	return !!this.isRendered && this.renderer.currentLocationCfi;
}, EPUBJS.Book.prototype.goto = function (a) {
	return 0 === a.indexOf("epubcfi(") ? this.gotoCfi(a) : a.indexOf("%") === a.length - 1 ? this.gotoPercentage(parseInt(a.substring(0, a.length - 1)) / 100) : "number" == typeof a || isNaN(a) === !1 ? this.gotoPage(a) : this.gotoHref(a);
}, EPUBJS.Book.prototype.gotoCfi = function (a, b) {
	var c,
	    d,
	    e,
	    f,
	    g,
	    h = b || new RSVP.defer();return this.isRendered ? this._moving || this._rendering ? (console.warn("Renderer is moving"), this._gotoQ.enqueue("gotoCfi", [a, h]), !1) : (c = new EPUBJS.EpubCFI(a), (d = c.spinePos) != -1 && (e = this.spine[d], f = h.promise, this._moving = !0, this.currentChapter && this.spinePos === d ? (this.renderer.gotoCfi(c), this._moving = !1, h.resolve(this.renderer.currentLocationCfi)) : (e && d != -1 || (d = 0, e = this.spine[d]), g = this.displayChapter(a), g.then(function (a) {
		this._moving = !1, h.resolve(a.currentLocationCfi);
	}.bind(this), function () {
		this._moving = !1;
	}.bind(this))), f.then(function () {
		this._gotoQ.dequeue();
	}.bind(this)), f)) : (console.warn("Not yet Rendered"), this.settings.previousLocationCfi = a, !1);
}, EPUBJS.Book.prototype.gotoHref = function (a, b) {
	var c,
	    d,
	    e,
	    f,
	    g,
	    h = b || new RSVP.defer();return this.isRendered ? this._moving || this._rendering ? (this._gotoQ.enqueue("gotoHref", [a, h]), !1) : (c = a.split("#"), d = c[0], e = c[1] || !1, f = d.search("://") == -1 ? d.replace(EPUBJS.core.uri(this.settings.contentsPath).path, "") : d.replace(this.settings.contentsPath, ""), g = this.spineIndexByURL[f], d || (g = this.currentChapter ? this.currentChapter.spinePos : 0), "number" == typeof g && (this.currentChapter && g == this.currentChapter.spinePos ? (e ? this.renderer.section(e) : this.renderer.firstPage(), h.resolve(this.renderer.currentLocationCfi), h.promise.then(function () {
		this._gotoQ.dequeue();
	}.bind(this)), h.promise) : this.displayChapter(g).then(function () {
		e && this.renderer.section(e), h.resolve(this.renderer.currentLocationCfi);
	}.bind(this)))) : (this.settings.goto = a, !1);
}, EPUBJS.Book.prototype.gotoPage = function (a) {
	var b = this.pagination.cfiFromPage(a);return this.gotoCfi(b);
}, EPUBJS.Book.prototype.gotoPercentage = function (a) {
	var b = this.pagination.pageFromPercentage(a);return this.gotoPage(b);
}, EPUBJS.Book.prototype.preloadNextChapter = function () {
	var a,
	    b = this.spinePos + 1;if (b >= this.spine.length) return !1;(a = new EPUBJS.Chapter(this.spine[b])) && EPUBJS.core.request(a.absolute);
}, EPUBJS.Book.prototype.storeOffline = function () {
	var a = this,
	    b = EPUBJS.core.values(this.manifest);return this.store.put(b).then(function () {
		a.settings.stored = !0, a.trigger("book:stored");
	});
}, EPUBJS.Book.prototype.availableOffline = function () {
	return this.settings.stored > 0;
}, EPUBJS.Book.prototype.toStorage = function () {
	var a = this.settings.bookKey;this.store.isStored(a).then(function (b) {
		return b === !0 ? (this.settings.stored = !0, !0) : this.storeOffline().then(function () {
			this.store.token(a, !0);
		}.bind(this));
	}.bind(this));
}, EPUBJS.Book.prototype.fromStorage = function (a) {
	EPUBJS.replace.head, EPUBJS.replace.resources, EPUBJS.replace.posters, EPUBJS.replace.svg;this.contained || this.settings.contained || (this.online && this.opened.then(this.toStorage.bind(this)), this.store && this.settings.fromStorage && a === !1 ? (this.settings.fromStorage = !1, this.store.off("offline"), this.store = !1) : this.settings.fromStorage || (this.store = new EPUBJS.Storage(this.settings.credentials), this.store.on("offline", function (a) {
		a ? (this.offline = !0, this.settings.fromStorage = !0, this.trigger("book:offline")) : (this.offline = !1, this.settings.fromStorage = !1, this.trigger("book:online"));
	}.bind(this))));
}, EPUBJS.Book.prototype.setStyle = function (a, b, c) {
	var d = ["color", "background", "background-color"];if (!this.isRendered) return this._q.enqueue("setStyle", arguments);this.settings.styles[a] = b, this.renderer.setStyle(a, b, c), d.indexOf(a) === -1 && this.renderer.reformat();
}, EPUBJS.Book.prototype.removeStyle = function (a) {
	if (!this.isRendered) return this._q.enqueue("removeStyle", arguments);this.renderer.removeStyle(a), this.renderer.reformat(), delete this.settings.styles[a];
}, EPUBJS.Book.prototype.resetClasses = function (a) {
	if (!this.isRendered) return this._q.enqueue("setClasses", arguments);a.constructor === String && (a = [a]), this.settings.classes = a, this.renderer.setClasses(this.settings.classes), this.renderer.reformat();
}, EPUBJS.Book.prototype.addClass = function (a) {
	if (!this.isRendered) return this._q.enqueue("addClass", arguments);this.settings.classes.indexOf(a) == -1 && this.settings.classes.push(a), this.renderer.setClasses(this.settings.classes), this.renderer.reformat();
}, EPUBJS.Book.prototype.removeClass = function (a) {
	if (!this.isRendered) return this._q.enqueue("removeClass", arguments);var b = this.settings.classes.indexOf(a);b != -1 && (delete this.settings.classes[b], this.renderer.setClasses(this.settings.classes), this.renderer.reformat());
}, EPUBJS.Book.prototype.addHeadTag = function (a, b) {
	if (!this.isRendered) return this._q.enqueue("addHeadTag", arguments);this.settings.headTags[a] = b;
}, EPUBJS.Book.prototype.useSpreads = function (a) {
	console.warn("useSpreads is deprecated, use forceSingle or set a layoutOveride instead"), a === !1 ? this.forceSingle(!0) : this.forceSingle(!1);
}, EPUBJS.Book.prototype.forceSingle = function (a) {
	var b = void 0 === a || a;this.renderer.forceSingle(b), this.settings.forceSingle = b, this.isRendered && this.renderer.reformat();
}, EPUBJS.Book.prototype.setMinSpreadWidth = function (a) {
	this.settings.minSpreadWidth = a, this.isRendered && (this.renderer.setMinSpreadWidth(this.settings.minSpreadWidth), this.renderer.reformat());
}, EPUBJS.Book.prototype.setGap = function (a) {
	this.settings.gap = a, this.isRendered && (this.renderer.setGap(this.settings.gap), this.renderer.reformat());
}, EPUBJS.Book.prototype.chapter = function (a) {
	var b,
	    c,
	    d = this.spineIndexByURL[a];return d && (b = this.spine[d], c = new EPUBJS.Chapter(b, this.store, this.settings.withCredentials), c.load()), c;
}, EPUBJS.Book.prototype.unload = function () {
	this.settings.restore && localStorage && this.saveContents(), this.unlistenToRenderer(this.renderer), this.trigger("book:unload");
}, EPUBJS.Book.prototype.destroy = function () {
	window.removeEventListener("beforeunload", this.unload), this.currentChapter && this.currentChapter.unload(), this.unload(), this.renderer && this.renderer.remove();
}, EPUBJS.Book.prototype._ready = function () {
	this.trigger("book:ready");
}, EPUBJS.Book.prototype._rendered = function (a) {
	this.isRendered = !0, this.trigger("book:rendered"), this._q.flush();
}, EPUBJS.Book.prototype.applyStyles = function (a, b) {
	a.applyStyles(this.settings.styles), b();
}, EPUBJS.Book.prototype.applyClasses = function (a, b) {
	a.setClasses(this.settings.classes), b();
}, EPUBJS.Book.prototype.applyHeadTags = function (a, b) {
	a.applyHeadTags(this.settings.headTags), b();
}, EPUBJS.Book.prototype._registerReplacements = function (a) {
	a.registerHook("beforeChapterDisplay", this.applyStyles.bind(this, a), !0), a.registerHook("beforeChapterDisplay", this.applyHeadTags.bind(this, a), !0), a.registerHook("beforeChapterDisplay", this.applyClasses.bind(this, a), !0), a.registerHook("beforeChapterDisplay", EPUBJS.replace.hrefs.bind(this), !0);
}, EPUBJS.Book.prototype._needsAssetReplacement = function () {
	return !!this.settings.fromStorage || !!this.settings.contained;
}, EPUBJS.Book.prototype.parseLayoutProperties = function (a) {
	return { layout: this.settings.layoutOveride && this.settings.layoutOveride.layout || a.layout || "reflowable", spread: this.settings.layoutOveride && this.settings.layoutOveride.spread || a.spread || "auto", orientation: this.settings.layoutOveride && this.settings.layoutOveride.orientation || a.orientation || "auto" };
}, RSVP.EventTarget.mixin(EPUBJS.Book.prototype), RSVP.on("error", function (a) {
	console.error(a);
}), RSVP.configure("instrument", !0), EPUBJS.Chapter = function (a, b, c) {
	this.href = a.href, this.absolute = a.url, this.id = a.id, this.spinePos = a.index, this.cfiBase = a.cfiBase, this.properties = a.properties, this.manifestProperties = a.manifestProperties, this.linear = a.linear, this.pages = 1, this.store = b, this.credentials = c, this.epubcfi = new EPUBJS.EpubCFI(), this.deferred = new RSVP.defer(), this.loaded = this.deferred.promise, EPUBJS.Hooks.mixin(this), this.getHooks("beforeChapterRender"), this.caches = {};
}, EPUBJS.Chapter.prototype.load = function (a, b) {
	var c,
	    d = a || this.store,
	    e = b || this.credentials;return c = d ? d.getXml(this.absolute) : EPUBJS.core.request(this.absolute, !1, e), c.then(function (a) {
		try {
			this.setDocument(a), this.deferred.resolve(this);
		} catch (a) {
			this.deferred.reject({ message: this.absolute + " -> " + a.message, stack: new Error().stack });
		}
	}.bind(this)), c;
}, EPUBJS.Chapter.prototype.render = function (a) {
	return this.load().then(function (a) {
		var b = a.querySelector("head"),
		    c = a.createElement("base");return c.setAttribute("href", this.absolute), b.insertBefore(c, b.firstChild), this.contents = a, new RSVP.Promise(function (b, c) {
			this.triggerHooks("beforeChapterRender", function () {
				b(a);
			}.bind(this), this);
		}.bind(this));
	}.bind(this)).then(function (a) {
		return new XMLSerializer().serializeToString(a);
	}.bind(this));
}, EPUBJS.Chapter.prototype.url = function (a) {
	var b,
	    c = new RSVP.defer(),
	    d = a || this.store,
	    e = this;return d ? this.tempUrl ? (b = this.tempUrl, c.resolve(b)) : d.getUrl(this.absolute).then(function (a) {
		e.tempUrl = a, c.resolve(a);
	}) : (b = this.absolute, c.resolve(b)), c.promise;
}, EPUBJS.Chapter.prototype.setPages = function (a) {
	this.pages = a;
}, EPUBJS.Chapter.prototype.getPages = function (a) {
	return this.pages;
}, EPUBJS.Chapter.prototype.getID = function () {
	return this.ID;
}, EPUBJS.Chapter.prototype.unload = function (a) {
	this.document = null, this.tempUrl && a && (a.revokeUrl(this.tempUrl), this.tempUrl = !1);
}, EPUBJS.Chapter.prototype.setDocument = function (a) {
	this.document = a, this.contents = a.documentElement, !this.document.evaluate && document.evaluate && (this.document.evaluate = document.evaluate);
}, EPUBJS.Chapter.prototype.cfiFromRange = function (a) {
	var b, c, d, e, f, g, h;if (this.document) {
		if (void 0 !== document.evaluate) {
			if (c = EPUBJS.core.getElementXPath(a.startContainer), d = EPUBJS.core.getElementXPath(a.endContainer), e = this.document.evaluate(c, this.document, EPUBJS.core.nsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue, a.collapsed || (f = this.document.evaluate(d, this.document, EPUBJS.core.nsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue), b = this.document.createRange(), e) try {
				b.setStart(e, a.startOffset), !a.collapsed && f && b.setEnd(f, a.endOffset);
			} catch (a) {
				console.log("missed"), e = !1;
			}e || (console.log("not found, try fuzzy match"), g = EPUBJS.core.cleanStringForXpath(a.startContainer.textContent), c = "//text()[contains(.," + g + ")]", (e = this.document.evaluate(c, this.document, EPUBJS.core.nsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue) && (b.setStart(e, a.startOffset), a.collapsed || (h = EPUBJS.core.cleanStringForXpath(a.endContainer.textContent), d = "//text()[contains(.," + h + ")]", (f = this.document.evaluate(d, this.document, EPUBJS.core.nsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue) && b.setEnd(f, a.endOffset))));
		} else b = a;return this.epubcfi.generateCfiFromRange(b, this.cfiBase);
	}
}, EPUBJS.Chapter.prototype.find = function (a) {
	var b = this,
	    c = [],
	    d = a.toLowerCase(),
	    e = function e(a) {
		for (var e, f, g, h = a.textContent.toLowerCase(), i = b.document.createRange(), j = -1, k = 150; f != -1;) {
			f = h.indexOf(d, j + 1), f != -1 && (i = b.document.createRange(), i.setStart(a, f), i.setEnd(a, f + d.length), e = b.cfiFromRange(i), a.textContent.length < k ? g = a.textContent : (g = a.textContent.substring(f - k / 2, f + k / 2), g = "..." + g + "..."), c.push({ cfi: e, excerpt: g })), j = f;
		}
	};return this.textSprint(this.document, function (a) {
		e(a);
	}), c;
}, EPUBJS.Chapter.prototype.textSprint = function (a, b) {
	for (var c, d = document.createTreeWalker(a, NodeFilter.SHOW_TEXT, { acceptNode: function acceptNode(a) {
			return a.data && !/^\s*$/.test(a.data) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
		} }, !1); c = d.nextNode();) {
		b(c);
	}
}, EPUBJS.Chapter.prototype.replace = function (a, b, c, d) {
	var e = this.contents.querySelectorAll(a),
	    f = Array.prototype.slice.call(e),
	    g = f.length;if (0 === g) return void c(!1);f.forEach(function (a) {
		var e = !1;b(a, function (a, b) {
			e === !1 && (g--, d && d(a, b, g), g <= 0 && c && c(!0), e = !0);
		});
	}.bind(this));
}, EPUBJS.Chapter.prototype.replaceWithStored = function (a, b, c, d) {
	var e,
	    f = {},
	    g = this.store,
	    h = this.caches[a],
	    i = EPUBJS.core.uri(this.absolute),
	    j = i.base,
	    k = b,
	    l = function l(a, b, c) {
		f[b] = a;
	},
	    m = function m(a) {
		d && d(), EPUBJS.core.values(e).forEach(function (a) {
			g.revokeUrl(a);
		}), h = f;
	};g && (h || (h = {}), e = EPUBJS.core.clone(h), this.replace(a, function (b, d) {
		var h = b.getAttribute(k),
		    i = EPUBJS.core.resolveUrl(j, h),
		    l = function l(c) {
			var e;b.onload = function () {
				clearTimeout(e), d(c, i);
			}, "svg image" == a && b.setAttribute("externalResourcesRequired", "true"), "link[href]" == a && "stylesheet" !== b.getAttribute("rel") ? d(c, i) : e = setTimeout(function () {
				d(c, i);
			}, 5), c && b.setAttribute(k, c);
		};i in e ? (l(e[i]), f[i] = e[i], delete e[i]) : c(g, i, l, b);
	}, m, l));
};var EPUBJS = EPUBJS || {};EPUBJS.core = {};var ELEMENT_NODE = 1,
    TEXT_NODE = 3,
    COMMENT_NODE = 8,
    DOCUMENT_NODE = 9;EPUBJS.core.getEl = function (a) {
	return document.getElementById(a);
}, EPUBJS.core.getEls = function (a) {
	return document.getElementsByClassName(a);
}, EPUBJS.core.request = function (a, b, c) {
	var d,
	    e = window.URL,
	    f = e ? "blob" : "arraybuffer",
	    g = new RSVP.defer(),
	    h = new XMLHttpRequest(),
	    i = XMLHttpRequest.prototype,
	    j = function j() {
		var a;this.readyState == this.DONE && (200 !== this.status && 0 !== this.status || !this.response ? g.reject({ message: this.response, stack: new Error().stack }) : (a = "xml" == b ? this.responseXML ? this.responseXML : new DOMParser().parseFromString(this.response, "application/xml") : "xhtml" == b ? this.responseXML ? this.responseXML : new DOMParser().parseFromString(this.response, "application/xhtml+xml") : "html" == b ? this.responseXML ? this.responseXML : new DOMParser().parseFromString(this.response, "text/html") : "json" == b ? JSON.parse(this.response) : "blob" == b ? e ? this.response : new Blob([this.response]) : this.response, g.resolve(a)));
	};return "overrideMimeType" in i || Object.defineProperty(i, "overrideMimeType", { value: function value(a) {} }), h.onreadystatechange = j, h.open("GET", a, !0), c && (h.withCredentials = !0), b || (d = EPUBJS.core.uri(a), b = d.extension, b = { htm: "html" }[b] || b), "blob" == b && (h.responseType = f), "json" == b && h.setRequestHeader("Accept", "application/json"), "xml" == b && (h.responseType = "document", h.overrideMimeType("text/xml")), "xhtml" == b && (h.responseType = "document"), "html" == b && (h.responseType = "document"), "binary" == b && (h.responseType = "arraybuffer"), h.send(), g.promise;
}, EPUBJS.core.toArray = function (a) {
	var b = [];for (var c in a) {
		var d;a.hasOwnProperty(c) && (d = a[c], d.ident = c, b.push(d));
	}return b;
}, EPUBJS.core.uri = function (a) {
	var b,
	    c,
	    d,
	    e = { protocol: "", host: "", path: "", origin: "", directory: "", base: "", filename: "", extension: "", fragment: "", href: a },
	    f = a.indexOf("blob:"),
	    g = a.indexOf("://"),
	    h = a.indexOf("?"),
	    i = a.indexOf("#");return 0 === f ? (e.protocol = "blob", e.base = a.indexOf(0, i), e) : (i != -1 && (e.fragment = a.slice(i + 1), a = a.slice(0, i)), h != -1 && (e.search = a.slice(h + 1), a = a.slice(0, h), href = e.href), g != -1 ? (e.protocol = a.slice(0, g), b = a.slice(g + 3), d = b.indexOf("/"), d === -1 ? (e.host = e.path, e.path = "") : (e.host = b.slice(0, d), e.path = b.slice(d)), e.origin = e.protocol + "://" + e.host, e.directory = EPUBJS.core.folder(e.path), e.base = e.origin + e.directory) : (e.path = a, e.directory = EPUBJS.core.folder(a), e.base = e.directory), e.filename = a.replace(e.base, ""), c = e.filename.lastIndexOf("."), c != -1 && (e.extension = e.filename.slice(c + 1)), e);
}, EPUBJS.core.folder = function (a) {
	var b = a.lastIndexOf("/");if (b == -1) ;return a.slice(0, b + 1);
}, EPUBJS.core.dataURLToBlob = function (a) {
	var b,
	    c,
	    d,
	    e,
	    f,
	    g = ";base64,";if (a.indexOf(g) == -1) return b = a.split(","), c = b[0].split(":")[1], d = b[1], new Blob([d], { type: c });b = a.split(g), c = b[0].split(":")[1], d = window.atob(b[1]), e = d.length, f = new Uint8Array(e);for (var h = 0; h < e; ++h) {
		f[h] = d.charCodeAt(h);
	}return new Blob([f], { type: c });
}, EPUBJS.core.addScript = function (a, b, c) {
	var d, e;e = !1, d = document.createElement("script"), d.type = "text/javascript", d.async = !1, d.src = a, d.onload = d.onreadystatechange = function () {
		e || this.readyState && "complete" != this.readyState || (e = !0, b && b());
	}, c = c || document.body, c.appendChild(d);
}, EPUBJS.core.addScripts = function (a, b, c) {
	var d = a.length,
	    e = 0,
	    f = function f() {
		e++, d == e ? b && b() : EPUBJS.core.addScript(a[e], f, c);
	};EPUBJS.core.addScript(a[e], f, c);
}, EPUBJS.core.addCss = function (a, b, c) {
	var d, e;e = !1, d = document.createElement("link"), d.type = "text/css", d.rel = "stylesheet", d.href = a, d.onload = d.onreadystatechange = function () {
		e || this.readyState && "complete" != this.readyState || (e = !0, b && b());
	}, c = c || document.body, c.appendChild(d);
}, EPUBJS.core.prefixed = function (a) {
	var b = ["Webkit", "Moz", "O", "ms"],
	    c = a[0].toUpperCase() + a.slice(1),
	    d = b.length;if (void 0 !== document.documentElement.style[a]) return a;for (var e = 0; e < d; e++) {
		if (void 0 !== document.documentElement.style[b[e] + c]) return b[e] + c;
	}return a;
}, EPUBJS.core.resolveUrl = function (a, b) {
	var c,
	    d,
	    e = [],
	    f = EPUBJS.core.uri(b),
	    g = a.split("/");return f.host ? b : (g.pop(), d = b.split("/"), d.forEach(function (a) {
		".." === a ? g.pop() : e.push(a);
	}), c = g.concat(e), c.join("/"));
}, EPUBJS.core.uuid = function () {
	var a = new Date().getTime();return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (b) {
		var c = (a + 16 * Math.random()) % 16 | 0;return a = Math.floor(a / 16), ("x" == b ? c : 7 & c | 8).toString(16);
	});
}, EPUBJS.core.insert = function (a, b, c) {
	var d = EPUBJS.core.locationOf(a, b, c);return b.splice(d, 0, a), d;
}, EPUBJS.core.locationOf = function (a, b, c, d, e) {
	var f,
	    g = d || 0,
	    h = e || b.length,
	    i = parseInt(g + (h - g) / 2);return c || (c = function c(a, b) {
		return a > b ? 1 : a < b ? -1 : (a = b) ? 0 : void 0;
	}), h - g <= 0 ? i : (f = c(b[i], a), h - g == 1 ? f > 0 ? i : i + 1 : 0 === f ? i : f === -1 ? EPUBJS.core.locationOf(a, b, c, i, h) : EPUBJS.core.locationOf(a, b, c, g, i));
}, EPUBJS.core.indexOfSorted = function (a, b, c, d, e) {
	var f,
	    g = d || 0,
	    h = e || b.length,
	    i = parseInt(g + (h - g) / 2);return c || (c = function c(a, b) {
		return a > b ? 1 : a < b ? -1 : (a = b) ? 0 : void 0;
	}), h - g <= 0 ? -1 : (f = c(b[i], a), h - g == 1 ? 0 === f ? i : -1 : 0 === f ? i : f === -1 ? EPUBJS.core.indexOfSorted(a, b, c, i, h) : EPUBJS.core.indexOfSorted(a, b, c, g, i));
}, EPUBJS.core.queue = function (a) {
	var b = [],
	    c = a,
	    d = function d(a, c, _d) {
		return b.push({ funcName: a, args: c, context: _d }), b;
	},
	    e = function e() {
		var a;b.length && (a = b.shift(), c[a.funcName].apply(a.context || c, a.args));
	};return { enqueue: d, dequeue: e, flush: function flush() {
			for (; b.length;) {
				e();
			}
		}, clear: function clear() {
			b = [];
		}, length: function length() {
			return b.length;
		} };
}, EPUBJS.core.getElementXPath = function (a) {
	return a && a.id ? '//*[@id="' + a.id + '"]' : EPUBJS.core.getElementTreeXPath(a);
}, EPUBJS.core.getElementTreeXPath = function (a) {
	var b,
	    c,
	    d,
	    e,
	    f = [],
	    g = "http://www.w3.org/1999/xhtml" === a.ownerDocument.documentElement.getAttribute("xmlns");for (a.nodeType === Node.TEXT_NODE && (b = EPUBJS.core.indexOfTextNode(a) + 1, f.push("text()[" + b + "]"), a = a.parentNode); a && 1 == a.nodeType; a = a.parentNode) {
		b = 0;for (var h = a.previousSibling; h; h = h.previousSibling) {
			h.nodeType != Node.DOCUMENT_TYPE_NODE && h.nodeName == a.nodeName && ++b;
		}c = a.nodeName.toLowerCase(), d = g ? "xhtml:" + c : c, e = b ? "[" + (b + 1) + "]" : "", f.splice(0, 0, d + e);
	}return f.length ? "./" + f.join("/") : null;
}, EPUBJS.core.nsResolver = function (a) {
	return { xhtml: "http://www.w3.org/1999/xhtml", epub: "http://www.idpf.org/2007/ops" }[a] || null;
}, EPUBJS.core.cleanStringForXpath = function (a) {
	var b = a.match(/[^'"]+|['"]/g);return b = b.map(function (a) {
		return "'" === a ? '"\'"' : '"' === a ? "'\"'" : "'" + a + "'";
	}), "concat(''," + b.join(",") + ")";
}, EPUBJS.core.indexOfTextNode = function (a) {
	for (var b, c = a.parentNode, d = c.childNodes, e = -1, f = 0; f < d.length && (b = d[f], b.nodeType === Node.TEXT_NODE && e++, b != a); f++) {}return e;
}, EPUBJS.core.defaults = function (a) {
	for (var b = 1, c = arguments.length; b < c; b++) {
		var d = arguments[b];for (var e in d) {
			void 0 === a[e] && (a[e] = d[e]);
		}
	}return a;
}, EPUBJS.core.extend = function (a) {
	return [].slice.call(arguments, 1).forEach(function (b) {
		b && Object.getOwnPropertyNames(b).forEach(function (c) {
			Object.defineProperty(a, c, Object.getOwnPropertyDescriptor(b, c));
		});
	}), a;
}, EPUBJS.core.clone = function (a) {
	return EPUBJS.core.isArray(a) ? a.slice() : EPUBJS.core.extend({}, a);
}, EPUBJS.core.isElement = function (a) {
	return !(!a || 1 != a.nodeType);
}, EPUBJS.core.isNumber = function (a) {
	return !isNaN(parseFloat(a)) && isFinite(a);
}, EPUBJS.core.isString = function (a) {
	return "string" == typeof a || a instanceof String;
}, EPUBJS.core.isArray = Array.isArray || function (a) {
	return "[object Array]" === Object.prototype.toString.call(a);
}, EPUBJS.core.values = function (a) {
	var b,
	    c,
	    d,
	    e = -1;if (!a) return [];for (b = Object.keys(a), c = b.length, d = Array(c); ++e < c;) {
		d[e] = a[b[e]];
	}return d;
}, EPUBJS.core.indexOfNode = function (a, b) {
	for (var c, d = a.parentNode, e = d.childNodes, f = -1, g = 0; g < e.length && (c = e[g], c.nodeType === b && f++, c != a); g++) {}return f;
}, EPUBJS.core.indexOfTextNode = function (a) {
	return EPUBJS.core.indexOfNode(a, TEXT_NODE);
}, EPUBJS.core.indexOfElementNode = function (a) {
	return EPUBJS.core.indexOfNode(a, ELEMENT_NODE);
}, EPUBJS.EpubCFI = function (a) {
	if (a) return this.parse(a);
}, EPUBJS.EpubCFI.prototype.generateChapterComponent = function (a, b, c) {
	var d = parseInt(b),
	    e = 2 * (a + 1),
	    f = "/" + e + "/";return f += 2 * (d + 1), c && (f += "[" + c + "]"), f;
}, EPUBJS.EpubCFI.prototype.generatePathComponent = function (a) {
	return a.map(function (a) {
		return 2 * (a.index + 1) + (a.id ? "[" + a.id + "]" : "");
	}).join("/");
}, EPUBJS.EpubCFI.prototype.generateCfiFromElement = function (a, b) {
	var c = this.pathTo(a),
	    d = this.generatePathComponent(c);return d.length ? "epubcfi(" + b + "!/" + d + "/1:0)" : "epubcfi(" + b + "!/4/)";
}, EPUBJS.EpubCFI.prototype.pathTo = function (a) {
	for (var b, c = []; a && null !== a.parentNode && 9 != a.parentNode.nodeType;) {
		b = a.parentNode.children, c.unshift({ id: a.id, tagName: a.tagName, index: b ? Array.prototype.indexOf.call(b, a) : 0 }), a = a.parentNode;
	}return c;
}, EPUBJS.EpubCFI.prototype.getChapterComponent = function (a) {
	return a.split("!")[0];
}, EPUBJS.EpubCFI.prototype.getPathComponent = function (a) {
	var b = a.split("!");return (b[1] ? b[1].split(":") : "")[0];
}, EPUBJS.EpubCFI.prototype.getCharecterOffsetComponent = EPUBJS.EpubCFI.prototype.getCharacterOffsetComponent = function (a) {
	return a.split(":")[1] || "";
}, EPUBJS.EpubCFI.prototype.parse = function (a) {
	var b,
	    c,
	    d,
	    e,
	    f,
	    g,
	    h,
	    i,
	    j,
	    k = {},
	    l = function l(a) {
		var b, c, d, e;return b = "element", c = parseInt(a) / 2 - 1, d = a.match(/\[(.*)\]/), d && d[1] && (e = d[1]), { type: b, index: c, id: e || !1 };
	};return "string" != typeof a ? { spinePos: -1 } : (k.str = a, 0 === a.indexOf("epubcfi(") && ")" === a[a.length - 1] && (a = a.slice(8, a.length - 1)), c = this.getChapterComponent(a), d = this.getPathComponent(a) || "", e = this.getCharacterOffsetComponent(a), c && (b = c.split("/")[2] || "") ? (k.spinePos = parseInt(b) / 2 - 1 || 0, g = b.match(/\[(.*)\]/), k.spineId = !!g && g[1], d.indexOf(",") != -1 && console.warn("CFI Ranges are not supported"), h = d.split("/"), i = h.pop(), k.steps = [], h.forEach(function (a) {
		var b;a && (b = l(a), k.steps.push(b));
	}), j = parseInt(i), isNaN(j) || (j % 2 == 0 ? k.steps.push(l(i)) : k.steps.push({ type: "text", index: (j - 1) / 2 })), f = e.match(/\[(.*)\]/), f && f[1] ? (k.characterOffset = parseInt(e.split("[")[0]), k.textLocationAssertion = f[1]) : k.characterOffset = parseInt(e), k) : { spinePos: -1 });
}, EPUBJS.EpubCFI.prototype.addMarker = function (a, b, c) {
	var d,
	    e,
	    f,
	    g,
	    h = b || document,
	    i = c || this.createMarker(h);return "string" == typeof a && (a = this.parse(a)), e = a.steps[a.steps.length - 1], a.spinePos !== -1 && !!(d = this.findParent(a, h)) && (e && "text" === e.type ? (f = d.childNodes[e.index], a.characterOffset ? (g = f.splitText(a.characterOffset), i.classList.add("EPUBJS-CFI-SPLIT"), d.insertBefore(i, g)) : d.insertBefore(i, f)) : d.insertBefore(i, d.firstChild), i);
}, EPUBJS.EpubCFI.prototype.createMarker = function (a) {
	var b = a || document,
	    c = b.createElement("span");return c.id = "EPUBJS-CFI-MARKER:" + EPUBJS.core.uuid(), c.classList.add("EPUBJS-CFI-MARKER"), c;
}, EPUBJS.EpubCFI.prototype.removeMarker = function (a, b) {
	b || document;a.classList.contains("EPUBJS-CFI-SPLIT") ? (nextSib = a.nextSibling, prevSib = a.previousSibling, nextSib && prevSib && 3 === nextSib.nodeType && 3 === prevSib.nodeType && (prevSib.textContent += nextSib.textContent, a.parentNode.removeChild(nextSib)), a.parentNode.removeChild(a)) : a.classList.contains("EPUBJS-CFI-MARKER") && a.parentNode.removeChild(a);
}, EPUBJS.EpubCFI.prototype.findParent = function (a, b) {
	var c,
	    d,
	    e,
	    f = b || document,
	    g = f.getElementsByTagName("html")[0],
	    h = Array.prototype.slice.call(g.children);if ("string" == typeof a && (a = this.parse(a)), d = a.steps.slice(0), !d.length) return f.getElementsByTagName("body")[0];for (; d && d.length > 0;) {
		if (c = d.shift(), "text" === c.type ? (e = g.childNodes[c.index], g = e.parentNode || g) : g = c.id ? f.getElementById(c.id) : h[c.index], !g || void 0 === g) return console.error("No Element For", c, a.str), !1;h = Array.prototype.slice.call(g.children);
	}return g;
}, EPUBJS.EpubCFI.prototype.compare = function (a, b) {
	if ("string" == typeof a && (a = new EPUBJS.EpubCFI(a)), "string" == typeof b && (b = new EPUBJS.EpubCFI(b)), a.spinePos > b.spinePos) return 1;if (a.spinePos < b.spinePos) return -1;for (var c = 0; c < a.steps.length; c++) {
		if (!b.steps[c]) return 1;if (a.steps[c].index > b.steps[c].index) return 1;if (a.steps[c].index < b.steps[c].index) return -1;
	}return a.steps.length < b.steps.length ? -1 : a.characterOffset > b.characterOffset ? 1 : a.characterOffset < b.characterOffset ? -1 : 0;
}, EPUBJS.EpubCFI.prototype.generateCfiFromHref = function (a, b) {
	var c,
	    d,
	    e = EPUBJS.core.uri(a),
	    f = e.path,
	    g = e.fragment,
	    h = b.spineIndexByURL[f],
	    i = new RSVP.defer(),
	    j = new EPUBJS.EpubCFI();return void 0 !== h && (d = b.spine[h], c = b.loadXml(d.url), c.then(function (a) {
		var b,
		    c = a.getElementById(g);b = j.generateCfiFromElement(c, d.cfiBase), i.resolve(b);
	})), i.promise;
}, EPUBJS.EpubCFI.prototype.generateCfiFromTextNode = function (a, b, c) {
	var d = a.parentNode,
	    e = this.pathTo(d);return "epubcfi(" + c + "!/" + this.generatePathComponent(e) + "/" + (1 + 2 * Array.prototype.indexOf.call(d.childNodes, a)) + ":" + (b || 0) + ")";
}, EPUBJS.EpubCFI.prototype.generateCfiFromRangeAnchor = function (a, b) {
	var c = a.anchorNode,
	    d = a.anchorOffset;return this.generateCfiFromTextNode(c, d, b);
}, EPUBJS.EpubCFI.prototype.generateCfiFromRange = function (a, b) {
	var c, d, e, f, g, h, i, j, k, l, m, n;if (c = a.startContainer, 3 === c.nodeType) d = c.parentNode, h = 1 + 2 * EPUBJS.core.indexOfTextNode(c), e = this.pathTo(d);else {
		if (a.collapsed) return this.generateCfiFromElement(c, b);e = this.pathTo(c);
	}return f = this.generatePathComponent(e), g = a.startOffset, a.collapsed ? "epubcfi(" + b + "!/" + f + "/" + h + ":" + g + ")" : (i = a.endContainer, 3 === i.nodeType ? (j = i.parentNode, n = 1 + 2 * EPUBJS.core.indexOfTextNode(i), k = this.pathTo(j)) : k = this.pathTo(i), l = this.generatePathComponent(k), m = a.endOffset, l = l.replace(f, ""), l.length && (l += "/"), "epubcfi(" + b + "!/" + f + "/" + h + ":" + g + "," + l + n + ":" + m + ")");
}, EPUBJS.EpubCFI.prototype.generateXpathFromSteps = function (a) {
	var b = [".", "*"];return a.forEach(function (a) {
		var c = a.index + 1;a.id ? b.push("*[position()=" + c + " and @id='" + a.id + "']") : "text" === a.type ? b.push("text()[" + c + "]") : b.push("*[" + c + "]");
	}), b.join("/");
}, EPUBJS.EpubCFI.prototype.generateQueryFromSteps = function (a) {
	var b = ["html"];return a.forEach(function (a) {
		var c = a.index + 1;a.id ? b.push("#" + a.id) : "text" === a.type || b.push("*:nth-child(" + c + ")");
	}), b.join(">");
}, EPUBJS.EpubCFI.prototype.generateRangeFromCfi = function (a, b) {
	var c,
	    d,
	    e,
	    f,
	    g,
	    h,
	    i = b || document,
	    j = i.createRange();return "string" == typeof a && (a = this.parse(a)), a.spinePos !== -1 && (c = a.steps[a.steps.length - 1], void 0 !== document.evaluate ? (d = this.generateXpathFromSteps(a.steps), e = i.evaluate(d, i, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue) : (g = this.generateQueryFromSteps(a.steps), (h = i.querySelector(g)) && "text" == c.type && (e = h.childNodes[c.index])), e ? (e && a.characterOffset >= 0 ? (f = e.length, a.characterOffset < f ? (j.setStart(e, a.characterOffset), j.setEnd(e, f)) : (console.debug("offset greater than length:", a.characterOffset, f), j.setStart(e, f - 1), j.setEnd(e, f))) : e && j.selectNode(e), j) : null);
}, EPUBJS.EpubCFI.prototype.isCfiString = function (a) {
	return "string" == typeof a && 0 === a.indexOf("epubcfi(");
}, EPUBJS.Events = function (a, b) {
	return this.events = {}, this.el = b ? b : document.createElement("div"), a.createEvent = this.createEvent, a.tell = this.tell, a.listen = this.listen, a.deafen = this.deafen, a.listenUntil = this.listenUntil, this;
}, EPUBJS.Events.prototype.createEvent = function (a) {
	var b = new CustomEvent(a);return this.events[a] = b, b;
}, EPUBJS.Events.prototype.tell = function (a, b) {
	var c;this.events[a] ? c = this.events[a] : (console.warn("No event:", a, "defined yet, creating."), c = this.createEvent(a)), b && (c.msg = b), this.el.dispatchEvent(c);
}, EPUBJS.Events.prototype.listen = function (a, b, c) {
	if (!this.events[a]) return console.warn("No event:", a, "defined yet, creating."), void this.createEvent(a);c ? this.el.addEventListener(a, b.bind(c), !1) : this.el.addEventListener(a, b, !1);
}, EPUBJS.Events.prototype.deafen = function (a, b) {
	this.el.removeEventListener(a, b, !1);
}, EPUBJS.Events.prototype.listenUntil = function (a, b, c, d) {
	function e() {
		this.deafen(a, c), this.deafen(b, e);
	}this.listen(a, c, d), this.listen(b, e, this);
}, EPUBJS.hooks = {}, EPUBJS.Hooks = function () {
	function a() {}return a.prototype.getHooks = function () {
		var a;this.hooks = {}, Array.prototype.slice.call(arguments).forEach(function (a) {
			this.hooks[a] = [];
		}, this);for (var b in this.hooks) {
			a = EPUBJS.core.values(EPUBJS.hooks[b]), a.forEach(function (a) {
				this.registerHook(b, a);
			}, this);
		}
	}, a.prototype.registerHook = function (a, b, c) {
		void 0 !== this.hooks[a] ? "function" == typeof b ? c ? this.hooks[a].unshift(b) : this.hooks[a].push(b) : Array.isArray(b) && b.forEach(function (b) {
			c ? this.hooks[a].unshift(b) : this.hooks[a].push(b);
		}, this) : (this.hooks[a] = [b], "function" == typeof b ? this.hooks[a] = [b] : Array.isArray(b) && (this.hooks[a] = [], b.forEach(function (b) {
			this.hooks[a].push(b);
		}, this)));
	}, a.prototype.removeHook = function (a, b) {
		var c;void 0 !== this.hooks[a] && ("function" == typeof b ? (c = this.hooks[a].indexOf(b)) > -1 && this.hooks[a].splice(c, 1) : Array.isArray(b) && b.forEach(function (b) {
			(c = this.hooks[a].indexOf(b)) > -1 && this.hooks[a].splice(c, 1);
		}, this));
	}, a.prototype.triggerHooks = function (a, b, c) {
		function d() {
			--f <= 0 && b && b();
		}var e, f;if (void 0 === this.hooks[a]) return !1;e = this.hooks[a], f = e.length, 0 === f && b && b(), e.forEach(function (a) {
			a(d, c);
		});
	}, { register: function register(a) {
			if (void 0 === EPUBJS.hooks[a] && (EPUBJS.hooks[a] = {}), "object" != _typeof(EPUBJS.hooks[a])) throw "Already registered: " + a;return EPUBJS.hooks[a];
		}, mixin: function mixin(b) {
			for (var c in a.prototype) {
				b[c] = a.prototype[c];
			}
		} };
}(), EPUBJS.Layout = EPUBJS.Layout || {}, EPUBJS.Layout.isFixedLayout = function (a) {
	var b = a.querySelector("[name=viewport]");if (!b || !b.hasAttribute("content")) return !1;var c = b.getAttribute("content");return (/width=(\d+)/.test(c) && /height=(\d+)/.test(c)
	);
}, EPUBJS.Layout.Reflowable = function () {
	this.documentElement = null, this.spreadWidth = null;
}, EPUBJS.Layout.Reflowable.prototype.format = function (a, b, c, d) {
	var e = EPUBJS.core.prefixed("columnAxis"),
	    f = EPUBJS.core.prefixed("columnGap"),
	    g = EPUBJS.core.prefixed("columnWidth"),
	    h = EPUBJS.core.prefixed("columnFill"),
	    i = Math.floor(b),
	    j = Math.floor(i / 8),
	    k = d >= 0 ? d : j % 2 == 0 ? j : j - 1;return this.documentElement = a, this.spreadWidth = i + k, a.style.overflow = "hidden", a.style.width = i + "px", a.style.height = c + "px", a.style[e] = "horizontal", a.style[h] = "auto", a.style[g] = i + "px", a.style[f] = k + "px", this.colWidth = i, this.gap = k, { pageWidth: this.spreadWidth, pageHeight: c };
}, EPUBJS.Layout.Reflowable.prototype.calculatePages = function () {
	var a, b;return this.documentElement.style.width = "auto", a = this.documentElement.scrollWidth, b = Math.ceil(a / this.spreadWidth), { displayedPages: b, pageCount: b };
}, EPUBJS.Layout.ReflowableSpreads = function () {
	this.documentElement = null, this.spreadWidth = null;
}, EPUBJS.Layout.ReflowableSpreads.prototype.format = function (a, b, c, d) {
	var e = EPUBJS.core.prefixed("columnAxis"),
	    f = EPUBJS.core.prefixed("columnGap"),
	    g = EPUBJS.core.prefixed("columnWidth"),
	    h = EPUBJS.core.prefixed("columnFill"),
	    i = 2,
	    j = Math.floor(b),
	    k = j % 2 == 0 ? j : j - 1,
	    l = Math.floor(k / 8),
	    m = d >= 0 ? d : l % 2 == 0 ? l : l - 1,
	    n = Math.floor((k - m) / i);return this.documentElement = a, this.spreadWidth = (n + m) * i, a.style.overflow = "hidden", a.style.width = k + "px", a.style.height = c + "px", a.style[e] = "horizontal", a.style[h] = "auto", a.style[f] = m + "px", a.style[g] = n + "px", this.colWidth = n, this.gap = m, { pageWidth: this.spreadWidth, pageHeight: c };
}, EPUBJS.Layout.ReflowableSpreads.prototype.calculatePages = function () {
	var a = this.documentElement.scrollWidth,
	    b = Math.ceil(a / this.spreadWidth);return this.documentElement.style.width = b * this.spreadWidth - this.gap + "px", { displayedPages: b, pageCount: 2 * b };
}, EPUBJS.Layout.Fixed = function () {
	this.documentElement = null;
}, EPUBJS.Layout.Fixed.prototype.format = function (a, b, c, d) {
	var e,
	    f,
	    g,
	    h,
	    i = EPUBJS.core.prefixed("columnWidth"),
	    j = EPUBJS.core.prefixed("transform"),
	    k = EPUBJS.core.prefixed("transformOrigin"),
	    l = a.querySelector("[name=viewport]");this.documentElement = a, l && l.hasAttribute("content") && (e = l.getAttribute("content"), f = e.split(","), f[0] && (g = f[0].replace("width=", "")), f[1] && (h = f[1].replace("height=", "")));var m = b / g,
	    n = c / h,
	    o = m < n ? m : n;return a.style.position = "absolute", a.style.top = "50%", a.style.left = "50%", a.style[j] = "scale(" + o + ") translate(-50%, -50%)", a.style[k] = "0px 0px 0px", a.style.width = g + "px" || "auto", a.style.height = h + "px" || "auto", a.style[i] = "auto", a.style.overflow = "auto", this.colWidth = g, this.gap = 0, { pageWidth: g, pageHeight: h };
}, EPUBJS.Layout.Fixed.prototype.calculatePages = function () {
	return { displayedPages: 1, pageCount: 1 };
}, EPUBJS.Locations = function (a, b, c) {
	this.spine = a, this.store = b, this.credentials = c, this.epubcfi = new EPUBJS.EpubCFI(), this._locations = [], this.total = 0, this.break = 150, this._current = 0;
}, EPUBJS.Locations.prototype.generate = function (a) {
	var b = new RSVP.defer(),
	    c = -1,
	    d = this.spine.length,
	    e = function (a) {
		var b,
		    f = c + 1,
		    g = a || new RSVP.defer();return f >= d ? g.resolve() : (c = f, b = new EPUBJS.Chapter(this.spine[c], this.store, this.credentials), this.process(b).then(function () {
			setTimeout(function () {
				e(g);
			}, 1);
		})), g.promise;
	}.bind(this);return "number" == typeof a && (this.break = a), e().then(function () {
		this.total = this._locations.length - 1, this._currentCfi && (this.currentLocation = this._currentCfi), b.resolve(this._locations);
	}.bind(this)), b.promise;
}, EPUBJS.Locations.prototype.process = function (a) {
	return a.load().then(function (b) {
		var c,
		    d,
		    e,
		    f = b,
		    g = f.documentElement.querySelector("body"),
		    h = 0,
		    i = this.break;this.sprint(g, function (b) {
			var g,
			    j = b.length,
			    k = 0;if (0 === b.textContent.trim().length) return !1;for (0 === h && (c = f.createRange(), c.setStart(b, 0)), g = i - h, g > j && (h += j, k = j); k < j;) {
				g = i - h, 0 === h && (k += 1, c = f.createRange(), c.setStart(b, k)), k + g >= j ? (h += j - k, k = j) : (k += g, c.setEnd(b, k), e = a.cfiFromRange(c), this._locations.push(e), h = 0);
			}d = b;
		}.bind(this)), c && (c.setEnd(d, d.length), e = a.cfiFromRange(c), this._locations.push(e), h = 0);
	}.bind(this));
}, EPUBJS.Locations.prototype.sprint = function (a, b) {
	for (var c, d = document.createTreeWalker(a, NodeFilter.SHOW_TEXT, null, !1); c = d.nextNode();) {
		b(c);
	}
}, EPUBJS.Locations.prototype.locationFromCfi = function (a) {
	return 0 === this._locations.length ? -1 : EPUBJS.core.locationOf(a, this._locations, this.epubcfi.compare);
}, EPUBJS.Locations.prototype.percentageFromCfi = function (a) {
	var b = this.locationFromCfi(a);return this.percentageFromLocation(b);
}, EPUBJS.Locations.prototype.percentageFromLocation = function (a) {
	return a && this.total ? a / this.total : 0;
}, EPUBJS.Locations.prototype.cfiFromLocation = function (a) {
	var b = -1;return "number" != typeof a && (a = parseInt(a)), a >= 0 && a < this._locations.length && (b = this._locations[a]), b;
}, EPUBJS.Locations.prototype.cfiFromPercentage = function (a) {
	var b = a > 1 ? a / 100 : a,
	    c = Math.ceil(this.total * b);return this.cfiFromLocation(c);
}, EPUBJS.Locations.prototype.load = function (a) {
	return this._locations = JSON.parse(a), this.total = this._locations.length - 1, this._locations;
}, EPUBJS.Locations.prototype.save = function (a) {
	return JSON.stringify(this._locations);
}, EPUBJS.Locations.prototype.getCurrent = function (a) {
	return this._current;
}, EPUBJS.Locations.prototype.setCurrent = function (a) {
	var b;if ("string" == typeof a) this._currentCfi = a;else {
		if ("number" != typeof a) return;this._current = a;
	}0 !== this._locations.length && ("string" == typeof a ? (b = this.locationFromCfi(a), this._current = b) : b = a, this.trigger("changed", { percentage: this.percentageFromLocation(b) }));
}, Object.defineProperty(EPUBJS.Locations.prototype, "currentLocation", { get: function get() {
		return this._current;
	}, set: function set(a) {
		this.setCurrent(a);
	} }), RSVP.EventTarget.mixin(EPUBJS.Locations.prototype), EPUBJS.Pagination = function (a) {
	this.pages = [], this.locations = [], this.epubcfi = new EPUBJS.EpubCFI(), a && a.length && this.process(a);
}, EPUBJS.Pagination.prototype.process = function (a) {
	a.forEach(function (a) {
		this.pages.push(a.page), this.locations.push(a.cfi);
	}, this), this.pageList = a, this.firstPage = parseInt(this.pages[0]), this.lastPage = parseInt(this.pages[this.pages.length - 1]), this.totalPages = this.lastPage - this.firstPage;
}, EPUBJS.Pagination.prototype.pageFromCfi = function (a) {
	var b = -1;if (0 === this.locations.length) return -1;var c = EPUBJS.core.indexOfSorted(a, this.locations, this.epubcfi.compare);return c != -1 ? b = this.pages[c] : (c = EPUBJS.core.locationOf(a, this.locations, this.epubcfi.compare), void 0 !== (b = c - 1 >= 0 ? this.pages[c - 1] : this.pages[0]) || (b = -1)), b;
}, EPUBJS.Pagination.prototype.cfiFromPage = function (a) {
	var b = -1;"number" != typeof a && (a = parseInt(a));var c = this.pages.indexOf(a);return c != -1 && (b = this.locations[c]), b;
}, EPUBJS.Pagination.prototype.pageFromPercentage = function (a) {
	return Math.round(this.totalPages * a);
}, EPUBJS.Pagination.prototype.percentageFromPage = function (a) {
	var b = (a - this.firstPage) / this.totalPages;return Math.round(1e3 * b) / 1e3;
}, EPUBJS.Pagination.prototype.percentageFromCfi = function (a) {
	var b = this.pageFromCfi(a);return this.percentageFromPage(b);
}, EPUBJS.Parser = function (a) {
	this.baseUrl = a || "";
}, EPUBJS.Parser.prototype.container = function (a) {
	var b, c, d, e;return a ? (b = a.querySelector("rootfile")) ? (c = b.getAttribute("full-path"), d = EPUBJS.core.uri(c).directory, e = a.xmlEncoding, { packagePath: c, basePath: d, encoding: e }) : void console.error("No RootFile Found") : void console.error("Container File Not Found");
}, EPUBJS.Parser.prototype.identifier = function (a) {
	var b;return a ? (b = a.querySelector("metadata"), b ? this.getElementText(b, "identifier") : void console.error("No Metadata Found")) : void console.error("Package File Not Found");
}, EPUBJS.Parser.prototype.packageContents = function (a, b) {
	var c,
	    d,
	    e,
	    f,
	    g,
	    h,
	    i,
	    j,
	    k,
	    l,
	    m,
	    n = this;return b && (this.baseUrl = b), a ? (c = a.querySelector("metadata")) ? (d = a.querySelector("manifest")) ? (e = a.querySelector("spine")) ? (f = n.manifest(d), g = n.findNavPath(d), h = n.findTocPath(d, e), i = n.findCoverPath(a), j = Array.prototype.indexOf.call(e.parentNode.childNodes, e), k = n.spine(e, f), l = {}, k.forEach(function (a) {
		l[a.href] = a.index;
	}), m = n.metadata(c), m.direction = e.getAttribute("page-progression-direction"), { metadata: m, spine: k, manifest: f, navPath: g, tocPath: h, coverPath: i, spineNodeIndex: j, spineIndexByURL: l }) : void console.error("No Spine Found") : void console.error("No Manifest Found") : void console.error("No Metadata Found") : void console.error("Package File Not Found");
}, EPUBJS.Parser.prototype.findNavPath = function (a) {
	var b = a.querySelector("item[properties$='nav'], item[properties^='nav '], item[properties*=' nav ']");return !!b && b.getAttribute("href");
}, EPUBJS.Parser.prototype.findTocPath = function (a, b) {
	var c,
	    d = a.querySelector("item[media-type='application/x-dtbncx+xml']");return d || (c = b.getAttribute("toc")) && (d = a.querySelector("item[id='" + c + "']")), !!d && d.getAttribute("href");
}, EPUBJS.Parser.prototype.metadata = function (a) {
	var b = {},
	    c = this;return b.bookTitle = c.getElementText(a, "title"), b.creator = c.getElementText(a, "creator"), b.description = c.getElementText(a, "description"), b.pubdate = c.getElementText(a, "date"), b.publisher = c.getElementText(a, "publisher"), b.identifier = c.getElementText(a, "identifier"), b.language = c.getElementText(a, "language"), b.rights = c.getElementText(a, "rights"), b.modified_date = c.querySelectorText(a, "meta[property='dcterms:modified']"), b.layout = c.querySelectorText(a, "meta[property='rendition:layout']"), b.orientation = c.querySelectorText(a, "meta[property='rendition:orientation']"), b.spread = c.querySelectorText(a, "meta[property='rendition:spread']"), b;
}, EPUBJS.Parser.prototype.findCoverPath = function (a) {
	if ("2.0" === a.querySelector("package").getAttribute("version")) {
		var b = a.querySelector('meta[name="cover"]');if (b) {
			var c = b.getAttribute("content"),
			    d = a.querySelector("item[id='" + c + "']");return !!d && d.getAttribute("href");
		}return !1;
	}var e = a.querySelector("item[properties='cover-image']");return !!e && e.getAttribute("href");
}, EPUBJS.Parser.prototype.getElementText = function (a, b) {
	var c,
	    d = a.getElementsByTagNameNS("http://purl.org/dc/elements/1.1/", b);return d && 0 !== d.length ? (c = d[0], c.childNodes.length ? c.childNodes[0].nodeValue : "") : "";
}, EPUBJS.Parser.prototype.querySelectorText = function (a, b) {
	var c = a.querySelector(b);return c && c.childNodes.length ? c.childNodes[0].nodeValue : "";
}, EPUBJS.Parser.prototype.manifest = function (a) {
	var b = this.baseUrl,
	    c = {},
	    d = a.querySelectorAll("item");return Array.prototype.slice.call(d).forEach(function (a) {
		var d = a.getAttribute("id"),
		    e = a.getAttribute("href") || "",
		    f = a.getAttribute("media-type") || "",
		    g = a.getAttribute("properties") || "";c[d] = { href: e, url: b + e, type: f, properties: g };
	}), c;
}, EPUBJS.Parser.prototype.spine = function (a, b) {
	var c = a.getElementsByTagName("itemref"),
	    d = Array.prototype.slice.call(c),
	    e = EPUBJS.core.indexOfElementNode(a),
	    f = new EPUBJS.EpubCFI();return d.map(function (a, c) {
		var d = a.getAttribute("idref"),
		    g = f.generateChapterComponent(e, c, d),
		    h = a.getAttribute("properties") || "",
		    i = h.length ? h.split(" ") : [],
		    j = b[d].properties,
		    k = j.length ? j.split(" ") : [];return { id: d, linear: a.getAttribute("linear") || "", properties: i, manifestProperties: k, href: b[d].href, url: b[d].url, index: c, cfiBase: g, cfi: "epubcfi(" + g + ")" };
	});
}, EPUBJS.Parser.prototype.querySelectorByType = function (a, b, c) {
	var d = a.querySelector(b + '[*|type="' + c + '"]');if (null !== d && 0 !== d.length) return d;d = a.querySelectorAll(b);for (var e = 0; e < d.length; e++) {
		if (d[e].getAttributeNS("http://www.idpf.org/2007/ops", "type") === c) return d[e];
	}
}, EPUBJS.Parser.prototype.nav = function (a, b, c) {
	var d = this.querySelectorByType(a, "nav", "toc");return this.navItems(d, b, c);
}, EPUBJS.Parser.prototype.navItems = function (a, b, c) {
	if (!a) return [];var d = a.querySelector("ol");if (!d) return [];var e = d.childNodes,
	    f = [];return Array.prototype.forEach.call(e, function (a) {
		if ("li" === a.tagName) {
			var d = a.querySelector("a, span"),
			    e = d.getAttribute("href") || "",
			    g = d.textContent || "",
			    h = e.split("#"),
			    i = h[0],
			    j = b[i],
			    k = c[j],
			    l = k ? k.cfi : "",
			    m = this.navItems(a, b, c);f.push({ href: e, label: g, spinePos: j, subitems: m, cfi: l });
		}
	}.bind(this)), f;
}, EPUBJS.Parser.prototype.toc = function (a, b, c) {
	var d,
	    e,
	    f,
	    g = a.querySelectorAll("navMap navPoint"),
	    h = g.length,
	    i = {},
	    j = [];if (!g || 0 === h) return j;for (d = 0; d < h; ++d) {
		e = this.tocItem(g[d], b, c), i[e.id] = e, e.parent ? (f = i[e.parent], f.subitems.push(e)) : j.push(e);
	}return j;
}, EPUBJS.Parser.prototype.tocItem = function (a, b, c) {
	var d,
	    e = a.getAttribute("id") || !1,
	    f = a.querySelector("content"),
	    g = f.getAttribute("src"),
	    h = a.querySelector("navLabel"),
	    i = h.textContent ? h.textContent : "",
	    j = g.split("#"),
	    k = j[0],
	    l = b[k],
	    m = c[l],
	    n = [],
	    o = a.parentNode,
	    p = m ? m.cfi : "";return o && "navPoint" === o.nodeName && (d = o.getAttribute("id")), e || (l ? (m = c[l], e = m.id, p = m.cfi) : (e = "epubjs-autogen-toc-id-" + EPUBJS.core.uuid(), a.setAttribute("id", e))), { id: e, href: g, label: i, spinePos: l, subitems: n, parent: d, cfi: p };
}, EPUBJS.Parser.prototype.pageList = function (a, b, c) {
	var d,
	    e,
	    f = this.querySelectorByType(a, "nav", "page-list"),
	    g = f ? f.querySelectorAll("ol li") : [],
	    h = g.length,
	    i = [];if (!g || 0 === h) return i;for (d = 0; d < h; ++d) {
		e = this.pageListItem(g[d], b, c), i.push(e);
	}return i;
}, EPUBJS.Parser.prototype.pageListItem = function (a, b, c) {
	var d,
	    e,
	    f,
	    g = (a.getAttribute("id"), a.querySelector("a")),
	    h = g.getAttribute("href") || "",
	    i = g.textContent || "",
	    j = parseInt(i),
	    k = h.indexOf("epubcfi");return k != -1 ? (d = h.split("#"), e = d[0], f = d.length > 1 && d[1], { cfi: f, href: h, packageUrl: e, page: j }) : { href: h, page: j };
}, EPUBJS.Render.Iframe = function () {
	this.iframe = null, this.document = null, this.window = null, this.docEl = null, this.bodyEl = null, this.leftPos = 0, this.pageWidth = 0, this.id = EPUBJS.core.uuid();
}, EPUBJS.Render.Iframe.prototype.create = function () {
	return this.element = document.createElement("div"), this.element.id = "epubjs-view:" + this.id, this.isMobile = navigator.userAgent.match(/(iPad|iPhone|iPod|Mobile|Android)/g), this.transform = EPUBJS.core.prefixed("transform"), this.element;
}, EPUBJS.Render.Iframe.prototype.addIframe = function () {
	return this.iframe = document.createElement("iframe"), this.iframe.id = "epubjs-iframe:" + this.id, this.iframe.scrolling = this.scrolling || "no", this.iframe.seamless = "seamless", this.iframe.style.border = "none", this.iframe.addEventListener("load", this.loaded.bind(this), !1), (this._width || this._height) && (this.iframe.height = this._height, this.iframe.width = this._width), this.iframe;
}, EPUBJS.Render.Iframe.prototype.load = function (a, b) {
	var c = this,
	    d = new RSVP.defer();return this.window && this.unload(), this.iframe && this.element.removeChild(this.iframe), this.iframe = this.addIframe(), this.element.appendChild(this.iframe), this.iframe.onload = function (a) {
		c.document = c.iframe.contentDocument, c.docEl = c.document.documentElement, c.headEl = c.document.head, c.bodyEl = c.document.body || c.document.querySelector("body"), c.window = c.iframe.contentWindow, c.window.addEventListener("resize", c.resized.bind(c), !1), c.leftPos = 0, c.setLeft(0), c.bodyEl && (c.bodyEl.style.margin = "0"), d.resolve(c.docEl);
	}, this.iframe.onerror = function (a) {
		d.reject({ message: "Error Loading Contents: " + a, stack: new Error().stack });
	}, this.document = this.iframe.contentDocument, this.document ? (this.iframe.contentDocument.open(), this.iframe.contentDocument.write(a), this.iframe.contentDocument.close(), d.promise) : (d.reject(new Error("No Document Available")), d.promise);
}, EPUBJS.Render.Iframe.prototype.loaded = function (a) {
	var b,
	    c,
	    d = this.iframe.contentWindow.location.href;this.document = this.iframe.contentDocument, this.docEl = this.document.documentElement, this.headEl = this.document.head, this.bodyEl = this.document.body || this.document.querySelector("body"), this.window = this.iframe.contentWindow, this.window.focus(), "about:blank" != d && (b = this.iframe.contentDocument.querySelector("base"), c = b.getAttribute("href"), this.trigger("render:loaded", c));
}, EPUBJS.Render.Iframe.prototype.resize = function (a, b) {
	this.element && (this.element.style.height = b, isNaN(a) || a % 2 == 0 || (a += 1), this.element.style.width = a, this.iframe && (this.iframe.height = b, this.iframe.width = a), this._height = b, this._width = a, this.width = this.element.getBoundingClientRect().width || a, this.height = this.element.getBoundingClientRect().height || b);
}, EPUBJS.Render.Iframe.prototype.resized = function (a) {
	this.width = this.iframe.getBoundingClientRect().width, this.height = this.iframe.getBoundingClientRect().height;
}, EPUBJS.Render.Iframe.prototype.totalWidth = function () {
	return this.docEl.scrollWidth;
}, EPUBJS.Render.Iframe.prototype.totalHeight = function () {
	return this.docEl.scrollHeight;
}, EPUBJS.Render.Iframe.prototype.setPageDimensions = function (a, b) {
	this.pageWidth = a, this.pageHeight = b;
}, EPUBJS.Render.Iframe.prototype.setDirection = function (a) {
	this.direction = a, this.docEl && "rtl" == this.docEl.dir && (this.docEl.dir = "rtl", "pre-paginated" !== this.layout && (this.docEl.style.position = "static", this.docEl.style.right = "auto"));
}, EPUBJS.Render.Iframe.prototype.setLeft = function (a) {
	this.isMobile ? this.docEl.style[this.transform] = "translate(" + -a + "px, 0)" : this.document.defaultView.scrollTo(a, 0);
}, EPUBJS.Render.Iframe.prototype.setLayout = function (a) {
	this.layout = a;
}, EPUBJS.Render.Iframe.prototype.setStyle = function (a, b, c) {
	c && (a = EPUBJS.core.prefixed(a)), this.bodyEl && (this.bodyEl.style[a] = b);
}, EPUBJS.Render.Iframe.prototype.removeStyle = function (a) {
	this.bodyEl && (this.bodyEl.style[a] = "");
}, EPUBJS.Render.Iframe.prototype.setClasses = function (a) {
	this.bodyEl && (this.bodyEl.className = a.join(" "));
}, EPUBJS.Render.Iframe.prototype.addHeadTag = function (a, b, c) {
	var d = c || this.document,
	    e = d.createElement(a),
	    f = d.head;for (var g in b) {
		e.setAttribute(g, b[g]);
	}f && f.insertBefore(e, f.firstChild);
}, EPUBJS.Render.Iframe.prototype.page = function (a) {
	this.leftPos = this.pageWidth * (a - 1), "rtl" === this.direction && (this.leftPos = this.leftPos * -1), this.setLeft(this.leftPos);
}, EPUBJS.Render.Iframe.prototype.getPageNumberByElement = function (a) {
	var b;if (a) return b = this.leftPos + a.getBoundingClientRect().left, Math.floor(b / this.pageWidth) + 1;
}, EPUBJS.Render.Iframe.prototype.getPageNumberByRect = function (a) {
	var b;return b = this.leftPos + a.left, Math.floor(b / this.pageWidth) + 1;
}, EPUBJS.Render.Iframe.prototype.getBaseElement = function () {
	return this.bodyEl;
}, EPUBJS.Render.Iframe.prototype.getDocumentElement = function () {
	return this.docEl;
}, EPUBJS.Render.Iframe.prototype.isElementVisible = function (a) {
	var b, c;return !!(a && "function" == typeof a.getBoundingClientRect && (b = a.getBoundingClientRect(), c = b.left, 0 !== b.width && 0 !== b.height && c >= 0 && c < this.pageWidth));
}, EPUBJS.Render.Iframe.prototype.scroll = function (a) {
	this.scrolling = a ? "yes" : "no";
}, EPUBJS.Render.Iframe.prototype.unload = function () {
	this.window.removeEventListener("resize", this.resized), this.iframe.removeEventListener("load", this.loaded);
}, RSVP.EventTarget.mixin(EPUBJS.Render.Iframe.prototype), EPUBJS.Renderer = function (a, b) {
	this.listenedEvents = ["keydown", "keyup", "keypressed", "mouseup", "mousedown", "click"], this.upEvent = "mouseup", this.downEvent = "mousedown", "ontouchstart" in document.documentElement && (this.listenedEvents.push("touchstart", "touchend"), this.upEvent = "touchend", this.downEvent = "touchstart"), a && void 0 !== EPUBJS.Render[a] ? this.render = new EPUBJS.Render[a]() : console.error("Not a Valid Rendering Method"), this.render.on("render:loaded", this.loaded.bind(this)), this.caches = {}, this.epubcfi = new EPUBJS.EpubCFI(), this.spreads = !0, this.isForcedSingle = !1, this.resized = this.onResized.bind(this), this.layoutSettings = {}, this.hidden = b || !1, EPUBJS.Hooks.mixin(this), this.getHooks("beforeChapterDisplay"), this._q = EPUBJS.core.queue(this), this._moving = !1;
}, EPUBJS.Renderer.prototype.Events = ["renderer:keydown", "renderer:keyup", "renderer:keypressed", "renderer:mouseup", "renderer:mousedown", "renderer:click", "renderer:touchstart", "renderer:touchend", "renderer:selected", "renderer:chapterUnload", "renderer:chapterUnloaded", "renderer:chapterDisplayed", "renderer:locationChanged", "renderer:visibleLocationChanged", "renderer:visibleRangeChanged", "renderer:resized", "renderer:spreads", "renderer:beforeResize"], EPUBJS.Renderer.prototype.initialize = function (a, b, c) {
	this.container = a, this.element = this.render.create(), this.initWidth = b, this.initHeight = c, this.width = b || this.container.clientWidth, this.height = c || this.container.clientHeight, this.container.appendChild(this.element), b && c ? this.render.resize(this.width, this.height) : this.render.resize("100%", "100%"), document.addEventListener("orientationchange", this.onResized.bind(this));
}, EPUBJS.Renderer.prototype.displayChapter = function (a, b) {
	if (this._moving) {
		console.warning("Rendering In Progress");var c = new RSVP.defer();return c.reject({ message: "Rendering In Progress", stack: new Error().stack }), c.promise;
	}return this._moving = !0, a.render().then(function (c) {
		return this.currentChapter && (this.trigger("renderer:chapterUnload"), this.currentChapter.unload(), this.render.window && this.render.window.removeEventListener("resize", this.resized), this.removeEventListeners(), this.removeSelectionListeners(), this.trigger("renderer:chapterUnloaded"), this.contents = null, this.doc = null, this.pageMap = null), this.currentChapter = a, this.chapterPos = 1, this.currentChapterCfiBase = a.cfiBase, this.layoutSettings = this.reconcileLayoutSettings(b, a.properties), this.load(c, a.href);
	}.bind(this), function () {
		this._moving = !1;
	}.bind(this));
}, EPUBJS.Renderer.prototype.load = function (a, b) {
	var c = new RSVP.defer();return this.layoutMethod = this.determineLayout(this.layoutSettings), this.layout = new EPUBJS.Layout[this.layoutMethod](), this.visible(!1), this.render.load(a, b).then(function (a) {
		EPUBJS.Layout.isFixedLayout(a) && (this.layoutSettings.layout = "pre-paginated", this.layoutMethod = this.determineLayout(this.layoutSettings), this.layout = new EPUBJS.Layout[this.layoutMethod]()), this.render.setLayout(this.layoutSettings.layout), "rtl" == this.render.direction && "rtl" != this.render.docEl.dir && (this.render.docEl.dir = "rtl", "pre-paginated" !== this.render.layout && (this.render.docEl.style.position = "absolute", this.render.docEl.style.right = "0")), this.afterLoad(a), this.beforeDisplay(function () {
			this.afterDisplay(), this.visible(!0), c.resolve(this);
		}.bind(this));
	}.bind(this)), c.promise;
}, EPUBJS.Renderer.prototype.afterLoad = function (a) {
	this.contents = a, this.doc = this.render.document, this.formated = this.layout.format(a, this.render.width, this.render.height, this.gap), this.render.setPageDimensions(this.formated.pageWidth, this.formated.pageHeight), this.initWidth || this.initHeight || this.render.window.addEventListener("resize", this.resized, !1), this.addEventListeners(), this.addSelectionListeners();
}, EPUBJS.Renderer.prototype.afterDisplay = function (a) {
	var b = this.layout.calculatePages(),
	    c = this.currentChapter,
	    d = this._q.length();this._moving = !1, this.updatePages(b), this.visibleRangeCfi = this.getVisibleRangeCfi(), this.currentLocationCfi = this.visibleRangeCfi.start, 0 === d && (this.trigger("renderer:locationChanged", this.currentLocationCfi), this.trigger("renderer:visibleRangeChanged", this.visibleRangeCfi)), c.cfi = this.currentLocationCfi, this.trigger("renderer:chapterDisplayed", c);
}, EPUBJS.Renderer.prototype.loaded = function (a) {
	this.trigger("render:loaded", a);
}, EPUBJS.Renderer.prototype.reconcileLayoutSettings = function (a, b) {
	var c = {};for (var d in a) {
		a.hasOwnProperty(d) && (c[d] = a[d]);
	}return b.forEach(function (a) {
		var b,
		    d,
		    e = a.replace("rendition:", ""),
		    f = e.indexOf("-");f != -1 && (b = e.slice(0, f), d = e.slice(f + 1), c[b] = d);
	}), c;
}, EPUBJS.Renderer.prototype.determineLayout = function (a) {
	var b = this.determineSpreads(this.minSpreadWidth),
	    c = b ? "ReflowableSpreads" : "Reflowable",
	    d = !1;return "pre-paginated" === a.layout && (c = "Fixed", d = !0, b = !1), "reflowable" === a.layout && "none" === a.spread && (c = "Reflowable", d = !1, b = !1), "reflowable" === a.layout && "both" === a.spread && (c = "ReflowableSpreads", d = !1, b = !0), this.spreads = b, this.render.scroll(d), this.trigger("renderer:spreads", b), c;
}, EPUBJS.Renderer.prototype.beforeDisplay = function (a, b) {
	this.triggerHooks("beforeChapterDisplay", a, this);
}, EPUBJS.Renderer.prototype.updatePages = function (a) {
	this.pageMap = this.mapPage(), this.spreads ? this.displayedPages = Math.ceil(this.pageMap.length / 2) : this.displayedPages = this.pageMap.length, this.currentChapter.pages = this.pageMap.length, this._q.flush();
}, EPUBJS.Renderer.prototype.reformat = function () {
	var a,
	    b,
	    c = this;this.contents && (b = this.determineSpreads(this.minSpreadWidth), b != this.spreads && (this.spreads = b, this.layoutMethod = this.determineLayout(this.layoutSettings), this.layout = new EPUBJS.Layout[this.layoutMethod]()), this.chapterPos = 1, this.render.page(this.chapterPos), c.formated = c.layout.format(c.render.docEl, c.render.width, c.render.height, c.gap), c.render.setPageDimensions(c.formated.pageWidth, c.formated.pageHeight), a = c.layout.calculatePages(), c.updatePages(a), c.currentLocationCfi && c.gotoCfi(c.currentLocationCfi));
}, EPUBJS.Renderer.prototype.visible = function (a) {
	if (void 0 === a) return this.element.style.visibility;a !== !0 || this.hidden ? a === !1 && (this.element.style.visibility = "hidden") : this.element.style.visibility = "visible";
}, EPUBJS.Renderer.prototype.remove = function () {
	this.render.window && (this.render.unload(), this.render.window.removeEventListener("resize", this.resized), this.removeEventListeners(), this.removeSelectionListeners()), this.container.removeChild(this.element);
}, EPUBJS.Renderer.prototype.applyStyles = function (a) {
	for (var b in a) {
		this.render.setStyle(b, a[b]);
	}
}, EPUBJS.Renderer.prototype.setStyle = function (a, b, c) {
	this.render.setStyle(a, b, c);
}, EPUBJS.Renderer.prototype.removeStyle = function (a) {
	this.render.removeStyle(a);
}, EPUBJS.Renderer.prototype.setClasses = function (a) {
	this.render.setClasses(a);
}, EPUBJS.Renderer.prototype.applyHeadTags = function (a) {
	for (var b in a) {
		this.render.addHeadTag(b, a[b]);
	}
}, EPUBJS.Renderer.prototype.page = function (a) {
	return this.pageMap ? a >= 1 && a <= this.displayedPages && (this.chapterPos = a, this.render.page(a), this.visibleRangeCfi = this.getVisibleRangeCfi(), this.currentLocationCfi = this.visibleRangeCfi.start, this.trigger("renderer:locationChanged", this.currentLocationCfi), this.trigger("renderer:visibleRangeChanged", this.visibleRangeCfi), !0) : (console.warn("pageMap not set, queuing"), this._q.enqueue("page", arguments), !0);
}, EPUBJS.Renderer.prototype.nextPage = function () {
	return this.page(this.chapterPos + 1);
}, EPUBJS.Renderer.prototype.prevPage = function () {
	return this.page(this.chapterPos - 1);
}, EPUBJS.Renderer.prototype.pageByElement = function (a) {
	var b;a && (b = this.render.getPageNumberByElement(a), this.page(b));
}, EPUBJS.Renderer.prototype.lastPage = function () {
	if (this._moving) return this._q.enqueue("lastPage", arguments);this.page(this.displayedPages);
}, EPUBJS.Renderer.prototype.firstPage = function () {
	if (this._moving) return this._q.enqueue("firstPage", arguments);this.page(1);
}, EPUBJS.Renderer.prototype.section = function (a) {
	var b = this.doc.getElementById(a);b && this.pageByElement(b);
}, EPUBJS.Renderer.prototype.firstElementisTextNode = function (a) {
	var b = a.childNodes;return !!(b.length && b[0] && 3 === b[0].nodeType && b[0].textContent.trim().length);
}, EPUBJS.Renderer.prototype.isGoodNode = function (a) {
	return ["audio", "canvas", "embed", "iframe", "img", "math", "object", "svg", "video"].indexOf(a.tagName.toLowerCase()) !== -1 || this.firstElementisTextNode(a);
}, EPUBJS.Renderer.prototype.walk = function (a, b, c) {
	for (var d, e, f, g, h = a, i = [h], j = 1e4, k = 0; !d && i.length;) {
		if (a = i.shift(), this.containsPoint(a, b, c) && this.isGoodNode(a) && (d = a), !d && a && a.childElementCount > 0) {
			if (!(e = a.children) || !e.length) return d;f = e.length ? e.length : 0;for (var l = f - 1; l >= 0; l--) {
				e[l] != g && i.unshift(e[l]);
			}
		}if (!d && 0 === i.length && h && null !== h.parentNode && (i.push(h.parentNode), g = h, h = h.parentNode), ++k > j) {
			console.error("ENDLESS LOOP");break;
		}
	}return d;
}, EPUBJS.Renderer.prototype.containsPoint = function (a, b, c) {
	var d;return !!(a && "function" == typeof a.getBoundingClientRect && (d = a.getBoundingClientRect(), 0 !== d.width && 0 !== d.height && d.left >= b && b <= d.left + d.width));
}, EPUBJS.Renderer.prototype.textSprint = function (a, b) {
	var c,
	    d,
	    e = function e(a) {
		return (/^\s*$/.test(a.data) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT
		);
	};try {
		for (c = document.createTreeWalker(a, NodeFilter.SHOW_TEXT, { acceptNode: e }, !1); d = c.nextNode();) {
			b(d);
		}
	} catch (f) {
		for (c = document.createTreeWalker(a, NodeFilter.SHOW_TEXT, e, !1); d = c.nextNode();) {
			b(d);
		}
	}
}, EPUBJS.Renderer.prototype.sprint = function (a, b) {
	for (var c, d = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, null, !1); c = d.nextNode();) {
		b(c);
	}
}, EPUBJS.Renderer.prototype.mapPage = function () {
	var a,
	    b,
	    c,
	    d,
	    e,
	    f,
	    g,
	    h,
	    i = this,
	    j = [],
	    k = this.render.getBaseElement(),
	    l = 1,
	    m = this.layout.colWidth + this.layout.gap,
	    n = this.formated.pageWidth * (this.chapterPos - 1),
	    o = m * l - n,
	    p = 0,
	    q = function q(b) {
		var c, e, f;if (b.nodeType == Node.TEXT_NODE) {
			if (e = document.createRange(), e.selectNodeContents(b), !(c = e.getBoundingClientRect()) || 0 === c.width && 0 === c.height) return;c.left > p && (f = r(b)), c.right > p && (f = r(b)), d = b, f && (a = null);
		}
	},
	    r = function r(e) {
		var f;return i.splitTextNodeIntoWordsRanges(e).forEach(function (e) {
			var g = e.getBoundingClientRect();!g || 0 === g.width && 0 === g.height || (g.left + g.width < o ? j[l - 1] || (e.collapse(!0), c = i.currentChapter.cfiFromRange(e), f = j.push({ start: c, end: null })) : (!a && d && (b = i.splitTextNodeIntoWordsRanges(d), a = b[b.length - 1]), a && j.length && (a.collapse(!1), c = i.currentChapter.cfiFromRange(a), j[j.length - 1] && (j[j.length - 1].end = c)), e.collapse(!0), c = i.currentChapter.cfiFromRange(e), f = j.push({ start: c, end: null }), l += 1, o = m * l - n, p = o), a = e);
		}), f;
	},
	    s = this.render.getDocumentElement(),
	    t = s.dir;return "rtl" == t && (s.dir = "ltr", "pre-paginated" !== this.layoutSettings.layout && (s.style.position = "static")), this.textSprint(k, q), "rtl" == t && (s.dir = t, "pre-paginated" !== this.layoutSettings.layout && (s.style.left = "auto", s.style.right = "0")), !a && d && (b = i.splitTextNodeIntoWordsRanges(d), a = b[b.length - 1]), a && (a.collapse(!1), c = i.currentChapter.cfiFromRange(a), j[j.length - 1].end = c), j.length || (e = this.doc.createRange(), e.selectNodeContents(k), e.collapse(!0), g = i.currentChapter.cfiFromRange(e), f = this.doc.createRange(), f.selectNodeContents(k), f.collapse(!1), h = i.currentChapter.cfiFromRange(f), j.push({ start: g, end: h })), a = null, b = void 0, e = null, f = null, k = null, j;
}, EPUBJS.Renderer.prototype.indexOfBreakableChar = function (a, b) {
	var c = "- \t\r\n\b\f";b || (b = 0);for (var d = b; d < a.length; d++) {
		if (c.indexOf(a.charAt(d)) != -1) return d;
	}return -1;
}, EPUBJS.Renderer.prototype.splitTextNodeIntoWordsRanges = function (a) {
	var b,
	    c = [],
	    d = a.textContent.trim(),
	    e = this.indexOfBreakableChar(d);if (e === -1) return b = this.doc.createRange(), b.selectNodeContents(a), [b];for (b = this.doc.createRange(), b.setStart(a, 0), b.setEnd(a, e), c.push(b), b = this.doc.createRange(), b.setStart(a, e + 1); e != -1;) {
		(e = this.indexOfBreakableChar(d, e + 1)) > 0 && (b && (b.setEnd(a, e), c.push(b)), b = this.doc.createRange(), b.setStart(a, e + 1));
	}return b && (b.setEnd(a, d.length), c.push(b)), c;
}, EPUBJS.Renderer.prototype.rangePosition = function (a) {
	var b;return b = a.getClientRects(), b.length ? b[0] : null;
}, EPUBJS.Renderer.prototype.getPageCfi = function () {
	var a = 2 * this.chapterPos - 1;return this.pageMap[a].start;
}, EPUBJS.Renderer.prototype.getRange = function (a, b, c) {
	var d,
	    e = this.doc.createRange();return c = !0, void 0 === document.caretPositionFromPoint || c ? void 0 === document.caretRangeFromPoint || c ? (this.visibileEl = this.findElementAfter(a, b), e.setStart(this.visibileEl, 1)) : e = this.doc.caretRangeFromPoint(a, b) : (d = this.doc.caretPositionFromPoint(a, b), e.setStart(d.offsetNode, d.offset)), e;
}, EPUBJS.Renderer.prototype.pagesInCurrentChapter = function () {
	return this.pageMap ? this.pageMap.length : (console.warn("page map not loaded"), !1);
}, EPUBJS.Renderer.prototype.currentRenderedPage = function () {
	return this.pageMap ? this.spreads && this.pageMap.length > 1 ? 2 * this.chapterPos - 1 : this.chapterPos : (console.warn("page map not loaded"), !1);
}, EPUBJS.Renderer.prototype.getRenderedPagesLeft = function () {
	var a, b;return this.pageMap ? (b = this.pageMap.length, a = this.spreads ? 2 * this.chapterPos - 1 : this.chapterPos, b - a) : (console.warn("page map not loaded"), !1);
}, EPUBJS.Renderer.prototype.getVisibleRangeCfi = function () {
	var a, b, c;return this.pageMap ? (this.spreads ? (a = 2 * this.chapterPos, b = this.pageMap[a - 2], c = b, this.pageMap.length > 1 && this.pageMap.length > a - 1 && (c = this.pageMap[a - 1])) : (a = this.chapterPos, b = this.pageMap[a - 1], c = b), b || (console.warn("page range miss:", a, this.pageMap), b = this.pageMap[this.pageMap.length - 1], c = b), { start: b.start, end: c.end }) : (console.warn("page map not loaded"), !1);
}, EPUBJS.Renderer.prototype.gotoCfi = function (a) {
	var b, c, d;if (this._moving) return this._q.enqueue("gotoCfi", arguments);if (EPUBJS.core.isString(a) && (a = this.epubcfi.parse(a)), void 0 === document.evaluate) (c = this.epubcfi.addMarker(a, this.doc)) && (b = this.render.getPageNumberByElement(c), this.epubcfi.removeMarker(c, this.doc), this.page(b));else if (d = this.epubcfi.generateRangeFromCfi(a, this.doc)) {
		var e = d.getBoundingClientRect();b = e ? this.render.getPageNumberByRect(e) : 1, this.page(b), this.currentLocationCfi = a.str;
	} else this.page(1);
}, EPUBJS.Renderer.prototype.findFirstVisible = function (a) {
	var b,
	    c = a || this.render.getBaseElement();return b = this.walk(c, 0, 0), b ? b : a;
}, EPUBJS.Renderer.prototype.findElementAfter = function (a, b, c) {
	var d,
	    e = c || this.render.getBaseElement();return d = this.walk(e, a, b), d ? d : e;
}, EPUBJS.Renderer.prototype.resize = function (a, b, c) {
	this.width = a, this.height = b, c !== !1 && this.render.resize(this.width, this.height), this.contents && this.reformat(), this.trigger("renderer:resized", { width: this.width, height: this.height });
}, EPUBJS.Renderer.prototype.onResized = function (a) {
	this.trigger("renderer:beforeResize");var b = this.container.clientWidth,
	    c = this.container.clientHeight;this.resize(b, c, !1);
}, EPUBJS.Renderer.prototype.addEventListeners = function () {
	this.render.document && this.listenedEvents.forEach(function (a) {
		this.render.document.addEventListener(a, this.triggerEvent.bind(this), !1);
	}, this);
}, EPUBJS.Renderer.prototype.removeEventListeners = function () {
	this.render.document && this.listenedEvents.forEach(function (a) {
		this.render.document.removeEventListener(a, this.triggerEvent, !1);
	}, this);
}, EPUBJS.Renderer.prototype.triggerEvent = function (a) {
	this.trigger("renderer:" + a.type, a);
}, EPUBJS.Renderer.prototype.addSelectionListeners = function () {
	this.render.document.addEventListener("selectionchange", this.onSelectionChange.bind(this), !1);
}, EPUBJS.Renderer.prototype.removeSelectionListeners = function () {
	this.render.document && this.doc.removeEventListener("selectionchange", this.onSelectionChange, !1);
}, EPUBJS.Renderer.prototype.onSelectionChange = function (a) {
	this.selectionEndTimeout && clearTimeout(this.selectionEndTimeout), this.selectionEndTimeout = setTimeout(function () {
		this.selectedRange = this.render.window.getSelection(), this.trigger("renderer:selected", this.selectedRange);
	}.bind(this), 500);
}, EPUBJS.Renderer.prototype.setMinSpreadWidth = function (a) {
	this.minSpreadWidth = a, this.spreads = this.determineSpreads(a);
}, EPUBJS.Renderer.prototype.determineSpreads = function (a) {
	return !(this.isForcedSingle || !a || this.width < a);
}, EPUBJS.Renderer.prototype.forceSingle = function (a) {
	this.isForcedSingle = !!a;
}, EPUBJS.Renderer.prototype.setGap = function (a) {
	this.gap = a;
}, EPUBJS.Renderer.prototype.setDirection = function (a) {
	this.direction = a, this.render.setDirection(this.direction);
};EPUBJS.Renderer.prototype.replace = function (a, b, c, d) {
	var e = this.contents.querySelectorAll(a),
	    f = Array.prototype.slice.call(e),
	    g = f.length;if (0 === g) return void c(!1);f.forEach(function (a) {
		var e = !1;b(a, function (a, b) {
			e === !1 && (g--, d && d(a, b, g), g <= 0 && c && c(!0), e = !0);
		});
	}.bind(this));
}, RSVP.EventTarget.mixin(EPUBJS.Renderer.prototype);var EPUBJS = EPUBJS || {};EPUBJS.replace = {}, EPUBJS.replace.hrefs = function (a, b) {
	var c = this,
	    d = function d(a, _d2) {
		var e,
		    f,
		    g,
		    h,
		    i,
		    j = a.getAttribute("href"),
		    k = j.search("://");if (0 === j.indexOf("mailto:")) return void _d2();k != -1 ? a.setAttribute("target", "_blank") : (g = b.render.docEl.querySelector("base"), i = g.getAttribute("href"), h = EPUBJS.core.uri(i), e = h.directory, 0 === j.indexOf("#") && (j = h.filename + j), f = e ? "file" === h.protocol ? EPUBJS.core.resolveUrl(h.base, j) : EPUBJS.core.resolveUrl(e, j) : j, a.onclick = function () {
			return c.trigger("book:linkClicked", j), c.goto(f), !1;
		}), _d2();
	};b.replace("a[href]", d, a);
}, EPUBJS.replace.head = function (a, b) {
	b.replaceWithStored("link[href]", "href", EPUBJS.replace.links, a);
}, EPUBJS.replace.resources = function (a, b) {
	b.replaceWithStored("[src]", "src", EPUBJS.replace.srcs, a);
}, EPUBJS.replace.posters = function (a, b) {
	b.replaceWithStored("[poster]", "poster", EPUBJS.replace.srcs, a);
}, EPUBJS.replace.svg = function (a, b) {
	b.replaceWithStored("svg image", "xlink:href", function (a, b, c) {
		a.getUrl(b).then(c);
	}, a);
}, EPUBJS.replace.srcs = function (a, b, c) {
	b.search("://") === -1 ? a.getUrl(b).then(c) : c();
}, EPUBJS.replace.links = function (a, b, c, d) {
	"stylesheet" === d.getAttribute("rel") ? EPUBJS.replace.stylesheets(a, b).then(function (a, b) {
		c(a, b);
	}, function (a) {
		c(null);
	}) : a.getUrl(b).then(c, function (a) {
		c(null);
	});
}, EPUBJS.replace.stylesheets = function (a, b) {
	var c = new RSVP.defer();if (a) return a.getText(b).then(function (d) {
		EPUBJS.replace.cssImports(a, b, d).then(function (e) {
			d = e + d, EPUBJS.replace.cssUrls(a, b, d).then(function (a) {
				var b = window.URL || window.webkitURL || window.mozURL,
				    d = new Blob([a], { type: "text/css" }),
				    e = b.createObjectURL(d);c.resolve(e);
			}, function (a) {
				c.reject(a);
			});
		}, function (a) {
			c.reject(a);
		});
	}, function (a) {
		c.reject(a);
	}), c.promise;
}, EPUBJS.replace.cssImports = function (a, b, c) {
	var d = new RSVP.defer();if (a) {
		for (var e, f = /@import\s+(?:url\()?\'?\"?((?!data:)[^\'|^\"^\)]*)\'?\"?\)?/gi, g = [], h = ""; e = f.exec(c);) {
			g.push(e[1]);
		}return 0 === g.length && d.resolve(h), g.forEach(function (c) {
			var e = EPUBJS.core.resolveUrl(b, c);e = EPUBJS.core.uri(e).path, a.getText(e).then(function (a) {
				h += a, g.indexOf(c) === g.length - 1 && d.resolve(h);
			}, function (a) {
				d.reject(a);
			});
		}), d.promise;
	}
}, EPUBJS.replace.cssUrls = function (a, b, c) {
	var d = new RSVP.defer(),
	    e = c.match(/url\(\'?\"?((?!data:)[^\'|^\"^\)]*)\'?\"?\)/g);if (a) {
		if (!e) return d.resolve(c), d.promise;var f = e.map(function (e) {
			var f = EPUBJS.core.resolveUrl(b, e.replace(/url\(|[|\)|\'|\"]|\?.*$/g, ""));return a.getUrl(f).then(function (a) {
				c = c.replace(e, 'url("' + a + '")');
			}, function (a) {
				d.reject(a);
			});
		});return RSVP.all(f).then(function () {
			d.resolve(c);
		}), d.promise;
	}
}, EPUBJS.Storage = function (a) {
	this.checkRequirements(), this.urlCache = {}, this.withCredentials = a, this.URL = window.URL || window.webkitURL || window.mozURL, this.offline = !1;
}, EPUBJS.Storage.prototype.checkRequirements = function (a) {
	"undefined" == typeof localforage && console.error("localForage library not loaded");
}, EPUBJS.Storage.prototype.put = function (a, b) {
	var c = new RSVP.defer(),
	    d = a.length,
	    e = 0,
	    f = function (b) {
		var c,
		    g,
		    h = b || new RSVP.defer();return e >= d ? h.resolve() : (c = a[e].url, g = window.encodeURIComponent(c), EPUBJS.core.request(c, "binary").then(function (a) {
			return localforage.setItem(g, a);
		}).then(function (a) {
			e++, setTimeout(function () {
				f(h);
			}, 1);
		})), h.promise;
	}.bind(this);return Array.isArray(a) || (a = [a]), f().then(function () {
		c.resolve();
	}.bind(this)), c.promise;
}, EPUBJS.Storage.prototype.token = function (a, b) {
	var c = window.encodeURIComponent(a);return localforage.setItem(c, b).then(function (a) {
		return null !== a;
	});
}, EPUBJS.Storage.prototype.isStored = function (a) {
	var b = window.encodeURIComponent(a);return localforage.getItem(b).then(function (a) {
		return null !== a;
	});
}, EPUBJS.Storage.prototype.getText = function (a) {
	var b = window.encodeURIComponent(a);return EPUBJS.core.request(a, "arraybuffer", this.withCredentials).then(function (a) {
		return this.offline && (this.offline = !1, this.trigger("offline", !1)), localforage.setItem(b, a), a;
	}.bind(this)).then(function (b) {
		var c = new RSVP.defer(),
		    d = EPUBJS.core.getMimeType(a),
		    e = new Blob([b], { type: d }),
		    f = new FileReader();return f.addEventListener("loadend", function () {
			c.resolve(f.result);
		}), f.readAsText(e, d), c.promise;
	}).catch(function () {
		var c = new RSVP.defer(),
		    d = localforage.getItem(b);return this.offline || (this.offline = !0, this.trigger("offline", !0)), d ? (d.then(function (b) {
			var d = EPUBJS.core.getMimeType(a),
			    e = new Blob([b], { type: d }),
			    f = new FileReader();f.addEventListener("loadend", function () {
				c.resolve(f.result);
			}), f.readAsText(e, d);
		}), c.promise) : (c.reject({ message: "File not found in the storage: " + a, stack: new Error().stack }), c.promise);
	}.bind(this));
}, EPUBJS.Storage.prototype.getUrl = function (a) {
	var b = window.encodeURIComponent(a);return EPUBJS.core.request(a, "arraybuffer", this.withCredentials).then(function (c) {
		return this.offline && (this.offline = !1, this.trigger("offline", !1)), localforage.setItem(b, c), a;
	}.bind(this)).catch(function () {
		var c,
		    d,
		    e = new RSVP.defer(),
		    f = window.URL || window.webkitURL || window.mozURL;return this.offline || (this.offline = !0, this.trigger("offline", !0)), b in this.urlCache ? (e.resolve(this.urlCache[b]), e.promise) : (c = localforage.getItem(b)) ? (c.then(function (c) {
			var g = new Blob([c], { type: EPUBJS.core.getMimeType(a) });d = f.createObjectURL(g), e.resolve(d), this.urlCache[b] = d;
		}.bind(this)), e.promise) : (e.reject({ message: "File not found in the storage: " + a, stack: new Error().stack }), e.promise);
	}.bind(this));
}, EPUBJS.Storage.prototype.getXml = function (a) {
	var b = window.encodeURIComponent(a);return EPUBJS.core.request(a, "arraybuffer", this.withCredentials).then(function (a) {
		return this.offline && (this.offline = !1, this.trigger("offline", !1)), localforage.setItem(b, a), a;
	}.bind(this)).then(function (b) {
		var c = new RSVP.defer(),
		    d = EPUBJS.core.getMimeType(a),
		    e = new Blob([b], { type: d }),
		    f = new FileReader();return f.addEventListener("loadend", function () {
			var a = new DOMParser(),
			    b = a.parseFromString(f.result, "text/xml");c.resolve(b);
		}), f.readAsText(e, d), c.promise;
	}).catch(function () {
		var c = new RSVP.defer(),
		    d = localforage.getItem(b);return this.offline || (this.offline = !0, this.trigger("offline", !0)), d ? (d.then(function (b) {
			var d = EPUBJS.core.getMimeType(a),
			    e = new Blob([b], { type: d }),
			    f = new FileReader();f.addEventListener("loadend", function () {
				var a = new DOMParser(),
				    b = a.parseFromString(f.result, "text/xml");c.resolve(b);
			}), f.readAsText(e, d);
		}), c.promise) : (c.reject({ message: "File not found in the storage: " + a, stack: new Error().stack }), c.promise);
	}.bind(this));
}, EPUBJS.Storage.prototype.revokeUrl = function (a) {
	var b = window.URL || window.webkitURL || window.mozURL,
	    c = this.urlCache[a];c && b.revokeObjectURL(c);
}, EPUBJS.Storage.prototype.failed = function (a) {
	console.error(a);
}, RSVP.EventTarget.mixin(EPUBJS.Storage.prototype), EPUBJS.Unarchiver = function (a) {
	this.checkRequirements(), this.urlCache = {};
}, EPUBJS.Unarchiver.prototype.checkRequirements = function (a) {
	"undefined" == typeof JSZip && console.error("JSZip lib not loaded");
}, EPUBJS.Unarchiver.prototype.open = function (a, b) {
	if (a instanceof ArrayBuffer) {
		this.zip = new JSZip(a);var c = new RSVP.defer();return c.resolve(), c.promise;
	}return EPUBJS.core.request(a, "binary").then(function (a) {
		this.zip = new JSZip(a);
	}.bind(this));
}, EPUBJS.Unarchiver.prototype.getXml = function (a, b) {
	var c = window.decodeURIComponent(a);return this.getText(c, b).then(function (b) {
		var c = new DOMParser(),
		    d = EPUBJS.core.getMimeType(a);return 65279 === b.charCodeAt(0) && (b = b.slice(1)), c.parseFromString(b, d);
	});
}, EPUBJS.Unarchiver.prototype.getUrl = function (a, b) {
	var c,
	    d,
	    e = this,
	    f = new RSVP.defer(),
	    g = window.decodeURIComponent(a),
	    h = this.zip.file(g),
	    i = window.URL || window.webkitURL || window.mozURL;return h ? a in this.urlCache ? (f.resolve(this.urlCache[a]), f.promise) : (d = new Blob([h.asUint8Array()], { type: EPUBJS.core.getMimeType(h.name) }), c = i.createObjectURL(d), f.resolve(c), e.urlCache[a] = c, f.promise) : (f.reject({ message: "File not found in the epub: " + a, stack: new Error().stack }), f.promise);
}, EPUBJS.Unarchiver.prototype.getText = function (a, b) {
	var c,
	    d = new RSVP.defer(),
	    e = window.decodeURIComponent(a),
	    f = this.zip.file(e);return f ? (c = f.asText(), d.resolve(c), d.promise) : (d.reject({ message: "File not found in the epub: " + a, stack: new Error().stack }), d.promise);
}, EPUBJS.Unarchiver.prototype.revokeUrl = function (a) {
	var b = window.URL || window.webkitURL || window.mozURL,
	    c = this.urlCache[a];c && b.revokeObjectURL(c);
}, EPUBJS.Unarchiver.prototype.failed = function (a) {
	console.error(a);
}, EPUBJS.Unarchiver.prototype.afterSaved = function (a) {
	this.callback();
}, EPUBJS.Unarchiver.prototype.toStorage = function (a) {
	function b() {
		0 === --e && d.afterSaved();
	}var c = 0,
	    d = this,
	    e = a.length;a.forEach(function (a) {
		setTimeout(function (a) {
			d.saveEntryFileToStorage(a, b);
		}, c, a), c += 20;
	}), console.log("time", c);
}, function () {
	var a = { application: { ecmascript: ["es", "ecma"], javascript: "js", ogg: "ogx", pdf: "pdf", postscript: ["ps", "ai", "eps", "epsi", "epsf", "eps2", "eps3"], "rdf+xml": "rdf", smil: ["smi", "smil"], "xhtml+xml": ["xhtml", "xht"], xml: ["xml", "xsl", "xsd", "opf", "ncx"], zip: "zip", "x-httpd-eruby": "rhtml", "x-latex": "latex", "x-maker": ["frm", "maker", "frame", "fm", "fb", "book", "fbdoc"], "x-object": "o", "x-shockwave-flash": ["swf", "swfl"], "x-silverlight": "scr", "epub+zip": "epub", "font-tdpfr": "pfr", "inkml+xml": ["ink", "inkml"], json: "json", "jsonml+json": "jsonml", "mathml+xml": "mathml", "metalink+xml": "metalink", mp4: "mp4s", "omdoc+xml": "omdoc", oxps: "oxps", "vnd.amazon.ebook": "azw", widget: "wgt", "x-dtbook+xml": "dtb", "x-dtbresource+xml": "res", "x-font-bdf": "bdf", "x-font-ghostscript": "gsf", "x-font-linux-psf": "psf", "x-font-otf": "otf", "x-font-pcf": "pcf", "x-font-snf": "snf", "x-font-ttf": ["ttf", "ttc"], "x-font-type1": ["pfa", "pfb", "pfm", "afm"], "x-font-woff": "woff", "x-mobipocket-ebook": ["prc", "mobi"], "x-mspublisher": "pub", "x-nzb": "nzb", "x-tgif": "obj", "xaml+xml": "xaml", "xml-dtd": "dtd", "xproc+xml": "xpl", "xslt+xml": "xslt", "internet-property-stream": "acx", "x-compress": "z", "x-compressed": "tgz", "x-gzip": "gz" }, audio: { flac: "flac", midi: ["mid", "midi", "kar", "rmi"], mpeg: ["mpga", "mpega", "mp2", "mp3", "m4a", "mp2a", "m2a", "m3a"], mpegurl: "m3u", ogg: ["oga", "ogg", "spx"], "x-aiff": ["aif", "aiff", "aifc"], "x-ms-wma": "wma", "x-wav": "wav", adpcm: "adp", mp4: "mp4a", webm: "weba", "x-aac": "aac", "x-caf": "caf", "x-matroska": "mka", "x-pn-realaudio-plugin": "rmp", xm: "xm", mid: ["mid", "rmi"] }, image: { gif: "gif", ief: "ief", jpeg: ["jpeg", "jpg", "jpe"], pcx: "pcx", png: "png", "svg+xml": ["svg", "svgz"], tiff: ["tiff", "tif"], "x-icon": "ico", bmp: "bmp", webp: "webp", "x-pict": ["pic", "pct"], "x-tga": "tga", "cis-cod": "cod" }, message: { rfc822: ["eml", "mime", "mht", "mhtml", "nws"] }, text: { "cache-manifest": ["manifest", "appcache"], calendar: ["ics", "icz", "ifb"], css: "css", csv: "csv", h323: "323", html: ["html", "htm", "shtml", "stm"], iuls: "uls", mathml: "mml", plain: ["txt", "text", "brf", "conf", "def", "list", "log", "in", "bas"], richtext: "rtx", "tab-separated-values": "tsv", "x-bibtex": "bib", "x-dsrc": "d", "x-diff": ["diff", "patch"], "x-haskell": "hs", "x-java": "java", "x-literate-haskell": "lhs", "x-moc": "moc", "x-pascal": ["p", "pas"], "x-pcs-gcd": "gcd", "x-perl": ["pl", "pm"], "x-python": "py", "x-scala": "scala", "x-setext": "etx", "x-tcl": ["tcl", "tk"], "x-tex": ["tex", "ltx", "sty", "cls"], "x-vcard": "vcf", sgml: ["sgml", "sgm"], "x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "x-fortran": ["f", "for", "f77", "f90"], "x-opml": "opml", "x-nfo": "nfo", "x-sfv": "sfv", "x-uuencode": "uu", webviewhtml: "htt" }, video: { mpeg: ["mpeg", "mpg", "mpe", "m1v", "m2v", "mp2", "mpa", "mpv2"], mp4: ["mp4", "mp4v", "mpg4"], quicktime: ["qt", "mov"], ogg: "ogv", "vnd.mpegurl": ["mxu", "m4u"], "x-flv": "flv", "x-la-asf": ["lsf", "lsx"], "x-mng": "mng", "x-ms-asf": ["asf", "asx", "asr"], "x-ms-wm": "wm", "x-ms-wmv": "wmv", "x-ms-wmx": "wmx", "x-ms-wvx": "wvx", "x-msvideo": "avi", "x-sgi-movie": "movie", "x-matroska": ["mpv", "mkv", "mk3d", "mks"], "3gpp2": "3g2", h261: "h261", h263: "h263", h264: "h264", jpeg: "jpgv", jpm: ["jpm", "jpgm"], mj2: ["mj2", "mjp2"], "vnd.ms-playready.media.pyv": "pyv", "vnd.uvvu.mp4": ["uvu", "uvvu"], "vnd.vivo": "viv", webm: "webm", "x-f4v": "f4v", "x-m4v": "m4v", "x-ms-vob": "vob", "x-smv": "smv" } },
	    b = function () {
		var b,
		    c,
		    d,
		    e,
		    f = {};for (b in a) {
			if (a.hasOwnProperty(b)) for (c in a[b]) {
				if (a[b].hasOwnProperty(c)) if ("string" == typeof (d = a[b][c])) f[d] = b + "/" + c;else for (e = 0; e < d.length; e++) {
					f[d[e]] = b + "/" + c;
				}
			}
		}return f;
	}();EPUBJS.core.getMimeType = function (a) {
		return a && b[a.split(".").pop().toLowerCase()] || "text/plain";
	};
}();
EPUBJS.Hooks.register("beforeChapterDisplay").endnotes = function (a, b) {
	var c = b.contents.querySelectorAll("a[href]"),
	    d = Array.prototype.slice.call(c),
	    e = EPUBJS.core.folder(location.pathname),
	    f = (EPUBJS.cssPath, {});EPUBJS.core.addCss(EPUBJS.cssPath + "popup.css", !1, b.render.document.head), d.forEach(function (a) {
		function c() {
			var c,
			    h,
			    n = b.height,
			    o = b.width,
			    p = 225;m || (c = j.cloneNode(!0), m = c.querySelector("p")), f[i] || (f[i] = document.createElement("div"), f[i].setAttribute("class", "popup"), pop_content = document.createElement("div"), f[i].appendChild(pop_content), pop_content.appendChild(m), pop_content.setAttribute("class", "pop_content"), b.render.document.body.appendChild(f[i]), f[i].addEventListener("mouseover", d, !1), f[i].addEventListener("mouseout", e, !1), b.on("renderer:pageChanged", g, this), b.on("renderer:pageChanged", e, this)), c = f[i], h = a.getBoundingClientRect(), k = h.left, l = h.top, c.classList.add("show"), popRect = c.getBoundingClientRect(), c.style.left = k - popRect.width / 2 + "px", c.style.top = l + "px", p > n / 2.5 && (p = n / 2.5, pop_content.style.maxHeight = p + "px"), popRect.height + l >= n - 25 ? (c.style.top = l - popRect.height + "px", c.classList.add("above")) : c.classList.remove("above"), k - popRect.width <= 0 ? (c.style.left = k + "px", c.classList.add("left")) : c.classList.remove("left"), k + popRect.width / 2 >= o ? (c.style.left = k - 300 + "px", popRect = c.getBoundingClientRect(), c.style.left = k - popRect.width + "px", popRect.height + l >= n - 25 ? (c.style.top = l - popRect.height + "px", c.classList.add("above")) : c.classList.remove("above"), c.classList.add("right")) : c.classList.remove("right");
		}function d() {
			f[i].classList.add("on");
		}function e() {
			f[i].classList.remove("on");
		}function g() {
			setTimeout(function () {
				f[i].classList.remove("show");
			}, 100);
		}var h, i, j, k, l, m;"noteref" == a.getAttribute("epub:type") && (h = a.getAttribute("href"), i = h.replace("#", ""), j = b.render.document.getElementById(i), a.addEventListener("mouseover", c, !1), a.addEventListener("mouseout", g, !1));
	}), a && a();
}, EPUBJS.Hooks.register("beforeChapterDisplay").mathml = function (a, b) {
	if (b.currentChapter.manifestProperties.indexOf("mathml") !== -1) {
		b.render.iframe.contentWindow.mathmlCallback = a;var c = document.createElement("script");c.type = "text/x-mathjax-config", c.innerHTML = '        MathJax.Hub.Register.StartupHook("End",function () {           window.mathmlCallback();         });        MathJax.Hub.Config({jax: ["input/TeX","input/MathML","output/SVG"],extensions: ["tex2jax.js","mml2jax.js","MathEvents.js"],TeX: {extensions: ["noErrors.js","noUndefined.js","autoload-all.js"]},MathMenu: {showRenderer: false},menuSettings: {zoom: "Click"},messageStyle: "none"});                 ', b.doc.body.appendChild(c), EPUBJS.core.addScript("http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML", null, b.doc.head);
	} else a && a();
}, EPUBJS.Hooks.register("beforeChapterDisplay").smartimages = function (a, b) {
	var c = b.contents.querySelectorAll("img"),
	    d = Array.prototype.slice.call(c),
	    e = b.height;if ("reflowable" != b.layoutSettings.layout) return void a();d.forEach(function (a) {
		var c = function c() {
			var c,
			    d = a.getBoundingClientRect(),
			    f = d.height,
			    g = d.top,
			    h = a.getAttribute("data-height"),
			    i = h || f,
			    j = Number(getComputedStyle(a, "").fontSize.match(/(\d*(\.\d*)?)px/)[1]),
			    k = j ? j / 2 : 0;e = b.contents.clientHeight, g < 0 && (g = 0), a.style.maxWidth = "100%", i + g >= e ? (g < e / 2 ? (c = e - g - k, a.style.maxHeight = c + "px", a.style.width = "auto") : (i > e && (a.style.maxHeight = e + "px", a.style.width = "auto", d = a.getBoundingClientRect(), i = d.height), a.style.display = "block", a.style.WebkitColumnBreakBefore = "always", a.style.breakBefore = "column"), a.setAttribute("data-height", c)) : (a.style.removeProperty("max-height"), a.style.removeProperty("margin-top"));
		},
		    d = function d() {
			b.off("renderer:resized", c), b.off("renderer:chapterUnload", this);
		};a.addEventListener("load", c, !1), b.on("renderer:resized", c), b.on("renderer:chapterUnload", d), c();
	}), a && a();
}, EPUBJS.Hooks.register("beforeChapterDisplay").transculsions = function (a, b) {
	var c = b.contents.querySelectorAll("[transclusion]");Array.prototype.slice.call(c).forEach(function (a) {
		function c() {
			j = g, k = h, j > chapter.colWidth && (d = chapter.colWidth / j, j = chapter.colWidth, k *= d), f.width = j, f.height = k;
		}var d,
		    e = a.getAttribute("ref"),
		    f = document.createElement("iframe"),
		    g = a.getAttribute("width"),
		    h = a.getAttribute("height"),
		    i = a.parentNode,
		    j = g,
		    k = h;c(), b.listenUntil("renderer:resized", "renderer:chapterUnloaded", c), f.src = e, i.replaceChild(f, a);
	}), a && a();
};
EPUBJS.reader = {}, EPUBJS.reader.plugins = {}, function (a, b) {
	var c = (a.ePubReader, a.ePubReader = function (a, b) {
		return new EPUBJS.Reader(a, b);
	});"function" == typeof define && define.amd ? define(function () {
		return Reader;
	}) : "undefined" != typeof module && module.exports && (module.exports = c);
}(window, jQuery), EPUBJS.Reader = function (a, b) {
	var c,
	    d,
	    e,
	    f = this,
	    g = $("#viewer"),
	    h = window.location.search;this.settings = EPUBJS.core.defaults(b || {}, { bookPath: a, restore: !1, reload: !1, bookmarks: void 0, annotations: void 0, contained: void 0, bookKey: void 0, styles: void 0, sidebarReflow: !1, generatePagination: !1, history: !0 }), h && (e = h.slice(1).split("&"), e.forEach(function (a) {
		var b = a.split("="),
		    c = b[0],
		    d = b[1] || "";f.settings[c] = decodeURIComponent(d);
	})), this.setBookKey(this.settings.bookPath), this.settings.restore && this.isSaved() && this.applySavedSettings(), this.settings.styles = this.settings.styles || { fontSize: "100%" }, this.book = c = new EPUBJS.Book(this.settings), this.settings.previousLocationCfi && c.gotoCfi(this.settings.previousLocationCfi), this.offline = !1, this.sidebarOpen = !1, this.settings.bookmarks || (this.settings.bookmarks = []), this.settings.annotations || (this.settings.annotations = []), this.settings.generatePagination && c.generatePagination(g.width(), g.height()), c.renderTo("viewer"), f.ReaderController = EPUBJS.reader.ReaderController.call(f, c), f.SettingsController = EPUBJS.reader.SettingsController.call(f, c), f.ControlsController = EPUBJS.reader.ControlsController.call(f, c), f.SidebarController = EPUBJS.reader.SidebarController.call(f, c), f.BookmarksController = EPUBJS.reader.BookmarksController.call(f, c), f.NotesController = EPUBJS.reader.NotesController.call(f, c);for (d in EPUBJS.reader.plugins) {
		EPUBJS.reader.plugins.hasOwnProperty(d) && (f[d] = EPUBJS.reader.plugins[d].call(f, c));
	}return c.ready.all.then(function () {
		f.ReaderController.hideLoader();
	}), c.getMetadata().then(function (a) {
		f.MetaController = EPUBJS.reader.MetaController.call(f, a);
	}), c.getToc().then(function (a) {
		f.TocController = EPUBJS.reader.TocController.call(f, a);
	}), window.addEventListener("beforeunload", this.unload.bind(this), !1), window.addEventListener("hashchange", this.hashChanged.bind(this), !1), document.addEventListener("keydown", this.adjustFontSize.bind(this), !1), c.on("renderer:keydown", this.adjustFontSize.bind(this)), c.on("renderer:keydown", f.ReaderController.arrowKeys.bind(this)), c.on("renderer:selected", this.selectedRange.bind(this)), this;
}, EPUBJS.Reader.prototype.adjustFontSize = function (a) {
	var b,
	    c = 2,
	    d = a.ctrlKey || a.metaKey;this.settings.styles && (this.settings.styles.fontSize || (this.settings.styles.fontSize = "100%"), b = parseInt(this.settings.styles.fontSize.slice(0, -1)), d && 187 == a.keyCode && (a.preventDefault(), this.book.setStyle("fontSize", b + c + "%")), d && 189 == a.keyCode && (a.preventDefault(), this.book.setStyle("fontSize", b - c + "%")), d && 48 == a.keyCode && (a.preventDefault(), this.book.setStyle("fontSize", "100%")));
}, EPUBJS.Reader.prototype.addBookmark = function (a) {
	this.isBookmarked(a) > -1 || (this.settings.bookmarks.push(a), this.trigger("reader:bookmarked", a));
}, EPUBJS.Reader.prototype.removeBookmark = function (a) {
	var b = this.isBookmarked(a);b !== -1 && (this.settings.bookmarks.splice(b, 1), this.trigger("reader:unbookmarked", b));
}, EPUBJS.Reader.prototype.isBookmarked = function (a) {
	return this.settings.bookmarks.indexOf(a);
}, EPUBJS.Reader.prototype.clearBookmarks = function () {
	this.settings.bookmarks = [];
}, EPUBJS.Reader.prototype.addNote = function (a) {
	this.settings.annotations.push(a);
}, EPUBJS.Reader.prototype.removeNote = function (a) {
	var b = this.settings.annotations.indexOf(a);b !== -1 && delete this.settings.annotations[b];
}, EPUBJS.Reader.prototype.clearNotes = function () {
	this.settings.annotations = [];
}, EPUBJS.Reader.prototype.setBookKey = function (a) {
	return this.settings.bookKey || (this.settings.bookKey = "epubjsreader:" + EPUBJS.VERSION + ":" + window.location.host + ":" + a), this.settings.bookKey;
}, EPUBJS.Reader.prototype.isSaved = function (a) {
	return !!localStorage && null !== localStorage.getItem(this.settings.bookKey);
}, EPUBJS.Reader.prototype.removeSavedSettings = function () {
	if (!localStorage) return !1;localStorage.removeItem(this.settings.bookKey);
}, EPUBJS.Reader.prototype.applySavedSettings = function () {
	var a;if (!localStorage) return !1;try {
		a = JSON.parse(localStorage.getItem(this.settings.bookKey));
	} catch (a) {
		return !1;
	}return !!a && (a.styles && (this.settings.styles = EPUBJS.core.defaults(this.settings.styles || {}, a.styles)), this.settings = EPUBJS.core.defaults(this.settings, a), !0);
}, EPUBJS.Reader.prototype.saveSettings = function () {
	if (this.book && (this.settings.previousLocationCfi = this.book.getCurrentLocationCfi()), !localStorage) return !1;localStorage.setItem(this.settings.bookKey, JSON.stringify(this.settings));
}, EPUBJS.Reader.prototype.unload = function () {
	this.settings.restore && localStorage && this.saveSettings();
}, EPUBJS.Reader.prototype.hashChanged = function () {
	var a = window.location.hash.slice(1);this.book.goto(a);
}, EPUBJS.Reader.prototype.selectedRange = function (a) {
	var b = new EPUBJS.EpubCFI(),
	    c = b.generateCfiFromRangeAnchor(a, this.book.renderer.currentChapter.cfiBase),
	    d = "#" + c;this.settings.history && window.location.hash != d && (history.pushState({}, "", d), this.currentLocationCfi = c);
}, RSVP.EventTarget.mixin(EPUBJS.Reader.prototype), EPUBJS.reader.BookmarksController = function () {
	var a = this.book,
	    b = $("#bookmarksView"),
	    c = b.find("#bookmarks"),
	    d = document.createDocumentFragment(),
	    e = function e() {
		b.show();
	},
	    f = function f() {
		b.hide();
	},
	    g = 0,
	    h = function h(b) {
		var c = document.createElement("li"),
		    d = document.createElement("a");return c.id = "bookmark-" + g, c.classList.add("list_item"), d.textContent = b, d.href = b, d.classList.add("bookmark_link"), d.addEventListener("click", function (b) {
			var c = this.getAttribute("href");a.gotoCfi(c), b.preventDefault();
		}, !1), c.appendChild(d), g++, c;
	};return this.settings.bookmarks.forEach(function (a) {
		var b = h(a);d.appendChild(b);
	}), c.append(d), this.on("reader:bookmarked", function (a) {
		var b = h(a);c.append(b);
	}), this.on("reader:unbookmarked", function (a) {
		$("#bookmark-" + a).remove();
	}), { show: e, hide: f };
}, EPUBJS.reader.ControlsController = function (a) {
	var b = this,
	    c = ($("#store"), $("#fullscreen")),
	    d = ($("#fullscreenicon"), $("#cancelfullscreenicon"), $("#slider")),
	    e = ($("#main"), $("#sidebar"), $("#setting")),
	    f = $("#bookmark"),
	    g = function g() {
		b.offline = !1;
	},
	    h = function h() {
		b.offline = !0;
	},
	    i = !1;return a.on("book:online", g), a.on("book:offline", h), d.on("click", function () {
		b.sidebarOpen ? (b.SidebarController.hide(), d.addClass("icon-menu"), d.removeClass("icon-right")) : (b.SidebarController.show(), d.addClass("icon-right"), d.removeClass("icon-menu"));
	}), "undefined" != typeof screenfull && (c.on("click", function () {
		screenfull.toggle($("#container")[0]);
	}), screenfull.raw && document.addEventListener(screenfull.raw.fullscreenchange, function () {
		i = screenfull.isFullscreen, i ? c.addClass("icon-resize-small").removeClass("icon-resize-full") : c.addClass("icon-resize-full").removeClass("icon-resize-small");
	})), e.on("click", function () {
		b.SettingsController.show();
	}), f.on("click", function () {
		var a = b.book.getCurrentLocationCfi();b.isBookmarked(a) === -1 ? (b.addBookmark(a), f.addClass("icon-bookmark").removeClass("icon-bookmark-empty")) : (b.removeBookmark(a), f.removeClass("icon-bookmark").addClass("icon-bookmark-empty"));
	}), a.on("renderer:locationChanged", function (a) {
		var c = "#" + a;b.isBookmarked(a) === -1 ? f.removeClass("icon-bookmark").addClass("icon-bookmark-empty") : f.addClass("icon-bookmark").removeClass("icon-bookmark-empty"), b.currentLocationCfi = a, b.settings.history && window.location.hash != c && history.pushState({}, "", c);
	}), a.on("book:pageChanged", function (a) {}), {};
}, EPUBJS.reader.MetaController = function (a) {
	var b = a.bookTitle,
	    c = a.creator,
	    d = $("#book-title"),
	    e = $("#chapter-title"),
	    f = $("#title-seperator");document.title = b + "  " + c, d.html(b), e.html(c), f.show();
}, EPUBJS.reader.NotesController = function () {
	var a = this.book,
	    b = this,
	    c = $("#notesView"),
	    d = $("#notes"),
	    e = $("#note-text"),
	    f = $("#note-anchor"),
	    g = b.settings.annotations,
	    h = a.renderer,
	    i = [],
	    j = new EPUBJS.EpubCFI(),
	    k = function k() {
		c.show();
	},
	    l = function l() {
		c.hide();
	},
	    m = function m(c) {
		var d,
		    g,
		    h,
		    i,
		    k,
		    l = a.renderer.doc;if (l.caretPositionFromPoint ? (d = l.caretPositionFromPoint(c.clientX, c.clientY), g = d.offsetNode, h = d.offset) : l.caretRangeFromPoint && (d = l.caretRangeFromPoint(c.clientX, c.clientY), g = d.startContainer, h = d.startOffset), 3 !== g.nodeType) for (var p = 0; p < g.childNodes.length; p++) {
			if (3 == g.childNodes[p].nodeType) {
				g = g.childNodes[p];break;
			}
		}h = g.textContent.indexOf(".", h), h === -1 ? h = g.length : h += 1, i = j.generateCfiFromTextNode(g, h, a.renderer.currentChapter.cfiBase), k = { annotatedAt: new Date(), anchor: i, body: e.val() }, b.addNote(k), n(k), o(k), e.val(""), f.text("Attach"), e.prop("disabled", !1), a.off("renderer:click", m);
	},
	    n = function n(b) {
		var c = document.createElement("li"),
		    e = document.createElement("a");c.innerHTML = b.body, e.innerHTML = " context &#187;", e.href = "#" + b.anchor, e.onclick = function () {
			return a.gotoCfi(b.anchor), !1;
		}, c.appendChild(e), d.append(c);
	},
	    o = function o(b) {
		var c = a.renderer.doc,
		    d = document.createElement("span"),
		    e = document.createElement("a");d.classList.add("footnotesuperscript", "reader_generated"), d.style.verticalAlign = "super", d.style.fontSize = ".75em", d.style.lineHeight = "1em", e.style.padding = "2px", e.style.backgroundColor = "#fffa96", e.style.borderRadius = "5px", e.style.cursor = "pointer", d.id = "note-" + EPUBJS.core.uuid(), e.innerHTML = g.indexOf(b) + 1 + "[Reader]", d.appendChild(e), j.addMarker(b.anchor, c, d), p(d, b.body);
	},
	    p = function p(a, c) {
		var d = a.id,
		    e = function e() {
			var b,
			    e,
			    k,
			    l,
			    m = h.height,
			    n = h.width,
			    o = 225;i[d] || (i[d] = document.createElement("div"), i[d].setAttribute("class", "popup"), pop_content = document.createElement("div"), i[d].appendChild(pop_content), pop_content.innerHTML = c, pop_content.setAttribute("class", "pop_content"), h.render.document.body.appendChild(i[d]), i[d].addEventListener("mouseover", f, !1), i[d].addEventListener("mouseout", g, !1), h.on("renderer:locationChanged", j, this), h.on("renderer:locationChanged", g, this)), b = i[d], e = a.getBoundingClientRect(), k = e.left, l = e.top, b.classList.add("show"), popRect = b.getBoundingClientRect(), b.style.left = k - popRect.width / 2 + "px", b.style.top = l + "px", o > m / 2.5 && (o = m / 2.5, pop_content.style.maxHeight = o + "px"), popRect.height + l >= m - 25 ? (b.style.top = l - popRect.height + "px", b.classList.add("above")) : b.classList.remove("above"), k - popRect.width <= 0 ? (b.style.left = k + "px", b.classList.add("left")) : b.classList.remove("left"), k + popRect.width / 2 >= n ? (b.style.left = k - 300 + "px", popRect = b.getBoundingClientRect(), b.style.left = k - popRect.width + "px", popRect.height + l >= m - 25 ? (b.style.top = l - popRect.height + "px", b.classList.add("above")) : b.classList.remove("above"), b.classList.add("right")) : b.classList.remove("right");
		},
		    f = function f() {
			i[d].classList.add("on");
		},
		    g = function g() {
			i[d].classList.remove("on");
		},
		    j = function j() {
			setTimeout(function () {
				i[d].classList.remove("show");
			}, 100);
		},
		    l = function l() {
			b.ReaderController.slideOut(), k();
		};a.addEventListener("mouseover", e, !1), a.addEventListener("mouseout", j, !1), a.addEventListener("click", l, !1);
	};return f.on("click", function (b) {
		f.text("Cancel"), e.prop("disabled", "true"), a.on("renderer:click", m);
	}), g.forEach(function (a) {
		n(a);
	}), h.registerHook("beforeChapterDisplay", function (a, b) {
		var c = b.currentChapter;g.forEach(function (a) {
			if (j.parse(a.anchor).spinePos === c.spinePos) try {
				o(a);
			} catch (b) {
				console.log("anchoring failed", a.anchor);
			}
		}), a();
	}, !0), { show: k, hide: l };
}, EPUBJS.reader.ReaderController = function (a) {
	var b = $("#main"),
	    c = $("#divider"),
	    d = $("#loader"),
	    e = $("#next"),
	    f = $("#prev"),
	    g = this,
	    a = this.book,
	    h = function h() {
		var c = a.getCurrentLocationCfi();g.settings.sidebarReflow ? (b.removeClass("single"), b.one("transitionend", function () {
			a.gotoCfi(c);
		})) : b.removeClass("closed");
	},
	    i = function i() {
		var c = a.getCurrentLocationCfi();g.settings.sidebarReflow ? (b.addClass("single"), b.one("transitionend", function () {
			a.gotoCfi(c);
		})) : b.addClass("closed");
	},
	    j = function j() {
		d.show(), m();
	},
	    k = function k() {
		d.hide();
	},
	    l = function l() {
		c.addClass("show");
	},
	    m = function m() {
		c.removeClass("show");
	},
	    n = !1,
	    o = function o(b) {
		37 == b.keyCode && ("rtl" === a.metadata.direction ? a.nextPage() : a.prevPage(), f.addClass("active"), n = !0, setTimeout(function () {
			n = !1, f.removeClass("active");
		}, 100), b.preventDefault()), 39 == b.keyCode && ("rtl" === a.metadata.direction ? a.prevPage() : a.nextPage(), e.addClass("active"), n = !0, setTimeout(function () {
			n = !1, e.removeClass("active");
		}, 100), b.preventDefault());
	};return document.addEventListener("keydown", o, !1), e.on("click", function (b) {
		"rtl" === a.metadata.direction ? a.prevPage() : a.nextPage(), b.preventDefault();
	}), f.on("click", function (b) {
		"rtl" === a.metadata.direction ? a.nextPage() : a.prevPage(), b.preventDefault();
	}), a.on("renderer:spreads", function (a) {
		a ? l() : m();
	}), { slideOut: i, slideIn: h, showLoader: j, hideLoader: k, showDivider: l, hideDivider: m, arrowKeys: o };
}, EPUBJS.reader.SettingsController = function () {
	var a = (this.book, this),
	    b = $("#settings-modal"),
	    c = $(".overlay"),
	    d = function d() {
		b.addClass("md-show");
	},
	    e = function e() {
		b.removeClass("md-show");
	};return $("#sidebarReflow").on("click", function () {
		a.settings.sidebarReflow = !a.settings.sidebarReflow;
	}), b.find(".closer").on("click", function () {
		e();
	}), c.on("click", function () {
		e();
	}), { show: d, hide: e };
}, EPUBJS.reader.SidebarController = function (a) {
	var b = this,
	    c = $("#sidebar"),
	    d = $("#panels"),
	    e = "Toc",
	    f = function f(a) {
		var c = a + "Controller";e != a && void 0 !== b[c] && (b[e + "Controller"].hide(), b[c].show(), e = a, d.find(".active").removeClass("active"), d.find("#show-" + a).addClass("active"));
	},
	    g = function g() {
		return e;
	},
	    h = function h() {
		b.sidebarOpen = !0, b.ReaderController.slideOut(), c.addClass("open");
	},
	    i = function i() {
		b.sidebarOpen = !1, b.ReaderController.slideIn(), c.removeClass("open");
	};return d.find(".show_view").on("click", function (a) {
		f($(this).data("view")), a.preventDefault();
	}), { show: h, hide: i, getActivePanel: g, changePanelTo: f };
}, EPUBJS.reader.TocController = function (a) {
	var b = this.book,
	    c = $("#tocView"),
	    d = document.createDocumentFragment(),
	    e = !1,
	    f = function f(a, b) {
		var c = document.createElement("ul");return b || (b = 1), a.forEach(function (a) {
			var d = document.createElement("li"),
			    e = document.createElement("a");toggle = document.createElement("a");var g;d.id = "toc-" + a.id, d.classList.add("list_item"), e.textContent = a.label, e.href = a.href, e.classList.add("toc_link"), d.appendChild(e), a.subitems.length > 0 && (b++, g = f(a.subitems, b), toggle.classList.add("toc_toggle"), d.insertBefore(toggle, e), d.appendChild(g)), c.appendChild(d);
		}), c;
	},
	    g = function g() {
		c.show();
	},
	    h = function h() {
		c.hide();
	},
	    i = function i(a) {
		var b = a.id,
		    d = c.find("#toc-" + b),
		    f = c.find(".currentChapter");c.find(".openChapter");d.length && (d != f && d.has(e).length > 0 && f.removeClass("currentChapter"), d.addClass("currentChapter"), d.parents("li").addClass("openChapter"));
	};b.on("renderer:chapterDisplayed", i);var j = f(a);return d.appendChild(j), c.append(d), c.find(".toc_link").on("click", function (a) {
		var d = this.getAttribute("href");a.preventDefault(), b.goto(d), c.find(".currentChapter").addClass("openChapter").removeClass("currentChapter"), $(this).parent("li").addClass("currentChapter");
	}), c.find(".toc_toggle").on("click", function (a) {
		var b = $(this).parent("li"),
		    c = b.hasClass("openChapter");a.preventDefault(), c ? b.removeClass("openChapter") : b.addClass("openChapter");
	}), { show: g, hide: h };
};

/*
 * Custom
 */

/*!
 * fullPage 2.9.6
 * https://github.com/alvarotrigo/fullPage.js
 * @license MIT licensed
 *
 * Copyright (C) 2015 alvarotrigo.com - A project by Alvaro Trigo
 */
(function (global, factory) {
	'use strict';

	if (typeof define === 'function' && define.amd) {
		define(['jquery'], function ($) {
			return factory($, global, global.document, global.Math);
		});
	} else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && exports) {
		module.exports = factory(require('jquery'), global, global.document, global.Math);
	} else {
		factory(jQuery, global, global.document, global.Math);
	}
})(typeof window !== 'undefined' ? window : this, function ($, window, document, Math, undefined) {
	'use strict';

	// keeping central set of classnames and selectors

	var WRAPPER = 'fullpage-wrapper';
	var WRAPPER_SEL = '.' + WRAPPER;

	// slimscroll
	var SCROLLABLE = 'fp-scrollable';
	var SCROLLABLE_SEL = '.' + SCROLLABLE;

	// util
	var RESPONSIVE = 'fp-responsive';
	var NO_TRANSITION = 'fp-notransition';
	var DESTROYED = 'fp-destroyed';
	var ENABLED = 'fp-enabled';
	var VIEWING_PREFIX = 'fp-viewing';
	var ACTIVE = 'active';
	var ACTIVE_SEL = '.' + ACTIVE;
	var COMPLETELY = 'fp-completely';
	var COMPLETELY_SEL = '.' + COMPLETELY;

	// section
	var SECTION_DEFAULT_SEL = '.section';
	var SECTION = 'fp-section';
	var SECTION_SEL = '.' + SECTION;
	var SECTION_ACTIVE_SEL = SECTION_SEL + ACTIVE_SEL;
	var SECTION_FIRST_SEL = SECTION_SEL + ':first';
	var SECTION_LAST_SEL = SECTION_SEL + ':last';
	var TABLE_CELL = 'fp-tableCell';
	var TABLE_CELL_SEL = '.' + TABLE_CELL;
	var AUTO_HEIGHT = 'fp-auto-height';
	var AUTO_HEIGHT_SEL = '.fp-auto-height';
	var NORMAL_SCROLL = 'fp-normal-scroll';
	var NORMAL_SCROLL_SEL = '.fp-normal-scroll';

	// section nav
	var SECTION_NAV = 'fp-nav';
	var SECTION_NAV_SEL = '#' + SECTION_NAV;
	var SECTION_NAV_TOOLTIP = 'fp-tooltip';
	var SECTION_NAV_TOOLTIP_SEL = '.' + SECTION_NAV_TOOLTIP;
	var SHOW_ACTIVE_TOOLTIP = 'fp-show-active';

	// slide
	var SLIDE_DEFAULT_SEL = '.slide';
	var SLIDE = 'fp-slide';
	var SLIDE_SEL = '.' + SLIDE;
	var SLIDE_ACTIVE_SEL = SLIDE_SEL + ACTIVE_SEL;
	var SLIDES_WRAPPER = 'fp-slides';
	var SLIDES_WRAPPER_SEL = '.' + SLIDES_WRAPPER;
	var SLIDES_CONTAINER = 'fp-slidesContainer';
	var SLIDES_CONTAINER_SEL = '.' + SLIDES_CONTAINER;
	var TABLE = 'fp-table';

	// slide nav
	var SLIDES_NAV = 'fp-slidesNav';
	var SLIDES_NAV_SEL = '.' + SLIDES_NAV;
	var SLIDES_NAV_LINK_SEL = SLIDES_NAV_SEL + ' a';
	var SLIDES_ARROW = 'fp-controlArrow';
	var SLIDES_ARROW_SEL = '.' + SLIDES_ARROW;
	var SLIDES_PREV = 'fp-prev';
	var SLIDES_PREV_SEL = '.' + SLIDES_PREV;
	var SLIDES_ARROW_PREV = SLIDES_ARROW + ' ' + SLIDES_PREV;
	var SLIDES_ARROW_PREV_SEL = SLIDES_ARROW_SEL + SLIDES_PREV_SEL;
	var SLIDES_NEXT = 'fp-next';
	var SLIDES_NEXT_SEL = '.' + SLIDES_NEXT;
	var SLIDES_ARROW_NEXT = SLIDES_ARROW + ' ' + SLIDES_NEXT;
	var SLIDES_ARROW_NEXT_SEL = SLIDES_ARROW_SEL + SLIDES_NEXT_SEL;

	var $window = $(window);
	var $document = $(document);

	$.fn.fullpage = function (options) {
		//only once my friend!
		if ($('html').hasClass(ENABLED)) {
			displayWarnings();return;
		}

		// common jQuery objects
		var $htmlBody = $('html, body');
		var $body = $('body');

		var FP = $.fn.fullpage;

		// Creating some defaults, extending them with any options that were provided
		options = $.extend({
			//navigation
			menu: false,
			anchors: [],
			lockAnchors: false,
			navigation: false,
			navigationPosition: 'right',
			navigationTooltips: [],
			showActiveTooltip: false,
			slidesNavigation: false,
			slidesNavPosition: 'bottom',
			scrollBar: false,
			hybrid: false,

			//scrolling
			css3: true,
			scrollingSpeed: 700,
			autoScrolling: true,
			fitToSection: true,
			fitToSectionDelay: 1000,
			easing: 'easeInOutCubic',
			easingcss3: 'ease',
			loopBottom: false,
			loopTop: false,
			loopHorizontal: true,
			continuousVertical: false,
			continuousHorizontal: false,
			scrollHorizontally: false,
			interlockedSlides: false,
			dragAndMove: false,
			offsetSections: false,
			resetSliders: false,
			fadingEffect: false,
			normalScrollElements: null,
			scrollOverflow: false,
			scrollOverflowReset: false,
			scrollOverflowHandler: $.fn.fp_scrolloverflow ? $.fn.fp_scrolloverflow.iscrollHandler : null,
			scrollOverflowOptions: null,
			touchSensitivity: 5,
			normalScrollElementTouchThreshold: 5,
			bigSectionsDestination: null,

			//Accessibility
			keyboardScrolling: true,
			animateAnchor: true,
			recordHistory: true,

			//design
			controlArrows: true,
			controlArrowColor: '#fff',
			verticalCentered: true,
			sectionsColor: [],
			paddingTop: 0,
			paddingBottom: 0,
			fixedElements: null,
			responsive: 0, //backwards compabitility with responsiveWiddth
			responsiveWidth: 0,
			responsiveHeight: 0,
			responsiveSlides: false,
			parallax: false,
			parallaxOptions: {
				type: 'reveal',
				percentage: 62,
				property: 'translate'
			},

			//Custom selectors
			sectionSelector: SECTION_DEFAULT_SEL,
			slideSelector: SLIDE_DEFAULT_SEL,

			//events
			afterLoad: null,
			onLeave: null,
			afterRender: null,
			afterResize: null,
			afterReBuild: null,
			afterSlideLoad: null,
			onSlideLeave: null,
			afterResponsive: null,

			lazyLoading: true
		}, options);

		//flag to avoid very fast sliding for landscape sliders
		var slideMoving = false;

		var isTouchDevice = navigator.userAgent.match(/(iPhone|iPod|iPad|Android|playbook|silk|BlackBerry|BB10|Windows Phone|Tizen|Bada|webOS|IEMobile|Opera Mini)/);
		var isTouch = 'ontouchstart' in window || navigator.msMaxTouchPoints > 0 || navigator.maxTouchPoints;
		var container = $(this);
		var windowsHeight = $window.height();
		var isResizing = false;
		var isWindowFocused = true;
		var lastScrolledDestiny;
		var lastScrolledSlide;
		var canScroll = true;
		var scrollings = [];
		var controlPressed;
		var startingSection;
		var isScrollAllowed = {};
		isScrollAllowed.m = { 'up': true, 'down': true, 'left': true, 'right': true };
		isScrollAllowed.k = $.extend(true, {}, isScrollAllowed.m);
		var MSPointer = getMSPointer();
		var events = {
			touchmove: 'ontouchmove' in window ? 'touchmove' : MSPointer.move,
			touchstart: 'ontouchstart' in window ? 'touchstart' : MSPointer.down
		};
		var scrollBarHandler;

		// taken from https://github.com/udacity/ud891/blob/gh-pages/lesson2-focus/07-modals-and-keyboard-traps/solution/modal.js
		var focusableElementsString = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex="0"], [contenteditable]';

		//timeouts
		var resizeId;
		var afterSectionLoadsId;
		var afterSlideLoadsId;
		var scrollId;
		var scrollId2;
		var keydownId;
		var originals = $.extend(true, {}, options); //deep copy

		displayWarnings();

		//easeInOutCubic animation included in the plugin
		$.extend($.easing, { easeInOutCubic: function easeInOutCubic(x, t, b, c, d) {
				if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;return c / 2 * ((t -= 2) * t * t + 2) + b;
			} });

		/**
  * Sets the autoScroll option.
  * It changes the scroll bar visibility and the history of the site as a result.
  */
		function setAutoScrolling(value, type) {
			//removing the transformation
			if (!value) {
				silentScroll(0);
			}

			setVariableState('autoScrolling', value, type);

			var element = $(SECTION_ACTIVE_SEL);

			if (options.autoScrolling && !options.scrollBar) {
				$htmlBody.css({
					'overflow': 'hidden',
					'height': '100%'
				});

				setRecordHistory(originals.recordHistory, 'internal');

				//for IE touch devices
				container.css({
					'-ms-touch-action': 'none',
					'touch-action': 'none'
				});

				if (element.length) {
					//moving the container up
					silentScroll(element.position().top);
				}
			} else {
				$htmlBody.css({
					'overflow': 'visible',
					'height': 'initial'
				});

				setRecordHistory(false, 'internal');

				//for IE touch devices
				container.css({
					'-ms-touch-action': '',
					'touch-action': ''
				});

				//scrolling the page to the section with no animation
				if (element.length) {
					$htmlBody.scrollTop(element.position().top);
				}
			}
		}

		/**
  * Defines wheter to record the history for each hash change in the URL.
  */
		function setRecordHistory(value, type) {
			setVariableState('recordHistory', value, type);
		}

		/**
  * Defines the scrolling speed
  */
		function setScrollingSpeed(value, type) {
			setVariableState('scrollingSpeed', value, type);
		}

		/**
  * Sets fitToSection
  */
		function setFitToSection(value, type) {
			setVariableState('fitToSection', value, type);
		}

		/**
  * Sets lockAnchors
  */
		function setLockAnchors(value) {
			options.lockAnchors = value;
		}

		/**
  * Adds or remove the possibility of scrolling through sections by using the mouse wheel or the trackpad.
  */
		function setMouseWheelScrolling(value) {
			if (value) {
				addMouseWheelHandler();
				addMiddleWheelHandler();
			} else {
				removeMouseWheelHandler();
				removeMiddleWheelHandler();
			}
		}

		/**
  * Adds or remove the possibility of scrolling through sections by using the mouse wheel/trackpad or touch gestures.
  * Optionally a second parameter can be used to specify the direction for which the action will be applied.
  *
  * @param directions string containing the direction or directions separated by comma.
  */
		function setAllowScrolling(value, directions) {
			if (typeof directions !== 'undefined') {
				directions = directions.replace(/ /g, '').split(',');

				$.each(directions, function (index, direction) {
					setIsScrollAllowed(value, direction, 'm');
				});
			} else {
				setIsScrollAllowed(value, 'all', 'm');

				if (value) {
					setMouseWheelScrolling(true);
					addTouchHandler();
				} else {
					setMouseWheelScrolling(false);
					removeTouchHandler();
				}
			}
		}

		/**
  * Adds or remove the possibility of scrolling through sections by using the keyboard arrow keys
  */
		function setKeyboardScrolling(value, directions) {
			if (typeof directions !== 'undefined') {
				directions = directions.replace(/ /g, '').split(',');

				$.each(directions, function (index, direction) {
					setIsScrollAllowed(value, direction, 'k');
				});
			} else {
				setIsScrollAllowed(value, 'all', 'k');
				options.keyboardScrolling = value;
			}
		}

		/**
  * Moves the page up one section.
  */
		function moveSectionUp() {
			var prev = $(SECTION_ACTIVE_SEL).prev(SECTION_SEL);

			//looping to the bottom if there's no more sections above
			if (!prev.length && (options.loopTop || options.continuousVertical)) {
				prev = $(SECTION_SEL).last();
			}

			if (prev.length) {
				scrollPage(prev, null, true);
			}
		}

		/**
  * Moves the page down one section.
  */
		function moveSectionDown() {
			var next = $(SECTION_ACTIVE_SEL).next(SECTION_SEL);

			//looping to the top if there's no more sections below
			if (!next.length && (options.loopBottom || options.continuousVertical)) {
				next = $(SECTION_SEL).first();
			}

			if (next.length) {
				scrollPage(next, null, false);
			}
		}

		/**
  * Moves the page to the given section and slide with no animation.
  * Anchors or index positions can be used as params.
  */
		function silentMoveTo(sectionAnchor, slideAnchor) {
			setScrollingSpeed(0, 'internal');
			moveTo(sectionAnchor, slideAnchor);
			setScrollingSpeed(originals.scrollingSpeed, 'internal');
		}

		/**
  * Moves the page to the given section and slide.
  * Anchors or index positions can be used as params.
  */
		function moveTo(sectionAnchor, slideAnchor) {
			var destiny = getSectionByAnchor(sectionAnchor);

			if (typeof slideAnchor !== 'undefined') {
				scrollPageAndSlide(sectionAnchor, slideAnchor);
			} else if (destiny.length > 0) {
				scrollPage(destiny);
			}
		}

		/**
  * Slides right the slider of the active section.
  * Optional `section` param.
  */
		function moveSlideRight(section) {
			moveSlide('right', section);
		}

		/**
  * Slides left the slider of the active section.
  * Optional `section` param.
  */
		function moveSlideLeft(section) {
			moveSlide('left', section);
		}

		/**
   * When resizing is finished, we adjust the slides sizes and positions
   */
		function reBuild(resizing) {
			if (container.hasClass(DESTROYED)) {
				return;
			} //nothing to do if the plugin was destroyed

			isResizing = true;

			windowsHeight = $window.height(); //updating global var

			$(SECTION_SEL).each(function () {
				var slidesWrap = $(this).find(SLIDES_WRAPPER_SEL);
				var slides = $(this).find(SLIDE_SEL);

				//adjusting the height of the table-cell for IE and Firefox
				if (options.verticalCentered) {
					$(this).find(TABLE_CELL_SEL).css('height', getTableHeight($(this)) + 'px');
				}

				$(this).css('height', windowsHeight + 'px');

				//adjusting the position fo the FULL WIDTH slides...
				if (slides.length > 1) {
					landscapeScroll(slidesWrap, slidesWrap.find(SLIDE_ACTIVE_SEL));
				}
			});

			if (options.scrollOverflow) {
				scrollBarHandler.createScrollBarForAll();
			}

			var activeSection = $(SECTION_ACTIVE_SEL);
			var sectionIndex = activeSection.index(SECTION_SEL);

			//isn't it the first section?
			if (sectionIndex) {
				//adjusting the position for the current section
				silentMoveTo(sectionIndex + 1);
			}

			isResizing = false;
			$.isFunction(options.afterResize) && resizing && options.afterResize.call(container);
			$.isFunction(options.afterReBuild) && !resizing && options.afterReBuild.call(container);
		}

		/**
  * Turns fullPage.js to normal scrolling mode when the viewport `width` or `height`
  * are smaller than the set limit values.
  */
		function setResponsive(active) {
			var isResponsive = $body.hasClass(RESPONSIVE);

			if (active) {
				if (!isResponsive) {
					setAutoScrolling(false, 'internal');
					setFitToSection(false, 'internal');
					$(SECTION_NAV_SEL).hide();
					$body.addClass(RESPONSIVE);
					$.isFunction(options.afterResponsive) && options.afterResponsive.call(container, active);
				}
			} else if (isResponsive) {
				setAutoScrolling(originals.autoScrolling, 'internal');
				setFitToSection(originals.autoScrolling, 'internal');
				$(SECTION_NAV_SEL).show();
				$body.removeClass(RESPONSIVE);
				$.isFunction(options.afterResponsive) && options.afterResponsive.call(container, active);
			}
		}

		if ($(this).length) {
			//public functions
			FP.version = '2.9.5';
			FP.setAutoScrolling = setAutoScrolling;
			FP.setRecordHistory = setRecordHistory;
			FP.setScrollingSpeed = setScrollingSpeed;
			FP.setFitToSection = setFitToSection;
			FP.setLockAnchors = setLockAnchors;
			FP.setMouseWheelScrolling = setMouseWheelScrolling;
			FP.setAllowScrolling = setAllowScrolling;
			FP.setKeyboardScrolling = setKeyboardScrolling;
			FP.moveSectionUp = moveSectionUp;
			FP.moveSectionDown = moveSectionDown;
			FP.silentMoveTo = silentMoveTo;
			FP.moveTo = moveTo;
			FP.moveSlideRight = moveSlideRight;
			FP.moveSlideLeft = moveSlideLeft;
			FP.fitToSection = fitToSection;
			FP.reBuild = reBuild;
			FP.setResponsive = setResponsive;
			FP.destroy = destroy;

			//functions we want to share across files but which are not
			//mean to be used on their own by developers
			FP.shared = {
				afterRenderActions: afterRenderActions
			};

			init();

			bindEvents();
		}

		function init() {
			//if css3 is not supported, it will use jQuery animations
			if (options.css3) {
				options.css3 = support3d();
			}

			options.scrollBar = options.scrollBar || options.hybrid;

			setOptionsFromDOM();
			prepareDom();
			setAllowScrolling(true);
			setAutoScrolling(options.autoScrolling, 'internal');
			responsive();

			//setting the class for the body element
			setBodyClass();

			if (document.readyState === 'complete') {
				scrollToAnchor();
			}
			$window.on('load', scrollToAnchor);
		}

		function bindEvents() {
			$window
			//when scrolling...
			.on('scroll', scrollHandler)

			//detecting any change on the URL to scroll to the given anchor link
			//(a way to detect back history button as we play with the hashes on the URL)
			.on('hashchange', hashChangeHandler)

			//when opening a new tab (ctrl + t), `control` won't be pressed when coming back.
			.blur(blurHandler)

			//when resizing the site, we adjust the heights of the sections, slimScroll...
			.resize(resizeHandler);

			$document
			//Sliding with arrow keys, both, vertical and horizontal
			.keydown(keydownHandler)

			//to prevent scrolling while zooming
			.keyup(keyUpHandler)

			//Scrolls to the section when clicking the navigation bullet
			.on('click touchstart', SECTION_NAV_SEL + ' a', sectionBulletHandler)

			//Scrolls the slider to the given slide destination for the given section
			.on('click touchstart', SLIDES_NAV_LINK_SEL, slideBulletHandler).on('click', SECTION_NAV_TOOLTIP_SEL, tooltipTextHandler);

			//Scrolling horizontally when clicking on the slider controls.
			$(SECTION_SEL).on('click touchstart', SLIDES_ARROW_SEL, slideArrowHandler);

			/**
   * Applying normalScroll elements.
   * Ignoring the scrolls over the specified selectors.
   */
			if (options.normalScrollElements) {
				$document.on('mouseenter touchstart', options.normalScrollElements, function () {
					setAllowScrolling(false);
				});

				$document.on('mouseleave touchend', options.normalScrollElements, function () {
					setAllowScrolling(true);
				});
			}
		}

		/**
  * Setting options from DOM elements if they are not provided.
  */
		function setOptionsFromDOM() {
			var sections = container.find(options.sectionSelector);

			//no anchors option? Checking for them in the DOM attributes
			if (!options.anchors.length) {
				options.anchors = sections.filter('[data-anchor]').map(function () {
					return $(this).data('anchor').toString();
				}).get();
			}

			//no tooltips option? Checking for them in the DOM attributes
			if (!options.navigationTooltips.length) {
				options.navigationTooltips = sections.filter('[data-tooltip]').map(function () {
					return $(this).data('tooltip').toString();
				}).get();
			}
		}

		/**
  * Works over the DOM structure to set it up for the current fullpage options.
  */
		function prepareDom() {
			container.css({
				'height': '100%',
				'position': 'relative'
			});

			//adding a class to recognize the container internally in the code
			container.addClass(WRAPPER);
			$('html').addClass(ENABLED);

			//due to https://github.com/alvarotrigo/fullPage.js/issues/1502
			windowsHeight = $window.height();

			container.removeClass(DESTROYED); //in case it was destroyed before initializing it again

			addInternalSelectors();

			//styling the sections / slides / menu
			$(SECTION_SEL).each(function (index) {
				var section = $(this);
				var slides = section.find(SLIDE_SEL);
				var numSlides = slides.length;

				//caching the original styles to add them back on destroy('all')
				section.data('fp-styles', section.attr('style'));

				styleSection(section, index);
				styleMenu(section, index);

				// if there's any slide
				if (numSlides > 0) {
					styleSlides(section, slides, numSlides);
				} else {
					if (options.verticalCentered) {
						addTableClass(section);
					}
				}
			});

			//fixed elements need to be moved out of the plugin container due to problems with CSS3.
			if (options.fixedElements && options.css3) {
				$(options.fixedElements).appendTo($body);
			}

			//vertical centered of the navigation + active bullet
			if (options.navigation) {
				addVerticalNavigation();
			}

			enableYoutubeAPI();

			if (options.scrollOverflow) {
				scrollBarHandler = options.scrollOverflowHandler.init(options);
			} else {
				afterRenderActions();
			}
		}

		/**
  * Styles the horizontal slides for a section.
  */
		function styleSlides(section, slides, numSlides) {
			var sliderWidth = numSlides * 100;
			var slideWidth = 100 / numSlides;

			slides.wrapAll('<div class="' + SLIDES_CONTAINER + '" />');
			slides.parent().wrap('<div class="' + SLIDES_WRAPPER + '" />');

			section.find(SLIDES_CONTAINER_SEL).css('width', sliderWidth + '%');

			if (numSlides > 1) {
				if (options.controlArrows) {
					createSlideArrows(section);
				}

				if (options.slidesNavigation) {
					addSlidesNavigation(section, numSlides);
				}
			}

			slides.each(function (index) {
				$(this).css('width', slideWidth + '%');

				if (options.verticalCentered) {
					addTableClass($(this));
				}
			});

			var startingSlide = section.find(SLIDE_ACTIVE_SEL);

			//if the slide won't be an starting point, the default will be the first one
			//the active section isn't the first one? Is not the first slide of the first section? Then we load that section/slide by default.
			if (startingSlide.length && ($(SECTION_ACTIVE_SEL).index(SECTION_SEL) !== 0 || $(SECTION_ACTIVE_SEL).index(SECTION_SEL) === 0 && startingSlide.index() !== 0)) {
				silentLandscapeScroll(startingSlide, 'internal');
			} else {
				slides.eq(0).addClass(ACTIVE);
			}
		}

		/**
  * Styling vertical sections
  */
		function styleSection(section, index) {
			//if no active section is defined, the 1st one will be the default one
			if (!index && $(SECTION_ACTIVE_SEL).length === 0) {
				section.addClass(ACTIVE);
			}
			startingSection = $(SECTION_ACTIVE_SEL);

			section.css('height', windowsHeight + 'px');

			if (options.paddingTop) {
				section.css('padding-top', options.paddingTop);
			}

			if (options.paddingBottom) {
				section.css('padding-bottom', options.paddingBottom);
			}

			if (typeof options.sectionsColor[index] !== 'undefined') {
				section.css('background-color', options.sectionsColor[index]);
			}

			if (typeof options.anchors[index] !== 'undefined') {
				section.attr('data-anchor', options.anchors[index]);
			}
		}

		/**
  * Sets the data-anchor attributes to the menu elements and activates the current one.
  */
		function styleMenu(section, index) {
			if (typeof options.anchors[index] !== 'undefined') {
				//activating the menu / nav element on load
				if (section.hasClass(ACTIVE)) {
					activateMenuAndNav(options.anchors[index], index);
				}
			}

			//moving the menu outside the main container if it is inside (avoid problems with fixed positions when using CSS3 tranforms)
			if (options.menu && options.css3 && $(options.menu).closest(WRAPPER_SEL).length) {
				$(options.menu).appendTo($body);
			}
		}

		/**
  * Adds internal classes to be able to provide customizable selectors
  * keeping the link with the style sheet.
  */
		function addInternalSelectors() {
			container.find(options.sectionSelector).addClass(SECTION);
			container.find(options.slideSelector).addClass(SLIDE);
		}

		/**
  * Creates the control arrows for the given section
  */
		function createSlideArrows(section) {
			section.find(SLIDES_WRAPPER_SEL).after('<div class="' + SLIDES_ARROW_PREV + '"></div><div class="' + SLIDES_ARROW_NEXT + '"></div>');

			if (options.controlArrowColor != '#fff') {
				section.find(SLIDES_ARROW_NEXT_SEL).css('border-color', 'transparent transparent transparent ' + options.controlArrowColor);
				section.find(SLIDES_ARROW_PREV_SEL).css('border-color', 'transparent ' + options.controlArrowColor + ' transparent transparent');
			}

			if (!options.loopHorizontal) {
				section.find(SLIDES_ARROW_PREV_SEL).hide();
			}
		}

		/**
  * Creates a vertical navigation bar.
  */
		function addVerticalNavigation() {
			$body.append('<div id="' + SECTION_NAV + '"><ul></ul></div>');
			var nav = $(SECTION_NAV_SEL);

			nav.addClass(function () {
				return options.showActiveTooltip ? SHOW_ACTIVE_TOOLTIP + ' ' + options.navigationPosition : options.navigationPosition;
			});

			for (var i = 0; i < $(SECTION_SEL).length; i++) {
				var link = '';
				if (options.anchors.length) {
					link = options.anchors[i];
				}

				var li = '<li><a href="#' + link + '"><span></span></a>';

				// Only add tooltip if needed (defined by user)
				var tooltip = options.navigationTooltips[i];

				if (typeof tooltip !== 'undefined' && tooltip !== '') {
					li += '<div class="' + SECTION_NAV_TOOLTIP + ' ' + options.navigationPosition + '">' + tooltip + '</div>';
				}

				li += '</li>';

				nav.find('ul').append(li);
			}

			//centering it vertically
			$(SECTION_NAV_SEL).css('margin-top', '-' + $(SECTION_NAV_SEL).height() / 2 + 'px');

			//activating the current active section
			$(SECTION_NAV_SEL).find('li').eq($(SECTION_ACTIVE_SEL).index(SECTION_SEL)).find('a').addClass(ACTIVE);
		}

		/*
  * Enables the Youtube videos API so we can control their flow if necessary.
  */
		function enableYoutubeAPI() {
			container.find('iframe[src*="youtube.com/embed/"]').each(function () {
				addURLParam($(this), 'enablejsapi=1');
			});
		}

		/**
  * Adds a new parameter and its value to the `src` of a given element
  */
		function addURLParam(element, newParam) {
			var originalSrc = element.attr('src');
			element.attr('src', originalSrc + getUrlParamSign(originalSrc) + newParam);
		}

		/*
  * Returns the prefix sign to use for a new parameter in an existen URL.
  *
  * @return {String}  ? | &
  */
		function getUrlParamSign(url) {
			return !/\?/.test(url) ? '?' : '&';
		}

		/**
  * Actions and callbacks to fire afterRender
  */
		function afterRenderActions() {
			var section = $(SECTION_ACTIVE_SEL);

			section.addClass(COMPLETELY);

			lazyLoad(section);
			playMedia(section);

			if (options.scrollOverflow) {
				options.scrollOverflowHandler.afterLoad();
			}

			if (isDestinyTheStartingSection()) {
				$.isFunction(options.afterLoad) && options.afterLoad.call(section, section.data('anchor'), section.index(SECTION_SEL) + 1);
			}

			$.isFunction(options.afterRender) && options.afterRender.call(container);
		}

		/**
  * Determines if the URL anchor destiny is the starting section (the one using 'active' class before initialization)
  */
		function isDestinyTheStartingSection() {
			var destinationSection = getSectionByAnchor(getAnchorsURL().section);
			return !destinationSection || destinationSection.length && destinationSection.index() === startingSection.index();
		}

		var isScrolling = false;
		var lastScroll = 0;

		//when scrolling...
		function scrollHandler() {
			var currentSection;

			if (!options.autoScrolling || options.scrollBar) {
				var currentScroll = $window.scrollTop();
				var scrollDirection = getScrollDirection(currentScroll);
				var visibleSectionIndex = 0;
				var screen_mid = currentScroll + $window.height() / 2.0;
				var isAtBottom = $body.height() - $window.height() === currentScroll;
				var sections = document.querySelectorAll(SECTION_SEL);

				//when using `auto-height` for a small last section it won't be centered in the viewport
				if (isAtBottom) {
					visibleSectionIndex = sections.length - 1;
				}
				//is at top? when using `auto-height` for a small first section it won't be centered in the viewport
				else if (!currentScroll) {
						visibleSectionIndex = 0;
					}

					//taking the section which is showing more content in the viewport
					else {
							for (var i = 0; i < sections.length; ++i) {
								var section = sections[i];

								// Pick the the last section which passes the middle line of the screen.
								if (section.offsetTop <= screen_mid) {
									visibleSectionIndex = i;
								}
							}
						}

				if (isCompletelyInViewPort(scrollDirection)) {
					if (!$(SECTION_ACTIVE_SEL).hasClass(COMPLETELY)) {
						$(SECTION_ACTIVE_SEL).addClass(COMPLETELY).siblings().removeClass(COMPLETELY);
					}
				}

				//geting the last one, the current one on the screen
				currentSection = $(sections).eq(visibleSectionIndex);

				//setting the visible section as active when manually scrolling
				//executing only once the first time we reach the section
				if (!currentSection.hasClass(ACTIVE)) {
					isScrolling = true;
					var leavingSection = $(SECTION_ACTIVE_SEL);
					var leavingSectionIndex = leavingSection.index(SECTION_SEL) + 1;
					var yMovement = getYmovement(currentSection);
					var anchorLink = currentSection.data('anchor');
					var sectionIndex = currentSection.index(SECTION_SEL) + 1;
					var activeSlide = currentSection.find(SLIDE_ACTIVE_SEL);
					var slideIndex;
					var slideAnchorLink;

					if (activeSlide.length) {
						slideAnchorLink = activeSlide.data('anchor');
						slideIndex = activeSlide.index();
					}

					if (canScroll) {
						currentSection.addClass(ACTIVE).siblings().removeClass(ACTIVE);

						$.isFunction(options.onLeave) && options.onLeave.call(leavingSection, leavingSectionIndex, sectionIndex, yMovement);
						$.isFunction(options.afterLoad) && options.afterLoad.call(currentSection, anchorLink, sectionIndex);

						stopMedia(leavingSection);
						lazyLoad(currentSection);
						playMedia(currentSection);

						activateMenuAndNav(anchorLink, sectionIndex - 1);

						if (options.anchors.length) {
							//needed to enter in hashChange event when using the menu with anchor links
							lastScrolledDestiny = anchorLink;
						}
						setState(slideIndex, slideAnchorLink, anchorLink, sectionIndex);
					}

					//small timeout in order to avoid entering in hashChange event when scrolling is not finished yet
					clearTimeout(scrollId);
					scrollId = setTimeout(function () {
						isScrolling = false;
					}, 100);
				}

				if (options.fitToSection) {
					//for the auto adjust of the viewport to fit a whole section
					clearTimeout(scrollId2);

					scrollId2 = setTimeout(function () {
						//checking it again in case it changed during the delay
						if (options.fitToSection &&

						//is the destination element bigger than the viewport?
						$(SECTION_ACTIVE_SEL).outerHeight() <= windowsHeight) {
							fitToSection();
						}
					}, options.fitToSectionDelay);
				}
			}
		}

		/**
  * Fits the site to the nearest active section
  */
		function fitToSection() {
			//checking fitToSection again in case it was set to false before the timeout delay
			if (canScroll) {
				//allows to scroll to an active section and
				//if the section is already active, we prevent firing callbacks
				isResizing = true;

				scrollPage($(SECTION_ACTIVE_SEL));
				isResizing = false;
			}
		}

		/**
  * Determines whether the active section has seen in its whole or not.
  */
		function isCompletelyInViewPort(movement) {
			var top = $(SECTION_ACTIVE_SEL).position().top;
			var bottom = top + $window.height();

			if (movement == 'up') {
				return bottom >= $window.scrollTop() + $window.height();
			}
			return top <= $window.scrollTop();
		}

		/**
  * Gets the directon of the the scrolling fired by the scroll event.
  */
		function getScrollDirection(currentScroll) {
			var direction = currentScroll > lastScroll ? 'down' : 'up';

			lastScroll = currentScroll;

			//needed for auto-height sections to determine if we want to scroll to the top or bottom of the destination
			previousDestTop = currentScroll;

			return direction;
		}

		/**
  * Determines the way of scrolling up or down:
  * by 'automatically' scrolling a section or by using the default and normal scrolling.
  */
		function scrolling(type) {
			if (!isScrollAllowed.m[type]) {
				return;
			}

			var scrollSection = type === 'down' ? moveSectionDown : moveSectionUp;

			if (options.scrollOverflow) {
				var scrollable = options.scrollOverflowHandler.scrollable($(SECTION_ACTIVE_SEL));
				var check = type === 'down' ? 'bottom' : 'top';

				if (scrollable.length > 0) {
					//is the scrollbar at the start/end of the scroll?
					if (options.scrollOverflowHandler.isScrolled(check, scrollable)) {
						scrollSection();
					} else {
						return true;
					}
				} else {
					// moved up/down
					scrollSection();
				}
			} else {
				// moved up/down
				scrollSection();
			}
		}

		/*
  * Preventing bouncing in iOS #2285
  */
		function preventBouncing(event) {
			var e = event.originalEvent;
			if (options.autoScrolling && isReallyTouch(e)) {
				//preventing the easing on iOS devices
				event.preventDefault();
			}
		}

		var touchStartY = 0;
		var touchStartX = 0;
		var touchEndY = 0;
		var touchEndX = 0;

		/* Detecting touch events
    * As we are changing the top property of the page on scrolling, we can not use the traditional way to detect it.
  * This way, the touchstart and the touch moves shows an small difference between them which is the
  * used one to determine the direction.
  */
		function touchMoveHandler(event) {
			var e = event.originalEvent;
			var activeSection = $(e.target).closest(SECTION_SEL);

			// additional: if one of the normalScrollElements isn't within options.normalScrollElementTouchThreshold hops up the DOM chain
			if (isReallyTouch(e)) {

				if (options.autoScrolling) {
					//preventing the easing on iOS devices
					event.preventDefault();
				}

				var touchEvents = getEventsPage(e);

				touchEndY = touchEvents.y;
				touchEndX = touchEvents.x;

				//if movement in the X axys is greater than in the Y and the currect section has slides...
				if (activeSection.find(SLIDES_WRAPPER_SEL).length && Math.abs(touchStartX - touchEndX) > Math.abs(touchStartY - touchEndY)) {

					//is the movement greater than the minimum resistance to scroll?
					if (!slideMoving && Math.abs(touchStartX - touchEndX) > $window.outerWidth() / 100 * options.touchSensitivity) {
						if (touchStartX > touchEndX) {
							if (isScrollAllowed.m.right) {
								moveSlideRight(activeSection); //next
							}
						} else {
							if (isScrollAllowed.m.left) {
								moveSlideLeft(activeSection); //prev
							}
						}
					}
				}

				//vertical scrolling (only when autoScrolling is enabled)
				else if (options.autoScrolling && canScroll) {

						//is the movement greater than the minimum resistance to scroll?
						if (Math.abs(touchStartY - touchEndY) > $window.height() / 100 * options.touchSensitivity) {
							if (touchStartY > touchEndY) {
								scrolling('down');
							} else if (touchEndY > touchStartY) {
								scrolling('up');
							}
						}
					}
			}
		}

		/**
  * As IE >= 10 fires both touch and mouse events when using a mouse in a touchscreen
  * this way we make sure that is really a touch event what IE is detecting.
  */
		function isReallyTouch(e) {
			//if is not IE   ||  IE is detecting `touch` or `pen`
			return typeof e.pointerType === 'undefined' || e.pointerType != 'mouse';
		}

		/**
  * Handler for the touch start event.
  */
		function touchStartHandler(event) {
			var e = event.originalEvent;

			//stopping the auto scroll to adjust to a section
			if (options.fitToSection) {
				$htmlBody.stop();
			}

			if (isReallyTouch(e)) {
				var touchEvents = getEventsPage(e);
				touchStartY = touchEvents.y;
				touchStartX = touchEvents.x;
			}
		}

		/**
  * Gets the average of the last `number` elements of the given array.
  */
		function getAverage(elements, number) {
			var sum = 0;

			//taking `number` elements from the end to make the average, if there are not enought, 1
			var lastElements = elements.slice(Math.max(elements.length - number, 1));

			for (var i = 0; i < lastElements.length; i++) {
				sum = sum + lastElements[i];
			}

			return Math.ceil(sum / number);
		}

		/**
   * Detecting mousewheel scrolling
   *
   * http://blogs.sitepointstatic.com/examples/tech/mouse-wheel/index.html
   * http://www.sitepoint.com/html5-javascript-mouse-wheel/
   */
		var prevTime = new Date().getTime();

		function MouseWheelHandler(e) {
			var curTime = new Date().getTime();
			var isNormalScroll = $(COMPLETELY_SEL).hasClass(NORMAL_SCROLL);

			//autoscrolling and not zooming?
			if (options.autoScrolling && !controlPressed && !isNormalScroll) {
				// cross-browser wheel delta
				e = e || window.event;
				var value = e.wheelDelta || -e.deltaY || -e.detail;
				var delta = Math.max(-1, Math.min(1, value));

				var horizontalDetection = typeof e.wheelDeltaX !== 'undefined' || typeof e.deltaX !== 'undefined';
				var isScrollingVertically = Math.abs(e.wheelDeltaX) < Math.abs(e.wheelDelta) || Math.abs(e.deltaX) < Math.abs(e.deltaY) || !horizontalDetection;

				//Limiting the array to 150 (lets not waste memory!)
				if (scrollings.length > 149) {
					scrollings.shift();
				}

				//keeping record of the previous scrollings
				scrollings.push(Math.abs(value));

				//preventing to scroll the site on mouse wheel when scrollbar is present
				if (options.scrollBar) {
					e.preventDefault ? e.preventDefault() : e.returnValue = false;
				}

				//time difference between the last scroll and the current one
				var timeDiff = curTime - prevTime;
				prevTime = curTime;

				//haven't they scrolled in a while?
				//(enough to be consider a different scrolling action to scroll another section)
				if (timeDiff > 200) {
					//emptying the array, we dont care about old scrollings for our averages
					scrollings = [];
				}

				if (canScroll) {
					var averageEnd = getAverage(scrollings, 10);
					var averageMiddle = getAverage(scrollings, 70);
					var isAccelerating = averageEnd >= averageMiddle;

					//to avoid double swipes...
					if (isAccelerating && isScrollingVertically) {
						//scrolling down?
						if (delta < 0) {
							scrolling('down');

							//scrolling up?
						} else {
							scrolling('up');
						}
					}
				}

				return false;
			}

			if (options.fitToSection) {
				//stopping the auto scroll to adjust to a section
				$htmlBody.stop();
			}
		}

		/**
  * Slides a slider to the given direction.
  * Optional `section` param.
  */
		function moveSlide(direction, section) {
			var activeSection = typeof section === 'undefined' ? $(SECTION_ACTIVE_SEL) : section;
			var slides = activeSection.find(SLIDES_WRAPPER_SEL);
			var numSlides = slides.find(SLIDE_SEL).length;

			// more than one slide needed and nothing should be sliding
			if (!slides.length || slideMoving || numSlides < 2) {
				return;
			}

			var currentSlide = slides.find(SLIDE_ACTIVE_SEL);
			var destiny = null;

			if (direction === 'left') {
				destiny = currentSlide.prev(SLIDE_SEL);
			} else {
				destiny = currentSlide.next(SLIDE_SEL);
			}

			//isn't there a next slide in the secuence?
			if (!destiny.length) {
				//respect loopHorizontal settin
				if (!options.loopHorizontal) return;

				if (direction === 'left') {
					destiny = currentSlide.siblings(':last');
				} else {
					destiny = currentSlide.siblings(':first');
				}
			}

			slideMoving = true;

			landscapeScroll(slides, destiny, direction);
		}

		/**
  * Maintains the active slides in the viewport
  * (Because the `scroll` animation might get lost with some actions, such as when using continuousVertical)
  */
		function keepSlidesPosition() {
			$(SLIDE_ACTIVE_SEL).each(function () {
				silentLandscapeScroll($(this), 'internal');
			});
		}

		var previousDestTop = 0;
		/**
  * Returns the destination Y position based on the scrolling direction and
  * the height of the section.
  */
		function getDestinationPosition(element) {
			var elemPosition = element.position();

			//top of the desination will be at the top of the viewport
			var position = elemPosition.top;
			var isScrollingDown = elemPosition.top > previousDestTop;
			var sectionBottom = position - windowsHeight + element.outerHeight();
			var bigSectionsDestination = options.bigSectionsDestination;

			//is the destination element bigger than the viewport?
			if (element.outerHeight() > windowsHeight) {
				//scrolling up?
				if (!isScrollingDown && !bigSectionsDestination || bigSectionsDestination === 'bottom') {
					position = sectionBottom;
				}
			}

			//sections equal or smaller than the viewport height && scrolling down? ||  is resizing and its in the last section
			else if (isScrollingDown || isResizing && element.is(':last-child')) {
					//The bottom of the destination will be at the bottom of the viewport
					position = sectionBottom;
				}

			/*
   Keeping record of the last scrolled position to determine the scrolling direction.
   No conventional methods can be used as the scroll bar might not be present
   AND the section might not be active if it is auto-height and didnt reach the middle
   of the viewport.
   */
			previousDestTop = position;
			return position;
		}

		/**
  * Scrolls the site to the given element and scrolls to the slide if a callback is given.
  */
		function scrollPage(element, callback, isMovementUp) {
			if (typeof element === 'undefined') {
				return;
			} //there's no element to scroll, leaving the function

			var dtop = getDestinationPosition(element);
			var slideAnchorLink;
			var slideIndex;

			//local variables
			var v = {
				element: element,
				callback: callback,
				isMovementUp: isMovementUp,
				dtop: dtop,
				yMovement: getYmovement(element),
				anchorLink: element.data('anchor'),
				sectionIndex: element.index(SECTION_SEL),
				activeSlide: element.find(SLIDE_ACTIVE_SEL),
				activeSection: $(SECTION_ACTIVE_SEL),
				leavingSection: $(SECTION_ACTIVE_SEL).index(SECTION_SEL) + 1,

				//caching the value of isResizing at the momment the function is called
				//because it will be checked later inside a setTimeout and the value might change
				localIsResizing: isResizing
			};

			//quiting when destination scroll is the same as the current one
			if (v.activeSection.is(element) && !isResizing || options.scrollBar && $window.scrollTop() === v.dtop && !element.hasClass(AUTO_HEIGHT)) {
				return;
			}

			if (v.activeSlide.length) {
				slideAnchorLink = v.activeSlide.data('anchor');
				slideIndex = v.activeSlide.index();
			}

			//callback (onLeave) if the site is not just resizing and readjusting the slides
			if ($.isFunction(options.onLeave) && !v.localIsResizing) {
				if (options.onLeave.call(v.activeSection, v.leavingSection, v.sectionIndex + 1, v.yMovement) === false) {
					return;
				}
			}

			// If continuousVertical && we need to wrap around
			if (options.autoScrolling && options.continuousVertical && typeof v.isMovementUp !== "undefined" && (!v.isMovementUp && v.yMovement == 'up' || // Intending to scroll down but about to go up or
			v.isMovementUp && v.yMovement == 'down')) {
				// intending to scroll up but about to go down

				v = createInfiniteSections(v);
			}

			//pausing media of the leaving section (if we are not just resizing, as destinatino will be the same one)
			if (!v.localIsResizing) {
				stopMedia(v.activeSection);
			}

			if (options.scrollOverflow) {
				options.scrollOverflowHandler.beforeLeave();
			}

			element.addClass(ACTIVE).siblings().removeClass(ACTIVE);
			lazyLoad(element);

			if (options.scrollOverflow) {
				options.scrollOverflowHandler.onLeave();
			}

			//preventing from activating the MouseWheelHandler event
			//more than once if the page is scrolling
			canScroll = false;

			setState(slideIndex, slideAnchorLink, v.anchorLink, v.sectionIndex);

			performMovement(v);

			//flag to avoid callingn `scrollPage()` twice in case of using anchor links
			lastScrolledDestiny = v.anchorLink;

			//avoid firing it twice (as it does also on scroll)
			activateMenuAndNav(v.anchorLink, v.sectionIndex);
		}

		/**
  * Performs the vertical movement (by CSS3 or by jQuery)
  */
		function performMovement(v) {
			// using CSS3 translate functionality
			if (options.css3 && options.autoScrolling && !options.scrollBar) {

				// The first section can have a negative value in iOS 10. Not quite sure why: -0.0142822265625
				// that's why we round it to 0.
				var translate3d = 'translate3d(0px, -' + Math.round(v.dtop) + 'px, 0px)';
				transformContainer(translate3d, true);

				//even when the scrollingSpeed is 0 there's a little delay, which might cause the
				//scrollingSpeed to change in case of using silentMoveTo();
				if (options.scrollingSpeed) {
					clearTimeout(afterSectionLoadsId);
					afterSectionLoadsId = setTimeout(function () {
						afterSectionLoads(v);
					}, options.scrollingSpeed);
				} else {
					afterSectionLoads(v);
				}
			}

			// using jQuery animate
			else {
					var scrollSettings = getScrollSettings(v);

					$(scrollSettings.element).animate(scrollSettings.options, options.scrollingSpeed, options.easing).promise().done(function () {
						//only one single callback in case of animating  `html, body`
						if (options.scrollBar) {

							/* Hack!
       The timeout prevents setting the most dominant section in the viewport as "active" when the user
       scrolled to a smaller section by using the mousewheel (auto scrolling) rather than draging the scroll bar.
         When using scrollBar:true It seems like the scroll events still getting propagated even after the scrolling animation has finished.
       */
							setTimeout(function () {
								afterSectionLoads(v);
							}, 30);
						} else {
							afterSectionLoads(v);
						}
					});
				}
		}

		/**
  * Gets the scrolling settings depending on the plugin autoScrolling option
  */
		function getScrollSettings(v) {
			var scroll = {};

			if (options.autoScrolling && !options.scrollBar) {
				scroll.options = { 'top': -v.dtop };
				scroll.element = WRAPPER_SEL;
			} else {
				scroll.options = { 'scrollTop': v.dtop };
				scroll.element = 'html, body';
			}

			return scroll;
		}

		/**
  * Adds sections before or after the current one to create the infinite effect.
  */
		function createInfiniteSections(v) {
			// Scrolling down
			if (!v.isMovementUp) {
				// Move all previous sections to after the active section
				$(SECTION_ACTIVE_SEL).after(v.activeSection.prevAll(SECTION_SEL).get().reverse());
			} else {
				// Scrolling up
				// Move all next sections to before the active section
				$(SECTION_ACTIVE_SEL).before(v.activeSection.nextAll(SECTION_SEL));
			}

			// Maintain the displayed position (now that we changed the element order)
			silentScroll($(SECTION_ACTIVE_SEL).position().top);

			// Maintain the active slides visible in the viewport
			keepSlidesPosition();

			// save for later the elements that still need to be reordered
			v.wrapAroundElements = v.activeSection;

			// Recalculate animation variables
			v.dtop = v.element.position().top;
			v.yMovement = getYmovement(v.element);

			//sections will temporally have another position in the DOM
			//updating this values in case we need them
			v.leavingSection = v.activeSection.index(SECTION_SEL) + 1;
			v.sectionIndex = v.element.index(SECTION_SEL);

			return v;
		}

		/**
  * Fix section order after continuousVertical changes have been animated
  */
		function continuousVerticalFixSectionOrder(v) {
			// If continuousVertical is in effect (and autoScrolling would also be in effect then),
			// finish moving the elements around so the direct navigation will function more simply
			if (!v.wrapAroundElements || !v.wrapAroundElements.length) {
				return;
			}

			if (v.isMovementUp) {
				$(SECTION_FIRST_SEL).before(v.wrapAroundElements);
			} else {
				$(SECTION_LAST_SEL).after(v.wrapAroundElements);
			}

			silentScroll($(SECTION_ACTIVE_SEL).position().top);

			// Maintain the active slides visible in the viewport
			keepSlidesPosition();
		}

		/**
  * Actions to do once the section is loaded.
  */
		function afterSectionLoads(v) {
			continuousVerticalFixSectionOrder(v);

			//callback (afterLoad) if the site is not just resizing and readjusting the slides
			$.isFunction(options.afterLoad) && !v.localIsResizing && options.afterLoad.call(v.element, v.anchorLink, v.sectionIndex + 1);

			if (options.scrollOverflow) {
				options.scrollOverflowHandler.afterLoad();
			}

			if (!v.localIsResizing) {
				playMedia(v.element);
			}

			v.element.addClass(COMPLETELY).siblings().removeClass(COMPLETELY);

			canScroll = true;

			$.isFunction(v.callback) && v.callback.call(this);
		}

		/**
  * Sets the value for the given attribute from the `data-` attribute with the same suffix
  * ie: data-srcset ==> srcset  |  data-src ==> src
  */
		function setSrc(element, attribute) {
			element.attr(attribute, element.data(attribute)).removeAttr('data-' + attribute);
		}

		/**
  * Lazy loads image, video and audio elements.
  */
		function lazyLoad(destiny) {
			if (!options.lazyLoading) {
				return;
			}

			var panel = getSlideOrSection(destiny);
			var element;

			panel.find('img[data-src], img[data-srcset], source[data-src], source[data-srcset], video[data-src], audio[data-src], iframe[data-src]').each(function () {
				element = $(this);

				$.each(['src', 'srcset'], function (index, type) {
					var attribute = element.attr('data-' + type);
					if (typeof attribute !== 'undefined' && attribute) {
						setSrc(element, type);
					}
				});

				if (element.is('source')) {
					var typeToPlay = element.closest('video').length ? 'video' : 'audio';
					element.closest(typeToPlay).get(0).load();
				}
			});
		}

		/**
  * Plays video and audio elements.
  */
		function playMedia(destiny) {
			var panel = getSlideOrSection(destiny);

			//playing HTML5 media elements
			panel.find('video, audio').each(function () {
				var element = $(this).get(0);

				if (element.hasAttribute('data-autoplay') && typeof element.play === 'function') {
					element.play();
				}
			});

			//youtube videos
			panel.find('iframe[src*="youtube.com/embed/"]').each(function () {
				var element = $(this).get(0);

				if (element.hasAttribute('data-autoplay')) {
					playYoutube(element);
				}

				//in case the URL was not loaded yet. On page load we need time for the new URL (with the API string) to load.
				element.onload = function () {
					if (element.hasAttribute('data-autoplay')) {
						playYoutube(element);
					}
				};
			});
		}

		/**
  * Plays a youtube video
  */
		function playYoutube(element) {
			element.contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', '*');
		}

		/**
  * Stops video and audio elements.
  */
		function stopMedia(destiny) {
			var panel = getSlideOrSection(destiny);

			//stopping HTML5 media elements
			panel.find('video, audio').each(function () {
				var element = $(this).get(0);

				if (!element.hasAttribute('data-keepplaying') && typeof element.pause === 'function') {
					element.pause();
				}
			});

			//youtube videos
			panel.find('iframe[src*="youtube.com/embed/"]').each(function () {
				var element = $(this).get(0);

				if (/youtube\.com\/embed\//.test($(this).attr('src')) && !element.hasAttribute('data-keepplaying')) {
					$(this).get(0).contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', '*');
				}
			});
		}

		/**
  * Gets the active slide (or section) for the given section
  */
		function getSlideOrSection(destiny) {
			var slide = destiny.find(SLIDE_ACTIVE_SEL);
			if (slide.length) {
				destiny = $(slide);
			}

			return destiny;
		}

		/**
  * Scrolls to the anchor in the URL when loading the site
  */
		function scrollToAnchor() {
			var anchors = getAnchorsURL();
			var sectionAnchor = anchors.section;
			var slideAnchor = anchors.slide;

			if (sectionAnchor) {
				//if theres any #
				if (options.animateAnchor) {
					scrollPageAndSlide(sectionAnchor, slideAnchor);
				} else {
					silentMoveTo(sectionAnchor, slideAnchor);
				}
			}
		}

		/**
  * Detecting any change on the URL to scroll to the given anchor link
  * (a way to detect back history button as we play with the hashes on the URL)
  */
		function hashChangeHandler() {
			if (!isScrolling && !options.lockAnchors) {
				var anchors = getAnchorsURL();
				var sectionAnchor = anchors.section;
				var slideAnchor = anchors.slide;

				//when moving to a slide in the first section for the first time (first time to add an anchor to the URL)
				var isFirstSlideMove = typeof lastScrolledDestiny === 'undefined';
				var isFirstScrollMove = typeof lastScrolledDestiny === 'undefined' && typeof slideAnchor === 'undefined' && !slideMoving;

				if (sectionAnchor.length) {
					/*in order to call scrollpage() only once for each destination at a time
     It is called twice for each scroll otherwise, as in case of using anchorlinks `hashChange`
     event is fired on every scroll too.*/
					if (sectionAnchor && sectionAnchor !== lastScrolledDestiny && !isFirstSlideMove || isFirstScrollMove || !slideMoving && lastScrolledSlide != slideAnchor) {

						scrollPageAndSlide(sectionAnchor, slideAnchor);
					}
				}
			}
		}

		//gets the URL anchors (section and slide)
		function getAnchorsURL() {
			var section;
			var slide;
			var hash = window.location.hash;

			if (hash.length) {
				//getting the anchor link in the URL and deleting the `#`
				var anchorsParts = hash.replace('#', '').split('/');

				//using / for visual reasons and not as a section/slide separator #2803
				var isFunkyAnchor = hash.indexOf('#/') > -1;

				section = isFunkyAnchor ? '/' + anchorsParts[1] : decodeURIComponent(anchorsParts[0]);

				var slideAnchor = isFunkyAnchor ? anchorsParts[2] : anchorsParts[1];
				if (slideAnchor && slideAnchor.length) {
					slide = decodeURIComponent(slideAnchor);
				}
			}

			return {
				section: section,
				slide: slide
			};
		}

		//Sliding with arrow keys, both, vertical and horizontal
		function keydownHandler(e) {
			clearTimeout(keydownId);

			var activeElement = $(':focus');
			var keyCode = e.which;

			//tab?
			if (keyCode === 9) {
				onTab(e);
			} else if (!activeElement.is('textarea') && !activeElement.is('input') && !activeElement.is('select') && activeElement.attr('contentEditable') !== "true" && activeElement.attr('contentEditable') !== '' && options.keyboardScrolling && options.autoScrolling) {

				//preventing the scroll with arrow keys & spacebar & Page Up & Down keys
				var keyControls = [40, 38, 32, 33, 34];
				if ($.inArray(keyCode, keyControls) > -1) {
					e.preventDefault();
				}

				controlPressed = e.ctrlKey;

				keydownId = setTimeout(function () {
					onkeydown(e);
				}, 150);
			}
		}

		function tooltipTextHandler() {
			$(this).prev().trigger('click');
		}

		//to prevent scrolling while zooming
		function keyUpHandler(e) {
			if (isWindowFocused) {
				//the keyup gets fired on new tab ctrl + t in Firefox
				controlPressed = e.ctrlKey;
			}
		}

		//binding the mousemove when the mouse's middle button is released
		function mouseDownHandler(e) {
			//middle button
			if (e.which == 2) {
				oldPageY = e.pageY;
				container.on('mousemove', mouseMoveHandler);
			}
		}

		//unbinding the mousemove when the mouse's middle button is released
		function mouseUpHandler(e) {
			//middle button
			if (e.which == 2) {
				container.off('mousemove');
			}
		}

		//Scrolling horizontally when clicking on the slider controls.
		function slideArrowHandler() {
			var section = $(this).closest(SECTION_SEL);

			if ($(this).hasClass(SLIDES_PREV)) {
				if (isScrollAllowed.m.left) {
					moveSlideLeft(section);
				}
			} else {
				if (isScrollAllowed.m.right) {
					moveSlideRight(section);
				}
			}
		}

		//when opening a new tab (ctrl + t), `control` won't be pressed when coming back.
		function blurHandler() {
			isWindowFocused = false;
			controlPressed = false;
		}

		//Scrolls to the section when clicking the navigation bullet
		function sectionBulletHandler(e) {
			e.preventDefault();
			var index = $(this).parent().index();
			scrollPage($(SECTION_SEL).eq(index));
		}

		//Scrolls the slider to the given slide destination for the given section
		function slideBulletHandler(e) {
			e.preventDefault();
			var slides = $(this).closest(SECTION_SEL).find(SLIDES_WRAPPER_SEL);
			var destiny = slides.find(SLIDE_SEL).eq($(this).closest('li').index());

			landscapeScroll(slides, destiny);
		}

		/**
  * Keydown event
  */
		function onkeydown(e) {
			var shiftPressed = e.shiftKey;

			//do nothing if we can not scroll or we are not using horizotnal key arrows.
			if (!canScroll && [37, 39].indexOf(e.which) < 0) {
				return;
			}

			switch (e.which) {
				//up
				case 38:
				case 33:
					if (isScrollAllowed.k.up) {
						moveSectionUp();
					}
					break;

				//down
				case 32:
					//spacebar
					if (shiftPressed && isScrollAllowed.k.up) {
						moveSectionUp();
						break;
					}
				/* falls through */
				case 40:
				case 34:
					if (isScrollAllowed.k.down) {
						moveSectionDown();
					}
					break;

				//Home
				case 36:
					if (isScrollAllowed.k.up) {
						moveTo(1);
					}
					break;

				//End
				case 35:
					if (isScrollAllowed.k.down) {
						moveTo($(SECTION_SEL).length);
					}
					break;

				//left
				case 37:
					if (isScrollAllowed.k.left) {
						moveSlideLeft();
					}
					break;

				//right
				case 39:
					if (isScrollAllowed.k.right) {
						moveSlideRight();
					}
					break;

				default:
					return; // exit this handler for other keys
			}
		}

		/**
  * Makes sure the tab key will only focus elements within the current section/slide
  * preventing this way from breaking the page.
  * Based on "Modals and keyboard traps"
  * from https://developers.google.com/web/fundamentals/accessibility/focus/using-tabindex
  */
		function onTab(e) {
			var isShiftPressed = e.shiftKey;
			var activeElement = $(':focus');
			var activeSection = $(SECTION_ACTIVE_SEL);
			var activeSlide = activeSection.find(SLIDE_ACTIVE_SEL);
			var focusableWrapper = activeSlide.length ? activeSlide : activeSection;
			var focusableElements = focusableWrapper.find(focusableElementsString);

			function preventAndFocusFirst(e) {
				e.preventDefault();
				return focusableElements.first().focus();
			}

			//is there an element with focus?
			if (activeElement.length) {
				if (!activeElement.closest(SECTION_ACTIVE_SEL, SLIDE_ACTIVE_SEL).length) {
					activeElement = preventAndFocusFirst(e);
				}
			}

			//no element if focused? Let's focus the first one of the section/slide
			else {
					preventAndFocusFirst(e);
				}

			//when reached the first or last focusable element of the section/slide
			//we prevent the tab action to keep it in the last focusable element
			if (!isShiftPressed && activeElement.is(focusableElements.last()) || isShiftPressed && activeElement.is(focusableElements.first())) {
				e.preventDefault();
			}
		}

		/**
  * Detecting the direction of the mouse movement.
  * Used only for the middle button of the mouse.
  */
		var oldPageY = 0;
		function mouseMoveHandler(e) {
			if (canScroll) {
				// moving up
				if (e.pageY < oldPageY && isScrollAllowed.m.up) {
					moveSectionUp();
				}

				// moving down
				else if (e.pageY > oldPageY && isScrollAllowed.m.down) {
						moveSectionDown();
					}
			}
			oldPageY = e.pageY;
		}

		/**
  * Scrolls horizontal sliders.
  */
		function landscapeScroll(slides, destiny, direction) {
			var section = slides.closest(SECTION_SEL);
			var v = {
				slides: slides,
				destiny: destiny,
				direction: direction,
				destinyPos: destiny.position(),
				slideIndex: destiny.index(),
				section: section,
				sectionIndex: section.index(SECTION_SEL),
				anchorLink: section.data('anchor'),
				slidesNav: section.find(SLIDES_NAV_SEL),
				slideAnchor: getAnchor(destiny),
				prevSlide: section.find(SLIDE_ACTIVE_SEL),
				prevSlideIndex: section.find(SLIDE_ACTIVE_SEL).index(),

				//caching the value of isResizing at the momment the function is called
				//because it will be checked later inside a setTimeout and the value might change
				localIsResizing: isResizing
			};
			v.xMovement = getXmovement(v.prevSlideIndex, v.slideIndex);

			//important!! Only do it when not resizing
			if (!v.localIsResizing) {
				//preventing from scrolling to the next/prev section when using scrollHorizontally
				canScroll = false;
			}

			if (options.onSlideLeave) {

				//if the site is not just resizing and readjusting the slides
				if (!v.localIsResizing && v.xMovement !== 'none') {
					if ($.isFunction(options.onSlideLeave)) {
						if (options.onSlideLeave.call(v.prevSlide, v.anchorLink, v.sectionIndex + 1, v.prevSlideIndex, v.direction, v.slideIndex) === false) {
							slideMoving = false;
							return;
						}
					}
				}
			}

			destiny.addClass(ACTIVE).siblings().removeClass(ACTIVE);

			if (!v.localIsResizing) {
				stopMedia(v.prevSlide);
				lazyLoad(destiny);
			}

			if (!options.loopHorizontal && options.controlArrows) {
				//hidding it for the fist slide, showing for the rest
				section.find(SLIDES_ARROW_PREV_SEL).toggle(v.slideIndex !== 0);

				//hidding it for the last slide, showing for the rest
				section.find(SLIDES_ARROW_NEXT_SEL).toggle(!destiny.is(':last-child'));
			}

			//only changing the URL if the slides are in the current section (not for resize re-adjusting)
			if (section.hasClass(ACTIVE) && !v.localIsResizing) {
				setState(v.slideIndex, v.slideAnchor, v.anchorLink, v.sectionIndex);
			}

			performHorizontalMove(slides, v, true);
		}

		function afterSlideLoads(v) {
			activeSlidesNavigation(v.slidesNav, v.slideIndex);

			//if the site is not just resizing and readjusting the slides
			if (!v.localIsResizing) {
				$.isFunction(options.afterSlideLoad) && options.afterSlideLoad.call(v.destiny, v.anchorLink, v.sectionIndex + 1, v.slideAnchor, v.slideIndex);

				//needs to be inside the condition to prevent problems with continuousVertical and scrollHorizontally
				//and to prevent double scroll right after a windows resize
				canScroll = true;

				playMedia(v.destiny);
			}

			//letting them slide again
			slideMoving = false;
		}

		/**
  * Performs the horizontal movement. (CSS3 or jQuery)
  *
  * @param fireCallback {Bool} - determines whether or not to fire the callback
  */
		function performHorizontalMove(slides, v, fireCallback) {
			var destinyPos = v.destinyPos;

			if (options.css3) {
				var translate3d = 'translate3d(-' + Math.round(destinyPos.left) + 'px, 0px, 0px)';

				addAnimation(slides.find(SLIDES_CONTAINER_SEL)).css(getTransforms(translate3d));

				afterSlideLoadsId = setTimeout(function () {
					fireCallback && afterSlideLoads(v);
				}, options.scrollingSpeed, options.easing);
			} else {
				slides.animate({
					scrollLeft: Math.round(destinyPos.left)
				}, options.scrollingSpeed, options.easing, function () {

					fireCallback && afterSlideLoads(v);
				});
			}
		}

		/**
  * Sets the state for the horizontal bullet navigations.
  */
		function activeSlidesNavigation(slidesNav, slideIndex) {
			slidesNav.find(ACTIVE_SEL).removeClass(ACTIVE);
			slidesNav.find('li').eq(slideIndex).find('a').addClass(ACTIVE);
		}

		var previousHeight = windowsHeight;

		//when resizing the site, we adjust the heights of the sections, slimScroll...
		function resizeHandler() {
			//checking if it needs to get responsive
			responsive();

			// rebuild immediately on touch devices
			if (isTouchDevice) {
				var activeElement = $(document.activeElement);

				//if the keyboard is NOT visible
				if (!activeElement.is('textarea') && !activeElement.is('input') && !activeElement.is('select')) {
					var currentHeight = $window.height();

					//making sure the change in the viewport size is enough to force a rebuild. (20 % of the window to avoid problems when hidding scroll bars)
					if (Math.abs(currentHeight - previousHeight) > 20 * Math.max(previousHeight, currentHeight) / 100) {
						reBuild(true);
						previousHeight = currentHeight;
					}
				}
			} else {
				//in order to call the functions only when the resize is finished
				//http://stackoverflow.com/questions/4298612/jquery-how-to-call-resize-event-only-once-its-finished-resizing
				clearTimeout(resizeId);

				resizeId = setTimeout(function () {
					reBuild(true);
				}, 350);
			}
		}

		/**
  * Checks if the site needs to get responsive and disables autoScrolling if so.
  * A class `fp-responsive` is added to the plugin's container in case the user wants to use it for his own responsive CSS.
  */
		function responsive() {
			var widthLimit = options.responsive || options.responsiveWidth; //backwards compatiblity
			var heightLimit = options.responsiveHeight;

			//only calculating what we need. Remember its called on the resize event.
			var isBreakingPointWidth = widthLimit && $window.outerWidth() < widthLimit;
			var isBreakingPointHeight = heightLimit && $window.height() < heightLimit;

			if (widthLimit && heightLimit) {
				setResponsive(isBreakingPointWidth || isBreakingPointHeight);
			} else if (widthLimit) {
				setResponsive(isBreakingPointWidth);
			} else if (heightLimit) {
				setResponsive(isBreakingPointHeight);
			}
		}

		/**
  * Adds transition animations for the given element
  */
		function addAnimation(element) {
			var transition = 'all ' + options.scrollingSpeed + 'ms ' + options.easingcss3;

			element.removeClass(NO_TRANSITION);
			return element.css({
				'-webkit-transition': transition,
				'transition': transition
			});
		}

		/**
  * Remove transition animations for the given element
  */
		function removeAnimation(element) {
			return element.addClass(NO_TRANSITION);
		}

		/**
  * Activating the vertical navigation bullets according to the given slide name.
  */
		function activateNavDots(name, sectionIndex) {
			if (options.navigation) {
				$(SECTION_NAV_SEL).find(ACTIVE_SEL).removeClass(ACTIVE);
				if (name) {
					$(SECTION_NAV_SEL).find('a[href="#' + name + '"]').addClass(ACTIVE);
				} else {
					$(SECTION_NAV_SEL).find('li').eq(sectionIndex).find('a').addClass(ACTIVE);
				}
			}
		}

		/**
  * Activating the website main menu elements according to the given slide name.
  */
		function activateMenuElement(name) {
			if (options.menu) {
				$(options.menu).find(ACTIVE_SEL).removeClass(ACTIVE);
				$(options.menu).find('[data-menuanchor="' + name + '"]').addClass(ACTIVE);
			}
		}

		/**
  * Sets to active the current menu and vertical nav items.
  */
		function activateMenuAndNav(anchor, index) {
			activateMenuElement(anchor);
			activateNavDots(anchor, index);
		}

		/**
  * Retuns `up` or `down` depending on the scrolling movement to reach its destination
  * from the current section.
  */
		function getYmovement(destiny) {
			var fromIndex = $(SECTION_ACTIVE_SEL).index(SECTION_SEL);
			var toIndex = destiny.index(SECTION_SEL);
			if (fromIndex == toIndex) {
				return 'none';
			}
			if (fromIndex > toIndex) {
				return 'up';
			}
			return 'down';
		}

		/**
  * Retuns `right` or `left` depending on the scrolling movement to reach its destination
  * from the current slide.
  */
		function getXmovement(fromIndex, toIndex) {
			if (fromIndex == toIndex) {
				return 'none';
			}
			if (fromIndex > toIndex) {
				return 'left';
			}
			return 'right';
		}

		function addTableClass(element) {
			//In case we are styling for the 2nd time as in with reponsiveSlides
			if (!element.hasClass(TABLE)) {
				element.addClass(TABLE).wrapInner('<div class="' + TABLE_CELL + '" style="height:' + getTableHeight(element) + 'px;" />');
			}
		}

		function getTableHeight(element) {
			var sectionHeight = windowsHeight;

			if (options.paddingTop || options.paddingBottom) {
				var section = element;
				if (!section.hasClass(SECTION)) {
					section = element.closest(SECTION_SEL);
				}

				var paddings = parseInt(section.css('padding-top')) + parseInt(section.css('padding-bottom'));
				sectionHeight = windowsHeight - paddings;
			}

			return sectionHeight;
		}

		/**
  * Adds a css3 transform property to the container class with or without animation depending on the animated param.
  */
		function transformContainer(translate3d, animated) {
			if (animated) {
				addAnimation(container);
			} else {
				removeAnimation(container);
			}

			container.css(getTransforms(translate3d));

			//syncronously removing the class after the animation has been applied.
			setTimeout(function () {
				container.removeClass(NO_TRANSITION);
			}, 10);
		}

		/**
  * Gets a section by its anchor / index
  */
		function getSectionByAnchor(sectionAnchor) {
			var section = container.find(SECTION_SEL + '[data-anchor="' + sectionAnchor + '"]');
			if (!section.length) {
				var sectionIndex = typeof sectionAnchor !== 'undefined' ? sectionAnchor - 1 : 0;
				section = $(SECTION_SEL).eq(sectionIndex);
			}

			return section;
		}

		/**
  * Gets a slide inside a given section by its anchor / index
  */
		function getSlideByAnchor(slideAnchor, section) {
			var slide = section.find(SLIDE_SEL + '[data-anchor="' + slideAnchor + '"]');
			if (!slide.length) {
				slideAnchor = typeof slideAnchor !== 'undefined' ? slideAnchor : 0;
				slide = section.find(SLIDE_SEL).eq(slideAnchor);
			}

			return slide;
		}

		/**
  * Scrolls to the given section and slide anchors
  */
		function scrollPageAndSlide(sectionAnchor, slideAnchor) {
			var section = getSectionByAnchor(sectionAnchor);

			//do nothing if there's no section with the given anchor name
			if (!section.length) return;

			var slide = getSlideByAnchor(slideAnchor, section);

			//we need to scroll to the section and then to the slide
			if (sectionAnchor !== lastScrolledDestiny && !section.hasClass(ACTIVE)) {
				scrollPage(section, function () {
					scrollSlider(slide);
				});
			}
			//if we were already in the section
			else {
					scrollSlider(slide);
				}
		}

		/**
  * Scrolls the slider to the given slide destination for the given section
  */
		function scrollSlider(slide) {
			if (slide.length) {
				landscapeScroll(slide.closest(SLIDES_WRAPPER_SEL), slide);
			}
		}

		/**
  * Creates a landscape navigation bar with dots for horizontal sliders.
  */
		function addSlidesNavigation(section, numSlides) {
			section.append('<div class="' + SLIDES_NAV + '"><ul></ul></div>');
			var nav = section.find(SLIDES_NAV_SEL);

			//top or bottom
			nav.addClass(options.slidesNavPosition);

			for (var i = 0; i < numSlides; i++) {
				nav.find('ul').append('<li><a href="#"><span></span></a></li>');
			}

			//centering it
			nav.css('margin-left', '-' + nav.width() / 2 + 'px');

			nav.find('li').first().find('a').addClass(ACTIVE);
		}

		/**
  * Sets the state of the website depending on the active section/slide.
  * It changes the URL hash when needed and updates the body class.
  */
		function setState(slideIndex, slideAnchor, anchorLink, sectionIndex) {
			var sectionHash = '';

			if (options.anchors.length && !options.lockAnchors) {

				//isn't it the first slide?
				if (slideIndex) {
					if (typeof anchorLink !== 'undefined') {
						sectionHash = anchorLink;
					}

					//slide without anchor link? We take the index instead.
					if (typeof slideAnchor === 'undefined') {
						slideAnchor = slideIndex;
					}

					lastScrolledSlide = slideAnchor;
					setUrlHash(sectionHash + '/' + slideAnchor);

					//first slide won't have slide anchor, just the section one
				} else if (typeof slideIndex !== 'undefined') {
					lastScrolledSlide = slideAnchor;
					setUrlHash(anchorLink);
				}

				//section without slides
				else {
						setUrlHash(anchorLink);
					}
			}

			setBodyClass();
		}

		/**
  * Sets the URL hash.
  */
		function setUrlHash(url) {
			if (options.recordHistory) {
				location.hash = url;
			} else {
				//Mobile Chrome doesn't work the normal way, so... lets use HTML5 for phones :)
				if (isTouchDevice || isTouch) {
					window.history.replaceState(undefined, undefined, '#' + url);
				} else {
					var baseUrl = window.location.href.split('#')[0];
					window.location.replace(baseUrl + '#' + url);
				}
			}
		}

		/**
  * Gets the anchor for the given slide / section. Its index will be used if there's none.
  */
		function getAnchor(element) {
			var anchor = element.data('anchor');
			var index = element.index();

			//Slide without anchor link? We take the index instead.
			if (typeof anchor === 'undefined') {
				anchor = index;
			}

			return anchor;
		}

		/**
  * Sets a class for the body of the page depending on the active section / slide
  */
		function setBodyClass() {
			var section = $(SECTION_ACTIVE_SEL);
			var slide = section.find(SLIDE_ACTIVE_SEL);

			var sectionAnchor = getAnchor(section);
			var slideAnchor = getAnchor(slide);

			var text = String(sectionAnchor);

			if (slide.length) {
				text = text + '-' + slideAnchor;
			}

			//changing slash for dash to make it a valid CSS style
			text = text.replace('/', '-').replace('#', '');

			//removing previous anchor classes
			var classRe = new RegExp('\\b\\s?' + VIEWING_PREFIX + '-[^\\s]+\\b', "g");
			$body[0].className = $body[0].className.replace(classRe, '');

			//adding the current anchor
			$body.addClass(VIEWING_PREFIX + '-' + text);
		}

		/**
  * Checks for translate3d support
  * @return boolean
  * http://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support
  */
		function support3d() {
			var el = document.createElement('p'),
			    has3d,
			    transforms = {
				'webkitTransform': '-webkit-transform',
				'OTransform': '-o-transform',
				'msTransform': '-ms-transform',
				'MozTransform': '-moz-transform',
				'transform': 'transform'
			};

			// Add it to the body to get the computed style.
			document.body.insertBefore(el, null);

			for (var t in transforms) {
				if (el.style[t] !== undefined) {
					el.style[t] = 'translate3d(1px,1px,1px)';
					has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);
				}
			}

			document.body.removeChild(el);

			return has3d !== undefined && has3d.length > 0 && has3d !== 'none';
		}

		/**
  * Removes the auto scrolling action fired by the mouse wheel and trackpad.
  * After this function is called, the mousewheel and trackpad movements won't scroll through sections.
  */
		function removeMouseWheelHandler() {
			if (document.addEventListener) {
				document.removeEventListener('mousewheel', MouseWheelHandler, false); //IE9, Chrome, Safari, Oper
				document.removeEventListener('wheel', MouseWheelHandler, false); //Firefox
				document.removeEventListener('MozMousePixelScroll', MouseWheelHandler, false); //old Firefox
			} else {
				document.detachEvent('onmousewheel', MouseWheelHandler); //IE 6/7/8
			}
		}

		/**
  * Adds the auto scrolling action for the mouse wheel and trackpad.
  * After this function is called, the mousewheel and trackpad movements will scroll through sections
  * https://developer.mozilla.org/en-US/docs/Web/Events/wheel
  */
		function addMouseWheelHandler() {
			var prefix = '';
			var _addEventListener;

			if (window.addEventListener) {
				_addEventListener = "addEventListener";
			} else {
				_addEventListener = "attachEvent";
				prefix = 'on';
			}

			// detect available wheel event
			var support = 'onwheel' in document.createElement('div') ? 'wheel' : // Modern browsers support "wheel"
			document.onmousewheel !== undefined ? 'mousewheel' : // Webkit and IE support at least "mousewheel"
			'DOMMouseScroll'; // let's assume that remaining browsers are older Firefox


			if (support == 'DOMMouseScroll') {
				document[_addEventListener](prefix + 'MozMousePixelScroll', MouseWheelHandler, false);
			}

			//handle MozMousePixelScroll in older Firefox
			else {
					document[_addEventListener](prefix + support, MouseWheelHandler, false);
				}
		}

		/**
  * Binding the mousemove when the mouse's middle button is pressed
  */
		function addMiddleWheelHandler() {
			container.on('mousedown', mouseDownHandler).on('mouseup', mouseUpHandler);
		}

		/**
  * Unbinding the mousemove when the mouse's middle button is released
  */
		function removeMiddleWheelHandler() {
			container.off('mousedown', mouseDownHandler).off('mouseup', mouseUpHandler);
		}

		/**
  * Adds the possibility to auto scroll through sections on touch devices.
  */
		function addTouchHandler() {
			if (isTouchDevice || isTouch) {
				if (options.autoScrolling) {
					$body.off(events.touchmove).on(events.touchmove, preventBouncing);
				}

				$(WRAPPER_SEL).off(events.touchstart).on(events.touchstart, touchStartHandler).off(events.touchmove).on(events.touchmove, touchMoveHandler);
			}
		}

		/**
  * Removes the auto scrolling for touch devices.
  */
		function removeTouchHandler() {
			if (isTouchDevice || isTouch) {
				if (options.autoScrolling) {
					$body.off(events.touchmove);
				}

				$(WRAPPER_SEL).off(events.touchstart).off(events.touchmove);
			}
		}

		/*
  * Returns and object with Microsoft pointers (for IE<11 and for IE >= 11)
  * http://msdn.microsoft.com/en-us/library/ie/dn304886(v=vs.85).aspx
  */
		function getMSPointer() {
			var pointer;

			//IE >= 11 & rest of browsers
			if (window.PointerEvent) {
				pointer = { down: 'pointerdown', move: 'pointermove' };
			}

			//IE < 11
			else {
					pointer = { down: 'MSPointerDown', move: 'MSPointerMove' };
				}

			return pointer;
		}

		/**
  * Gets the pageX and pageY properties depending on the browser.
  * https://github.com/alvarotrigo/fullPage.js/issues/194#issuecomment-34069854
  */
		function getEventsPage(e) {
			var events = [];

			events.y = typeof e.pageY !== 'undefined' && (e.pageY || e.pageX) ? e.pageY : e.touches[0].pageY;
			events.x = typeof e.pageX !== 'undefined' && (e.pageY || e.pageX) ? e.pageX : e.touches[0].pageX;

			//in touch devices with scroll bar, e.pageY is detected, but we have to deal with touch events. #1008
			if (isTouch && isReallyTouch(e) && (options.scrollBar || !options.autoScrolling)) {
				events.y = e.touches[0].pageY;
				events.x = e.touches[0].pageX;
			}

			return events;
		}

		/**
  * Slides silently (with no animation) the active slider to the given slide.
  * @param noCallback {bool} true or defined -> no callbacks
  */
		function silentLandscapeScroll(activeSlide, noCallbacks) {
			setScrollingSpeed(0, 'internal');

			if (typeof noCallbacks !== 'undefined') {
				//preventing firing callbacks afterSlideLoad etc.
				isResizing = true;
			}

			landscapeScroll(activeSlide.closest(SLIDES_WRAPPER_SEL), activeSlide);

			if (typeof noCallbacks !== 'undefined') {
				isResizing = false;
			}

			setScrollingSpeed(originals.scrollingSpeed, 'internal');
		}

		/**
  * Scrolls silently (with no animation) the page to the given Y position.
  */
		function silentScroll(top) {
			// The first section can have a negative value in iOS 10. Not quite sure why: -0.0142822265625
			// that's why we round it to 0.
			var roundedTop = Math.round(top);

			if (options.css3 && options.autoScrolling && !options.scrollBar) {
				var translate3d = 'translate3d(0px, -' + roundedTop + 'px, 0px)';
				transformContainer(translate3d, false);
			} else if (options.autoScrolling && !options.scrollBar) {
				container.css('top', -roundedTop);
			} else {
				$htmlBody.scrollTop(roundedTop);
			}
		}

		/**
  * Returns the cross-browser transform string.
  */
		function getTransforms(translate3d) {
			return {
				'-webkit-transform': translate3d,
				'-moz-transform': translate3d,
				'-ms-transform': translate3d,
				'transform': translate3d
			};
		}

		/**
  * Allowing or disallowing the mouse/swipe scroll in a given direction. (not for keyboard)
  * @type  m (mouse) or k (keyboard)
  */
		function setIsScrollAllowed(value, direction, type) {
			//up, down, left, right
			if (direction !== 'all') {
				isScrollAllowed[type][direction] = value;
			}

			//all directions?
			else {
					$.each(Object.keys(isScrollAllowed[type]), function (index, key) {
						isScrollAllowed[type][key] = value;
					});
				}
		}

		/*
  * Destroys fullpage.js plugin events and optinally its html markup and styles
  */
		function destroy(all) {
			setAutoScrolling(false, 'internal');
			setAllowScrolling(false);
			setKeyboardScrolling(false);
			container.addClass(DESTROYED);

			clearTimeout(afterSlideLoadsId);
			clearTimeout(afterSectionLoadsId);
			clearTimeout(resizeId);
			clearTimeout(scrollId);
			clearTimeout(scrollId2);

			$window.off('scroll', scrollHandler).off('hashchange', hashChangeHandler).off('resize', resizeHandler);

			$document.off('click touchstart', SECTION_NAV_SEL + ' a').off('mouseenter', SECTION_NAV_SEL + ' li').off('mouseleave', SECTION_NAV_SEL + ' li').off('click touchstart', SLIDES_NAV_LINK_SEL).off('mouseover', options.normalScrollElements).off('mouseout', options.normalScrollElements);

			$(SECTION_SEL).off('click touchstart', SLIDES_ARROW_SEL);

			clearTimeout(afterSlideLoadsId);
			clearTimeout(afterSectionLoadsId);

			//lets make a mess!
			if (all) {
				destroyStructure();
			}
		}

		/*
  * Removes inline styles added by fullpage.js
  */
		function destroyStructure() {
			//reseting the `top` or `translate` properties to 0
			silentScroll(0);

			//loading all the lazy load content
			container.find('img[data-src], source[data-src], audio[data-src], iframe[data-src]').each(function () {
				setSrc($(this), 'src');
			});

			container.find('img[data-srcset]').each(function () {
				setSrc($(this), 'srcset');
			});

			$(SECTION_NAV_SEL + ', ' + SLIDES_NAV_SEL + ', ' + SLIDES_ARROW_SEL).remove();

			//removing inline styles
			$(SECTION_SEL).css({
				'height': '',
				'background-color': '',
				'padding': ''
			});

			$(SLIDE_SEL).css({
				'width': ''
			});

			container.css({
				'height': '',
				'position': '',
				'-ms-touch-action': '',
				'touch-action': ''
			});

			$htmlBody.css({
				'overflow': '',
				'height': ''
			});

			// remove .fp-enabled class
			$('html').removeClass(ENABLED);

			// remove .fp-responsive class
			$body.removeClass(RESPONSIVE);

			// remove all of the .fp-viewing- classes
			$.each($body.get(0).className.split(/\s+/), function (index, className) {
				if (className.indexOf(VIEWING_PREFIX) === 0) {
					$body.removeClass(className);
				}
			});

			//removing added classes
			$(SECTION_SEL + ', ' + SLIDE_SEL).each(function () {
				if (options.scrollOverflowHandler) {
					options.scrollOverflowHandler.remove($(this));
				}
				$(this).removeClass(TABLE + ' ' + ACTIVE);
				$(this).attr('style', $(this).data('fp-styles'));
			});

			removeAnimation(container);

			//Unwrapping content
			container.find(TABLE_CELL_SEL + ', ' + SLIDES_CONTAINER_SEL + ', ' + SLIDES_WRAPPER_SEL).each(function () {
				//unwrap not being use in case there's no child element inside and its just text
				$(this).replaceWith(this.childNodes);
			});

			//removing the applied transition from the fullpage wrapper
			container.css({
				'-webkit-transition': 'none',
				'transition': 'none'
			});

			//scrolling the page to the top with no animation
			$htmlBody.scrollTop(0);

			//removing selectors
			var usedSelectors = [SECTION, SLIDE, SLIDES_CONTAINER];
			$.each(usedSelectors, function (index, value) {
				$('.' + value).removeClass(value);
			});
		}

		/*
  * Sets the state for a variable with multiple states (original, and temporal)
  * Some variables such as `autoScrolling` or `recordHistory` might change automatically its state when using `responsive` or `autoScrolling:false`.
  * This function is used to keep track of both states, the original and the temporal one.
  * If type is not 'internal', then we assume the user is globally changing the variable.
  */
		function setVariableState(variable, value, type) {
			options[variable] = value;
			if (type !== 'internal') {
				originals[variable] = value;
			}
		}

		/**
  * Displays warnings
  */
		function displayWarnings() {
			var extensions = ['fadingEffect', 'continuousHorizontal', 'scrollHorizontally', 'interlockedSlides', 'resetSliders', 'responsiveSlides', 'offsetSections', 'dragAndMove', 'scrollOverflowReset', 'parallax'];
			if ($('html').hasClass(ENABLED)) {
				showError('error', 'Fullpage.js can only be initialized once and you are doing it multiple times!');
				return;
			}

			// Disable mutually exclusive settings
			if (options.continuousVertical && (options.loopTop || options.loopBottom)) {
				options.continuousVertical = false;
				showError('warn', 'Option `loopTop/loopBottom` is mutually exclusive with `continuousVertical`; `continuousVertical` disabled');
			}

			if (options.scrollBar && options.scrollOverflow) {
				showError('warn', 'Option `scrollBar` is mutually exclusive with `scrollOverflow`. Sections with scrollOverflow might not work well in Firefox');
			}

			if (options.continuousVertical && (options.scrollBar || !options.autoScrolling)) {
				options.continuousVertical = false;
				showError('warn', 'Scroll bars (`scrollBar:true` or `autoScrolling:false`) are mutually exclusive with `continuousVertical`; `continuousVertical` disabled');
			}

			if (options.scrollOverflow && !options.scrollOverflowHandler) {
				options.scrollOverflow = false;
				showError('error', 'The option `scrollOverflow:true` requires the file `scrolloverflow.min.js`. Please include it before fullPage.js.');
			}

			//using extensions? Wrong file!
			$.each(extensions, function (index, extension) {
				//is the option set to true?
				if (options[extension]) {
					showError('warn', 'fullpage.js extensions require jquery.fullpage.extensions.min.js file instead of the usual jquery.fullpage.js. Requested: ' + extension);
				}
			});

			//anchors can not have the same value as any element ID or NAME
			$.each(options.anchors, function (index, name) {

				//case insensitive selectors (http://stackoverflow.com/a/19465187/1081396)
				var nameAttr = $document.find('[name]').filter(function () {
					return $(this).attr('name') && $(this).attr('name').toLowerCase() == name.toLowerCase();
				});

				var idAttr = $document.find('[id]').filter(function () {
					return $(this).attr('id') && $(this).attr('id').toLowerCase() == name.toLowerCase();
				});

				if (idAttr.length || nameAttr.length) {
					showError('error', 'data-anchor tags can not have the same value as any `id` element on the site (or `name` element for IE).');
					idAttr.length && showError('error', '"' + name + '" is is being used by another element `id` property');
					nameAttr.length && showError('error', '"' + name + '" is is being used by another element `name` property');
				}
			});
		}

		/**
  * Shows a message in the console of the given type.
  */
		function showError(type, text) {
			console && console[type] && console[type]('fullPage: ' + text);
		}
	}; //end of $.fn.fullpage
});
!function (t, e) {
	"object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.tableDragger = e() : t.tableDragger = e();
}(this, function () {
	return function (t) {
		function e(r) {
			if (n[r]) return n[r].exports;var o = n[r] = { exports: {}, id: r, loaded: !1 };return t[r].call(o.exports, o, o.exports, e), o.loaded = !0, o.exports;
		}var n = {};return e.m = t, e.c = n, e.p = "", e(0);
	}([function (t, e, n) {
		"use strict";
		function r(t) {
			return t && t.__esModule ? t : { default: t };
		}Object.defineProperty(e, "__esModule", { value: !0 }), n(1);var o = n(5),
		    i = r(o),
		    u = function u(t, e) {
			return i.default.create(t, e);
		};e.default = u, t.exports = u;
	}, function (t, e, n) {
		var r = n(2);"string" == typeof r && (r = [[t.id, r, ""]]);n(4)(r, {});r.locals && (t.exports = r.locals);
	}, function (t, e, n) {
		e = t.exports = n(3)(), e.push([t.id, ".sindu_dragger{list-style:none;margin:0;padding:0;overflow:hidden;box-sizing:border-box}.sindu_handle{cursor:move}.sindu_dragger li{margin:0;padding:0;list-style:none;text-align:inherit}.sindu_dragger li table,.sindu_dragger td,.sindu_dragger th,.sindu_dragger tr{box-sizing:border-box}.gu-mirror{list-style:none}.sindu_dragger.sindu_column li{float:left}.sindu_dragging .sindu_origin_table{visibility:hidden}.gu-mirror{position:fixed!important;margin:0!important;z-index:9999!important;opacity:.8}.gu-mirror li{margin:0;padding:0;list-style:none;text-align:inherit}.gu-mirror li table,.gu-mirror td,.gu-mirror th,.gu-mirror tr{box-sizing:border-box}.gu-hide{display:none!important}.gu-unselectable{-webkit-user-select:none!important;-moz-user-select:none!important;-ms-user-select:none!important;user-select:none!important}.gu-transit{opacity:.5}", ""]);
	}, function (t, e) {
		t.exports = function () {
			var t = [];return t.toString = function () {
				for (var t = [], e = 0; e < this.length; e++) {
					var n = this[e];n[2] ? t.push("@media " + n[2] + "{" + n[1] + "}") : t.push(n[1]);
				}return t.join("");
			}, t.i = function (e, n) {
				"string" == typeof e && (e = [[null, e, ""]]);for (var r = {}, o = 0; o < this.length; o++) {
					var i = this[o][0];"number" == typeof i && (r[i] = !0);
				}for (o = 0; o < e.length; o++) {
					var u = e[o];"number" == typeof u[0] && r[u[0]] || (n && !u[2] ? u[2] = n : n && (u[2] = "(" + u[2] + ") and (" + n + ")"), t.push(u));
				}
			}, t;
		};
	}, function (t, e, n) {
		function r(t, e) {
			for (var n = 0; n < t.length; n++) {
				var r = t[n],
				    o = p[r.id];if (o) {
					o.refs++;for (var i = 0; i < o.parts.length; i++) {
						o.parts[i](r.parts[i]);
					}for (; i < r.parts.length; i++) {
						o.parts.push(s(r.parts[i], e));
					}
				} else {
					for (var u = [], i = 0; i < r.parts.length; i++) {
						u.push(s(r.parts[i], e));
					}p[r.id] = { id: r.id, refs: 1, parts: u };
				}
			}
		}function o(t) {
			for (var e = [], n = {}, r = 0; r < t.length; r++) {
				var o = t[r],
				    i = o[0],
				    u = o[1],
				    a = o[2],
				    c = o[3],
				    s = { css: u, media: a, sourceMap: c };n[i] ? n[i].parts.push(s) : e.push(n[i] = { id: i, parts: [s] });
			}return e;
		}function i(t, e) {
			var n = m(),
			    r = b[b.length - 1];if ("top" === t.insertAt) r ? r.nextSibling ? n.insertBefore(e, r.nextSibling) : n.appendChild(e) : n.insertBefore(e, n.firstChild), b.push(e);else {
				if ("bottom" !== t.insertAt) throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");n.appendChild(e);
			}
		}function u(t) {
			t.parentNode.removeChild(t);var e = b.indexOf(t);e >= 0 && b.splice(e, 1);
		}function a(t) {
			var e = document.createElement("style");return e.type = "text/css", i(t, e), e;
		}function c(t) {
			var e = document.createElement("link");return e.rel = "stylesheet", i(t, e), e;
		}function s(t, e) {
			var n, r, o;if (e.singleton) {
				var i = y++;n = g || (g = a(e)), r = f.bind(null, n, i, !1), o = f.bind(null, n, i, !0);
			} else t.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (n = c(e), r = d.bind(null, n), o = function o() {
				u(n), n.href && URL.revokeObjectURL(n.href);
			}) : (n = a(e), r = l.bind(null, n), o = function o() {
				u(n);
			});return r(t), function (e) {
				if (e) {
					if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap) return;r(t = e);
				} else o();
			};
		}function f(t, e, n, r) {
			var o = n ? "" : r.css;if (t.styleSheet) t.styleSheet.cssText = w(e, o);else {
				var i = document.createTextNode(o),
				    u = t.childNodes;u[e] && t.removeChild(u[e]), u.length ? t.insertBefore(i, u[e]) : t.appendChild(i);
			}
		}function l(t, e) {
			var n = e.css,
			    r = e.media;if (r && t.setAttribute("media", r), t.styleSheet) t.styleSheet.cssText = n;else {
				for (; t.firstChild;) {
					t.removeChild(t.firstChild);
				}t.appendChild(document.createTextNode(n));
			}
		}function d(t, e) {
			var n = e.css,
			    r = e.sourceMap;r && (n += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(r)))) + " */");var o = new Blob([n], { type: "text/css" }),
			    i = t.href;t.href = URL.createObjectURL(o), i && URL.revokeObjectURL(i);
		}var p = {},
		    v = function v(t) {
			var e;return function () {
				return "undefined" == typeof e && (e = t.apply(this, arguments)), e;
			};
		},
		    h = v(function () {
			return (/msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase())
			);
		}),
		    m = v(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		    g = null,
		    y = 0,
		    b = [];t.exports = function (t, e) {
			e = e || {}, "undefined" == typeof e.singleton && (e.singleton = h()), "undefined" == typeof e.insertAt && (e.insertAt = "bottom");var n = o(t);return r(n, e), function (t) {
				for (var i = [], u = 0; u < n.length; u++) {
					var a = n[u],
					    c = p[a.id];c.refs--, i.push(c);
				}if (t) {
					var s = o(t);r(s, e);
				}for (var u = 0; u < i.length; u++) {
					var c = i[u];if (0 === c.refs) {
						for (var f = 0; f < c.parts.length; f++) {
							c.parts[f]();
						}delete p[c.id];
					}
				}
			};
		};var w = function () {
			var t = [];return function (e, n) {
				return t[e] = n, t.filter(Boolean).join("\n");
			};
		}();
	}, function (t, e, n) {
		"use strict";
		function r(t) {
			return t && t.__esModule ? t : { default: t };
		}function o(t) {
			return t && "object" === ("undefined" == typeof t ? "undefined" : (0, c.default)(t)) && "nodeType" in t && 1 === t.nodeType && t.cloneNode && "TABLE" === t.nodeName;
		}function i(t) {
			return "touches" in t ? 1 === t.touches.length : "buttons" in t ? 1 === t.buttons : "button" in t && 0 === t.button;
		}function u() {
			var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
			    e = {};return t.on = function (n, r) {
				return e[n] = e[n] || [], e[n].push(r), t;
			}, t.emit = function (t) {
				for (var n = arguments.length, r = Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) {
					r[o - 1] = arguments[o];
				}if (e[t]) {
					var i = !0,
					    u = !1,
					    a = void 0;try {
						for (var c, s = (0, f.default)(e[t]); !(i = (c = s.next()).done); i = !0) {
							var l = c.value;l.apply(void 0, r);
						}
					} catch (t) {
						u = !0, a = t;
					} finally {
						try {
							!i && s.return && s.return();
						} finally {
							if (u) throw a;
						}
					}
				}
			}, t;
		}Object.defineProperty(e, "__esModule", { value: !0 });var a = n(6),
		    c = r(a),
		    s = n(73),
		    f = r(s),
		    l = n(78),
		    d = r(l),
		    p = n(85),
		    v = r(p),
		    h = n(89),
		    m = r(h),
		    g = n(90),
		    y = r(g),
		    b = n(94),
		    w = r(b),
		    x = n(107),
		    E = r(x),
		    S = n(108),
		    T = function () {
			function t() {
				var e = this,
				    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
				    r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};if ((0, m.default)(this, t), !o(n)) throw new TypeError("table-dragger: el must be TABLE HTMLElement, not " + {}.toString.call(n));if (n.rows.length) {
					var i = { mode: "column", dragHandler: "", onlyBody: !1, animation: 300 },
					    a = this.options = (0, v.default)({}, i, r),
					    c = a.mode;if ("free" === c && !a.dragHandler) throw new Error("table-dragger: please specify dragHandler in free mode");["onTap", "destroy", "startBecauseMouseMoved", "sortColumn", "sortRow"].forEach(function (t) {
						e[t] = e[t].bind(e);
					});var s = this.dragger = u({ dragging: !1, destroy: this.destroy });s.on("drop", function (t, n, r, o) {
						("column" === o ? e.sortColumn : e.sortRow)(t, n);
					});var f = void 0;if (a.dragHandler) {
						if (f = n.querySelectorAll(a.dragHandler), f && !f.length) throw new Error("table-dragger: no element match dragHandler selector");
					} else f = "column" === c ? n.rows[0] ? n.rows[0].children : [] : (0, d.default)(n.rows).map(function (t) {
						return t.children[0];
					});this.handlers = (0, d.default)(f), this.handlers.forEach(function (t) {
						t.classList.add(E.default.handle);
					}), n.classList.add(E.default.originTable), this.tappedCoord = { x: 0, y: 0 }, this.cellIndex = { x: 0, y: 0 }, this.el = n, this.bindEvents();
				}
			}return (0, y.default)(t, [{ key: "bindEvents", value: function value() {
					var t = !0,
					    e = !1,
					    n = void 0;try {
						for (var r, o = (0, f.default)(this.handlers); !(t = (r = o.next()).done); t = !0) {
							var i = r.value;(0, S.touchy)(i, "add", "mousedown", this.onTap);
						}
					} catch (t) {
						e = !0, n = t;
					} finally {
						try {
							!t && o.return && o.return();
						} finally {
							if (e) throw n;
						}
					}
				} }, { key: "onTap", value: function value(t) {
					for (var e = this, n = t.target; "TD" !== n.nodeName && "TH" !== n.nodeName;) {
						n = n.parentElement;
					}var r = !i(t) || t.metaKey || t.ctrlKey;r || (this.cellIndex = { x: n.cellIndex, y: n.parentElement.rowIndex }, this.tappedCoord = { x: t.clientX, y: t.clientY }, this.eventualStart(!1), (0, S.touchy)(document, "add", "mouseup", function () {
						e.eventualStart(!0);
					}));
				} }, { key: "startBecauseMouseMoved", value: function value(t) {
					var e = this.tappedCoord,
					    n = this.options.mode,
					    r = Math.abs(t.clientX - e.x),
					    o = Math.abs(t.clientY - e.y),
					    i = "free" === n,
					    u = n;if (0 !== r || 0 !== o) {
						i && (u = r < o ? "row" : "column");var a = new w.default({ mode: u, originTable: this });this.eventualStart(!0), (0, S.touchy)(document, "add", "mouseup", a.destroy);
					}
				} }, { key: "eventualStart", value: function value(t) {
					var e = t ? "remove" : "add";(0, S.touchy)(document, e, "mousemove", this.startBecauseMouseMoved);
				} }, { key: "destroy", value: function value() {
					var t = !0,
					    e = !1,
					    n = void 0;try {
						for (var r, o = (0, f.default)(this.handlers); !(t = (r = o.next()).done); t = !0) {
							var i = r.value;(0, S.touchy)(i, "remove", "mousedown", this.onTap);
						}
					} catch (t) {
						e = !0, n = t;
					} finally {
						try {
							!t && o.return && o.return();
						} finally {
							if (e) throw n;
						}
					}this.el.classList.remove(E.default.originTable);
				} }, { key: "sortColumn", value: function value(t, e) {
					if (t !== e) {
						var n = this.el;(0, d.default)(n.rows).forEach(function (n) {
							(0, S.sort)({ list: n.children, from: t, to: e });
						});var r = n.querySelectorAll("col");r.length && (0, S.sort)({ list: r, from: t, to: e });
					}
				} }, { key: "sortRow", value: function value(t, e) {
					if (t !== e) {
						var n = this.el,
						    r = (0, d.default)(n.rows);(0, S.sort)({ list: r, parent: r[e].parentElement, from: t, to: e });
					}
				} }], [{ key: "create", value: function value(e, n) {
					var r = new t(e, n);return r && r.dragger;
				} }]), t;
		}();T.version = "1.0", e.default = T;
	}, function (t, e, n) {
		"use strict";
		function r(t) {
			return t && t.__esModule ? t : { default: t };
		}e.__esModule = !0;var o = n(7),
		    i = r(o),
		    u = n(58),
		    a = r(u),
		    c = "function" == typeof a.default && "symbol" == _typeof(i.default) ? function (t) {
			return typeof t === "undefined" ? "undefined" : _typeof(t);
		} : function (t) {
			return t && "function" == typeof a.default && t.constructor === a.default && t !== a.default.prototype ? "symbol" : typeof t === "undefined" ? "undefined" : _typeof(t);
		};e.default = "function" == typeof a.default && "symbol" === c(i.default) ? function (t) {
			return "undefined" == typeof t ? "undefined" : c(t);
		} : function (t) {
			return t && "function" == typeof a.default && t.constructor === a.default && t !== a.default.prototype ? "symbol" : "undefined" == typeof t ? "undefined" : c(t);
		};
	}, function (t, e, n) {
		t.exports = { default: n(8), __esModule: !0 };
	}, function (t, e, n) {
		n(9), n(53), t.exports = n(57).f("iterator");
	}, function (t, e, n) {
		"use strict";
		var r = n(10)(!0);n(13)(String, "String", function (t) {
			this._t = String(t), this._i = 0;
		}, function () {
			var t,
			    e = this._t,
			    n = this._i;return n >= e.length ? { value: void 0, done: !0 } : (t = r(e, n), this._i += t.length, { value: t, done: !1 });
		});
	}, function (t, e, n) {
		var r = n(11),
		    o = n(12);t.exports = function (t) {
			return function (e, n) {
				var i,
				    u,
				    a = String(o(e)),
				    c = r(n),
				    s = a.length;return c < 0 || c >= s ? t ? "" : void 0 : (i = a.charCodeAt(c), i < 55296 || i > 56319 || c + 1 === s || (u = a.charCodeAt(c + 1)) < 56320 || u > 57343 ? t ? a.charAt(c) : i : t ? a.slice(c, c + 2) : (i - 55296 << 10) + (u - 56320) + 65536);
			};
		};
	}, function (t, e) {
		var n = Math.ceil,
		    r = Math.floor;t.exports = function (t) {
			return isNaN(t = +t) ? 0 : (t > 0 ? r : n)(t);
		};
	}, function (t, e) {
		t.exports = function (t) {
			if (void 0 == t) throw TypeError("Can't call method on  " + t);return t;
		};
	}, function (t, e, n) {
		"use strict";
		var r = n(14),
		    o = n(15),
		    i = n(30),
		    u = n(20),
		    a = n(31),
		    c = n(32),
		    s = n(33),
		    f = n(49),
		    l = n(51),
		    d = n(50)("iterator"),
		    p = !([].keys && "next" in [].keys()),
		    v = "@@iterator",
		    h = "keys",
		    m = "values",
		    g = function g() {
			return this;
		};t.exports = function (t, e, n, y, b, w, x) {
			s(n, e, y);var E,
			    S,
			    T,
			    O = function O(t) {
				if (!p && t in M) return M[t];switch (t) {case h:
						return function () {
							return new n(this, t);
						};case m:
						return function () {
							return new n(this, t);
						};}return function () {
					return new n(this, t);
				};
			},
			    _ = e + " Iterator",
			    C = b == m,
			    L = !1,
			    M = t.prototype,
			    j = M[d] || M[v] || b && M[b],
			    k = j || O(b),
			    P = b ? C ? O("entries") : k : void 0,
			    A = "Array" == e ? M.entries || j : j;if (A && (T = l(A.call(new t())), T !== Object.prototype && T.next && (f(T, _, !0), r || a(T, d) || u(T, d, g))), C && j && j.name !== m && (L = !0, k = function k() {
				return j.call(this);
			}), r && !x || !p && !L && M[d] || u(M, d, k), c[e] = k, c[_] = g, b) if (E = { values: C ? k : O(m), keys: w ? k : O(h), entries: P }, x) for (S in E) {
				S in M || i(M, S, E[S]);
			} else o(o.P + o.F * (p || L), e, E);return E;
		};
	}, function (t, e) {
		t.exports = !0;
	}, function (t, e, n) {
		var r = n(16),
		    o = n(17),
		    i = n(18),
		    u = n(20),
		    a = "prototype",
		    c = function c(t, e, n) {
			var s,
			    f,
			    l,
			    d = t & c.F,
			    p = t & c.G,
			    v = t & c.S,
			    h = t & c.P,
			    m = t & c.B,
			    g = t & c.W,
			    y = p ? o : o[e] || (o[e] = {}),
			    b = y[a],
			    w = p ? r : v ? r[e] : (r[e] || {})[a];p && (n = e);for (s in n) {
				f = !d && w && void 0 !== w[s], f && s in y || (l = f ? w[s] : n[s], y[s] = p && "function" != typeof w[s] ? n[s] : m && f ? i(l, r) : g && w[s] == l ? function (t) {
					var e = function (_e) {
						function e(_x5, _x6, _x7) {
							return _e.apply(this, arguments);
						}

						e.toString = function () {
							return _e.toString();
						};

						return e;
					}(function (e, n, r) {
						if (this instanceof t) {
							switch (arguments.length) {case 0:
									return new t();case 1:
									return new t(e);case 2:
									return new t(e, n);}return new t(e, n, r);
						}return t.apply(this, arguments);
					});return e[a] = t[a], e;
				}(l) : h && "function" == typeof l ? i(Function.call, l) : l, h && ((y.virtual || (y.virtual = {}))[s] = l, t & c.R && b && !b[s] && u(b, s, l)));
			}
		};c.F = 1, c.G = 2, c.S = 4, c.P = 8, c.B = 16, c.W = 32, c.U = 64, c.R = 128, t.exports = c;
	}, function (t, e) {
		var n = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();"number" == typeof __g && (__g = n);
	}, function (t, e) {
		var n = t.exports = { version: "2.5.1" };"number" == typeof __e && (__e = n);
	}, function (t, e, n) {
		var r = n(19);t.exports = function (t, e, n) {
			if (r(t), void 0 === e) return t;switch (n) {case 1:
					return function (n) {
						return t.call(e, n);
					};case 2:
					return function (n, r) {
						return t.call(e, n, r);
					};case 3:
					return function (n, r, o) {
						return t.call(e, n, r, o);
					};}return function () {
				return t.apply(e, arguments);
			};
		};
	}, function (t, e) {
		t.exports = function (t) {
			if ("function" != typeof t) throw TypeError(t + " is not a function!");return t;
		};
	}, function (t, e, n) {
		var r = n(21),
		    o = n(29);t.exports = n(25) ? function (t, e, n) {
			return r.f(t, e, o(1, n));
		} : function (t, e, n) {
			return t[e] = n, t;
		};
	}, function (t, e, n) {
		var r = n(22),
		    o = n(24),
		    i = n(28),
		    u = Object.defineProperty;e.f = n(25) ? Object.defineProperty : function (t, e, n) {
			if (r(t), e = i(e, !0), r(n), o) try {
				return u(t, e, n);
			} catch (t) {}if ("get" in n || "set" in n) throw TypeError("Accessors not supported!");return "value" in n && (t[e] = n.value), t;
		};
	}, function (t, e, n) {
		var r = n(23);t.exports = function (t) {
			if (!r(t)) throw TypeError(t + " is not an object!");return t;
		};
	}, function (t, e) {
		t.exports = function (t) {
			return "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) ? null !== t : "function" == typeof t;
		};
	}, function (t, e, n) {
		t.exports = !n(25) && !n(26)(function () {
			return 7 != Object.defineProperty(n(27)("div"), "a", { get: function get() {
					return 7;
				} }).a;
		});
	}, function (t, e, n) {
		t.exports = !n(26)(function () {
			return 7 != Object.defineProperty({}, "a", { get: function get() {
					return 7;
				} }).a;
		});
	}, function (t, e) {
		t.exports = function (t) {
			try {
				return !!t();
			} catch (t) {
				return !0;
			}
		};
	}, function (t, e, n) {
		var r = n(23),
		    o = n(16).document,
		    i = r(o) && r(o.createElement);t.exports = function (t) {
			return i ? o.createElement(t) : {};
		};
	}, function (t, e, n) {
		var r = n(23);t.exports = function (t, e) {
			if (!r(t)) return t;var n, o;if (e && "function" == typeof (n = t.toString) && !r(o = n.call(t))) return o;if ("function" == typeof (n = t.valueOf) && !r(o = n.call(t))) return o;if (!e && "function" == typeof (n = t.toString) && !r(o = n.call(t))) return o;throw TypeError("Can't convert object to primitive value");
		};
	}, function (t, e) {
		t.exports = function (t, e) {
			return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e };
		};
	}, function (t, e, n) {
		t.exports = n(20);
	}, function (t, e) {
		var n = {}.hasOwnProperty;t.exports = function (t, e) {
			return n.call(t, e);
		};
	}, function (t, e) {
		t.exports = {};
	}, function (t, e, n) {
		"use strict";
		var r = n(34),
		    o = n(29),
		    i = n(49),
		    u = {};n(20)(u, n(50)("iterator"), function () {
			return this;
		}), t.exports = function (t, e, n) {
			t.prototype = r(u, { next: o(1, n) }), i(t, e + " Iterator");
		};
	}, function (t, e, n) {
		var r = n(22),
		    o = n(35),
		    i = n(47),
		    u = n(44)("IE_PROTO"),
		    a = function a() {},
		    c = "prototype",
		    _s = function s() {
			var t,
			    e = n(27)("iframe"),
			    r = i.length,
			    o = "<",
			    u = ">";for (e.style.display = "none", n(48).appendChild(e), e.src = "javascript:", t = e.contentWindow.document, t.open(), t.write(o + "script" + u + "document.F=Object" + o + "/script" + u), t.close(), _s = t.F; r--;) {
				delete _s[c][i[r]];
			}return _s();
		};t.exports = Object.create || function (t, e) {
			var n;return null !== t ? (a[c] = r(t), n = new a(), a[c] = null, n[u] = t) : n = _s(), void 0 === e ? n : o(n, e);
		};
	}, function (t, e, n) {
		var r = n(21),
		    o = n(22),
		    i = n(36);t.exports = n(25) ? Object.defineProperties : function (t, e) {
			o(t);for (var n, u = i(e), a = u.length, c = 0; a > c;) {
				r.f(t, n = u[c++], e[n]);
			}return t;
		};
	}, function (t, e, n) {
		var r = n(37),
		    o = n(47);t.exports = Object.keys || function (t) {
			return r(t, o);
		};
	}, function (t, e, n) {
		var r = n(31),
		    o = n(38),
		    i = n(41)(!1),
		    u = n(44)("IE_PROTO");t.exports = function (t, e) {
			var n,
			    a = o(t),
			    c = 0,
			    s = [];for (n in a) {
				n != u && r(a, n) && s.push(n);
			}for (; e.length > c;) {
				r(a, n = e[c++]) && (~i(s, n) || s.push(n));
			}return s;
		};
	}, function (t, e, n) {
		var r = n(39),
		    o = n(12);t.exports = function (t) {
			return r(o(t));
		};
	}, function (t, e, n) {
		var r = n(40);t.exports = Object("z").propertyIsEnumerable(0) ? Object : function (t) {
			return "String" == r(t) ? t.split("") : Object(t);
		};
	}, function (t, e) {
		var n = {}.toString;t.exports = function (t) {
			return n.call(t).slice(8, -1);
		};
	}, function (t, e, n) {
		var r = n(38),
		    o = n(42),
		    i = n(43);t.exports = function (t) {
			return function (e, n, u) {
				var a,
				    c = r(e),
				    s = o(c.length),
				    f = i(u, s);if (t && n != n) {
					for (; s > f;) {
						if (a = c[f++], a != a) return !0;
					}
				} else for (; s > f; f++) {
					if ((t || f in c) && c[f] === n) return t || f || 0;
				}return !t && -1;
			};
		};
	}, function (t, e, n) {
		var r = n(11),
		    o = Math.min;t.exports = function (t) {
			return t > 0 ? o(r(t), 9007199254740991) : 0;
		};
	}, function (t, e, n) {
		var r = n(11),
		    o = Math.max,
		    i = Math.min;t.exports = function (t, e) {
			return t = r(t), t < 0 ? o(t + e, 0) : i(t, e);
		};
	}, function (t, e, n) {
		var r = n(45)("keys"),
		    o = n(46);t.exports = function (t) {
			return r[t] || (r[t] = o(t));
		};
	}, function (t, e, n) {
		var r = n(16),
		    o = "__core-js_shared__",
		    i = r[o] || (r[o] = {});t.exports = function (t) {
			return i[t] || (i[t] = {});
		};
	}, function (t, e) {
		var n = 0,
		    r = Math.random();t.exports = function (t) {
			return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++n + r).toString(36));
		};
	}, function (t, e) {
		t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
	}, function (t, e, n) {
		var r = n(16).document;t.exports = r && r.documentElement;
	}, function (t, e, n) {
		var r = n(21).f,
		    o = n(31),
		    i = n(50)("toStringTag");t.exports = function (t, e, n) {
			t && !o(t = n ? t : t.prototype, i) && r(t, i, { configurable: !0, value: e });
		};
	}, function (t, e, n) {
		var r = n(45)("wks"),
		    o = n(46),
		    i = n(16).Symbol,
		    u = "function" == typeof i,
		    a = t.exports = function (t) {
			return r[t] || (r[t] = u && i[t] || (u ? i : o)("Symbol." + t));
		};a.store = r;
	}, function (t, e, n) {
		var r = n(31),
		    o = n(52),
		    i = n(44)("IE_PROTO"),
		    u = Object.prototype;t.exports = Object.getPrototypeOf || function (t) {
			return t = o(t), r(t, i) ? t[i] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? u : null;
		};
	}, function (t, e, n) {
		var r = n(12);t.exports = function (t) {
			return Object(r(t));
		};
	}, function (t, e, n) {
		n(54);for (var r = n(16), o = n(20), i = n(32), u = n(50)("toStringTag"), a = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), c = 0; c < a.length; c++) {
			var s = a[c],
			    f = r[s],
			    l = f && f.prototype;l && !l[u] && o(l, u, s), i[s] = i.Array;
		}
	}, function (t, e, n) {
		"use strict";
		var r = n(55),
		    o = n(56),
		    i = n(32),
		    u = n(38);t.exports = n(13)(Array, "Array", function (t, e) {
			this._t = u(t), this._i = 0, this._k = e;
		}, function () {
			var t = this._t,
			    e = this._k,
			    n = this._i++;return !t || n >= t.length ? (this._t = void 0, o(1)) : "keys" == e ? o(0, n) : "values" == e ? o(0, t[n]) : o(0, [n, t[n]]);
		}, "values"), i.Arguments = i.Array, r("keys"), r("values"), r("entries");
	}, function (t, e) {
		t.exports = function () {};
	}, function (t, e) {
		t.exports = function (t, e) {
			return { value: e, done: !!t };
		};
	}, function (t, e, n) {
		e.f = n(50);
	}, function (t, e, n) {
		t.exports = { default: n(59), __esModule: !0 };
	}, function (t, e, n) {
		n(60), n(70), n(71), n(72), t.exports = n(17).Symbol;
	}, function (t, e, n) {
		"use strict";
		var r = n(16),
		    o = n(31),
		    i = n(25),
		    u = n(15),
		    a = n(30),
		    c = n(61).KEY,
		    s = n(26),
		    f = n(45),
		    l = n(49),
		    d = n(46),
		    p = n(50),
		    v = n(57),
		    h = n(62),
		    m = n(63),
		    g = n(66),
		    y = n(22),
		    b = n(38),
		    w = n(28),
		    x = n(29),
		    E = n(34),
		    S = n(67),
		    T = n(69),
		    O = n(21),
		    _ = n(36),
		    C = T.f,
		    L = O.f,
		    M = S.f,
		    _j = r.Symbol,
		    k = r.JSON,
		    P = k && k.stringify,
		    A = "prototype",
		    N = p("_hidden"),
		    R = p("toPrimitive"),
		    B = {}.propertyIsEnumerable,
		    I = f("symbol-registry"),
		    F = f("symbols"),
		    D = f("op-symbols"),
		    U = Object[A],
		    z = "function" == typeof _j,
		    H = r.QObject,
		    Y = !H || !H[A] || !H[A].findChild,
		    X = i && s(function () {
			return 7 != E(L({}, "a", { get: function get() {
					return L(this, "a", { value: 7 }).a;
				} })).a;
		}) ? function (t, e, n) {
			var r = C(U, e);r && delete U[e], L(t, e, n), r && t !== U && L(U, e, r);
		} : L,
		    W = function W(t) {
			var e = F[t] = E(_j[A]);return e._k = t, e;
		},
		    G = z && "symbol" == _typeof(_j.iterator) ? function (t) {
			return "symbol" == (typeof t === "undefined" ? "undefined" : _typeof(t));
		} : function (t) {
			return t instanceof _j;
		},
		    V = function V(t, e, n) {
			return t === U && V(D, e, n), y(t), e = w(e, !0), y(n), o(F, e) ? (n.enumerable ? (o(t, N) && t[N][e] && (t[N][e] = !1), n = E(n, { enumerable: x(0, !1) })) : (o(t, N) || L(t, N, x(1, {})), t[N][e] = !0), X(t, e, n)) : L(t, e, n);
		},
		    q = function q(t, e) {
			y(t);for (var n, r = m(e = b(e)), o = 0, i = r.length; i > o;) {
				V(t, n = r[o++], e[n]);
			}return t;
		},
		    K = function K(t, e) {
			return void 0 === e ? E(t) : q(E(t), e);
		},
		    J = function J(t) {
			var e = B.call(this, t = w(t, !0));return !(this === U && o(F, t) && !o(D, t)) && (!(e || !o(this, t) || !o(F, t) || o(this, N) && this[N][t]) || e);
		},
		    $ = function $(t, e) {
			if (t = b(t), e = w(e, !0), t !== U || !o(F, e) || o(D, e)) {
				var n = C(t, e);return !n || !o(F, e) || o(t, N) && t[N][e] || (n.enumerable = !0), n;
			}
		},
		    Q = function Q(t) {
			for (var e, n = M(b(t)), r = [], i = 0; n.length > i;) {
				o(F, e = n[i++]) || e == N || e == c || r.push(e);
			}return r;
		},
		    Z = function Z(t) {
			for (var e, n = t === U, r = M(n ? D : b(t)), i = [], u = 0; r.length > u;) {
				!o(F, e = r[u++]) || n && !o(U, e) || i.push(F[e]);
			}return i;
		};z || (_j = function j() {
			if (this instanceof _j) throw TypeError("Symbol is not a constructor!");var t = d(arguments.length > 0 ? arguments[0] : void 0),
			    e = function e(n) {
				this === U && e.call(D, n), o(this, N) && o(this[N], t) && (this[N][t] = !1), X(this, t, x(1, n));
			};return i && Y && X(U, t, { configurable: !0, set: e }), W(t);
		}, a(_j[A], "toString", function () {
			return this._k;
		}), T.f = $, O.f = V, n(68).f = S.f = Q, n(65).f = J, n(64).f = Z, i && !n(14) && a(U, "propertyIsEnumerable", J, !0), v.f = function (t) {
			return W(p(t));
		}), u(u.G + u.W + u.F * !z, { Symbol: _j });for (var tt = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), et = 0; tt.length > et;) {
			p(tt[et++]);
		}for (var nt = _(p.store), rt = 0; nt.length > rt;) {
			h(nt[rt++]);
		}u(u.S + u.F * !z, "Symbol", { for: function _for(t) {
				return o(I, t += "") ? I[t] : I[t] = _j(t);
			}, keyFor: function keyFor(t) {
				if (!G(t)) throw TypeError(t + " is not a symbol!");for (var e in I) {
					if (I[e] === t) return e;
				}
			}, useSetter: function useSetter() {
				Y = !0;
			}, useSimple: function useSimple() {
				Y = !1;
			} }), u(u.S + u.F * !z, "Object", { create: K, defineProperty: V, defineProperties: q, getOwnPropertyDescriptor: $, getOwnPropertyNames: Q, getOwnPropertySymbols: Z }), k && u(u.S + u.F * (!z || s(function () {
			var t = _j();return "[null]" != P([t]) || "{}" != P({ a: t }) || "{}" != P(Object(t));
		})), "JSON", { stringify: function stringify(t) {
				if (void 0 !== t && !G(t)) {
					for (var e, n, r = [t], o = 1; arguments.length > o;) {
						r.push(arguments[o++]);
					}return e = r[1], "function" == typeof e && (n = e), !n && g(e) || (e = function (_e2) {
						function e(_x8, _x9) {
							return _e2.apply(this, arguments);
						}

						e.toString = function () {
							return _e2.toString();
						};

						return e;
					}(function (t, e) {
						if (n && (e = n.call(this, t, e)), !G(e)) return e;
					})), r[1] = e, P.apply(k, r);
				}
			} }), _j[A][R] || n(20)(_j[A], R, _j[A].valueOf), l(_j, "Symbol"), l(Math, "Math", !0), l(r.JSON, "JSON", !0);
	}, function (t, e, n) {
		var r = n(46)("meta"),
		    o = n(23),
		    i = n(31),
		    u = n(21).f,
		    a = 0,
		    c = Object.isExtensible || function () {
			return !0;
		},
		    s = !n(26)(function () {
			return c(Object.preventExtensions({}));
		}),
		    f = function f(t) {
			u(t, r, { value: { i: "O" + ++a, w: {} } });
		},
		    l = function l(t, e) {
			if (!o(t)) return "symbol" == (typeof t === "undefined" ? "undefined" : _typeof(t)) ? t : ("string" == typeof t ? "S" : "P") + t;if (!i(t, r)) {
				if (!c(t)) return "F";if (!e) return "E";f(t);
			}return t[r].i;
		},
		    d = function d(t, e) {
			if (!i(t, r)) {
				if (!c(t)) return !0;if (!e) return !1;f(t);
			}return t[r].w;
		},
		    p = function p(t) {
			return s && v.NEED && c(t) && !i(t, r) && f(t), t;
		},
		    v = t.exports = { KEY: r, NEED: !1, fastKey: l, getWeak: d, onFreeze: p };
	}, function (t, e, n) {
		var r = n(16),
		    o = n(17),
		    i = n(14),
		    u = n(57),
		    a = n(21).f;t.exports = function (t) {
			var e = o.Symbol || (o.Symbol = i ? {} : r.Symbol || {});"_" == t.charAt(0) || t in e || a(e, t, { value: u.f(t) });
		};
	}, function (t, e, n) {
		var r = n(36),
		    o = n(64),
		    i = n(65);t.exports = function (t) {
			var e = r(t),
			    n = o.f;if (n) for (var u, a = n(t), c = i.f, s = 0; a.length > s;) {
				c.call(t, u = a[s++]) && e.push(u);
			}return e;
		};
	}, function (t, e) {
		e.f = Object.getOwnPropertySymbols;
	}, function (t, e) {
		e.f = {}.propertyIsEnumerable;
	}, function (t, e, n) {
		var r = n(40);t.exports = Array.isArray || function (t) {
			return "Array" == r(t);
		};
	}, function (t, e, n) {
		var r = n(38),
		    o = n(68).f,
		    i = {}.toString,
		    u = "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
		    a = function a(t) {
			try {
				return o(t);
			} catch (t) {
				return u.slice();
			}
		};t.exports.f = function (t) {
			return u && "[object Window]" == i.call(t) ? a(t) : o(r(t));
		};
	}, function (t, e, n) {
		var r = n(37),
		    o = n(47).concat("length", "prototype");e.f = Object.getOwnPropertyNames || function (t) {
			return r(t, o);
		};
	}, function (t, e, n) {
		var r = n(65),
		    o = n(29),
		    i = n(38),
		    u = n(28),
		    a = n(31),
		    c = n(24),
		    s = Object.getOwnPropertyDescriptor;e.f = n(25) ? s : function (t, e) {
			if (t = i(t), e = u(e, !0), c) try {
				return s(t, e);
			} catch (t) {}if (a(t, e)) return o(!r.f.call(t, e), t[e]);
		};
	}, function (t, e) {}, function (t, e, n) {
		n(62)("asyncIterator");
	}, function (t, e, n) {
		n(62)("observable");
	}, function (t, e, n) {
		t.exports = { default: n(74), __esModule: !0 };
	}, function (t, e, n) {
		n(53), n(9), t.exports = n(75);
	}, function (t, e, n) {
		var r = n(22),
		    o = n(76);t.exports = n(17).getIterator = function (t) {
			var e = o(t);if ("function" != typeof e) throw TypeError(t + " is not iterable!");return r(e.call(t));
		};
	}, function (t, e, n) {
		var r = n(77),
		    o = n(50)("iterator"),
		    i = n(32);t.exports = n(17).getIteratorMethod = function (t) {
			if (void 0 != t) return t[o] || t["@@iterator"] || i[r(t)];
		};
	}, function (t, e, n) {
		var r = n(40),
		    o = n(50)("toStringTag"),
		    i = "Arguments" == r(function () {
			return arguments;
		}()),
		    u = function u(t, e) {
			try {
				return t[e];
			} catch (t) {}
		};t.exports = function (t) {
			var e, n, a;return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (n = u(e = Object(t), o)) ? n : i ? r(e) : "Object" == (a = r(e)) && "function" == typeof e.callee ? "Arguments" : a;
		};
	}, function (t, e, n) {
		t.exports = { default: n(79), __esModule: !0 };
	}, function (t, e, n) {
		n(9), n(80), t.exports = n(17).Array.from;
	}, function (t, e, n) {
		"use strict";
		var r = n(18),
		    o = n(15),
		    i = n(52),
		    u = n(81),
		    a = n(82),
		    c = n(42),
		    s = n(83),
		    f = n(76);o(o.S + o.F * !n(84)(function (t) {
			Array.from(t);
		}), "Array", { from: function from(t) {
				var e,
				    n,
				    o,
				    l,
				    d = i(t),
				    p = "function" == typeof this ? this : Array,
				    v = arguments.length,
				    h = v > 1 ? arguments[1] : void 0,
				    m = void 0 !== h,
				    g = 0,
				    y = f(d);if (m && (h = r(h, v > 2 ? arguments[2] : void 0, 2)), void 0 == y || p == Array && a(y)) for (e = c(d.length), n = new p(e); e > g; g++) {
					s(n, g, m ? h(d[g], g) : d[g]);
				} else for (l = y.call(d), n = new p(); !(o = l.next()).done; g++) {
					s(n, g, m ? u(l, h, [o.value, g], !0) : o.value);
				}return n.length = g, n;
			} });
	}, function (t, e, n) {
		var r = n(22);t.exports = function (t, e, n, o) {
			try {
				return o ? e(r(n)[0], n[1]) : e(n);
			} catch (e) {
				var i = t.return;throw void 0 !== i && r(i.call(t)), e;
			}
		};
	}, function (t, e, n) {
		var r = n(32),
		    o = n(50)("iterator"),
		    i = Array.prototype;t.exports = function (t) {
			return void 0 !== t && (r.Array === t || i[o] === t);
		};
	}, function (t, e, n) {
		"use strict";
		var r = n(21),
		    o = n(29);t.exports = function (t, e, n) {
			e in t ? r.f(t, e, o(0, n)) : t[e] = n;
		};
	}, function (t, e, n) {
		var r = n(50)("iterator"),
		    o = !1;try {
			var i = [7][r]();i.return = function () {
				o = !0;
			}, Array.from(i, function () {
				throw 2;
			});
		} catch (t) {}t.exports = function (t, e) {
			if (!e && !o) return !1;var n = !1;try {
				var i = [7],
				    u = i[r]();u.next = function () {
					return { done: n = !0 };
				}, i[r] = function () {
					return u;
				}, t(i);
			} catch (t) {}return n;
		};
	}, function (t, e, n) {
		t.exports = { default: n(86), __esModule: !0 };
	}, function (t, e, n) {
		n(87), t.exports = n(17).Object.assign;
	}, function (t, e, n) {
		var r = n(15);r(r.S + r.F, "Object", { assign: n(88) });
	}, function (t, e, n) {
		"use strict";
		var r = n(36),
		    o = n(64),
		    i = n(65),
		    u = n(52),
		    a = n(39),
		    c = Object.assign;t.exports = !c || n(26)(function () {
			var t = {},
			    e = {},
			    n = Symbol(),
			    r = "abcdefghijklmnopqrst";return t[n] = 7, r.split("").forEach(function (t) {
				e[t] = t;
			}), 7 != c({}, t)[n] || Object.keys(c({}, e)).join("") != r;
		}) ? function (t, e) {
			for (var n = u(t), c = arguments.length, s = 1, f = o.f, l = i.f; c > s;) {
				for (var d, p = a(arguments[s++]), v = f ? r(p).concat(f(p)) : r(p), h = v.length, m = 0; h > m;) {
					l.call(p, d = v[m++]) && (n[d] = p[d]);
				}
			}return n;
		} : c;
	}, function (t, e) {
		"use strict";
		e.__esModule = !0, e.default = function (t, e) {
			if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
		};
	}, function (t, e, n) {
		"use strict";
		function r(t) {
			return t && t.__esModule ? t : { default: t };
		}e.__esModule = !0;var o = n(91),
		    i = r(o);e.default = function () {
			function t(t, e) {
				for (var n = 0; n < e.length; n++) {
					var r = e[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), (0, i.default)(t, r.key, r);
				}
			}return function (e, n, r) {
				return n && t(e.prototype, n), r && t(e, r), e;
			};
		}();
	}, function (t, e, n) {
		t.exports = { default: n(92), __esModule: !0 };
	}, function (t, e, n) {
		n(93);var r = n(17).Object;t.exports = function (t, e, n) {
			return r.defineProperty(t, e, n);
		};
	}, function (t, e, n) {
		var r = n(15);r(r.S + r.F * !n(25), "Object", { defineProperty: n(21).f });
	}, function (t, e, n) {
		"use strict";
		function r(t) {
			return t && t.__esModule ? t : { default: t };
		}function o(t) {
			(0, b.css)(t, { "table-layout": "fixed", width: "initial", height: "initial", padding: 0, margin: 0 }), ["width", "height", "id"].forEach(function (e) {
				t.removeAttribute(e);
			}), t.classList.remove(y.default.originTable), (0, f.default)(t.querySelectorAll("col")).forEach(function (t) {
				t.removeAttribute("width"), (0, b.css)(t, { width: "initial" });
			});
		}function i(t, e) {
			var n = t.cloneNode(!0);o(n);var r = n.querySelectorAll("col");return r.length && (0, f.default)(r).forEach(function (t, n) {
				n !== e && t.parentElement.removeChild(t);
			}), (0, f.default)(n.rows).forEach(function (t) {
				var n = t.children[e];(0, b.empty)(t), n && t.appendChild(n);
			}), n;
		}function u(t) {
			return (0, f.default)(t.rows).map(function (e) {
				var n = t.cloneNode(!0);o(n), (0, f.default)(n.children).forEach(function (t) {
					var e = t.nodeName;"COL" !== e && "COLGROUP" !== e && n.removeChild(t);
				});var r = e.parentNode.cloneNode();return r.innerHTML = "", r.appendChild(e.cloneNode(!0)), n.appendChild(r), n;
			});
		}function a(t) {
			return (0, f.default)((0, b.getLongestRow)(t).children).map(function (e, n) {
				return i(t, n);
			});
		}function c(t, e) {
			return "column" === e ? a(t) : u(t);
		}Object.defineProperty(e, "__esModule", { value: !0 });var s = n(78),
		    f = r(s),
		    l = n(89),
		    d = r(l),
		    p = n(90),
		    v = r(p),
		    h = n(95),
		    m = r(h),
		    g = n(107),
		    y = r(g),
		    b = n(108),
		    w = !1,
		    x = void 0,
		    E = void 0,
		    S = function () {
			function t(e) {
				var n = this,
				    r = e.originTable,
				    o = e.mode;(0, d.default)(this, t);var i = r.dragger,
				    u = r.cellIndex,
				    a = r.el,
				    s = r.options,
				    f = this.fakeTables = c(a, o);x = parseInt(document.body.style.paddingRight, 0) || 0, E = document.body.style.overflow, this.options = s, this.mode = o, this.originTable = r, this.dragger = i, this.index = "column" === o ? u.x : u.y, ["destroy", "onDrag", "onDragend", "onShadow", "onOut"].forEach(function (t) {
					n[t] = n[t].bind(n);
				}), this.el = f.reduce(function (t, e) {
					var n = document.createElement("li");return n.appendChild(e), t.appendChild(n) && t;
				}, document.createElement("ul")), this.drake = (0, m.default)([this.el], { animation: 300, staticClass: y.default.static, direction: "column" === o ? "horizontal" : "vertical" }).on("drag", this.onDrag).on("dragend", this.onDragend).on("shadow", this.onShadow).on("out", this.onOut), this.renderEl(), this.dispatchMousedown();
			}return (0, v.default)(t, [{ key: "onDrag", value: function value() {
					(0, b.css)(document.body, { overflow: "hidden" });var t = (0, b.getScrollBarWidth)();this.dragger.dragging = !0, t && (0, b.css)(document.body, { "padding-right": t + x + "px" }), (0, b.touchy)(document, "remove", "mouseup", this.destroy), this.dragger.emit("drag", this.originTable.el, this.options.mode);
				} }, { key: "onDragend", value: function value(t) {
					var e = this.originTable.el,
					    n = this.dragger,
					    r = this.index,
					    o = this.mode,
					    i = this.el;(0, b.css)(document.body, { overflow: E, "padding-right": x + "px" }), this.dragger.dragging = !1;var u = r,
					    a = (0, f.default)(i.children).indexOf(t);this.destroy(), n.emit("drop", u, a, e, o);
				} }, { key: "onShadow", value: function value(t) {
					var e = this.originTable.el,
					    n = this.dragger,
					    r = this.index,
					    o = this.el,
					    i = this.mode,
					    u = r,
					    a = (0, f.default)(o.children).indexOf(t);n.emit("shadowMove", u, a, e, i);
				} }, { key: "onOut", value: function value() {
					this.dragger.dragging = !1, this.dragger.emit("out", this.originTable.el, this.mode);
				} }, { key: "destroy", value: function value() {
					var t = this;(0, b.remove)(document, "mouseup", this.destroy), this.el.parentElement.classList.remove(y.default.dragging), w || this.el.parentElement.removeChild(this.el), setTimeout(function () {
						t.drake.destroy();
					}, 0);
				} }, { key: "dispatchMousedown", value: function value() {
					var t = this.el,
					    e = this.index;t.children[e].dispatchEvent((0, b.getTouchyEvent)());
				} }, { key: "renderEl", value: function value() {
					var t = this,
					    e = this.mode,
					    n = this.el,
					    r = this.originTable.el;this.sizeFakes(), (0, b.css)(n, { position: "absolute", top: r.offsetTop + "px", left: r.offsetLeft + "px" }), (0, b.insertBeforeSibling)({ target: n, origin: r });var o = window.getComputedStyle(r).getPropertyValue("border-spacing").split(" ")[0],
					    i = "column" === e ? "margin-right" : "margin-bottom",
					    u = n.children.length;(0, f.default)(n.children).forEach(function (n, r) {
						var a = n && n.querySelector("table");t.options.onlyBody && "row" === e && !(0, f.default)(a.children).some(function (t) {
							return "TBODY" === t.nodeName;
						}) && n.classList.add(y.default.static), o && r < u - 1 && (n.style[i] = "-" + o);
					}), n.parentElement.classList.add(y.default.dragging), n.classList.add(y.default.draggableTable), n.classList.add("sindu_" + e);
				} }, { key: "sizeFakes", value: function value() {
					return "column" === this.mode ? this.sizeColumnFake() : this.sizeRowFake();
				} }, { key: "sizeColumnFake", value: function value() {
					var t = this.fakeTables,
					    e = this.originTable.el;(0, f.default)((0, b.getLongestRow)(e).children).forEach(function (e, n) {
						var r = e.getBoundingClientRect().width,
						    o = t[n];(0, b.css)(o, { width: r + "px" }), (0, b.css)(o.rows[0].children[0], {
							width: r + "px" });
					});var n = (0, f.default)(e.rows).map(function (t) {
						return t.children[0].getBoundingClientRect().height;
					});t.forEach(function (t) {
						(0, f.default)(t.rows).forEach(function (t, e) {
							(0, b.css)(t, { height: n[e] + "px" });
						});
					});
				} }, { key: "sizeRowFake", value: function value() {
					var t = this.fakeTables,
					    e = this.originTable.el,
					    n = (0, b.getLongestRow)(e).children,
					    r = e.getBoundingClientRect().width;t.forEach(function (t) {
						(0, b.css)(t, { width: r + "px" }), (0, f.default)(t.rows[0].children).forEach(function (t, e) {
							(0, b.css)(t, { width: n[e].getBoundingClientRect().width + "px" });
						});
					});
				} }]), t;
		}();e.default = S;
	}, function (t, e, n) {
		(function (e) {
			"use strict";
			function r(t, e) {
				function n(t) {
					return dt.containers.indexOf(t) !== -1 || lt.isContainer(t);
				}function r(t) {
					var e = t ? "remove" : "add";o(T, e, "mousedown", C), o(T, e, "mouseup", B);
				}function a(t) {
					var e = t ? "remove" : "add";o(T, e, "mousemove", L);
				}function h(t) {
					var e = t ? "remove" : "add";x[e](T, "selectstart", _), x[e](T, "click", _);
				}function y() {
					r(!0), B({});
				}function _(t) {
					st && t.preventDefault();
				}function C(t) {
					rt = t.clientX, ot = t.clientY;var e = 1 !== i(t) || t.metaKey || t.ctrlKey;if (!e) {
						var n = t.target,
						    r = M(n);r && (st = r, a(), "mousedown" === t.type && (v(n) ? n.focus() : t.preventDefault()));
					}
				}function L(t) {
					if (st) {
						if (0 === i(t)) return void B({});if (void 0 === t.clientX || t.clientX !== rt || void 0 === t.clientY || t.clientY !== ot) {
							if (lt.ignoreInputTextSelection) {
								var e = b("clientX", t),
								    n = b("clientY", t),
								    r = S.elementFromPoint(e, n);if (v(r)) return;
							}var o = st;a(!0), h(), N(), P(o);var c = u(tt);et = b("pageX", t) - c.left, nt = b("pageY", t) - c.top, E.add(at || tt, "gu-transit"), G(), Y(t);
						}
					}
				}function M(t) {
					if (!(dt.dragging && Q || n(t))) {
						for (var e = t; p(t) && n(p(t)) === !1;) {
							if (lt.invalid(t, e)) return;if (t = p(t), !t) return;
						}var r = p(t);if (r && !(lt.invalid(t, e) || lt.staticClass && t.classList.contains(lt.staticClass))) {
							var o = lt.moves(t, r, e, m(t));if (o) return { item: t, source: r };
						}
					}
				}function j(t) {
					return !!M(t);
				}function k(t) {
					var e = M(t);e && P(e);
				}function P(t) {
					J(t.item, t.source) && (at = t.item.cloneNode(!0), dt.emit("cloned", at, t.item, "copy")), Z = t.source, tt = t.item, it = ut = m(t.item), dt.dragging = !0, dt.emit("drag", tt, Z);
				}function A() {
					return !1;
				}function N() {
					if (dt.dragging) {
						var t = at || tt;I(t, p(t));
					}
				}function R() {
					st = !1, a(!0), h(!0);
				}function B(t) {
					if (R(), dt.dragging) {
						var e = at || tt,
						    n = b("clientX", t),
						    r = b("clientY", t),
						    o = c(Q, n, r),
						    i = H(o, n, r);i && (at && lt.copySortSource || !at || i !== Z) ? I(e, i) : lt.removeOnSpill ? F() : D();
					}
				}function I(t, e) {
					var n = p(t);at && lt.copySortSource && e === Z && n.removeChild(tt), z(e) ? dt.emit("cancel", t, Z, Z) : dt.emit("drop", t, e, Z, ut), U();
				}function F() {
					if (dt.dragging) {
						var t = at || tt,
						    e = p(t);e && e.removeChild(t), dt.emit(at ? "cancel" : "remove", t, e, Z), U();
					}
				}function D(t) {
					if (dt.dragging) {
						var e = arguments.length > 0 ? t : lt.revertOnSpill,
						    n = at || tt,
						    r = p(n),
						    o = z(r);o === !1 && e && (at ? r && r.removeChild(at) : Z.insertBefore(n, it)), o || e ? dt.emit("cancel", n, Z, Z) : dt.emit("drop", n, r, Z, ut), U();
					}
				}function U() {
					var t = at || tt;R(), V(), t && E.rm(t, "gu-transit"), ct && clearTimeout(ct), dt.dragging = !1, ft && dt.emit("out", t, ft, Z), dt.emit("dragend", t), Z = tt = at = it = ut = ct = ft = null;
				}function z(t, e) {
					var n;return n = void 0 !== e ? e : Q ? ut : m(at || tt), t === Z && n === it;
				}function H(t, e, r) {
					function o() {
						var o = n(i);if (o === !1) return !1;var u = q(i, t),
						    a = K(i, u, e, r),
						    c = z(i, a);return !!c || lt.accepts(tt, i, Z, a);
					}for (var i = t; i && !o();) {
						i = p(i);
					}return i;
				}function Y(t) {
					function e(t) {
						dt.emit(t, s, ft, Z);
					}function n() {
						d && e("over");
					}function r() {
						ft && e("out");
					}if (Q) {
						t.preventDefault();var o = b("clientX", t),
						    i = b("clientY", t),
						    u = o - et,
						    a = i - nt;Q.style.left = u + "px", Q.style.top = a + "px";var s = at || tt,
						    f = c(Q, o, i),
						    l = H(f, o, i),
						    d = null !== l && l !== ft;(d || null === l) && (r(), ft = l, n());var v = p(s);if (l === Z && at && !lt.copySortSource) return void (v && v.removeChild(s));var h,
						    y = q(l, f);if (null !== y) h = K(l, y, o, i);else {
							if (lt.revertOnSpill !== !0 || at) return void (at && v && v.removeChild(s));h = it, l = Z;
						}if (null === h && d || h !== s && h !== m(s)) {
							ut = h;var w,
							    x = s.parentElement === l,
							    E = x && lt.animation,
							    S = s.getBoundingClientRect(),
							    T = lt.direction,
							    _ = "horizontal" === T ? t.pageX : t.pageY;if (w = _ < O ? h : h ? h.previousElementSibling ? h.previousElementSibling : h : l.lastElementChild, O = _, !w) return;if (lt.staticClass && w.classList.contains(lt.staticClass)) return;var C = w && w.getBoundingClientRect();l.insertBefore(s, h), E && w && C && (g(C, w, lt.animation), g(S, s, lt.animation)), dt.emit("shadow", s, l, Z);
						}
					}
				}function X(t) {
					E.rm(t, "gu-hide");
				}function W(t) {
					dt.dragging && E.add(t, "gu-hide");
				}function G() {
					if (!Q) {
						var t = tt.getBoundingClientRect();Q = tt.cloneNode(!0), Q.style.width = l(t) + "px", Q.style.height = d(t) + "px", E.rm(Q, "gu-transit"), E.add(Q, "gu-mirror"), lt.mirrorContainer.appendChild(Q), o(T, "add", "mousemove", Y), E.add(lt.mirrorContainer, "gu-unselectable"), dt.emit("cloned", Q, tt, "mirror");
					}
				}function V() {
					Q && (E.rm(lt.mirrorContainer, "gu-unselectable"), o(T, "remove", "mousemove", Y), p(Q).removeChild(Q), Q = null);
				}function q(t, e) {
					for (var n = e; n !== t && p(n) !== t;) {
						n = p(n);
					}return n === T ? null : n;
				}function K(t, e, n, r) {
					function o() {
						var e,
						    o,
						    i,
						    u = t.children.length;for (e = 0; e < u; e++) {
							if (o = t.children[e], i = o.getBoundingClientRect(), a && i.left + i.width / 2 > n) return o;if (!a && i.top + i.height / 2 > r) return o;
						}return null;
					}function i() {
						var t = e.getBoundingClientRect();return u(a ? n > t.left + l(t) / 2 : r > t.top + d(t) / 2);
					}function u(t) {
						return t ? m(e) : e;
					}var a = "horizontal" === lt.direction,
					    c = e !== t ? i() : o();return c;
				}function J(t, e) {
					return "boolean" == typeof lt.copy ? lt.copy : lt.copy(t, e);
				}var $ = arguments.length;1 === $ && Array.isArray(t) === !1 && (e = t, t = []);var Q,
				    Z,
				    tt,
				    et,
				    nt,
				    rt,
				    ot,
				    it,
				    ut,
				    at,
				    ct,
				    st,
				    ft = null,
				    lt = e || {};void 0 === lt.moves && (lt.moves = f), void 0 === lt.accepts && (lt.accepts = f), void 0 === lt.invalid && (lt.invalid = A), void 0 === lt.containers && (lt.containers = t || []), void 0 === lt.isContainer && (lt.isContainer = s), void 0 === lt.copy && (lt.copy = !1), void 0 === lt.copySortSource && (lt.copySortSource = !1), void 0 === lt.revertOnSpill && (lt.revertOnSpill = !1), void 0 === lt.removeOnSpill && (lt.removeOnSpill = !1), void 0 === lt.direction && (lt.direction = "vertical"), void 0 === lt.ignoreInputTextSelection && (lt.ignoreInputTextSelection = !0), void 0 === lt.mirrorContainer && (lt.mirrorContainer = S.body), void 0 === lt.animation && (lt.animation = !1), void 0 === lt.staticClass && (lt.staticClass = "");var dt = w({ containers: lt.containers, start: k, end: N, cancel: D, remove: F, destroy: y, canMove: j, dragging: !1 });return lt.removeOnSpill === !0 && dt.on("over", X).on("out", W), r(), dt;
			}function o(t, n, r, o) {
				var i = { mouseup: "touchend", mousedown: "touchstart", mousemove: "touchmove" },
				    u = { mouseup: "pointerup", mousedown: "pointerdown", mousemove: "pointermove" },
				    a = { mouseup: "MSPointerUp", mousedown: "MSPointerDown", mousemove: "MSPointerMove" };e.navigator.pointerEnabled ? x[n](t, u[r], o) : e.navigator.msPointerEnabled ? x[n](t, a[r], o) : (x[n](t, i[r], o), x[n](t, r, o));
			}function i(t) {
				if (void 0 !== t.touches) return t.touches.length;if (void 0 !== t.which && 0 !== t.which) return t.which;if (void 0 !== t.buttons) return t.buttons;var e = t.button;return void 0 !== e ? 1 & e ? 1 : 2 & e ? 3 : 4 & e ? 2 : 0 : void 0;
			}function u(t) {
				var e = t.getBoundingClientRect();return { left: e.left + a("scrollLeft", "pageXOffset"), top: e.top + a("scrollTop", "pageYOffset") };
			}function a(t, n) {
				return "undefined" != typeof e[n] ? e[n] : T.clientHeight ? T[t] : S.body[t];
			}function c(t, e, n) {
				var r,
				    o = t || {},
				    i = o.className;return o.className += " gu-hide", r = S.elementFromPoint(e, n), o.className = i, r;
			}function s() {
				return !1;
			}function f() {
				return !0;
			}function l(t) {
				return t.width || t.right - t.left;
			}function d(t) {
				return t.height || t.bottom - t.top;
			}function p(t) {
				return t.parentNode === S ? null : t.parentNode;
			}function v(t) {
				return "INPUT" === t.tagName || "TEXTAREA" === t.tagName || "SELECT" === t.tagName || h(t);
			}function h(t) {
				return !!t && "false" !== t.contentEditable && ("true" === t.contentEditable || h(p(t)));
			}function m(t) {
				function e() {
					var e = t;do {
						e = e.nextSibling;
					} while (e && 1 !== e.nodeType);return e;
				}return t.nextElementSibling || e();
			}function g(t, e, n) {
				if (n) {
					if (!t || !e) return;var r = e.getBoundingClientRect();e.style.transition = "none", e.style.transform = "translate3d(" + (t.left - r.left) + "px," + (t.top - r.top) + "px,0)", e.offsetWidth, e.style.transition = "all " + n + "ms", e.style.transform = "translate3d(0,0,0)", clearTimeout(e.animated), e.animated = setTimeout(function () {
						e.style.transition = "", e.style.transform = "", e.animated = !1;
					}, n);
				}
			}function y(t) {
				return t.targetTouches && t.targetTouches.length ? t.targetTouches[0] : t.changedTouches && t.changedTouches.length ? t.changedTouches[0] : t;
			}function b(t, e) {
				var n = y(e),
				    r = { pageX: "clientX", pageY: "clientY" };return t in r && !(t in n) && r[t] in n && (t = r[t]), n[t];
			}var w = n(96),
			    x = n(103),
			    E = n(106),
			    S = document,
			    T = S.documentElement,
			    O = 0;t.exports = r;
		}).call(e, function () {
			return this;
		}());
	}, function (t, e, n) {
		"use strict";
		var r = n(97),
		    o = n(98);t.exports = function (t, e) {
			var n = e || {},
			    i = {};return void 0 === t && (t = {}), t.on = function (e, n) {
				return i[e] ? i[e].push(n) : i[e] = [n], t;
			}, t.once = function (e, n) {
				return n._once = !0, t.on(e, n), t;
			}, t.off = function (e, n) {
				var r = arguments.length;if (1 === r) delete i[e];else if (0 === r) i = {};else {
					var o = i[e];if (!o) return t;o.splice(o.indexOf(n), 1);
				}return t;
			}, t.emit = function () {
				var e = r(arguments);return t.emitterSnapshot(e.shift()).apply(this, e);
			}, t.emitterSnapshot = function (e) {
				var u = (i[e] || []).slice(0);return function () {
					var i = r(arguments),
					    a = this || t;if ("error" === e && n.throws !== !1 && !u.length) throw 1 === i.length ? i[0] : i;return u.forEach(function (r) {
						n.async ? o(r, i, a) : r.apply(a, i), r._once && t.off(e, r);
					}), t;
				};
			}, t;
		};
	}, function (t, e) {
		t.exports = function (t, e) {
			return Array.prototype.slice.call(t, e);
		};
	}, function (t, e, n) {
		"use strict";
		var r = n(99);t.exports = function (t, e, n) {
			t && r(function () {
				t.apply(n || null, e || []);
			});
		};
	}, function (t, e, n) {
		(function (e) {
			var n,
			    r = "function" == typeof e;n = r ? function (t) {
				e(t);
			} : function (t) {
				setTimeout(t, 0);
			}, t.exports = n;
		}).call(e, n(100).setImmediate);
	}, function (t, e, n) {
		function r(t, e) {
			this._id = t, this._clearFn = e;
		}var o = Function.prototype.apply;e.setTimeout = function () {
			return new r(o.call(setTimeout, window, arguments), clearTimeout);
		}, e.setInterval = function () {
			return new r(o.call(setInterval, window, arguments), clearInterval);
		}, e.clearTimeout = e.clearInterval = function (t) {
			t && t.close();
		}, r.prototype.unref = r.prototype.ref = function () {}, r.prototype.close = function () {
			this._clearFn.call(window, this._id);
		}, e.enroll = function (t, e) {
			clearTimeout(t._idleTimeoutId), t._idleTimeout = e;
		}, e.unenroll = function (t) {
			clearTimeout(t._idleTimeoutId), t._idleTimeout = -1;
		}, e._unrefActive = e.active = function (t) {
			clearTimeout(t._idleTimeoutId);var e = t._idleTimeout;e >= 0 && (t._idleTimeoutId = setTimeout(function () {
				t._onTimeout && t._onTimeout();
			}, e));
		}, n(101), e.setImmediate = setImmediate, e.clearImmediate = clearImmediate;
	}, function (t, e, n) {
		(function (t, e) {
			!function (t, n) {
				"use strict";
				function r(t) {
					"function" != typeof t && (t = new Function("" + t));for (var e = new Array(arguments.length - 1), n = 0; n < e.length; n++) {
						e[n] = arguments[n + 1];
					}var r = { callback: t, args: e };return h[v] = r, p(v), v++;
				}function o(t) {
					delete h[t];
				}function i(t) {
					var e = t.callback,
					    r = t.args;switch (r.length) {case 0:
							e();break;case 1:
							e(r[0]);break;case 2:
							e(r[0], r[1]);break;case 3:
							e(r[0], r[1], r[2]);break;default:
							e.apply(n, r);}
				}function u(t) {
					if (m) setTimeout(u, 0, t);else {
						var e = h[t];if (e) {
							m = !0;try {
								i(e);
							} finally {
								o(t), m = !1;
							}
						}
					}
				}function a() {
					p = function p(t) {
						e.nextTick(function () {
							u(t);
						});
					};
				}function c() {
					if (t.postMessage && !t.importScripts) {
						var e = !0,
						    n = t.onmessage;return t.onmessage = function () {
							e = !1;
						}, t.postMessage("", "*"), t.onmessage = n, e;
					}
				}function s() {
					var e = "setImmediate$" + Math.random() + "$",
					    n = function n(_n) {
						_n.source === t && "string" == typeof _n.data && 0 === _n.data.indexOf(e) && u(+_n.data.slice(e.length));
					};t.addEventListener ? t.addEventListener("message", n, !1) : t.attachEvent("onmessage", n), p = function p(n) {
						t.postMessage(e + n, "*");
					};
				}function f() {
					var t = new MessageChannel();t.port1.onmessage = function (t) {
						var e = t.data;u(e);
					}, p = function p(e) {
						t.port2.postMessage(e);
					};
				}function l() {
					var t = g.documentElement;p = function p(e) {
						var n = g.createElement("script");n.onreadystatechange = function () {
							u(e), n.onreadystatechange = null, t.removeChild(n), n = null;
						}, t.appendChild(n);
					};
				}function d() {
					p = function p(t) {
						setTimeout(u, 0, t);
					};
				}if (!t.setImmediate) {
					var p,
					    v = 1,
					    h = {},
					    m = !1,
					    g = t.document,
					    y = Object.getPrototypeOf && Object.getPrototypeOf(t);y = y && y.setTimeout ? y : t, "[object process]" === {}.toString.call(t.process) ? a() : c() ? s() : t.MessageChannel ? f() : g && "onreadystatechange" in g.createElement("script") ? l() : d(), y.setImmediate = r, y.clearImmediate = o;
				}
			}("undefined" == typeof self ? "undefined" == typeof t ? this : t : self);
		}).call(e, function () {
			return this;
		}(), n(102));
	}, function (t, e) {
		function n() {
			throw new Error("setTimeout has not been defined");
		}function r() {
			throw new Error("clearTimeout has not been defined");
		}function o(t) {
			if (f === setTimeout) return setTimeout(t, 0);if ((f === n || !f) && setTimeout) return f = setTimeout, setTimeout(t, 0);try {
				return f(t, 0);
			} catch (e) {
				try {
					return f.call(null, t, 0);
				} catch (e) {
					return f.call(this, t, 0);
				}
			}
		}function i(t) {
			if (l === clearTimeout) return clearTimeout(t);if ((l === r || !l) && clearTimeout) return l = clearTimeout, clearTimeout(t);try {
				return l(t);
			} catch (e) {
				try {
					return l.call(null, t);
				} catch (e) {
					return l.call(this, t);
				}
			}
		}function u() {
			h && p && (h = !1, p.length ? v = p.concat(v) : m = -1, v.length && a());
		}function a() {
			if (!h) {
				var t = o(u);h = !0;for (var e = v.length; e;) {
					for (p = v, v = []; ++m < e;) {
						p && p[m].run();
					}m = -1, e = v.length;
				}p = null, h = !1, i(t);
			}
		}function c(t, e) {
			this.fun = t, this.array = e;
		}function s() {}var f,
		    l,
		    d = t.exports = {};!function () {
			try {
				f = "function" == typeof setTimeout ? setTimeout : n;
			} catch (t) {
				f = n;
			}try {
				l = "function" == typeof clearTimeout ? clearTimeout : r;
			} catch (t) {
				l = r;
			}
		}();var p,
		    v = [],
		    h = !1,
		    m = -1;d.nextTick = function (t) {
			var e = new Array(arguments.length - 1);if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) {
				e[n - 1] = arguments[n];
			}v.push(new c(t, e)), 1 !== v.length || h || o(a);
		}, c.prototype.run = function () {
			this.fun.apply(null, this.array);
		}, d.title = "browser", d.browser = !0, d.env = {}, d.argv = [], d.version = "", d.versions = {}, d.on = s, d.addListener = s, d.once = s, d.off = s, d.removeListener = s, d.removeAllListeners = s, d.emit = s, d.prependListener = s, d.prependOnceListener = s, d.listeners = function (t) {
			return [];
		}, d.binding = function (t) {
			throw new Error("process.binding is not supported");
		}, d.cwd = function () {
			return "/";
		}, d.chdir = function (t) {
			throw new Error("process.chdir is not supported");
		}, d.umask = function () {
			return 0;
		};
	}, function (t, e, n) {
		(function (e) {
			"use strict";
			function r(t, e, n, r) {
				return t.addEventListener(e, n, r);
			}function o(t, e, n) {
				return t.attachEvent("on" + e, s(t, e, n));
			}function i(t, e, n, r) {
				return t.removeEventListener(e, n, r);
			}function u(t, e, n) {
				var r = f(t, e, n);if (r) return t.detachEvent("on" + e, r);
			}function a(t, e, n) {
				function r() {
					var t;return v.createEvent ? (t = v.createEvent("Event"), t.initEvent(e, !0, !0)) : v.createEventObject && (t = v.createEventObject()), t;
				}function o() {
					return new d(e, { detail: n });
				}var i = p.indexOf(e) === -1 ? o() : r();t.dispatchEvent ? t.dispatchEvent(i) : t.fireEvent("on" + e, i);
			}function c(t, n, r) {
				return function (n) {
					var o = n || e.event;o.target = o.target || o.srcElement, o.preventDefault = o.preventDefault || function () {
						o.returnValue = !1;
					}, o.stopPropagation = o.stopPropagation || function () {
						o.cancelBubble = !0;
					}, o.which = o.which || o.keyCode, r.call(t, o);
				};
			}function s(t, e, n) {
				var r = f(t, e, n) || c(t, e, n);return g.push({ wrapper: r, element: t, type: e, fn: n }), r;
			}function f(t, e, n) {
				var r = l(t, e, n);if (r) {
					var o = g[r].wrapper;return g.splice(r, 1), o;
				}
			}function l(t, e, n) {
				var r, o;for (r = 0; r < g.length; r++) {
					if (o = g[r], o.element === t && o.type === e && o.fn === n) return r;
				}
			}var d = n(104),
			    p = n(105),
			    v = e.document,
			    h = r,
			    m = i,
			    g = [];e.addEventListener || (h = o, m = u), t.exports = { add: h, remove: m, fabricate: a };
		}).call(e, function () {
			return this;
		}());
	}, function (t, e) {
		(function (e) {
			function n() {
				try {
					var t = new r("cat", { detail: { foo: "bar" } });return "cat" === t.type && "bar" === t.detail.foo;
				} catch (t) {}return !1;
			}var r = e.CustomEvent;t.exports = n() ? r : "function" == typeof document.createEvent ? function (t, e) {
				var n = document.createEvent("CustomEvent");return e ? n.initCustomEvent(t, e.bubbles, e.cancelable, e.detail) : n.initCustomEvent(t, !1, !1, void 0), n;
			} : function (t, e) {
				var n = document.createEventObject();return n.type = t, e ? (n.bubbles = Boolean(e.bubbles), n.cancelable = Boolean(e.cancelable), n.detail = e.detail) : (n.bubbles = !1, n.cancelable = !1, n.detail = void 0), n;
			};
		}).call(e, function () {
			return this;
		}());
	}, function (t, e) {
		(function (e) {
			"use strict";
			var n = [],
			    r = "",
			    o = /^on/;for (r in e) {
				o.test(r) && n.push(r.slice(2));
			}t.exports = n;
		}).call(e, function () {
			return this;
		}());
	}, function (t, e) {
		"use strict";
		function n(t) {
			var e = i[t];return e ? e.lastIndex = 0 : i[t] = e = new RegExp(u + t + a, "g"), e;
		}function r(t, e) {
			var r = t.className;r.length ? n(e).test(r) || (t.className += " " + e) : t.className = e;
		}function o(t, e) {
			t.className = t.className.replace(n(e), " ").trim();
		}var i = {},
		    u = "(?:^|\\s)",
		    a = "(?:\\s|$)";t.exports = { add: r, rm: o };
	}, function (t, e) {
		"use strict";
		Object.defineProperty(e, "__esModule", { value: !0 }), e.default = { originTable: "sindu_origin_table", draggableTable: "sindu_dragger", dragging: "sindu_dragging", static: "sindu_static", handle: "sindu_handle" };
	}, function (t, e, n) {
		"use strict";
		function r(t) {
			return t && t.__esModule ? t : { default: t };
		}Object.defineProperty(e, "__esModule", { value: !0 }), e.getScrollBarWidth = e.sort = e.insertBeforeSibling = e.appendSibling = e.remove = e.on = e.empty = e.css = e.getLongestRow = e.touchy = e.getTouchyEvent = void 0;var o = n(109),
		    i = r(o),
		    u = n(78),
		    a = r(u),
		    c = n(113),
		    s = r(c),
		    f = window,
		    l = { mouseup: "touchend", mousedown: "touchstart", mousemove: "touchmove" },
		    d = { mouseup: "pointerup", mousedown: "pointerdown", mousemove: "pointermove" },
		    p = (e.getTouchyEvent = function () {
			var t = void 0;return f.navigator.pointerEnabled && (document.createEvent ? (t = document.createEvent("PointerEvent"), t.initMouseEvent("pointerdown", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null)) : t = new PointerEvent("pointerdown", { cancelable: !0, bubbles: !0, view: window })), document.createEvent ? (t = document.createEvent("MouseEvent"), t.initMouseEvent("mousedown", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null)) : t = new MouseEvent("mousedown", { view: window, bubbles: !0, cancelable: !0 }), t;
		}, e.touchy = function (t, e, n, r) {
			f.navigator.pointerEnabled ? s.default[e](t, d[n], r) : (s.default[e](t, l[n], r), s.default[e](t, n, r));
		}, e.getLongestRow = function (t) {
			var e = t.rows[0];return (0, a.default)(t.rows).forEach(function (t) {
				var n = t.children.length,
				    r = e.children.length;e = n > r ? t : e;
			}), e;
		}, e.css = function (t, e) {
			return (0, i.default)(e).forEach(function (n) {
				t.style[n] = e[n];
			}), t;
		}, e.empty = function (t) {
			for (; t.firstChild;) {
				t.removeChild(t.firstChild);
			}
		}, e.on = function (t, e, n) {
			t.addEventListener(e, n);
		}, e.remove = function (t, e, n) {
			t.removeEventListener(e, n);
		}, e.appendSibling = function (t) {
			var e = t.target,
			    n = t.origin,
			    r = t.parent;e && (r || e.parentNode).insertBefore(e, n ? n.nextElementSibling : null);
		}),
		    v = e.insertBeforeSibling = function (t) {
			var e = t.target,
			    n = t.origin;e && n.parentNode.insertBefore(e, n);
		};e.sort = function (t) {
			var e = t.list,
			    n = t.from,
			    r = t.to,
			    o = t.parent;n < r ? p({ target: e[n], origin: e[r], parent: o }) : v({ target: e[n], origin: e[r] });
		}, e.getScrollBarWidth = function () {
			if (document.documentElement.scrollHeight <= document.documentElement.clientHeight) return 0;var t = document.createElement("p");t.style.width = "100%", t.style.height = "200px";var e = document.createElement("div");e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", e.style.visibility = "hidden", e.style.width = "200px", e.style.height = "150px", e.style.overflow = "hidden", e.appendChild(t), document.body.appendChild(e);var n = t.offsetWidth;e.style.overflow = "scroll";var r = t.offsetWidth;return n === r && (r = e.clientWidth), document.body.removeChild(e), n - r;
		};
	}, function (t, e, n) {
		t.exports = { default: n(110), __esModule: !0 };
	}, function (t, e, n) {
		n(111), t.exports = n(17).Object.keys;
	}, function (t, e, n) {
		var r = n(52),
		    o = n(36);n(112)("keys", function () {
			return function (t) {
				return o(r(t));
			};
		});
	}, function (t, e, n) {
		var r = n(15),
		    o = n(17),
		    i = n(26);t.exports = function (t, e) {
			var n = (o.Object || {})[t] || Object[t],
			    u = {};u[t] = e(n), r(r.S + r.F * i(function () {
				n(1);
			}), "Object", u);
		};
	}, function (t, e, n) {
		(function (e) {
			"use strict";
			function r(t, e, n, r) {
				return t.addEventListener(e, n, r);
			}function o(t, e, n) {
				return t.attachEvent("on" + e, s(t, e, n));
			}function i(t, e, n, r) {
				return t.removeEventListener(e, n, r);
			}function u(t, e, n) {
				var r = f(t, e, n);if (r) return t.detachEvent("on" + e, r);
			}function a(t, e, n) {
				function r() {
					var t;return v.createEvent ? (t = v.createEvent("Event"), t.initEvent(e, !0, !0)) : v.createEventObject && (t = v.createEventObject()), t;
				}function o() {
					return new d(e, { detail: n });
				}var i = p.indexOf(e) === -1 ? o() : r();t.dispatchEvent ? t.dispatchEvent(i) : t.fireEvent("on" + e, i);
			}function c(t, n, r) {
				return function (n) {
					var o = n || e.event;o.target = o.target || o.srcElement, o.preventDefault = o.preventDefault || function () {
						o.returnValue = !1;
					}, o.stopPropagation = o.stopPropagation || function () {
						o.cancelBubble = !0;
					}, o.which = o.which || o.keyCode, r.call(t, o);
				};
			}function s(t, e, n) {
				var r = f(t, e, n) || c(t, e, n);return g.push({ wrapper: r, element: t, type: e, fn: n }), r;
			}function f(t, e, n) {
				var r = l(t, e, n);if (r) {
					var o = g[r].wrapper;return g.splice(r, 1), o;
				}
			}function l(t, e, n) {
				var r, o;for (r = 0; r < g.length; r++) {
					if (o = g[r], o.element === t && o.type === e && o.fn === n) return r;
				}
			}var d = n(114),
			    p = n(115),
			    v = e.document,
			    h = r,
			    m = i,
			    g = [];e.addEventListener || (h = o, m = u), t.exports = { add: h, remove: m, fabricate: a };
		}).call(e, function () {
			return this;
		}());
	}, function (t, e) {
		(function (e) {
			function n() {
				try {
					var t = new r("cat", { detail: { foo: "bar" } });return "cat" === t.type && "bar" === t.detail.foo;
				} catch (t) {}return !1;
			}var r = e.CustomEvent;t.exports = n() ? r : "undefined" != typeof document && "function" == typeof document.createEvent ? function (t, e) {
				var n = document.createEvent("CustomEvent");return e ? n.initCustomEvent(t, e.bubbles, e.cancelable, e.detail) : n.initCustomEvent(t, !1, !1, void 0), n;
			} : function (t, e) {
				var n = document.createEventObject();return n.type = t, e ? (n.bubbles = Boolean(e.bubbles), n.cancelable = Boolean(e.cancelable), n.detail = e.detail) : (n.bubbles = !1, n.cancelable = !1, n.detail = void 0), n;
			};
		}).call(e, function () {
			return this;
		}());
	}, function (t, e) {
		(function (e) {
			"use strict";
			var n = [],
			    r = "",
			    o = /^on/;for (r in e) {
				o.test(r) && n.push(r.slice(2));
			}t.exports = n;
		}).call(e, function () {
			return this;
		}());
	}]);
});
/*!
 * VERSION: 0.8.4
 * DATE: 2016-02-16
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * This is a special version of the plugin that is only to be used on certain sites like codepen.io. It will redirect to a page on GreenSock.com if you try using it on a different domain. Please sign up for Club GreenSock to get the fully-functional version at http://greensock.com/club/
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * MorphSVGPlugin is a Club GreenSock membership benefit; You must have a valid membership to use
 * this code without violating the terms of use. Visit http://greensock.com/club/ to sign up or get more details.
 * For licensing details, see http://greensock.com/licensing/
 *
 * @author: Jack Doyle, jack@greensock.com
 */
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
	"use strict";

	var a = Math.PI / 180,
	    b = 180 / Math.PI,
	    c = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
	    d = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
	    e = /[achlmqstvz]/gi,
	    f = /\d+e[\-\+]\d+/gi,
	    g = _gsScope._gsDefine.globals.TweenLite,
	    h = "codepen",
	    i = "MorphSVGPlugin",
	    j = String.fromCharCode(103, 114, 101, 101, 110, 115, 111, 99, 107, 46, 99, 111, 109),
	    k = String.fromCharCode(47, 114, 101, 113, 117, 105, 114, 101, 115, 45, 109, 101, 109, 98, 101, 114, 115, 104, 105, 112, 47),
	    l = function (a) {
		return !0;
	}(window ? window.location.host : ""),
	    m = function m(a) {
		window.console && console.log(a);
	},
	    n = function n(b, c) {
		var g,
		    h,
		    i,
		    j,
		    k,
		    l,
		    d = Math.ceil(Math.abs(c) / 90),
		    e = 0,
		    f = [];
		for (b *= a, c *= a, g = c / d, h = 4 / 3 * Math.sin(g / 2) / (1 + Math.cos(g / 2)), l = 0; d > l; l++) {
			i = b + l * g, j = Math.cos(i), k = Math.sin(i), f[e++] = j - h * k, f[e++] = k + h * j, i += g, j = Math.cos(i), k = Math.sin(i), f[e++] = j + h * k, f[e++] = k - h * j, f[e++] = j, f[e++] = k;
		}return f;
	},
	    o = function o(c, d, e, f, g, h, i, j, k) {
		if (c !== j || d !== k) {
			e = Math.abs(e), f = Math.abs(f);
			var l = g % 360 * a,
			    m = Math.cos(l),
			    o = Math.sin(l),
			    p = (c - j) / 2,
			    q = (d - k) / 2,
			    r = m * p + o * q,
			    s = -o * p + m * q,
			    t = e * e,
			    u = f * f,
			    v = r * r,
			    w = s * s,
			    x = v / t + w / u;
			x > 1 && (e = Math.sqrt(x) * e, f = Math.sqrt(x) * f, t = e * e, u = f * f);
			var y = h === i ? -1 : 1,
			    z = (t * u - t * w - u * v) / (t * w + u * v);
			0 > z && (z = 0);
			var A = y * Math.sqrt(z),
			    B = A * (e * s / f),
			    C = A * -(f * r / e),
			    D = (c + j) / 2,
			    E = (d + k) / 2,
			    F = D + (m * B - o * C),
			    G = E + (o * B + m * C),
			    H = (r - B) / e,
			    I = (s - C) / f,
			    J = (-r - B) / e,
			    K = (-s - C) / f,
			    L = Math.sqrt(H * H + I * I),
			    M = H;
			y = 0 > I ? -1 : 1;
			var N = y * Math.acos(M / L) * b;
			L = Math.sqrt((H * H + I * I) * (J * J + K * K)), M = H * J + I * K, y = 0 > H * K - I * J ? -1 : 1;
			var O = y * Math.acos(M / L) * b;!i && O > 0 ? O -= 360 : i && 0 > O && (O += 360), O %= 360, N %= 360;
			var V,
			    W,
			    X,
			    P = n(N, O),
			    Q = m * e,
			    R = o * e,
			    S = o * -f,
			    T = m * f,
			    U = P.length - 2;
			for (V = 0; U > V; V += 2) {
				W = P[V], X = P[V + 1], P[V] = W * Q + X * S + F, P[V + 1] = W * R + X * T + G;
			}return P[P.length - 2] = j, P[P.length - 1] = k, P;
		}
	},
	    p = function p(a) {
		var k,
		    l,
		    n,
		    p,
		    q,
		    r,
		    s,
		    t,
		    u,
		    v,
		    w,
		    x,
		    y,
		    b = (a + "").replace(f, function (a) {
			var b = +a;
			return 1e-4 > b && b > -1e-4 ? 0 : a;
		}).match(c) || [],
		    d = [],
		    e = 0,
		    g = 0,
		    h = b.length,
		    i = 2,
		    j = 0;
		if (!a || !isNaN(b[0]) || isNaN(b[1])) return m("ERROR: malformed path data: " + a), d;
		for (k = 0; h > k; k++) {
			if (y = q, isNaN(b[k]) ? (q = b[k].toUpperCase(), r = q !== b[k]) : k--, n = +b[k + 1], p = +b[k + 2], r && (n += e, p += g), 0 === k && (t = n, u = p), "M" === q) s && s.length < 8 && (d.length -= 1, i = 0), e = t = n, g = u = p, s = [n, p], j += i, i = 2, d.push(s), k += 2, q = "L";else if ("C" === q) s || (s = [0, 0]), s[i++] = n, s[i++] = p, r || (e = g = 0), s[i++] = e + 1 * b[k + 3], s[i++] = g + 1 * b[k + 4], s[i++] = e += 1 * b[k + 5], s[i++] = g += 1 * b[k + 6], k += 6;else if ("S" === q) "C" === y || "S" === y ? (v = e - s[i - 4], w = g - s[i - 3], s[i++] = e + v, s[i++] = g + w) : (s[i++] = e, s[i++] = g), s[i++] = n, s[i++] = p, r || (e = g = 0), s[i++] = e += 1 * b[k + 3], s[i++] = g += 1 * b[k + 4], k += 4;else if ("Q" === q) v = n - e, w = p - g, s[i++] = e + 2 * v / 3, s[i++] = g + 2 * w / 3, r || (e = g = 0), e += 1 * b[k + 3], g += 1 * b[k + 4], v = n - e, w = p - g, s[i++] = e + 2 * v / 3, s[i++] = g + 2 * w / 3, s[i++] = e, s[i++] = g, k += 4;else if ("T" === q) v = e - s[i - 4], w = g - s[i - 3], s[i++] = e + v, s[i++] = g + w, v = e + 1.5 * v - n, w = g + 1.5 * w - p, s[i++] = n + 2 * v / 3, s[i++] = p + 2 * w / 3, s[i++] = e = n, s[i++] = g = p, k += 2;else if ("H" === q) p = g, s[i++] = e + (n - e) / 3, s[i++] = g + (p - g) / 3, s[i++] = e + 2 * (n - e) / 3, s[i++] = g + 2 * (p - g) / 3, s[i++] = e = n, s[i++] = p, k += 1;else if ("V" === q) p = n, n = e, r && (p += g - e), s[i++] = n, s[i++] = g + (p - g) / 3, s[i++] = n, s[i++] = g + 2 * (p - g) / 3, s[i++] = n, s[i++] = g = p, k += 1;else if ("L" === q || "Z" === q) "Z" === q && (n = t, p = u, s.closed = !0), ("L" === q || Math.abs(e - n) > .5 || Math.abs(g - p) > .5) && (s[i++] = e + (n - e) / 3, s[i++] = g + (p - g) / 3, s[i++] = e + 2 * (n - e) / 3, s[i++] = g + 2 * (p - g) / 3, s[i++] = n, s[i++] = p, "L" === q && (k += 2)), e = n, g = p;else if ("A" === q) {
				for (x = o(e, g, 1 * b[k + 1], 1 * b[k + 2], 1 * b[k + 3], 1 * b[k + 4], 1 * b[k + 5], (r ? e : 0) + 1 * b[k + 6], (r ? g : 0) + 1 * b[k + 7]), l = 0; l < x.length; l++) {
					s[i++] = x[l];
				}e = s[i - 2], g = s[i - 1], k += 7;
			} else m("Error: malformed path data: " + a);
		}return d.totalPoints = j + i, d;
	},
	    q = function q(a, b) {
		var g,
		    h,
		    i,
		    j,
		    k,
		    l,
		    m,
		    n,
		    o,
		    p,
		    q,
		    r,
		    s,
		    t,
		    c = 0,
		    d = .999999,
		    e = a.length,
		    f = b / ((e - 2) / 6);
		for (s = 2; e > s; s += 6) {
			for (c += f; c > d;) {
				g = a[s - 2], h = a[s - 1], i = a[s], j = a[s + 1], k = a[s + 2], l = a[s + 3], m = a[s + 4], n = a[s + 5], t = 1 / (Math.floor(c) + 1), o = g + (i - g) * t, q = i + (k - i) * t, o += (q - o) * t, q += (k + (m - k) * t - q) * t, p = h + (j - h) * t, r = j + (l - j) * t, p += (r - p) * t, r += (l + (n - l) * t - r) * t, a.splice(s, 4, g + (i - g) * t, h + (j - h) * t, o, p, o + (q - o) * t, p + (r - p) * t, q, r, k + (m - k) * t, l + (n - l) * t), s += 6, e += 6, c--;
			}
		}return a;
	},
	    r = function r(a) {
		var e,
		    f,
		    g,
		    h,
		    b = "",
		    c = a.length,
		    d = 100;
		for (f = 0; c > f; f++) {
			for (h = a[f], b += "M" + h[0] + "," + h[1] + " C", e = h.length, g = 2; e > g; g++) {
				b += (h[g++] * d | 0) / d + "," + (h[g++] * d | 0) / d + " " + (h[g++] * d | 0) / d + "," + (h[g++] * d | 0) / d + " " + (h[g++] * d | 0) / d + "," + (h[g] * d | 0) / d + " ";
			}h.closed && (b += "z");
		}
		return b;
	},
	    s = function s(a) {
		for (var b = [], c = a.length - 1, d = 0; --c > -1;) {
			b[d++] = a[c], b[d++] = a[c + 1], c--;
		}for (c = 0; d > c; c++) {
			a[c] = b[c];
		}a.reversed = a.reversed ? !1 : !0;
	},
	    t = function t(a) {
		var e,
		    b = a.length,
		    c = 0,
		    d = 0;
		for (e = 0; b > e; e++) {
			c += a[e++], d += a[e];
		}return [c / (b / 2), d / (b / 2)];
	},
	    u = function u(a) {
		var g,
		    h,
		    i,
		    b = a.length,
		    c = a[0],
		    d = c,
		    e = a[1],
		    f = e;
		for (i = 6; b > i; i += 6) {
			g = a[i], h = a[i + 1], g > c ? c = g : d > g && (d = g), h > e ? e = h : f > h && (f = h);
		}return a.centerX = (c + d) / 2, a.centerY = (e + f) / 2, a.size = (c - d) * (e - f);
	},
	    v = function v(a) {
		for (var g, h, i, j, k, b = a.length, c = a[0][0], d = c, e = a[0][1], f = e; --b > -1;) {
			for (k = a[b], g = k.length, j = 6; g > j; j += 6) {
				h = k[j], i = k[j + 1], h > c ? c = h : d > h && (d = h), i > e ? e = i : f > i && (f = i);
			}
		}return a.centerX = (c + d) / 2, a.centerY = (e + f) / 2, a.size = (c - d) * (e - f);
	},
	    w = function w(a, b) {
		return b.length - a.length;
	},
	    x = function x(a, b) {
		var c = a.size || u(a),
		    d = b.size || u(b);
		return Math.abs(d - c) < (c + d) / 20 ? b.centerX - a.centerX || b.centerY - a.centerY : d - c;
	},
	    y = function y(a, b) {
		var f,
		    g,
		    c = a.slice(0),
		    d = a.length,
		    e = d - 2;
		for (b = 0 | b, f = 0; d > f; f++) {
			g = (f + b) % e, a[f++] = c[g], a[f] = c[g + 1];
		}
	},
	    z = function z(a, b, c, d, e) {
		var i,
		    j,
		    k,
		    l,
		    f = a.length,
		    g = 0,
		    h = f - 2;
		for (c *= 6, j = 0; f > j; j += 6) {
			i = (j + c) % h, l = a[i] - (b[j] - d), k = a[i + 1] - (b[j + 1] - e), g += Math.sqrt(k * k + l * l);
		}return g;
	},
	    A = function A(a, b, c) {
		var k,
		    l,
		    m,
		    d = a.length,
		    e = t(a),
		    f = t(b),
		    g = f[0] - e[0],
		    h = f[1] - e[1],
		    i = z(a, b, 0, g, h),
		    j = 0;
		for (m = 6; d > m; m += 6) {
			l = z(a, b, m / 6, g, h), i > l && (i = l, j = m);
		}if (c) for (k = a.slice(0), s(k), m = 6; d > m; m += 6) {
			l = z(k, b, m / 6, g, h), i > l && (i = l, j = -m);
		}return j / 6;
	},
	    B = function B(a, b, c) {
		for (var h, i, j, k, l, m, d = a.length, e = 99999999999, f = 0, g = 0; --d > -1;) {
			for (h = a[d], m = h.length, l = 0; m > l; l += 6) {
				i = h[l] - b, j = h[l + 1] - c, k = Math.sqrt(i * i + j * j), e > k && (e = k, f = h[l], g = h[l + 1]);
			}
		}return [f, g];
	},
	    C = function C(a, b, c, d, e, f) {
		var m,
		    n,
		    o,
		    p,
		    q,
		    g = b.length,
		    h = 0,
		    i = Math.min(a.size || u(a), b[c].size || u(b[c])) * d,
		    j = 999999999999,
		    k = a.centerX + e,
		    l = a.centerY + f;
		for (n = c; g > n && (m = b[n].size || u(b[n]), !(i > m)); n++) {
			o = b[n].centerX - k, p = b[n].centerY - l, q = Math.sqrt(o * o + p * p), j > q && (h = n, j = q);
		}return q = b[h], b.splice(h, 1), q;
	},
	    D = function D(a, b, c, d) {
		var p,
		    r,
		    t,
		    z,
		    D,
		    E,
		    F,
		    e = b.length - a.length,
		    f = e > 0 ? b : a,
		    g = e > 0 ? a : b,
		    h = 0,
		    i = "complexity" === d ? w : x,
		    j = "position" === d ? 0 : "number" == typeof d ? d : .8,
		    k = g.length,
		    l = "object" == (typeof c === "undefined" ? "undefined" : _typeof(c)) && c.push ? c.slice(0) : [c],
		    n = "reverse" === l[0] || l[0] < 0,
		    o = "log" === c;
		if (g[0]) {
			if (f.length > 1 && (a.sort(i), b.sort(i), E = f.size || v(f), E = g.size || v(g), E = f.centerX - g.centerX, F = f.centerY - g.centerY, i === x)) for (k = 0; k < g.length; k++) {
				f.splice(k, 0, C(g[k], f, k, j, E, F));
			}if (e) for (0 > e && (e = -e), f[0].length > g[0].length && q(g[0], (f[0].length - g[0].length) / 6 | 0), k = g.length; e > h;) {
				z = f[k].size || u(f[k]), t = B(g, f[k].centerX, f[k].centerY), z = t[0], D = t[1], g[k++] = [z, D, z, D, z, D, z, D], g.totalPoints += 8, h++;
			}for (k = 0; k < a.length; k++) {
				p = b[k], r = a[k], e = p.length - r.length, 0 > e ? q(p, -e / 6 | 0) : e > 0 && q(r, e / 6 | 0), n && !r.reversed && s(r), c = l[k] || 0 === l[k] ? l[k] : "auto", c && (r.closed || Math.abs(r[0] - r[r.length - 2]) < .5 && Math.abs(r[1] - r[r.length - 1]) < .5 ? "auto" === c || "log" === c ? (l[k] = c = A(r, p, 0 === k), 0 > c && (n = !0, s(r), c = -c), y(r, 6 * c)) : "reverse" !== c && (k && 0 > c && s(r), y(r, 6 * (0 > c ? -c : c))) : !n && ("auto" === c && Math.abs(p[0] - r[0]) + Math.abs(p[1] - r[1]) + Math.abs(p[p.length - 2] - r[r.length - 2]) + Math.abs(p[p.length - 1] - r[r.length - 1]) > Math.abs(p[0] - r[r.length - 2]) + Math.abs(p[1] - r[r.length - 1]) + Math.abs(p[p.length - 2] - r[0]) + Math.abs(p[p.length - 1] - r[1]) || c % 2) ? (s(r), l[k] = -1, n = !0) : "auto" === c ? l[k] = 0 : "reverse" === c && (l[k] = -1), r.closed !== p.closed && (r.closed = p.closed = !1));
			}return o && m("shapeIndex:[" + l.join(",") + "]"), l;
		}
	},
	    E = function E(a, b, c, d) {
		var e = p(a[0]),
		    f = p(a[1]);
		D(e, f, b || 0 === b ? b : "auto", c) && (a[0] = r(e), a[1] = r(f), ("log" === d || d === !0) && m('precompile:["' + a[0] + '","' + a[1] + '"]'));
	},
	    F = function F(a, b, c) {
		return b || c || a || 0 === a ? function (d) {
			E(d, a, b, c);
		} : E;
	},
	    G = function G(a, b) {
		if (!b) return a;
		var g,
		    h,
		    i,
		    c = a.match(d) || [],
		    e = c.length,
		    f = "";
		for ("reverse" === b ? (h = e - 1, g = -2) : (h = (2 * (parseInt(b, 10) || 0) + 1 + 100 * e) % e, g = 2), i = 0; e > i; i += 2) {
			f += c[h - 1] + "," + c[h] + " ", h = (h + g) % e;
		}return f;
	},
	    H = function H(a, b) {
		var h,
		    i,
		    j,
		    k,
		    l,
		    m,
		    n,
		    c = 0,
		    d = parseFloat(a[0]),
		    e = parseFloat(a[1]),
		    f = d + "," + e + " ",
		    g = .999999;
		for (j = a.length, h = .5 * b / (.5 * j - 1), i = 0; j - 2 > i; i += 2) {
			if (c += h, m = parseFloat(a[i + 2]), n = parseFloat(a[i + 3]), c > g) for (l = 1 / (Math.floor(c) + 1), k = 1; c > g;) {
				f += (d + (m - d) * l * k).toFixed(2) + "," + (e + (n - e) * l * k).toFixed(2) + " ", c--, k++;
			}f += m + "," + n + " ", d = m, e = n;
		}
		return f;
	},
	    I = function I(a) {
		var b = a[0].match(d) || [],
		    c = a[1].match(d) || [],
		    e = c.length - b.length;
		e > 0 ? a[0] = H(b, e) : a[1] = H(c, -e);
	},
	    J = function J(a) {
		return isNaN(a) ? I : function (b) {
			I(b), b[1] = G(b[1], parseInt(a, 10));
		};
	},
	    K = function K(a, b) {
		var c = document.createElementNS("http://www.w3.org/2000/svg", "path"),
		    d = Array.prototype.slice.call(a.attributes),
		    e = d.length;
		for (b = "," + b + ","; --e > -1;) {
			-1 === b.indexOf("," + d[e].nodeName + ",") && c.setAttributeNS(null, d[e].nodeName, d[e].nodeValue);
		}return c;
	},
	    L = function L(a, b) {
		var f,
		    g,
		    h,
		    i,
		    j,
		    k,
		    l,
		    m,
		    n,
		    o,
		    p,
		    q,
		    r,
		    s,
		    t,
		    u,
		    v,
		    w,
		    x,
		    y,
		    z,
		    c = a.tagName.toLowerCase(),
		    e = .552284749831;
		return "path" !== c && a.getBBox ? (k = K(a, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"), "rect" === c ? (i = +a.getAttribute("rx") || 0, j = +a.getAttribute("ry") || 0, g = +a.getAttribute("x") || 0, h = +a.getAttribute("y") || 0, o = (+a.getAttribute("width") || 0) - 2 * i, p = (+a.getAttribute("height") || 0) - 2 * j, i || j ? (q = g + i * (1 - e), r = g + i, s = r + o, t = s + i * e, u = s + i, v = h + j * (1 - e), w = h + j, x = w + p, y = x + j * e, z = x + j, f = "M" + u + "," + w + " V" + x + " C" + [u, y, t, z, s, z, s - (s - r) / 3, z, r + (s - r) / 3, z, r, z, q, z, g, y, g, x, g, x - (x - w) / 3, g, w + (x - w) / 3, g, w, g, v, q, h, r, h, r + (s - r) / 3, h, s - (s - r) / 3, h, s, h, t, h, u, v, u, w].join(",") + "z") : f = "M" + (g + o) + "," + h + " v" + p + " h" + -o + " v" + -p + " h" + o + "z") : "circle" === c || "ellipse" === c ? ("circle" === c ? (i = j = +a.getAttribute("r") || 0, m = i * e) : (i = +a.getAttribute("rx") || 0, j = +a.getAttribute("ry") || 0, m = j * e), g = +a.getAttribute("cx") || 0, h = +a.getAttribute("cy") || 0, l = i * e, f = "M" + (g + i) + "," + h + " C" + [g + i, h + m, g + l, h + j, g, h + j, g - l, h + j, g - i, h + m, g - i, h, g - i, h - m, g - l, h - j, g, h - j, g + l, h - j, g + i, h - m, g + i, h].join(",") + "z") : "line" === c ? f = "M" + a.getAttribute("x1") + "," + a.getAttribute("y1") + " L" + a.getAttribute("x2") + "," + a.getAttribute("y2") : ("polyline" === c || "polygon" === c) && (n = (a.getAttribute("points") + "").match(d) || [], g = n.shift(), h = n.shift(), f = "M" + g + "," + h + " L" + n.join(","), "polygon" === c && (f += "," + g + "," + h + "z")), k.setAttribute("d", f), b && a.parentNode && (a.parentNode.insertBefore(k, a), a.parentNode.removeChild(a)), k) : a;
	},
	    M = function M(a, b, c) {
		var f,
		    h,
		    e = "string" == typeof a;
		return (!e || (a.match(d) || []).length < 3) && (f = e ? g.selector(a) : a && a[0] ? a : [a], f && f[0] ? (f = f[0], h = f.nodeName.toUpperCase(), b && "PATH" !== h && (f = L(f, !1), h = "PATH"), a = f.getAttribute("PATH" === h ? "d" : "points") || "", f === c && (a = f.getAttributeNS(null, "data-original") || a)) : (m("WARNING: invalid morph to: " + a), a = !1)), a;
	},
	    N = "Use MorphSVGPlugin.convertToPath(elementOrSelectorText) to convert to a path before morphing.",
	    O = _gsScope._gsDefine.plugin({ propName: "morphSVG", API: 2, global: !0, version: "0.8.4", init: function init(a, b, c) {
			var d, f, g, n, o;
			return "function" != typeof a.setAttribute ? !1 : l ? (d = a.nodeName.toUpperCase(), o = "POLYLINE" === d || "POLYGON" === d, "PATH" === d || o ? (f = "PATH" === d ? "d" : "points", ("string" == typeof b || b.getBBox || b[0]) && (b = { shape: b }), n = M(b.shape || b.d || b.points || "", "d" === f, a), o && e.test(n) ? (m("WARNING: a <" + d + "> cannot accept path data. " + N), !1) : (n && (this._target = a, a.getAttributeNS(null, "data-original") || a.setAttributeNS(null, "data-original", a.getAttribute(f)), g = this._addTween(a, "setAttribute", a.getAttribute(f) + "", n + "", "morphSVG", !1, f, "object" == _typeof(b.precompile) ? function (a) {
				a[0] = b.precompile[0], a[1] = b.precompile[1];
			} : "d" === f ? F(b.shapeIndex, b.map || O.defaultMap, b.precompile) : J(b.shapeIndex)), g && (this._overwriteProps.push("morphSVG"), g.end = n, g.endProp = f)), l)) : (m("WARNING: cannot morph a <" + d + "> SVG element. " + N), !1)) : (window.location.href = "http://" + j + k + "?plugin=" + i + "&source=" + h, !1);
		}, set: function set(a) {
			var b;
			if (this._super.setRatio.call(this, a), 1 === a) for (b = this._firstPT; b;) {
				b.end && this._target.setAttribute(b.endProp, b.end), b = b._next;
			}
		} });
	O.pathFilter = E, O.pointsFilter = I, O.subdivideRawBezier = q, O.defaultMap = "size", O.pathDataToRawBezier = function (a) {
		return p(M(a, !0));
	}, O.equalizeSegmentQuantity = D, O.convertToPath = function (a, b) {
		"string" == typeof a && (a = g.selector(a));
		for (var c = a && 0 !== a.length ? a.length && a[0] && a[0].nodeType ? Array.prototype.slice.call(a, 0) : [a] : [], d = c.length; --d > -1;) {
			c[d] = L(c[d], b !== !1);
		}return c;
	}, O.pathDataToBezier = function (a, b) {
		var e,
		    f,
		    h,
		    i,
		    j,
		    k,
		    l,
		    m,
		    c = p(M(a, !0))[0] || [],
		    d = 0;
		if (b = b || {}, m = b.align || b.relative, i = b.matrix || [1, 0, 0, 1, 0, 0], j = b.offsetX || 0, k = b.offsetY || 0, "relative" === m || m === !0 ? (j -= c[0] * i[0] + c[1] * i[2], k -= c[0] * i[1] + c[1] * i[3], d = "+=") : (j += i[4], k += i[5], m && (m = "string" == typeof m ? g.selector(m) : m && m[0] ? m : [m], m && m[0] && (l = m[0].getBBox() || { x: 0, y: 0 }, j -= l.x, k -= l.y))), e = [], h = c.length, i) for (f = 0; h > f; f += 2) {
			e.push({ x: d + (c[f] * i[0] + c[f + 1] * i[2] + j), y: d + (c[f] * i[1] + c[f + 1] * i[3] + k) });
		} else for (f = 0; h > f; f += 2) {
			e.push({ x: d + (c[f] + j), y: d + (c[f + 1] + k) });
		}return e;
	};
}), _gsScope._gsDefine && _gsScope._gsQueue.pop()();
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
!function (a) {
	"use strict";

	var b = a.GreenSockGlobals || a,
	    c = function c(a) {
		var e,
		    c = a.split("."),
		    d = b;
		for (e = 0; e < c.length; e++) {
			d[c[e]] = d = d[c[e]] || {};
		}return d;
	},
	    d = c("com.greensock.utils"),

	// e = "codepen",
	// f = "SplitText",
	// g = String.fromCharCode(103, 114, 101, 101, 110, 115, 111, 99, 107, 46, 99, 111, 109),
	// h = String.fromCharCode(47, 114, 101, 113, 117, 105, 114, 101, 115, 45, 109, 101, 109, 98, 101, 114, 115, 104, 105, 112, 47),
	i = function i(b) {
		return true;
	},

	// i = function(b) {
	//     for (var c = -1 !== (a ? a.location.href : "").indexOf(String.fromCharCode(103, 114, 101, 101, 110, 115, 111, 99, 107)) && -1 !== b.indexOf(String.fromCharCode(108, 111, 99, 97, 108, 104, 111, 115, 116)), d = [g, String.fromCharCode(99, 111, 100, 101, 112, 101, 110, 46, 105, 111), String.fromCharCode(99, 111, 100, 101, 112, 101, 110, 46, 100, 101, 118), String.fromCharCode(99, 115, 115, 45, 116, 114, 105, 99, 107, 115, 46, 99, 111, 109), String.fromCharCode(99, 100, 112, 110, 46, 105, 111), String.fromCharCode(103, 97, 110, 110, 111, 110, 46, 116, 118), String.fromCharCode(99, 111, 100, 101, 99, 97, 110, 121, 111, 110, 46, 110, 101, 116), String.fromCharCode(116, 104, 101, 109, 101, 102, 111, 114, 101, 115, 116, 46, 110, 101, 116), String.fromCharCode(99, 101, 114, 101, 98, 114, 97, 120, 46, 99, 111, 46, 117, 107), String.fromCharCode(116, 121, 109, 112, 97, 110, 117, 115, 46, 110, 101, 116), String.fromCharCode(116, 119, 101, 101, 110, 109, 97, 120, 46, 99, 111, 109), String.fromCharCode(116, 119, 101, 101, 110, 108, 105, 116, 101, 46, 99, 111, 109), String.fromCharCode(112, 108, 110, 107, 114, 46, 99, 111), String.fromCharCode(104, 111, 116, 106, 97, 114, 46, 99, 111, 109), String.fromCharCode(106, 115, 102, 105, 100, 100, 108, 101, 46, 110, 101, 116)], e = d.length; --e > -1;)
	//         if (-1 !== b.indexOf(d[e])) return !0;
	//     return c && a && a.console && console.log(String.fromCharCode(87, 65, 82, 78, 73, 78, 71, 58, 32, 97, 32, 115, 112, 101, 99, 105, 97, 108, 32, 118, 101, 114, 115, 105, 111, 110, 32, 111, 102, 32) + f + String.fromCharCode(32, 105, 115, 32, 114, 117, 110, 110, 105, 110, 103, 32, 108, 111, 99, 97, 108, 108, 121, 44, 32, 98, 117, 116, 32, 105, 116, 32, 119, 105, 108, 108, 32, 110, 111, 116, 32, 119, 111, 114, 107, 32, 111, 110, 32, 97, 32, 108, 105, 118, 101, 32, 100, 111, 109, 97, 105, 110, 32, 98, 101, 99, 97, 117, 115, 101, 32, 105, 116, 32, 105, 115, 32, 97, 32, 109, 101, 109, 98, 101, 114, 115, 104, 105, 112, 32, 98, 101, 110, 101, 102, 105, 116, 32, 111, 102, 32, 67, 108, 117, 98, 32, 71, 114, 101, 101, 110, 83, 111, 99, 107, 46, 32, 80, 108, 101, 97, 115, 101, 32, 115, 105, 103, 110, 32, 117, 112, 32, 97, 116, 32, 104, 116, 116, 112, 58, 47, 47, 103, 114, 101, 101, 110, 115, 111, 99, 107, 46, 99, 111, 109, 47, 99, 108, 117, 98, 47, 32, 97, 110, 100, 32, 116, 104, 101, 110, 32, 100, 111, 119, 110, 108, 111, 97, 100, 32, 116, 104, 101, 32, 39, 114, 101, 97, 108, 39, 32, 118, 101, 114, 115, 105, 111, 110, 32, 102, 114, 111, 109, 32, 121, 111, 117, 114, 32, 71, 114, 101, 101, 110, 83, 111, 99, 107, 32, 97, 99, 99, 111, 117, 110, 116, 32, 119, 104, 105, 99, 104, 32, 104, 97, 115, 32, 110, 111, 32, 115, 117, 99, 104, 32, 108, 105, 109, 105, 116, 97, 116, 105, 111, 110, 115, 46, 32, 84, 104, 101, 32, 102, 105, 108, 101, 32, 121, 111, 117, 39, 114, 101, 32, 117, 115, 105, 110, 103, 32, 119, 97, 115, 32, 108, 105, 107, 101, 108, 121, 32, 100, 111, 119, 110, 108, 111, 97, 100, 101, 100, 32, 102, 114, 111, 109, 32, 101, 108, 115, 101, 119, 104, 101, 114, 101, 32, 111, 110, 32, 116, 104, 101, 32, 119, 101, 98, 32, 97, 110, 100, 32, 105, 115, 32, 114, 101, 115, 116, 114, 105, 99, 116, 101, 100, 32, 116, 111, 32, 108, 111, 99, 97, 108, 32, 117, 115, 101, 32, 111, 114, 32, 111, 110, 32, 115, 105, 116, 101, 115, 32, 108, 105, 107, 101, 32, 99, 111, 100, 101, 112, 101, 110, 46, 105, 111, 46)), c }(a ? a.location.host : ""),
	j = function j(a) {
		var b = a.nodeType,
		    c = "";
		if (1 === b || 9 === b || 11 === b) {
			if ("string" == typeof a.textContent) return a.textContent;
			for (a = a.firstChild; a; a = a.nextSibling) {
				c += j(a);
			}
		} else if (3 === b || 4 === b) return a.nodeValue;
		return c;
	},
	    k = document,
	    l = k.defaultView ? k.defaultView.getComputedStyle : function () {},
	    m = /([A-Z])/g,
	    n = function n(a, b, c, d) {
		var e;
		return (c = c || l(a, null)) ? (a = c.getPropertyValue(b.replace(m, "-$1").toLowerCase()), e = a || c.length ? a : c[b]) : a.currentStyle && (c = a.currentStyle, e = c[b]), d ? e : parseInt(e, 10) || 0;
	},
	    o = function o(a) {
		return a.length && a[0] && (a[0].nodeType && a[0].style && !a.nodeType || a[0].length && a[0][0]) ? !0 : !1;
	},
	    p = function p(a) {
		var d,
		    e,
		    f,
		    b = [],
		    c = a.length;
		for (d = 0; c > d; d++) {
			if (e = a[d], o(e)) for (f = e.length, f = 0; f < e.length; f++) {
				b.push(e[f]);
			} else b.push(e);
		}return b;
	},
	    q = /(?:\r|\n|\t\t)/g,
	    r = /(?:\s\s+)/g,
	    s = 55296,
	    t = 56319,
	    u = 56320,
	    v = 127462,
	    w = 127487,
	    x = 127995,
	    y = 127999,
	    z = function z(a) {
		return (a.charCodeAt(0) - s << 10) + (a.charCodeAt(1) - u) + 65536;
	},
	    A = k.all && !k.addEventListener,
	    B = " style='position:relative;display:inline-block;" + (A ? "*display:inline;*zoom:1;'" : "'"),
	    C = function C(a, b) {
		a = a || "";
		var c = -1 !== a.indexOf("++"),
		    d = 1;
		return c && (a = a.split("++").join("")), function () {
			return "<" + b + B + (a ? " class='" + a + (c ? d++ : "") + "'>" : ">");
		};
	},
	    D = d.SplitText = b.SplitText = function (b, c) {
		if ("string" == typeof b && (b = D.selector(b)), !b) throw "cannot split a null element.";
		return i ? (this.elements = o(b) ? p(b) : [b], this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = c || {}, void this.split(c)) : (a.location.href = "http://" + g + h + "?plugin=" + f + "&source=" + e, !1);
	},
	    E = function E(a, b, c) {
		var d = a.nodeType;
		if (1 === d || 9 === d || 11 === d) for (a = a.firstChild; a; a = a.nextSibling) {
			E(a, b, c);
		} else (3 === d || 4 === d) && (a.nodeValue = a.nodeValue.split(b).join(c));
	},
	    F = function F(a, b) {
		for (var c = b.length; --c > -1;) {
			a.push(b[c]);
		}
	},
	    G = function G(a) {
		var d,
		    b = [],
		    c = a.length;
		for (d = 0; d !== c; b.push(a[d++])) {}
		return b;
	},
	    H = function H(a, b, c) {
		for (; a && a !== b;) {
			if (a.nextSibling) return a.nextSibling.textContent.charAt(0) === c;
			a = a.parentNode;
		}
		return !1;
	},
	    I = function I(a, b, c, d, e, f, g) {
		var I,
		    J,
		    K,
		    L,
		    M,
		    N,
		    O,
		    P,
		    Q,
		    R,
		    S,
		    T,
		    h = l(a),
		    i = n(a, "paddingLeft", h),
		    j = -999,
		    m = n(a, "borderBottomWidth", h) + n(a, "borderTopWidth", h),
		    o = n(a, "borderLeftWidth", h) + n(a, "borderRightWidth", h),
		    p = n(a, "paddingTop", h) + n(a, "paddingBottom", h),
		    q = n(a, "paddingLeft", h) + n(a, "paddingRight", h),
		    r = .2 * n(a, "fontSize"),
		    s = n(a, "textAlign", h, !0),
		    t = [],
		    u = [],
		    v = [],
		    w = b.wordDelimiter || " ",
		    x = b.span ? "span" : "div",
		    y = b.type || b.split || "chars,words,lines",
		    z = e && -1 !== y.indexOf("lines") ? [] : null,
		    A = -1 !== y.indexOf("words"),
		    B = -1 !== y.indexOf("chars"),
		    C = "absolute" === b.position || b.absolute === !0,
		    D = b.linesClass,
		    G = -1 !== (D || "").indexOf("++");
		for (G && (D = D.split("++").join("")), J = a.getElementsByTagName("*"), K = J.length, M = [], I = 0; K > I; I++) {
			M[I] = J[I];
		}if (z || C) for (I = 0; K > I; I++) {
			L = M[I], N = L.parentNode === a, (N || C || B && !A) && (T = L.offsetTop, z && N && Math.abs(T - j) > r && "BR" !== L.nodeName && (O = [], z.push(O), j = T), C && (L._x = L.offsetLeft, L._y = T, L._w = L.offsetWidth, L._h = L.offsetHeight), z && ((L._isSplit || !B && N || A && N || !A && L.parentNode.parentNode === a && !L.parentNode._isSplit) && (O.push(L), L._x -= i, H(L, a, w) && (L._wordEnd = !0)), "BR" === L.nodeName && L.nextSibling && "BR" === L.nextSibling.nodeName && z.push([])));
		}for (I = 0; K > I; I++) {
			L = M[I], N = L.parentNode === a, "BR" !== L.nodeName ? (C && (Q = L.style, A || N || (L._x += L.parentNode._x, L._y += L.parentNode._y), Q.left = L._x + "px", Q.top = L._y + "px", Q.position = "absolute", Q.display = "block", Q.width = L._w + 1 + "px", Q.height = L._h + "px"), !A && B ? L._isSplit ? L.parentNode.appendChild(L) : L.parentNode._isSplit ? (L._parent = L.parentNode, L._next = L.nextSibling, L.parentNode.removeChild(L), M.splice(I--, 1), K--) : !N && B && (T = !L.nextSibling && L.parentNode._next && L.parentNode._next.textContent.charAt(0) === w, L.parentNode._parent && L.parentNode._parent.appendChild(L), T && L.parentNode.appendChild(k.createTextNode(" ")), b.span && (L.style.display = "inline"), t.push(L)) : L.parentNode._isSplit && !L._isSplit && "" !== L.innerHTML ? u.push(L) : B && !L._isSplit && (b.span && (L.style.display = "inline"), t.push(L))) : z || C ? (a.removeChild(L), M.splice(I--, 1), K--) : A || a.appendChild(L);
		}if (z) {
			for (C && (R = k.createElement(x), a.appendChild(R), S = R.offsetWidth + "px", T = R.offsetParent === a ? 0 : a.offsetLeft, a.removeChild(R)), Q = a.style.cssText, a.style.cssText = "display:none;"; a.firstChild;) {
				a.removeChild(a.firstChild);
			}for (P = " " === w && (!C || !A && !B), I = 0; I < z.length; I++) {
				for (O = z[I], R = k.createElement(x), R.style.cssText = "display:block;text-align:" + s + ";position:" + (C ? "absolute;" : "relative;"), D && (R.className = D + (G ? I + 1 : "")), v.push(R), K = O.length, J = 0; K > J; J++) {
					"BR" !== O[J].nodeName && (L = O[J], R.appendChild(L), P && L._wordEnd && R.appendChild(k.createTextNode(" ")), C && (0 === J && (R.style.top = L._y + "px", R.style.left = i + T + "px"), L.style.top = "0px", T && (L.style.left = L._x - T + "px")));
				}0 === K ? R.innerHTML = "&nbsp;" : A || B || E(R, String.fromCharCode(160), " "), C && (R.style.width = S, R.style.height = L._h + "px"), a.appendChild(R);
			}
			a.style.cssText = Q;
		}
		C && (g > a.clientHeight && (a.style.height = g - p + "px", a.clientHeight < g && (a.style.height = g + m + "px")), f > a.clientWidth && (a.style.width = f - q + "px", a.clientWidth < f && (a.style.width = f + o + "px"))), F(c, t), F(d, u), F(e, v);
	},
	    J = function J(a, b, c, d) {
		var p,
		    u,
		    A,
		    B,
		    C,
		    D,
		    F,
		    G,
		    H,
		    e = b.span ? "span" : "div",
		    f = b.type || b.split || "chars,words,lines",
		    h = (-1 !== f.indexOf("words"), -1 !== f.indexOf("chars")),
		    i = "absolute" === b.position || b.absolute === !0,
		    l = b.wordDelimiter || " ",
		    m = " " !== l ? "" : i ? "&#173; " : " ",
		    n = b.span ? "</span>" : "</div>",
		    o = !0,
		    I = k.createElement("div"),
		    J = a.parentNode;
		for (J.insertBefore(I, a), I.textContent = a.nodeValue, J.removeChild(a), a = I, p = j(a), F = -1 !== p.indexOf("<"), b.reduceWhiteSpace !== !1 && (p = p.replace(r, " ").replace(q, "")), F && (p = p.split("<").join("{{LT}}")), C = p.length, u = (" " === p.charAt(0) ? m : "") + c(), A = 0; C > A; A++) {
			if (D = p.charAt(A), D === l && p.charAt(A - 1) !== l && A) {
				for (u += o ? n : "", o = !1; p.charAt(A + 1) === l;) {
					u += m, A++;
				}A === C - 1 ? u += m : ")" !== p.charAt(A + 1) && (u += m + c(), o = !0);
			} else "{" === D && "{{LT}}" === p.substr(A, 6) ? (u += h ? d() + "{{LT}}</" + e + ">" : "{{LT}}", A += 5) : D.charCodeAt(0) >= s && D.charCodeAt(0) <= t || p.charCodeAt(A + 1) >= 65024 && p.charCodeAt(A + 1) <= 65039 ? (G = z(p.substr(A, 2)), H = z(p.substr(A + 2, 2)), B = G >= v && w >= G && H >= v && w >= H || H >= x && y >= H ? 4 : 2, u += h && " " !== D ? d() + p.substr(A, B) + "</" + e + ">" : p.substr(A, B), A += B - 1) : u += h && " " !== D ? d() + D + "</" + e + ">" : D;
		}a.outerHTML = u + (o ? n : ""), F && E(J, "{{LT}}", "<");
	},
	    K = function K(a, b, c, d) {
		var h,
		    i,
		    e = G(a.childNodes),
		    f = e.length,
		    g = "absolute" === b.position || b.absolute === !0;
		if (3 !== a.nodeType || f > 1) {
			for (b.absolute = !1, h = 0; f > h; h++) {
				i = e[h], (3 !== i.nodeType || /\S+/.test(i.nodeValue)) && (g && 3 !== i.nodeType && "inline" === n(i, "display", null, !0) && (i.style.display = "inline-block", i.style.position = "relative"), i._isSplit = !0, K(i, b, c, d));
			}return b.absolute = g, void (a._isSplit = !0);
		}
		J(a, b, c, d);
	},
	    L = D.prototype;
	L.split = function (a) {
		this.isSplit && this.revert(), this.vars = a = a || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
		for (var g, h, i, b = this.elements.length, c = a.span ? "span" : "div", e = ("absolute" === a.position || a.absolute === !0, C(a.wordsClass, c)), f = C(a.charsClass, c); --b > -1;) {
			i = this.elements[b], this._originals[b] = i.innerHTML, g = i.clientHeight, h = i.clientWidth, K(i, a, e, f), I(i, a, this.chars, this.words, this.lines, h, g);
		}return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this;
	}, L.revert = function () {
		if (!this._originals) throw "revert() call wasn't scoped properly.";
		for (var a = this._originals.length; --a > -1;) {
			this.elements[a].innerHTML = this._originals[a];
		}return this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this;
	}, D.selector = a.$ || a.jQuery || function (b) {
		var c = a.$ || a.jQuery;
		return c ? (D.selector = c, c(b)) : "undefined" == typeof document ? b : document.querySelectorAll ? document.querySelectorAll(b) : document.getElementById("#" === b.charAt(0) ? b.substr(1) : b);
	}, D.version = "0.5.4";
}(_gsScope), function (a) {
	"use strict";

	var b = function b() {
		return (_gsScope.GreenSockGlobals || _gsScope)[a];
	};"function" == typeof define && define.amd ? define([], b) : "undefined" != typeof module && module.exports && (module.exports = b());
}("SplitText");
/*!
 * VERSION: 0.0.10
 * DATE: 2016-02-11
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * DrawSVGPlugin is a Club GreenSock membership benefit; You must have a valid membership to use
 * this code without violating the terms of use. Visit http://greensock.com/club/ to sign up or get more details.
 * This work is subject to the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
	"use strict";

	function a(a, b, c, d) {
		return c = parseFloat(c) - parseFloat(a), d = parseFloat(d) - parseFloat(b), Math.sqrt(c * c + d * d);
	}

	function b(a) {
		return "string" != typeof a && a.nodeType || (a = _gsScope.TweenLite.selector(a), a.length && (a = a[0])), a;
	}

	function c(a, b, c) {
		var d,
		    e,
		    f = a.indexOf(" ");
		return -1 === f ? (d = void 0 !== c ? c + "" : a, e = a) : (d = a.substr(0, f), e = a.substr(f + 1)), d = -1 !== d.indexOf("%") ? parseFloat(d) / 100 * b : parseFloat(d), e = -1 !== e.indexOf("%") ? parseFloat(e) / 100 * b : parseFloat(e), d > e ? [e, d] : [d, e];
	}

	function d(c) {
		if (!c) return 0;
		c = b(c);
		var d,
		    e,
		    f,
		    g,
		    i,
		    j,
		    k,
		    l = c.tagName.toLowerCase();
		if ("path" === l) {
			g = c.style.strokeDasharray, c.style.strokeDasharray = "none", d = c.getTotalLength() || 0;
			try {
				e = c.getBBox();
			} catch (m) {}
			c.style.strokeDasharray = g;
		} else if ("rect" === l) d = 2 * c.getAttribute("width") + 2 * c.getAttribute("height");else if ("circle" === l) d = 2 * Math.PI * parseFloat(c.getAttribute("r"));else if ("line" === l) d = a(c.getAttribute("x1"), c.getAttribute("y1"), c.getAttribute("x2"), c.getAttribute("y2"));else if ("polyline" === l || "polygon" === l) for (f = c.getAttribute("points").match(h) || [], "polygon" === l && f.push(f[0], f[1]), d = 0, i = 2; i < f.length; i += 2) {
			d += a(f[i - 2], f[i - 1], f[i], f[i + 1]) || 0;
		} else "ellipse" === l && (j = parseFloat(c.getAttribute("rx")), k = parseFloat(c.getAttribute("ry")), d = Math.PI * (3 * (j + k) - Math.sqrt((3 * j + k) * (j + 3 * k))));
		return d || 0;
	}

	function e(a, c) {
		if (!a) return [0, 0];
		a = b(a), c = c || d(a) + 1;
		var e = g(a),
		    f = e.strokeDasharray || "",
		    h = parseFloat(e.strokeDashoffset),
		    i = f.indexOf(",");
		return 0 > i && (i = f.indexOf(" ")), f = 0 > i ? c : parseFloat(f.substr(0, i)) || 1e-5, f > c && (f = c), [Math.max(0, -h), Math.max(0, f - h)];
	}
	var f,
	    g = document.defaultView ? document.defaultView.getComputedStyle : function () {},
	    h = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi;
	f = _gsScope._gsDefine.plugin({ propName: "drawSVG", API: 2, version: "0.0.10", global: !0, overwriteProps: ["drawSVG"], init: function init(a, b, f) {
			if (!a.getBBox) return !1;
			var g,
			    h,
			    i,
			    j = d(a) + 1;
			return this._style = a.style, b === !0 || "true" === b ? b = "0 100%" : b ? -1 === (b + "").indexOf(" ") && (b = "0 " + b) : b = "0 0", g = e(a, j), h = c(b, j, g[0]), this._length = j + 10, 0 === g[0] && 0 === h[0] ? (i = Math.max(1e-5, h[1] - j), this._dash = j + i, this._offset = j - g[1] + i, this._addTween(this, "_offset", this._offset, j - h[1] + i, "drawSVG")) : (this._dash = g[1] - g[0] || 1e-6, this._offset = -g[0], this._addTween(this, "_dash", this._dash, h[1] - h[0] || 1e-5, "drawSVG"), this._addTween(this, "_offset", this._offset, -h[0], "drawSVG")), !0;
		}, set: function set(a) {
			this._firstPT && (this._super.setRatio.call(this, a), this._style.strokeDashoffset = this._offset, 1 === a || 0 === a ? this._style.strokeDasharray = this._offset < .001 && this._length - this._dash <= 10 ? "none" : this._offset === this._dash ? "0px, 999999px" : this._dash + "px," + this._length + "px" : this._style.strokeDasharray = this._dash + "px," + this._length + "px");
		} }), f.getLength = d, f.getPosition = e;
}), _gsScope._gsDefine && _gsScope._gsQueue.pop()();
/*! jQuery UI - v1.12.0 - 2016-08-01
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/autocomplete.js, widgets/menu.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function (t) {
	"function" == typeof define && define.amd ? define(["jquery"], t) : t(jQuery);
})(function (t) {
	function e(t) {
		for (var e = t.css("visibility"); "inherit" === e;) {
			t = t.parent(), e = t.css("visibility");
		}return "hidden" !== e;
	}t.ui = t.ui || {}, t.ui.version = "1.12.0";var i = 0,
	    s = Array.prototype.slice;t.cleanData = function (e) {
		return function (i) {
			var s, n, o;for (o = 0; null != (n = i[o]); o++) {
				try {
					s = t._data(n, "events"), s && s.remove && t(n).triggerHandler("remove");
				} catch (a) {}
			}e(i);
		};
	}(t.cleanData), t.widget = function (e, i, s) {
		var n,
		    o,
		    a,
		    r = {},
		    l = e.split(".")[0];e = e.split(".")[1];var h = l + "-" + e;return s || (s = i, i = t.Widget), t.isArray(s) && (s = t.extend.apply(null, [{}].concat(s))), t.expr[":"][h.toLowerCase()] = function (e) {
			return !!t.data(e, h);
		}, t[l] = t[l] || {}, n = t[l][e], o = t[l][e] = function (t, e) {
			return this._createWidget ? (arguments.length && this._createWidget(t, e), void 0) : new o(t, e);
		}, t.extend(o, n, { version: s.version, _proto: t.extend({}, s), _childConstructors: [] }), a = new i(), a.options = t.widget.extend({}, a.options), t.each(s, function (e, s) {
			return t.isFunction(s) ? (r[e] = function () {
				function t() {
					return i.prototype[e].apply(this, arguments);
				}function n(t) {
					return i.prototype[e].apply(this, t);
				}return function () {
					var e,
					    i = this._super,
					    o = this._superApply;return this._super = t, this._superApply = n, e = s.apply(this, arguments), this._super = i, this._superApply = o, e;
				};
			}(), void 0) : (r[e] = s, void 0);
		}), o.prototype = t.widget.extend(a, { widgetEventPrefix: n ? a.widgetEventPrefix || e : e }, r, { constructor: o, namespace: l, widgetName: e, widgetFullName: h }), n ? (t.each(n._childConstructors, function (e, i) {
			var s = i.prototype;t.widget(s.namespace + "." + s.widgetName, o, i._proto);
		}), delete n._childConstructors) : i._childConstructors.push(o), t.widget.bridge(e, o), o;
	}, t.widget.extend = function (e) {
		for (var i, n, o = s.call(arguments, 1), a = 0, r = o.length; r > a; a++) {
			for (i in o[a]) {
				n = o[a][i], o[a].hasOwnProperty(i) && void 0 !== n && (e[i] = t.isPlainObject(n) ? t.isPlainObject(e[i]) ? t.widget.extend({}, e[i], n) : t.widget.extend({}, n) : n);
			}
		}return e;
	}, t.widget.bridge = function (e, i) {
		var n = i.prototype.widgetFullName || e;t.fn[e] = function (o) {
			var a = "string" == typeof o,
			    r = s.call(arguments, 1),
			    l = this;return a ? this.each(function () {
				var i,
				    s = t.data(this, n);return "instance" === o ? (l = s, !1) : s ? t.isFunction(s[o]) && "_" !== o.charAt(0) ? (i = s[o].apply(s, r), i !== s && void 0 !== i ? (l = i && i.jquery ? l.pushStack(i.get()) : i, !1) : void 0) : t.error("no such method '" + o + "' for " + e + " widget instance") : t.error("cannot call methods on " + e + " prior to initialization; " + "attempted to call method '" + o + "'");
			}) : (r.length && (o = t.widget.extend.apply(null, [o].concat(r))), this.each(function () {
				var e = t.data(this, n);e ? (e.option(o || {}), e._init && e._init()) : t.data(this, n, new i(o, this));
			})), l;
		};
	}, t.Widget = function () {}, t.Widget._childConstructors = [], t.Widget.prototype = { widgetName: "widget", widgetEventPrefix: "", defaultElement: "<div>", options: { classes: {}, disabled: !1, create: null }, _createWidget: function _createWidget(e, s) {
			s = t(s || this.defaultElement || this)[0], this.element = t(s), this.uuid = i++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = t(), this.hoverable = t(), this.focusable = t(), this.classesElementLookup = {}, s !== this && (t.data(s, this.widgetFullName, this), this._on(!0, this.element, { remove: function remove(t) {
					t.target === s && this.destroy();
				} }), this.document = t(s.style ? s.ownerDocument : s.document || s), this.window = t(this.document[0].defaultView || this.document[0].parentWindow)), this.options = t.widget.extend({}, this.options, this._getCreateOptions(), e), this._create(), this.options.disabled && this._setOptionDisabled(this.options.disabled), this._trigger("create", null, this._getCreateEventData()), this._init();
		}, _getCreateOptions: function _getCreateOptions() {
			return {};
		}, _getCreateEventData: t.noop, _create: t.noop, _init: t.noop, destroy: function destroy() {
			var e = this;this._destroy(), t.each(this.classesElementLookup, function (t, i) {
				e._removeClass(i, t);
			}), this.element.off(this.eventNamespace).removeData(this.widgetFullName), this.widget().off(this.eventNamespace).removeAttr("aria-disabled"), this.bindings.off(this.eventNamespace);
		}, _destroy: t.noop, widget: function widget() {
			return this.element;
		}, option: function option(e, i) {
			var s,
			    n,
			    o,
			    a = e;if (0 === arguments.length) return t.widget.extend({}, this.options);if ("string" == typeof e) if (a = {}, s = e.split("."), e = s.shift(), s.length) {
				for (n = a[e] = t.widget.extend({}, this.options[e]), o = 0; s.length - 1 > o; o++) {
					n[s[o]] = n[s[o]] || {}, n = n[s[o]];
				}if (e = s.pop(), 1 === arguments.length) return void 0 === n[e] ? null : n[e];n[e] = i;
			} else {
				if (1 === arguments.length) return void 0 === this.options[e] ? null : this.options[e];a[e] = i;
			}return this._setOptions(a), this;
		}, _setOptions: function _setOptions(t) {
			var e;for (e in t) {
				this._setOption(e, t[e]);
			}return this;
		}, _setOption: function _setOption(t, e) {
			return "classes" === t && this._setOptionClasses(e), this.options[t] = e, "disabled" === t && this._setOptionDisabled(e), this;
		}, _setOptionClasses: function _setOptionClasses(e) {
			var i, s, n;for (i in e) {
				n = this.classesElementLookup[i], e[i] !== this.options.classes[i] && n && n.length && (s = t(n.get()), this._removeClass(n, i), s.addClass(this._classes({ element: s, keys: i, classes: e, add: !0 })));
			}
		}, _setOptionDisabled: function _setOptionDisabled(t) {
			this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!t), t && (this._removeClass(this.hoverable, null, "ui-state-hover"), this._removeClass(this.focusable, null, "ui-state-focus"));
		}, enable: function enable() {
			return this._setOptions({ disabled: !1 });
		}, disable: function disable() {
			return this._setOptions({ disabled: !0 });
		}, _classes: function _classes(e) {
			function i(i, o) {
				var a, r;for (r = 0; i.length > r; r++) {
					a = n.classesElementLookup[i[r]] || t(), a = e.add ? t(t.unique(a.get().concat(e.element.get()))) : t(a.not(e.element).get()), n.classesElementLookup[i[r]] = a, s.push(i[r]), o && e.classes[i[r]] && s.push(e.classes[i[r]]);
				}
			}var s = [],
			    n = this;return e = t.extend({ element: this.element, classes: this.options.classes || {} }, e), e.keys && i(e.keys.match(/\S+/g) || [], !0), e.extra && i(e.extra.match(/\S+/g) || []), s.join(" ");
		}, _removeClass: function _removeClass(t, e, i) {
			return this._toggleClass(t, e, i, !1);
		}, _addClass: function _addClass(t, e, i) {
			return this._toggleClass(t, e, i, !0);
		}, _toggleClass: function _toggleClass(t, e, i, s) {
			s = "boolean" == typeof s ? s : i;var n = "string" == typeof t || null === t,
			    o = { extra: n ? e : i, keys: n ? t : e, element: n ? this.element : t, add: s };return o.element.toggleClass(this._classes(o), s), this;
		}, _on: function _on(e, i, s) {
			var n,
			    o = this;"boolean" != typeof e && (s = i, i = e, e = !1), s ? (i = n = t(i), this.bindings = this.bindings.add(i)) : (s = i, i = this.element, n = this.widget()), t.each(s, function (s, a) {
				function r() {
					return e || o.options.disabled !== !0 && !t(this).hasClass("ui-state-disabled") ? ("string" == typeof a ? o[a] : a).apply(o, arguments) : void 0;
				}"string" != typeof a && (r.guid = a.guid = a.guid || r.guid || t.guid++);var l = s.match(/^([\w:-]*)\s*(.*)$/),
				    h = l[1] + o.eventNamespace,
				    c = l[2];c ? n.on(h, c, r) : i.on(h, r);
			});
		}, _off: function _off(e, i) {
			i = (i || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, e.off(i).off(i), this.bindings = t(this.bindings.not(e).get()), this.focusable = t(this.focusable.not(e).get()), this.hoverable = t(this.hoverable.not(e).get());
		}, _delay: function _delay(t, e) {
			function i() {
				return ("string" == typeof t ? s[t] : t).apply(s, arguments);
			}var s = this;return setTimeout(i, e || 0);
		}, _hoverable: function _hoverable(e) {
			this.hoverable = this.hoverable.add(e), this._on(e, { mouseenter: function mouseenter(e) {
					this._addClass(t(e.currentTarget), null, "ui-state-hover");
				}, mouseleave: function mouseleave(e) {
					this._removeClass(t(e.currentTarget), null, "ui-state-hover");
				} });
		}, _focusable: function _focusable(e) {
			this.focusable = this.focusable.add(e), this._on(e, { focusin: function focusin(e) {
					this._addClass(t(e.currentTarget), null, "ui-state-focus");
				}, focusout: function focusout(e) {
					this._removeClass(t(e.currentTarget), null, "ui-state-focus");
				} });
		}, _trigger: function _trigger(e, i, s) {
			var n,
			    o,
			    a = this.options[e];if (s = s || {}, i = t.Event(i), i.type = (e === this.widgetEventPrefix ? e : this.widgetEventPrefix + e).toLowerCase(), i.target = this.element[0], o = i.originalEvent) for (n in o) {
				n in i || (i[n] = o[n]);
			}return this.element.trigger(i, s), !(t.isFunction(a) && a.apply(this.element[0], [i].concat(s)) === !1 || i.isDefaultPrevented());
		} }, t.each({ show: "fadeIn", hide: "fadeOut" }, function (e, i) {
		t.Widget.prototype["_" + e] = function (s, n, o) {
			"string" == typeof n && (n = { effect: n });var a,
			    r = n ? n === !0 || "number" == typeof n ? i : n.effect || i : e;n = n || {}, "number" == typeof n && (n = { duration: n }), a = !t.isEmptyObject(n), n.complete = o, n.delay && s.delay(n.delay), a && t.effects && t.effects.effect[r] ? s[e](n) : r !== e && s[r] ? s[r](n.duration, n.easing, o) : s.queue(function (i) {
				t(this)[e](), o && o.call(s[0]), i();
			});
		};
	}), t.widget, function () {
		function e(t, e, i) {
			return [parseFloat(t[0]) * (p.test(t[0]) ? e / 100 : 1), parseFloat(t[1]) * (p.test(t[1]) ? i / 100 : 1)];
		}function i(e, i) {
			return parseInt(t.css(e, i), 10) || 0;
		}function s(e) {
			var i = e[0];return 9 === i.nodeType ? { width: e.width(), height: e.height(), offset: { top: 0, left: 0 } } : t.isWindow(i) ? { width: e.width(), height: e.height(), offset: { top: e.scrollTop(), left: e.scrollLeft() } } : i.preventDefault ? { width: 0, height: 0, offset: { top: i.pageY, left: i.pageX } } : { width: e.outerWidth(), height: e.outerHeight(), offset: e.offset() };
		}var n,
		    _o,
		    a = Math.max,
		    r = Math.abs,
		    l = Math.round,
		    h = /left|center|right/,
		    c = /top|center|bottom/,
		    u = /[\+\-]\d+(\.[\d]+)?%?/,
		    d = /^\w+/,
		    p = /%$/,
		    f = t.fn.position;_o = function o() {
			var e = t("<div>").css("position", "absolute").appendTo("body").offset({ top: 1.5, left: 1.5 }),
			    i = 1.5 === e.offset().top;return e.remove(), _o = function o() {
				return i;
			}, i;
		}, t.position = { scrollbarWidth: function scrollbarWidth() {
				if (void 0 !== n) return n;var e,
				    i,
				    s = t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
				    o = s.children()[0];return t("body").append(s), e = o.offsetWidth, s.css("overflow", "scroll"), i = o.offsetWidth, e === i && (i = s[0].clientWidth), s.remove(), n = e - i;
			}, getScrollInfo: function getScrollInfo(e) {
				var i = e.isWindow || e.isDocument ? "" : e.element.css("overflow-x"),
				    s = e.isWindow || e.isDocument ? "" : e.element.css("overflow-y"),
				    n = "scroll" === i || "auto" === i && e.width < e.element[0].scrollWidth,
				    o = "scroll" === s || "auto" === s && e.height < e.element[0].scrollHeight;return { width: o ? t.position.scrollbarWidth() : 0, height: n ? t.position.scrollbarWidth() : 0 };
			}, getWithinInfo: function getWithinInfo(e) {
				var i = t(e || window),
				    s = t.isWindow(i[0]),
				    n = !!i[0] && 9 === i[0].nodeType,
				    o = !s && !n;return { element: i, isWindow: s, isDocument: n, offset: o ? t(e).offset() : { left: 0, top: 0 }, scrollLeft: i.scrollLeft(), scrollTop: i.scrollTop(), width: i.outerWidth(), height: i.outerHeight() };
			} }, t.fn.position = function (n) {
			if (!n || !n.of) return f.apply(this, arguments);n = t.extend({}, n);var p,
			    g,
			    m,
			    _,
			    v,
			    b,
			    y = t(n.of),
			    w = t.position.getWithinInfo(n.within),
			    k = t.position.getScrollInfo(w),
			    x = (n.collision || "flip").split(" "),
			    C = {};return b = s(y), y[0].preventDefault && (n.at = "left top"), g = b.width, m = b.height, _ = b.offset, v = t.extend({}, _), t.each(["my", "at"], function () {
				var t,
				    e,
				    i = (n[this] || "").split(" ");1 === i.length && (i = h.test(i[0]) ? i.concat(["center"]) : c.test(i[0]) ? ["center"].concat(i) : ["center", "center"]), i[0] = h.test(i[0]) ? i[0] : "center", i[1] = c.test(i[1]) ? i[1] : "center", t = u.exec(i[0]), e = u.exec(i[1]), C[this] = [t ? t[0] : 0, e ? e[0] : 0], n[this] = [d.exec(i[0])[0], d.exec(i[1])[0]];
			}), 1 === x.length && (x[1] = x[0]), "right" === n.at[0] ? v.left += g : "center" === n.at[0] && (v.left += g / 2), "bottom" === n.at[1] ? v.top += m : "center" === n.at[1] && (v.top += m / 2), p = e(C.at, g, m), v.left += p[0], v.top += p[1], this.each(function () {
				var s,
				    h,
				    c = t(this),
				    u = c.outerWidth(),
				    d = c.outerHeight(),
				    f = i(this, "marginLeft"),
				    b = i(this, "marginTop"),
				    D = u + f + i(this, "marginRight") + k.width,
				    T = d + b + i(this, "marginBottom") + k.height,
				    I = t.extend({}, v),
				    M = e(C.my, c.outerWidth(), c.outerHeight());"right" === n.my[0] ? I.left -= u : "center" === n.my[0] && (I.left -= u / 2), "bottom" === n.my[1] ? I.top -= d : "center" === n.my[1] && (I.top -= d / 2), I.left += M[0], I.top += M[1], _o() || (I.left = l(I.left), I.top = l(I.top)), s = { marginLeft: f, marginTop: b }, t.each(["left", "top"], function (e, i) {
					t.ui.position[x[e]] && t.ui.position[x[e]][i](I, { targetWidth: g, targetHeight: m, elemWidth: u, elemHeight: d, collisionPosition: s, collisionWidth: D, collisionHeight: T, offset: [p[0] + M[0], p[1] + M[1]], my: n.my, at: n.at, within: w, elem: c });
				}), n.using && (h = function h(t) {
					var e = _.left - I.left,
					    i = e + g - u,
					    s = _.top - I.top,
					    o = s + m - d,
					    l = { target: { element: y, left: _.left, top: _.top, width: g, height: m }, element: { element: c, left: I.left, top: I.top, width: u, height: d }, horizontal: 0 > i ? "left" : e > 0 ? "right" : "center", vertical: 0 > o ? "top" : s > 0 ? "bottom" : "middle" };u > g && g > r(e + i) && (l.horizontal = "center"), d > m && m > r(s + o) && (l.vertical = "middle"), l.important = a(r(e), r(i)) > a(r(s), r(o)) ? "horizontal" : "vertical", n.using.call(this, t, l);
				}), c.offset(t.extend(I, { using: h }));
			});
		}, t.ui.position = { fit: { left: function left(t, e) {
					var i,
					    s = e.within,
					    n = s.isWindow ? s.scrollLeft : s.offset.left,
					    o = s.width,
					    r = t.left - e.collisionPosition.marginLeft,
					    l = n - r,
					    h = r + e.collisionWidth - o - n;e.collisionWidth > o ? l > 0 && 0 >= h ? (i = t.left + l + e.collisionWidth - o - n, t.left += l - i) : t.left = h > 0 && 0 >= l ? n : l > h ? n + o - e.collisionWidth : n : l > 0 ? t.left += l : h > 0 ? t.left -= h : t.left = a(t.left - r, t.left);
				}, top: function top(t, e) {
					var i,
					    s = e.within,
					    n = s.isWindow ? s.scrollTop : s.offset.top,
					    o = e.within.height,
					    r = t.top - e.collisionPosition.marginTop,
					    l = n - r,
					    h = r + e.collisionHeight - o - n;e.collisionHeight > o ? l > 0 && 0 >= h ? (i = t.top + l + e.collisionHeight - o - n, t.top += l - i) : t.top = h > 0 && 0 >= l ? n : l > h ? n + o - e.collisionHeight : n : l > 0 ? t.top += l : h > 0 ? t.top -= h : t.top = a(t.top - r, t.top);
				} }, flip: { left: function left(t, e) {
					var i,
					    s,
					    n = e.within,
					    o = n.offset.left + n.scrollLeft,
					    a = n.width,
					    l = n.isWindow ? n.scrollLeft : n.offset.left,
					    h = t.left - e.collisionPosition.marginLeft,
					    c = h - l,
					    u = h + e.collisionWidth - a - l,
					    d = "left" === e.my[0] ? -e.elemWidth : "right" === e.my[0] ? e.elemWidth : 0,
					    p = "left" === e.at[0] ? e.targetWidth : "right" === e.at[0] ? -e.targetWidth : 0,
					    f = -2 * e.offset[0];0 > c ? (i = t.left + d + p + f + e.collisionWidth - a - o, (0 > i || r(c) > i) && (t.left += d + p + f)) : u > 0 && (s = t.left - e.collisionPosition.marginLeft + d + p + f - l, (s > 0 || u > r(s)) && (t.left += d + p + f));
				}, top: function top(t, e) {
					var i,
					    s,
					    n = e.within,
					    o = n.offset.top + n.scrollTop,
					    a = n.height,
					    l = n.isWindow ? n.scrollTop : n.offset.top,
					    h = t.top - e.collisionPosition.marginTop,
					    c = h - l,
					    u = h + e.collisionHeight - a - l,
					    d = "top" === e.my[1],
					    p = d ? -e.elemHeight : "bottom" === e.my[1] ? e.elemHeight : 0,
					    f = "top" === e.at[1] ? e.targetHeight : "bottom" === e.at[1] ? -e.targetHeight : 0,
					    g = -2 * e.offset[1];0 > c ? (s = t.top + p + f + g + e.collisionHeight - a - o, (0 > s || r(c) > s) && (t.top += p + f + g)) : u > 0 && (i = t.top - e.collisionPosition.marginTop + p + f + g - l, (i > 0 || u > r(i)) && (t.top += p + f + g));
				} }, flipfit: { left: function left() {
					t.ui.position.flip.left.apply(this, arguments), t.ui.position.fit.left.apply(this, arguments);
				}, top: function top() {
					t.ui.position.flip.top.apply(this, arguments), t.ui.position.fit.top.apply(this, arguments);
				} } };
	}(), t.ui.position, t.extend(t.expr[":"], { data: t.expr.createPseudo ? t.expr.createPseudo(function (e) {
			return function (i) {
				return !!t.data(i, e);
			};
		}) : function (e, i, s) {
			return !!t.data(e, s[3]);
		} }), t.fn.extend({ disableSelection: function () {
			var t = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";return function () {
				return this.on(t + ".ui-disableSelection", function (t) {
					t.preventDefault();
				});
			};
		}(), enableSelection: function enableSelection() {
			return this.off(".ui-disableSelection");
		} }), t.ui.focusable = function (i, s) {
		var n,
		    o,
		    a,
		    r,
		    l,
		    h = i.nodeName.toLowerCase();return "area" === h ? (n = i.parentNode, o = n.name, i.href && o && "map" === n.nodeName.toLowerCase() ? (a = t("img[usemap='#" + o + "']"), a.length > 0 && a.is(":visible")) : !1) : (/^(input|select|textarea|button|object)$/.test(h) ? (r = !i.disabled, r && (l = t(i).closest("fieldset")[0], l && (r = !l.disabled))) : r = "a" === h ? i.href || s : s, r && t(i).is(":visible") && e(t(i)));
	}, t.extend(t.expr[":"], { focusable: function focusable(e) {
			return t.ui.focusable(e, null != t.attr(e, "tabindex"));
		} }), t.ui.focusable, t.fn.form = function () {
		return "string" == typeof this[0].form ? this.closest("form") : t(this[0].form);
	}, t.ui.formResetMixin = { _formResetHandler: function _formResetHandler() {
			var e = t(this);setTimeout(function () {
				var i = e.data("ui-form-reset-instances");t.each(i, function () {
					this.refresh();
				});
			});
		}, _bindFormResetHandler: function _bindFormResetHandler() {
			if (this.form = this.element.form(), this.form.length) {
				var t = this.form.data("ui-form-reset-instances") || [];t.length || this.form.on("reset.ui-form-reset", this._formResetHandler), t.push(this), this.form.data("ui-form-reset-instances", t);
			}
		}, _unbindFormResetHandler: function _unbindFormResetHandler() {
			if (this.form.length) {
				var e = this.form.data("ui-form-reset-instances");e.splice(t.inArray(this, e), 1), e.length ? this.form.data("ui-form-reset-instances", e) : this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset");
			}
		} }, "1.7" === t.fn.jquery.substring(0, 3) && (t.each(["Width", "Height"], function (e, i) {
		function s(e, i, s, o) {
			return t.each(n, function () {
				i -= parseFloat(t.css(e, "padding" + this)) || 0, s && (i -= parseFloat(t.css(e, "border" + this + "Width")) || 0), o && (i -= parseFloat(t.css(e, "margin" + this)) || 0);
			}), i;
		}var n = "Width" === i ? ["Left", "Right"] : ["Top", "Bottom"],
		    o = i.toLowerCase(),
		    a = { innerWidth: t.fn.innerWidth, innerHeight: t.fn.innerHeight, outerWidth: t.fn.outerWidth, outerHeight: t.fn.outerHeight };t.fn["inner" + i] = function (e) {
			return void 0 === e ? a["inner" + i].call(this) : this.each(function () {
				t(this).css(o, s(this, e) + "px");
			});
		}, t.fn["outer" + i] = function (e, n) {
			return "number" != typeof e ? a["outer" + i].call(this, e) : this.each(function () {
				t(this).css(o, s(this, e, !0, n) + "px");
			});
		};
	}), t.fn.addBack = function (t) {
		return this.add(null == t ? this.prevObject : this.prevObject.filter(t));
	}), t.ui.keyCode = { BACKSPACE: 8, COMMA: 188, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, LEFT: 37, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SPACE: 32, TAB: 9, UP: 38 }, t.ui.escapeSelector = function () {
		var t = /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g;return function (e) {
			return e.replace(t, "\\$1");
		};
	}(), t.fn.labels = function () {
		var e, i, s, n, o;return this[0].labels && this[0].labels.length ? this.pushStack(this[0].labels) : (n = this.eq(0).parents("label"), s = this.attr("id"), s && (e = this.eq(0).parents().last(), o = e.add(e.length ? e.siblings() : this.siblings()), i = "label[for='" + t.ui.escapeSelector(s) + "']", n = n.add(o.find(i).addBack(i))), this.pushStack(n));
	}, t.fn.scrollParent = function (e) {
		var i = this.css("position"),
		    s = "absolute" === i,
		    n = e ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
		    o = this.parents().filter(function () {
			var e = t(this);return s && "static" === e.css("position") ? !1 : n.test(e.css("overflow") + e.css("overflow-y") + e.css("overflow-x"));
		}).eq(0);return "fixed" !== i && o.length ? o : t(this[0].ownerDocument || document);
	}, t.extend(t.expr[":"], { tabbable: function tabbable(e) {
			var i = t.attr(e, "tabindex"),
			    s = null != i;return (!s || i >= 0) && t.ui.focusable(e, s);
		} }), t.fn.extend({ uniqueId: function () {
			var t = 0;return function () {
				return this.each(function () {
					this.id || (this.id = "ui-id-" + ++t);
				});
			};
		}(), removeUniqueId: function removeUniqueId() {
			return this.each(function () {
				/^ui-id-\d+$/.test(this.id) && t(this).removeAttr("id");
			});
		} }), t.ui.safeActiveElement = function (t) {
		var e;try {
			e = t.activeElement;
		} catch (i) {
			e = t.body;
		}return e || (e = t.body), e.nodeName || (e = t.body), e;
	}, t.widget("ui.menu", { version: "1.12.0", defaultElement: "<ul>", delay: 300, options: { icons: { submenu: "ui-icon-caret-1-e" }, items: "> *", menus: "ul", position: { my: "left top", at: "right top" }, role: "menu", blur: null, focus: null, select: null }, _create: function _create() {
			this.activeMenu = this.element, this.mouseHandled = !1, this.element.uniqueId().attr({ role: this.options.role, tabIndex: 0 }), this._addClass("ui-menu", "ui-widget ui-widget-content"), this._on({ "mousedown .ui-menu-item": function mousedownUiMenuItem(t) {
					t.preventDefault();
				}, "click .ui-menu-item": function clickUiMenuItem(e) {
					var i = t(e.target),
					    s = t(t.ui.safeActiveElement(this.document[0]));!this.mouseHandled && i.not(".ui-state-disabled").length && (this.select(e), e.isPropagationStopped() || (this.mouseHandled = !0), i.has(".ui-menu").length ? this.expand(e) : !this.element.is(":focus") && s.closest(".ui-menu").length && (this.element.trigger("focus", [!0]), this.active && 1 === this.active.parents(".ui-menu").length && clearTimeout(this.timer)));
				}, "mouseenter .ui-menu-item": function mouseenterUiMenuItem(e) {
					if (!this.previousFilter) {
						var i = t(e.target).closest(".ui-menu-item"),
						    s = t(e.currentTarget);i[0] === s[0] && (this._removeClass(s.siblings().children(".ui-state-active"), null, "ui-state-active"), this.focus(e, s));
					}
				}, mouseleave: "collapseAll", "mouseleave .ui-menu": "collapseAll", focus: function focus(t, e) {
					var i = this.active || this.element.find(this.options.items).eq(0);e || this.focus(t, i);
				}, blur: function blur(e) {
					this._delay(function () {
						var i = !t.contains(this.element[0], t.ui.safeActiveElement(this.document[0]));i && this.collapseAll(e);
					});
				}, keydown: "_keydown" }), this.refresh(), this._on(this.document, { click: function click(t) {
					this._closeOnDocumentClick(t) && this.collapseAll(t), this.mouseHandled = !1;
				} });
		}, _destroy: function _destroy() {
			var e = this.element.find(".ui-menu-item").removeAttr("role aria-disabled"),
			    i = e.children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(), i.children().each(function () {
				var e = t(this);e.data("ui-menu-submenu-caret") && e.remove();
			});
		}, _keydown: function _keydown(e) {
			var i,
			    s,
			    n,
			    o,
			    a = !0;switch (e.keyCode) {case t.ui.keyCode.PAGE_UP:
					this.previousPage(e);break;case t.ui.keyCode.PAGE_DOWN:
					this.nextPage(e);break;case t.ui.keyCode.HOME:
					this._move("first", "first", e);break;case t.ui.keyCode.END:
					this._move("last", "last", e);break;case t.ui.keyCode.UP:
					this.previous(e);break;case t.ui.keyCode.DOWN:
					this.next(e);break;case t.ui.keyCode.LEFT:
					this.collapse(e);break;case t.ui.keyCode.RIGHT:
					this.active && !this.active.is(".ui-state-disabled") && this.expand(e);break;case t.ui.keyCode.ENTER:case t.ui.keyCode.SPACE:
					this._activate(e);break;case t.ui.keyCode.ESCAPE:
					this.collapse(e);break;default:
					a = !1, s = this.previousFilter || "", n = String.fromCharCode(e.keyCode), o = !1, clearTimeout(this.filterTimer), n === s ? o = !0 : n = s + n, i = this._filterMenuItems(n), i = o && -1 !== i.index(this.active.next()) ? this.active.nextAll(".ui-menu-item") : i, i.length || (n = String.fromCharCode(e.keyCode), i = this._filterMenuItems(n)), i.length ? (this.focus(e, i), this.previousFilter = n, this.filterTimer = this._delay(function () {
						delete this.previousFilter;
					}, 1e3)) : delete this.previousFilter;}a && e.preventDefault();
		}, _activate: function _activate(t) {
			this.active && !this.active.is(".ui-state-disabled") && (this.active.children("[aria-haspopup='true']").length ? this.expand(t) : this.select(t));
		}, refresh: function refresh() {
			var e,
			    i,
			    s,
			    n,
			    o,
			    a = this,
			    r = this.options.icons.submenu,
			    l = this.element.find(this.options.menus);this._toggleClass("ui-menu-icons", null, !!this.element.find(".ui-icon").length), s = l.filter(":not(.ui-menu)").hide().attr({ role: this.options.role, "aria-hidden": "true", "aria-expanded": "false" }).each(function () {
				var e = t(this),
				    i = e.prev(),
				    s = t("<span>").data("ui-menu-submenu-caret", !0);a._addClass(s, "ui-menu-icon", "ui-icon " + r), i.attr("aria-haspopup", "true").prepend(s), e.attr("aria-labelledby", i.attr("id"));
			}), this._addClass(s, "ui-menu", "ui-widget ui-widget-content ui-front"), e = l.add(this.element), i = e.find(this.options.items), i.not(".ui-menu-item").each(function () {
				var e = t(this);a._isDivider(e) && a._addClass(e, "ui-menu-divider", "ui-widget-content");
			}), n = i.not(".ui-menu-item, .ui-menu-divider"), o = n.children().not(".ui-menu").uniqueId().attr({ tabIndex: -1, role: this._itemRole() }), this._addClass(n, "ui-menu-item")._addClass(o, "ui-menu-item-wrapper"), i.filter(".ui-state-disabled").attr("aria-disabled", "true"), this.active && !t.contains(this.element[0], this.active[0]) && this.blur();
		}, _itemRole: function _itemRole() {
			return { menu: "menuitem", listbox: "option" }[this.options.role];
		}, _setOption: function _setOption(t, e) {
			if ("icons" === t) {
				var i = this.element.find(".ui-menu-icon");this._removeClass(i, null, this.options.icons.submenu)._addClass(i, null, e.submenu);
			}this._super(t, e);
		}, _setOptionDisabled: function _setOptionDisabled(t) {
			this._super(t), this.element.attr("aria-disabled", t + ""), this._toggleClass(null, "ui-state-disabled", !!t);
		}, focus: function focus(t, e) {
			var i, s, n;this.blur(t, t && "focus" === t.type), this._scrollIntoView(e), this.active = e.first(), s = this.active.children(".ui-menu-item-wrapper"), this._addClass(s, null, "ui-state-active"), this.options.role && this.element.attr("aria-activedescendant", s.attr("id")), n = this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"), this._addClass(n, null, "ui-state-active"), t && "keydown" === t.type ? this._close() : this.timer = this._delay(function () {
				this._close();
			}, this.delay), i = e.children(".ui-menu"), i.length && t && /^mouse/.test(t.type) && this._startOpening(i), this.activeMenu = e.parent(), this._trigger("focus", t, { item: e });
		}, _scrollIntoView: function _scrollIntoView(e) {
			var i, s, n, o, a, r;this._hasScroll() && (i = parseFloat(t.css(this.activeMenu[0], "borderTopWidth")) || 0, s = parseFloat(t.css(this.activeMenu[0], "paddingTop")) || 0, n = e.offset().top - this.activeMenu.offset().top - i - s, o = this.activeMenu.scrollTop(), a = this.activeMenu.height(), r = e.outerHeight(), 0 > n ? this.activeMenu.scrollTop(o + n) : n + r > a && this.activeMenu.scrollTop(o + n - a + r));
		}, blur: function blur(t, e) {
			e || clearTimeout(this.timer), this.active && (this._removeClass(this.active.children(".ui-menu-item-wrapper"), null, "ui-state-active"), this._trigger("blur", t, { item: this.active }), this.active = null);
		}, _startOpening: function _startOpening(t) {
			clearTimeout(this.timer), "true" === t.attr("aria-hidden") && (this.timer = this._delay(function () {
				this._close(), this._open(t);
			}, this.delay));
		}, _open: function _open(e) {
			var i = t.extend({ of: this.active }, this.options.position);clearTimeout(this.timer), this.element.find(".ui-menu").not(e.parents(".ui-menu")).hide().attr("aria-hidden", "true"), e.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(i);
		}, collapseAll: function collapseAll(e, i) {
			clearTimeout(this.timer), this.timer = this._delay(function () {
				var s = i ? this.element : t(e && e.target).closest(this.element.find(".ui-menu"));s.length || (s = this.element), this._close(s), this.blur(e), this._removeClass(s.find(".ui-state-active"), null, "ui-state-active"), this.activeMenu = s;
			}, this.delay);
		}, _close: function _close(t) {
			t || (t = this.active ? this.active.parent() : this.element), t.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false");
		}, _closeOnDocumentClick: function _closeOnDocumentClick(e) {
			return !t(e.target).closest(".ui-menu").length;
		}, _isDivider: function _isDivider(t) {
			return !/[^\-\u2014\u2013\s]/.test(t.text());
		}, collapse: function collapse(t) {
			var e = this.active && this.active.parent().closest(".ui-menu-item", this.element);e && e.length && (this._close(), this.focus(t, e));
		}, expand: function expand(t) {
			var e = this.active && this.active.children(".ui-menu ").find(this.options.items).first();e && e.length && (this._open(e.parent()), this._delay(function () {
				this.focus(t, e);
			}));
		}, next: function next(t) {
			this._move("next", "first", t);
		}, previous: function previous(t) {
			this._move("prev", "last", t);
		}, isFirstItem: function isFirstItem() {
			return this.active && !this.active.prevAll(".ui-menu-item").length;
		}, isLastItem: function isLastItem() {
			return this.active && !this.active.nextAll(".ui-menu-item").length;
		}, _move: function _move(t, e, i) {
			var s;this.active && (s = "first" === t || "last" === t ? this.active["first" === t ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1) : this.active[t + "All"](".ui-menu-item").eq(0)), s && s.length && this.active || (s = this.activeMenu.find(this.options.items)[e]()), this.focus(i, s);
		}, nextPage: function nextPage(e) {
			var i, s, n;return this.active ? (this.isLastItem() || (this._hasScroll() ? (s = this.active.offset().top, n = this.element.height(), this.active.nextAll(".ui-menu-item").each(function () {
				return i = t(this), 0 > i.offset().top - s - n;
			}), this.focus(e, i)) : this.focus(e, this.activeMenu.find(this.options.items)[this.active ? "last" : "first"]())), void 0) : (this.next(e), void 0);
		}, previousPage: function previousPage(e) {
			var i, s, n;return this.active ? (this.isFirstItem() || (this._hasScroll() ? (s = this.active.offset().top, n = this.element.height(), this.active.prevAll(".ui-menu-item").each(function () {
				return i = t(this), i.offset().top - s + n > 0;
			}), this.focus(e, i)) : this.focus(e, this.activeMenu.find(this.options.items).first())), void 0) : (this.next(e), void 0);
		}, _hasScroll: function _hasScroll() {
			return this.element.outerHeight() < this.element.prop("scrollHeight");
		}, select: function select(e) {
			this.active = this.active || t(e.target).closest(".ui-menu-item");var i = { item: this.active };this.active.has(".ui-menu").length || this.collapseAll(e, !0), this._trigger("select", e, i);
		}, _filterMenuItems: function _filterMenuItems(e) {
			var i = e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"),
			    s = RegExp("^" + i, "i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function () {
				return s.test(t.trim(t(this).children(".ui-menu-item-wrapper").text()));
			});
		} }), t.widget("ui.autocomplete", { version: "1.12.0", defaultElement: "<input>", options: { appendTo: null, autoFocus: !1, delay: 300, minLength: 1, position: { my: "left top", at: "left bottom", collision: "none" }, source: null, change: null, close: null, focus: null, open: null, response: null, search: null, select: null }, requestIndex: 0, pending: 0, _create: function _create() {
			var e,
			    i,
			    s,
			    n = this.element[0].nodeName.toLowerCase(),
			    o = "textarea" === n,
			    a = "input" === n;this.isMultiLine = o || !a && this._isContentEditable(this.element), this.valueMethod = this.element[o || a ? "val" : "text"], this.isNewMenu = !0, this._addClass("ui-autocomplete-input"), this.element.attr("autocomplete", "off"), this._on(this.element, { keydown: function keydown(n) {
					if (this.element.prop("readOnly")) return e = !0, s = !0, i = !0, void 0;e = !1, s = !1, i = !1;var o = t.ui.keyCode;switch (n.keyCode) {case o.PAGE_UP:
							e = !0, this._move("previousPage", n);break;case o.PAGE_DOWN:
							e = !0, this._move("nextPage", n);break;case o.UP:
							e = !0, this._keyEvent("previous", n);break;case o.DOWN:
							e = !0, this._keyEvent("next", n);break;case o.ENTER:
							this.menu.active && (e = !0, n.preventDefault(), this.menu.select(n));break;case o.TAB:
							this.menu.active && this.menu.select(n);break;case o.ESCAPE:
							this.menu.element.is(":visible") && (this.isMultiLine || this._value(this.term), this.close(n), n.preventDefault());break;default:
							i = !0, this._searchTimeout(n);}
				}, keypress: function keypress(s) {
					if (e) return e = !1, (!this.isMultiLine || this.menu.element.is(":visible")) && s.preventDefault(), void 0;if (!i) {
						var n = t.ui.keyCode;switch (s.keyCode) {case n.PAGE_UP:
								this._move("previousPage", s);break;case n.PAGE_DOWN:
								this._move("nextPage", s);break;case n.UP:
								this._keyEvent("previous", s);break;case n.DOWN:
								this._keyEvent("next", s);}
					}
				}, input: function input(t) {
					return s ? (s = !1, t.preventDefault(), void 0) : (this._searchTimeout(t), void 0);
				}, focus: function focus() {
					this.selectedItem = null, this.previous = this._value();
				}, blur: function blur(t) {
					return this.cancelBlur ? (delete this.cancelBlur, void 0) : (clearTimeout(this.searching), this.close(t), this._change(t), void 0);
				} }), this._initSource(), this.menu = t("<ul>").appendTo(this._appendTo()).menu({ role: null }).hide().menu("instance"), this._addClass(this.menu.element, "ui-autocomplete", "ui-front"), this._on(this.menu.element, { mousedown: function mousedown(e) {
					e.preventDefault(), this.cancelBlur = !0, this._delay(function () {
						delete this.cancelBlur, this.element[0] !== t.ui.safeActiveElement(this.document[0]) && this.element.trigger("focus");
					});
				}, menufocus: function menufocus(e, i) {
					var s, n;return this.isNewMenu && (this.isNewMenu = !1, e.originalEvent && /^mouse/.test(e.originalEvent.type)) ? (this.menu.blur(), this.document.one("mousemove", function () {
						t(e.target).trigger(e.originalEvent);
					}), void 0) : (n = i.item.data("ui-autocomplete-item"), !1 !== this._trigger("focus", e, { item: n }) && e.originalEvent && /^key/.test(e.originalEvent.type) && this._value(n.value), s = i.item.attr("aria-label") || n.value, s && t.trim(s).length && (this.liveRegion.children().hide(), t("<div>").text(s).appendTo(this.liveRegion)), void 0);
				}, menuselect: function menuselect(e, i) {
					var s = i.item.data("ui-autocomplete-item"),
					    n = this.previous;this.element[0] !== t.ui.safeActiveElement(this.document[0]) && (this.element.trigger("focus"), this.previous = n, this._delay(function () {
						this.previous = n, this.selectedItem = s;
					})), !1 !== this._trigger("select", e, { item: s }) && this._value(s.value), this.term = this._value(), this.close(e), this.selectedItem = s;
				} }), this.liveRegion = t("<div>", { role: "status", "aria-live": "assertive", "aria-relevant": "additions" }).appendTo(this.document[0].body), this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible"), this._on(this.window, { beforeunload: function beforeunload() {
					this.element.removeAttr("autocomplete");
				} });
		}, _destroy: function _destroy() {
			clearTimeout(this.searching), this.element.removeAttr("autocomplete"), this.menu.element.remove(), this.liveRegion.remove();
		}, _setOption: function _setOption(t, e) {
			this._super(t, e), "source" === t && this._initSource(), "appendTo" === t && this.menu.element.appendTo(this._appendTo()), "disabled" === t && e && this.xhr && this.xhr.abort();
		}, _isEventTargetInWidget: function _isEventTargetInWidget(e) {
			var i = this.menu.element[0];return e.target === this.element[0] || e.target === i || t.contains(i, e.target);
		}, _closeOnClickOutside: function _closeOnClickOutside(t) {
			this._isEventTargetInWidget(t) || this.close();
		}, _appendTo: function _appendTo() {
			var e = this.options.appendTo;return e && (e = e.jquery || e.nodeType ? t(e) : this.document.find(e).eq(0)), e && e[0] || (e = this.element.closest(".ui-front, dialog")), e.length || (e = this.document[0].body), e;
		}, _initSource: function _initSource() {
			var e,
			    i,
			    s = this;t.isArray(this.options.source) ? (e = this.options.source, this.source = function (i, s) {
				s(t.ui.autocomplete.filter(e, i.term));
			}) : "string" == typeof this.options.source ? (i = this.options.source, this.source = function (e, n) {
				s.xhr && s.xhr.abort(), s.xhr = t.ajax({ url: i, data: e, dataType: "json", success: function success(t) {
						n(t);
					}, error: function error() {
						n([]);
					} });
			}) : this.source = this.options.source;
		}, _searchTimeout: function _searchTimeout(t) {
			clearTimeout(this.searching), this.searching = this._delay(function () {
				var e = this.term === this._value(),
				    i = this.menu.element.is(":visible"),
				    s = t.altKey || t.ctrlKey || t.metaKey || t.shiftKey;
				(!e || e && !i && !s) && (this.selectedItem = null, this.search(null, t));
			}, this.options.delay);
		}, search: function search(t, e) {
			return t = null != t ? t : this._value(), this.term = this._value(), t.length < this.options.minLength ? this.close(e) : this._trigger("search", e) !== !1 ? this._search(t) : void 0;
		}, _search: function _search(t) {
			this.pending++, this._addClass("ui-autocomplete-loading"), this.cancelSearch = !1, this.source({ term: t }, this._response());
		}, _response: function _response() {
			var e = ++this.requestIndex;return t.proxy(function (t) {
				e === this.requestIndex && this.__response(t), this.pending--, this.pending || this._removeClass("ui-autocomplete-loading");
			}, this);
		}, __response: function __response(t) {
			t && (t = this._normalize(t)), this._trigger("response", null, { content: t }), !this.options.disabled && t && t.length && !this.cancelSearch ? (this._suggest(t), this._trigger("open")) : this._close();
		}, close: function close(t) {
			this.cancelSearch = !0, this._close(t);
		}, _close: function _close(t) {
			this._off(this.document, "mousedown"), this.menu.element.is(":visible") && (this.menu.element.hide(), this.menu.blur(), this.isNewMenu = !0, this._trigger("close", t));
		}, _change: function _change(t) {
			this.previous !== this._value() && this._trigger("change", t, { item: this.selectedItem });
		}, _normalize: function _normalize(e) {
			return e.length && e[0].label && e[0].value ? e : t.map(e, function (e) {
				return "string" == typeof e ? { label: e, value: e } : t.extend({}, e, { label: e.label || e.value, value: e.value || e.label });
			});
		}, _suggest: function _suggest(e) {
			var i = this.menu.element.empty();this._renderMenu(i, e), this.isNewMenu = !0, this.menu.refresh(), i.show(), this._resizeMenu(), i.position(t.extend({ of: this.element }, this.options.position)), this.options.autoFocus && this.menu.next(), this._on(this.document, { mousedown: "_closeOnClickOutside" });
		}, _resizeMenu: function _resizeMenu() {
			var t = this.menu.element;t.outerWidth(Math.max(t.width("").outerWidth() + 1, this.element.outerWidth()));
		}, _renderMenu: function _renderMenu(e, i) {
			var s = this;t.each(i, function (t, i) {
				s._renderItemData(e, i);
			});
		}, _renderItemData: function _renderItemData(t, e) {
			return this._renderItem(t, e).data("ui-autocomplete-item", e);
		}, _renderItem: function _renderItem(e, i) {
			return t("<li>").append(t("<div>").text(i.label)).appendTo(e);
		}, _move: function _move(t, e) {
			return this.menu.element.is(":visible") ? this.menu.isFirstItem() && /^previous/.test(t) || this.menu.isLastItem() && /^next/.test(t) ? (this.isMultiLine || this._value(this.term), this.menu.blur(), void 0) : (this.menu[t](e), void 0) : (this.search(null, e), void 0);
		}, widget: function widget() {
			return this.menu.element;
		}, _value: function _value() {
			return this.valueMethod.apply(this.element, arguments);
		}, _keyEvent: function _keyEvent(t, e) {
			(!this.isMultiLine || this.menu.element.is(":visible")) && (this._move(t, e), e.preventDefault());
		}, _isContentEditable: function _isContentEditable(t) {
			if (!t.length) return !1;var e = t.prop("contentEditable");return "inherit" === e ? this._isContentEditable(t.parent()) : "true" === e;
		} }), t.extend(t.ui.autocomplete, { escapeRegex: function escapeRegex(t) {
			return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
		}, filter: function filter(e, i) {
			var s = RegExp(t.ui.autocomplete.escapeRegex(i), "i");return t.grep(e, function (t) {
				return s.test(t.label || t.value || t);
			});
		} }), t.widget("ui.autocomplete", t.ui.autocomplete, { options: { messages: { noResults: "No search results.", results: function results(t) {
					return t + (t > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate.";
				} } }, __response: function __response(e) {
			var i;this._superApply(arguments), this.options.disabled || this.cancelSearch || (i = e && e.length ? this.options.messages.results(e.length) : this.options.messages.noResults, this.liveRegion.children().hide(), t("<div>").text(i).appendTo(this.liveRegion));
		} }), t.ui.autocomplete;
});
/* Tooltipster v3.3.0 */;(function (e, t, n) {
	function s(t, n) {
		this.bodyOverflowX;this.callbacks = { hide: [], show: [] };this.checkInterval = null;this.Content;this.$el = e(t);this.$elProxy;this.elProxyPosition;this.enabled = true;this.options = e.extend({}, i, n);this.mouseIsOverProxy = false;this.namespace = "tooltipster-" + Math.round(Math.random() * 1e5);this.Status = "hidden";this.timerHide = null;this.timerShow = null;this.$tooltip;this.options.iconTheme = this.options.iconTheme.replace(".", "");this.options.theme = this.options.theme.replace(".", "");this._init();
	}function o(t, n) {
		var r = true;e.each(t, function (e, i) {
			if (typeof n[e] === "undefined" || t[e] !== n[e]) {
				r = false;return false;
			}
		});return r;
	}function f() {
		return !a && u;
	}function l() {
		var e = n.body || n.documentElement,
		    t = e.style,
		    r = "transition";if (typeof t[r] == "string") {
			return true;
		}v = ["Moz", "Webkit", "Khtml", "O", "ms"], r = r.charAt(0).toUpperCase() + r.substr(1);for (var i = 0; i < v.length; i++) {
			if (typeof t[v[i] + r] == "string") {
				return true;
			}
		}return false;
	}var r = "tooltipster",
	    i = { animation: "fade", arrow: true, arrowColor: "", autoClose: true, content: null, contentAsHTML: false, contentCloning: true, debug: true, delay: 200, minWidth: 0, maxWidth: null, functionInit: function functionInit(e, t) {}, functionBefore: function functionBefore(e, t) {
			t();
		}, functionReady: function functionReady(e, t) {}, functionAfter: function functionAfter(e) {}, hideOnClick: false, icon: "(?)", iconCloning: true, iconDesktop: false, iconTouch: false, iconTheme: "tooltipster-icon", interactive: false, interactiveTolerance: 350, multiple: false, offsetX: 0, offsetY: 0, onlyOne: false, position: "top", positionTracker: false, positionTrackerCallback: function positionTrackerCallback(e) {
			if (this.option("trigger") == "hover" && this.option("autoClose")) {
				this.hide();
			}
		}, restoration: "current", speed: 350, timer: 0, theme: "tooltipster-default", touchDevices: true, trigger: "hover", updateAnimation: true };s.prototype = { _init: function _init() {
			var t = this;if (n.querySelector) {
				var r = null;if (t.$el.data("tooltipster-initialTitle") === undefined) {
					r = t.$el.attr("title");if (r === undefined) r = null;t.$el.data("tooltipster-initialTitle", r);
				}if (t.options.content !== null) {
					t._content_set(t.options.content);
				} else {
					t._content_set(r);
				}var i = t.options.functionInit.call(t.$el, t.$el, t.Content);if (typeof i !== "undefined") t._content_set(i);t.$el.removeAttr("title").addClass("tooltipstered");if (!u && t.options.iconDesktop || u && t.options.iconTouch) {
					if (typeof t.options.icon === "string") {
						t.$elProxy = e('<span class="' + t.options.iconTheme + '"></span>');t.$elProxy.text(t.options.icon);
					} else {
						if (t.options.iconCloning) t.$elProxy = t.options.icon.clone(true);else t.$elProxy = t.options.icon;
					}t.$elProxy.insertAfter(t.$el);
				} else {
					t.$elProxy = t.$el;
				}if (t.options.trigger == "hover") {
					t.$elProxy.on("mouseenter." + t.namespace, function () {
						if (!f() || t.options.touchDevices) {
							t.mouseIsOverProxy = true;t._show();
						}
					}).on("mouseleave." + t.namespace, function () {
						if (!f() || t.options.touchDevices) {
							t.mouseIsOverProxy = false;
						}
					});if (u && t.options.touchDevices) {
						t.$elProxy.on("touchstart." + t.namespace, function () {
							t._showNow();
						});
					}
				} else if (t.options.trigger == "click") {
					t.$elProxy.on("click." + t.namespace, function () {
						if (!f() || t.options.touchDevices) {
							t._show();
						}
					});
				}
			}
		}, _show: function _show() {
			var e = this;if (e.Status != "shown" && e.Status != "appearing") {
				if (e.options.delay) {
					e.timerShow = setTimeout(function () {
						if (e.options.trigger == "click" || e.options.trigger == "hover" && e.mouseIsOverProxy) {
							e._showNow();
						}
					}, e.options.delay);
				} else e._showNow();
			}
		}, _showNow: function _showNow(n) {
			var r = this;r.options.functionBefore.call(r.$el, r.$el, function () {
				if (r.enabled && r.Content !== null) {
					if (n) r.callbacks.show.push(n);r.callbacks.hide = [];clearTimeout(r.timerShow);r.timerShow = null;clearTimeout(r.timerHide);r.timerHide = null;if (r.options.onlyOne) {
						e(".tooltipstered").not(r.$el).each(function (t, n) {
							var r = e(n),
							    i = r.data("tooltipster-ns");e.each(i, function (e, t) {
								var n = r.data(t),
								    i = n.status(),
								    s = n.option("autoClose");if (i !== "hidden" && i !== "disappearing" && s) {
									n.hide();
								}
							});
						});
					}var i = function i() {
						r.Status = "shown";e.each(r.callbacks.show, function (e, t) {
							t.call(r.$el);
						});r.callbacks.show = [];
					};if (r.Status !== "hidden") {
						var s = 0;if (r.Status === "disappearing") {
							r.Status = "appearing";if (l()) {
								r.$tooltip.clearQueue().removeClass("tooltipster-dying").addClass("tooltipster-" + r.options.animation + "-show");if (r.options.speed > 0) r.$tooltip.delay(r.options.speed);r.$tooltip.queue(i);
							} else {
								r.$tooltip.stop().fadeIn(i);
							}
						} else if (r.Status === "shown") {
							i();
						}
					} else {
						r.Status = "appearing";var s = r.options.speed;r.bodyOverflowX = e("body").css("overflow-x");e("body").css("overflow-x", "hidden");var o = "tooltipster-" + r.options.animation,
						    a = "-webkit-transition-duration: " + r.options.speed + "ms; -webkit-animation-duration: " + r.options.speed + "ms; -moz-transition-duration: " + r.options.speed + "ms; -moz-animation-duration: " + r.options.speed + "ms; -o-transition-duration: " + r.options.speed + "ms; -o-animation-duration: " + r.options.speed + "ms; -ms-transition-duration: " + r.options.speed + "ms; -ms-animation-duration: " + r.options.speed + "ms; transition-duration: " + r.options.speed + "ms; animation-duration: " + r.options.speed + "ms;",
						    f = r.options.minWidth ? "min-width:" + Math.round(r.options.minWidth) + "px;" : "",
						    c = r.options.maxWidth ? "max-width:" + Math.round(r.options.maxWidth) + "px;" : "",
						    h = r.options.interactive ? "pointer-events: auto;" : "";r.$tooltip = e('<div class="tooltipster-base ' + r.options.theme + '" style="' + f + " " + c + " " + h + " " + a + '"><div class="tooltipster-content"></div></div>');if (l()) r.$tooltip.addClass(o);r._content_insert();r.$tooltip.appendTo("body");r.reposition();r.options.functionReady.call(r.$el, r.$el, r.$tooltip);if (l()) {
							r.$tooltip.addClass(o + "-show");if (r.options.speed > 0) r.$tooltip.delay(r.options.speed);r.$tooltip.queue(i);
						} else {
							r.$tooltip.css("display", "none").fadeIn(r.options.speed, i);
						}r._interval_set();e(t).on("scroll." + r.namespace + " resize." + r.namespace, function () {
							r.reposition();
						});if (r.options.autoClose) {
							e("body").off("." + r.namespace);if (r.options.trigger == "hover") {
								if (u) {
									setTimeout(function () {
										e("body").on("touchstart." + r.namespace, function () {
											r.hide();
										});
									}, 0);
								}if (r.options.interactive) {
									if (u) {
										r.$tooltip.on("touchstart." + r.namespace, function (e) {
											e.stopPropagation();
										});
									}var p = null;r.$elProxy.add(r.$tooltip).on("mouseleave." + r.namespace + "-autoClose", function () {
										clearTimeout(p);p = setTimeout(function () {
											r.hide();
										}, r.options.interactiveTolerance);
									}).on("mouseenter." + r.namespace + "-autoClose", function () {
										clearTimeout(p);
									});
								} else {
									r.$elProxy.on("mouseleave." + r.namespace + "-autoClose", function () {
										r.hide();
									});
								}if (r.options.hideOnClick) {
									r.$elProxy.on("click." + r.namespace + "-autoClose", function () {
										r.hide();
									});
								}
							} else if (r.options.trigger == "click") {
								setTimeout(function () {
									e("body").on("click." + r.namespace + " touchstart." + r.namespace, function () {
										r.hide();
									});
								}, 0);if (r.options.interactive) {
									r.$tooltip.on("click." + r.namespace + " touchstart." + r.namespace, function (e) {
										e.stopPropagation();
									});
								}
							}
						}
					}if (r.options.timer > 0) {
						r.timerHide = setTimeout(function () {
							r.timerHide = null;r.hide();
						}, r.options.timer + s);
					}
				}
			});
		}, _interval_set: function _interval_set() {
			var t = this;t.checkInterval = setInterval(function () {
				if (e("body").find(t.$el).length === 0 || e("body").find(t.$elProxy).length === 0 || t.Status == "hidden" || e("body").find(t.$tooltip).length === 0) {
					if (t.Status == "shown" || t.Status == "appearing") t.hide();t._interval_cancel();
				} else {
					if (t.options.positionTracker) {
						var n = t._repositionInfo(t.$elProxy),
						    r = false;if (o(n.dimension, t.elProxyPosition.dimension)) {
							if (t.$elProxy.css("position") === "fixed") {
								if (o(n.position, t.elProxyPosition.position)) r = true;
							} else {
								if (o(n.offset, t.elProxyPosition.offset)) r = true;
							}
						}if (!r) {
							t.reposition();t.options.positionTrackerCallback.call(t, t.$el);
						}
					}
				}
			}, 200);
		}, _interval_cancel: function _interval_cancel() {
			clearInterval(this.checkInterval);this.checkInterval = null;
		}, _content_set: function _content_set(e) {
			if ((typeof e === "undefined" ? "undefined" : _typeof(e)) === "object" && e !== null && this.options.contentCloning) {
				e = e.clone(true);
			}this.Content = e;
		}, _content_insert: function _content_insert() {
			var e = this,
			    t = this.$tooltip.find(".tooltipster-content");if (typeof e.Content === "string" && !e.options.contentAsHTML) {
				t.text(e.Content);
			} else {
				t.empty().append(e.Content);
			}
		}, _update: function _update(e) {
			var t = this;t._content_set(e);if (t.Content !== null) {
				if (t.Status !== "hidden") {
					t._content_insert();t.reposition();if (t.options.updateAnimation) {
						if (l()) {
							t.$tooltip.css({ width: "", "-webkit-transition": "all " + t.options.speed + "ms, width 0ms, height 0ms, left 0ms, top 0ms", "-moz-transition": "all " + t.options.speed + "ms, width 0ms, height 0ms, left 0ms, top 0ms", "-o-transition": "all " + t.options.speed + "ms, width 0ms, height 0ms, left 0ms, top 0ms", "-ms-transition": "all " + t.options.speed + "ms, width 0ms, height 0ms, left 0ms, top 0ms", transition: "all " + t.options.speed + "ms, width 0ms, height 0ms, left 0ms, top 0ms" }).addClass("tooltipster-content-changing");setTimeout(function () {
								if (t.Status != "hidden") {
									t.$tooltip.removeClass("tooltipster-content-changing");setTimeout(function () {
										if (t.Status !== "hidden") {
											t.$tooltip.css({ "-webkit-transition": t.options.speed + "ms", "-moz-transition": t.options.speed + "ms", "-o-transition": t.options.speed + "ms", "-ms-transition": t.options.speed + "ms", transition: t.options.speed + "ms" });
										}
									}, t.options.speed);
								}
							}, t.options.speed);
						} else {
							t.$tooltip.fadeTo(t.options.speed, .5, function () {
								if (t.Status != "hidden") {
									t.$tooltip.fadeTo(t.options.speed, 1);
								}
							});
						}
					}
				}
			} else {
				t.hide();
			}
		}, _repositionInfo: function _repositionInfo(e) {
			return { dimension: { height: e.outerHeight(false), width: e.outerWidth(false) }, offset: e.offset(), position: { left: parseInt(e.css("left")), top: parseInt(e.css("top")) } };
		}, hide: function hide(n) {
			var r = this;if (n) r.callbacks.hide.push(n);r.callbacks.show = [];clearTimeout(r.timerShow);r.timerShow = null;clearTimeout(r.timerHide);r.timerHide = null;var i = function i() {
				e.each(r.callbacks.hide, function (e, t) {
					t.call(r.$el);
				});r.callbacks.hide = [];
			};if (r.Status == "shown" || r.Status == "appearing") {
				r.Status = "disappearing";var s = function s() {
					r.Status = "hidden";if (_typeof(r.Content) == "object" && r.Content !== null) {
						r.Content.detach();
					}r.$tooltip.remove();r.$tooltip = null;e(t).off("." + r.namespace);e("body").off("." + r.namespace).css("overflow-x", r.bodyOverflowX);e("body").off("." + r.namespace);r.$elProxy.off("." + r.namespace + "-autoClose");r.options.functionAfter.call(r.$el, r.$el);i();
				};if (l()) {
					r.$tooltip.clearQueue().removeClass("tooltipster-" + r.options.animation + "-show").addClass("tooltipster-dying");if (r.options.speed > 0) r.$tooltip.delay(r.options.speed);r.$tooltip.queue(s);
				} else {
					r.$tooltip.stop().fadeOut(r.options.speed, s);
				}
			} else if (r.Status == "hidden") {
				i();
			}return r;
		}, show: function show(e) {
			this._showNow(e);return this;
		}, update: function update(e) {
			return this.content(e);
		}, content: function content(e) {
			if (typeof e === "undefined") {
				return this.Content;
			} else {
				this._update(e);return this;
			}
		}, reposition: function reposition() {
			var n = this;if (e("body").find(n.$tooltip).length !== 0) {
				var _H = function _H() {
					var n = e(t).scrollLeft();if (A - n < 0) {
						r = A - n;A = n;
					}if (A + o - n > i) {
						r = A - (i + n - o);A = i + n - o;
					}
				};

				var B = function B(n, r) {
					if (s.offset.top - e(t).scrollTop() - a - _ - 12 < 0 && r.indexOf("top") > -1) {
						P = n;
					}if (s.offset.top + s.dimension.height + a + 12 + _ > e(t).scrollTop() + e(t).height() && r.indexOf("bottom") > -1) {
						P = n;M = s.offset.top - a - _ - 12;
					}
				};

				n.$tooltip.css("width", "");n.elProxyPosition = n._repositionInfo(n.$elProxy);var r = null,
				    i = e(t).width(),
				    s = n.elProxyPosition,
				    o = n.$tooltip.outerWidth(false),
				    u = n.$tooltip.innerWidth() + 1,
				    a = n.$tooltip.outerHeight(false);if (n.$elProxy.is("area")) {
					var f = n.$elProxy.attr("shape"),
					    l = n.$elProxy.parent().attr("name"),
					    c = e('img[usemap="#' + l + '"]'),
					    h = c.offset().left,
					    p = c.offset().top,
					    d = n.$elProxy.attr("coords") !== undefined ? n.$elProxy.attr("coords").split(",") : undefined;if (f == "circle") {
						var v = parseInt(d[0]),
						    m = parseInt(d[1]),
						    g = parseInt(d[2]);s.dimension.height = g * 2;s.dimension.width = g * 2;s.offset.top = p + m - g;s.offset.left = h + v - g;
					} else if (f == "rect") {
						var v = parseInt(d[0]),
						    m = parseInt(d[1]),
						    y = parseInt(d[2]),
						    b = parseInt(d[3]);s.dimension.height = b - m;s.dimension.width = y - v;s.offset.top = p + m;s.offset.left = h + v;
					} else if (f == "poly") {
						var w = [],
						    E = [],
						    S = 0,
						    x = 0,
						    T = 0,
						    N = 0,
						    C = "even";for (var k = 0; k < d.length; k++) {
							var L = parseInt(d[k]);if (C == "even") {
								if (L > T) {
									T = L;if (k === 0) {
										S = T;
									}
								}if (L < S) {
									S = L;
								}C = "odd";
							} else {
								if (L > N) {
									N = L;if (k == 1) {
										x = N;
									}
								}if (L < x) {
									x = L;
								}C = "even";
							}
						}s.dimension.height = N - x;s.dimension.width = T - S;s.offset.top = p + x;s.offset.left = h + S;
					} else {
						s.dimension.height = c.outerHeight(false);s.dimension.width = c.outerWidth(false);s.offset.top = p;s.offset.left = h;
					}
				}var A = 0,
				    O = 0,
				    M = 0,
				    _ = parseInt(n.options.offsetY),
				    D = parseInt(n.options.offsetX),
				    P = n.options.position;if (P == "top") {
					var j = s.offset.left + o - (s.offset.left + s.dimension.width);A = s.offset.left + D - j / 2;M = s.offset.top - a - _ - 12;_H();B("bottom", "top");
				}if (P == "top-left") {
					A = s.offset.left + D;M = s.offset.top - a - _ - 12;_H();B("bottom-left", "top-left");
				}if (P == "top-right") {
					A = s.offset.left + s.dimension.width + D - o;M = s.offset.top - a - _ - 12;_H();B("bottom-right", "top-right");
				}if (P == "bottom") {
					var j = s.offset.left + o - (s.offset.left + s.dimension.width);A = s.offset.left - j / 2 + D;M = s.offset.top + s.dimension.height + _ + 12;_H();B("top", "bottom");
				}if (P == "bottom-left") {
					A = s.offset.left + D;M = s.offset.top + s.dimension.height + _ + 12;_H();B("top-left", "bottom-left");
				}if (P == "bottom-right") {
					A = s.offset.left + s.dimension.width + D - o;M = s.offset.top + s.dimension.height + _ + 12;_H();B("top-right", "bottom-right");
				}if (P == "left") {
					A = s.offset.left - D - o - 12;O = s.offset.left + D + s.dimension.width + 12;var F = s.offset.top + a - (s.offset.top + s.dimension.height);M = s.offset.top - F / 2 - _;if (A < 0 && O + o > i) {
						var I = parseFloat(n.$tooltip.css("border-width")) * 2,
						    q = o + A - I;n.$tooltip.css("width", q + "px");a = n.$tooltip.outerHeight(false);A = s.offset.left - D - q - 12 - I;F = s.offset.top + a - (s.offset.top + s.dimension.height);M = s.offset.top - F / 2 - _;
					} else if (A < 0) {
						A = s.offset.left + D + s.dimension.width + 12;r = "left";
					}
				}if (P == "right") {
					A = s.offset.left + D + s.dimension.width + 12;O = s.offset.left - D - o - 12;var F = s.offset.top + a - (s.offset.top + s.dimension.height);M = s.offset.top - F / 2 - _;if (A + o > i && O < 0) {
						var I = parseFloat(n.$tooltip.css("border-width")) * 2,
						    q = i - A - I;n.$tooltip.css("width", q + "px");a = n.$tooltip.outerHeight(false);F = s.offset.top + a - (s.offset.top + s.dimension.height);M = s.offset.top - F / 2 - _;
					} else if (A + o > i) {
						A = s.offset.left - D - o - 12;r = "right";
					}
				}if (n.options.arrow) {
					var R = "tooltipster-arrow-" + P;if (n.options.arrowColor.length < 1) {
						var U = n.$tooltip.css("background-color");
					} else {
						var U = n.options.arrowColor;
					}if (!r) {
						r = "";
					} else if (r == "left") {
						R = "tooltipster-arrow-right";r = "";
					} else if (r == "right") {
						R = "tooltipster-arrow-left";r = "";
					} else {
						r = "left:" + Math.round(r) + "px;";
					}if (P == "top" || P == "top-left" || P == "top-right") {
						var z = parseFloat(n.$tooltip.css("border-bottom-width")),
						    W = n.$tooltip.css("border-bottom-color");
					} else if (P == "bottom" || P == "bottom-left" || P == "bottom-right") {
						var z = parseFloat(n.$tooltip.css("border-top-width")),
						    W = n.$tooltip.css("border-top-color");
					} else if (P == "left") {
						var z = parseFloat(n.$tooltip.css("border-right-width")),
						    W = n.$tooltip.css("border-right-color");
					} else if (P == "right") {
						var z = parseFloat(n.$tooltip.css("border-left-width")),
						    W = n.$tooltip.css("border-left-color");
					} else {
						var z = parseFloat(n.$tooltip.css("border-bottom-width")),
						    W = n.$tooltip.css("border-bottom-color");
					}if (z > 1) {
						z++;
					}var X = "";if (z !== 0) {
						var V = "",
						    J = "border-color: " + W + ";";if (R.indexOf("bottom") !== -1) {
							V = "margin-top: -" + Math.round(z) + "px;";
						} else if (R.indexOf("top") !== -1) {
							V = "margin-bottom: -" + Math.round(z) + "px;";
						} else if (R.indexOf("left") !== -1) {
							V = "margin-right: -" + Math.round(z) + "px;";
						} else if (R.indexOf("right") !== -1) {
							V = "margin-left: -" + Math.round(z) + "px;";
						}X = '<span class="tooltipster-arrow-border" style="' + V + " " + J + ';"></span>';
					}n.$tooltip.find(".tooltipster-arrow").remove();var K = '<div class="' + R + ' tooltipster-arrow" style="' + r + '">' + X + '<span style="border-color:' + U + ';"></span></div>';n.$tooltip.append(K);
				}n.$tooltip.css({ top: Math.round(M) + "px", left: Math.round(A) + "px" });
			}return n;
		}, enable: function enable() {
			this.enabled = true;return this;
		}, disable: function disable() {
			this.hide();this.enabled = false;return this;
		}, destroy: function destroy() {
			var t = this;t.hide();if (t.$el[0] !== t.$elProxy[0]) {
				t.$elProxy.remove();
			}t.$el.removeData(t.namespace).off("." + t.namespace);var n = t.$el.data("tooltipster-ns");if (n.length === 1) {
				var r = null;if (t.options.restoration === "previous") {
					r = t.$el.data("tooltipster-initialTitle");
				} else if (t.options.restoration === "current") {
					r = typeof t.Content === "string" ? t.Content : e("<div></div>").append(t.Content).html();
				}if (r) {
					t.$el.attr("title", r);
				}t.$el.removeClass("tooltipstered").removeData("tooltipster-ns").removeData("tooltipster-initialTitle");
			} else {
				n = e.grep(n, function (e, n) {
					return e !== t.namespace;
				});t.$el.data("tooltipster-ns", n);
			}return t;
		}, elementIcon: function elementIcon() {
			return this.$el[0] !== this.$elProxy[0] ? this.$elProxy[0] : undefined;
		}, elementTooltip: function elementTooltip() {
			return this.$tooltip ? this.$tooltip[0] : undefined;
		}, option: function option(e, t) {
			if (typeof t == "undefined") return this.options[e];else {
				this.options[e] = t;return this;
			}
		}, status: function status() {
			return this.Status;
		} };e.fn[r] = function () {
		var t = arguments;if (this.length === 0) {
			if (typeof t[0] === "string") {
				var n = true;switch (t[0]) {case "setDefaults":
						e.extend(i, t[1]);break;default:
						n = false;break;}if (n) return true;else return this;
			} else {
				return this;
			}
		} else {
			if (typeof t[0] === "string") {
				var r = "#*$~&";this.each(function () {
					var n = e(this).data("tooltipster-ns"),
					    i = n ? e(this).data(n[0]) : null;if (i) {
						if (typeof i[t[0]] === "function") {
							var s = i[t[0]](t[1], t[2]);
						} else {
							throw new Error('Unknown method .tooltipster("' + t[0] + '")');
						}if (s !== i) {
							r = s;return false;
						}
					} else {
						throw new Error("You called Tooltipster's \"" + t[0] + '" method on an uninitialized element');
					}
				});return r !== "#*$~&" ? r : this;
			} else {
				var o = [],
				    u = t[0] && typeof t[0].multiple !== "undefined",
				    a = u && t[0].multiple || !u && i.multiple,
				    f = t[0] && typeof t[0].debug !== "undefined",
				    l = f && t[0].debug || !f && i.debug;this.each(function () {
					var n = false,
					    r = e(this).data("tooltipster-ns"),
					    i = null;if (!r) {
						n = true;
					} else if (a) {
						n = true;
					} else if (l) {
						console.log('Tooltipster: one or more tooltips are already attached to this element: ignoring. Use the "multiple" option to attach more tooltips.');
					}if (n) {
						i = new s(this, t[0]);if (!r) r = [];r.push(i.namespace);e(this).data("tooltipster-ns", r);e(this).data(i.namespace, i);
					}o.push(i);
				});if (a) return o;else return this;
			}
		}
	};var u = !!("ontouchstart" in t);var a = false;e("body").one("mousemove", function () {
		a = true;
	});
})(jQuery, window, document);
function getCookie(name) {
	var matches = document.cookie.match(new RegExp("(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"));
	return matches ? decodeURIComponent(matches[1]) : undefined;
}

function setCookie(name, value, options) {
	options = options || {};

	var expires = options.expires;

	if (typeof expires == "number" && expires) {
		var d = new Date();
		d.setTime(d.getTime() + expires * 1000);
		expires = options.expires = d;
	}
	if (expires && expires.toUTCString) {
		options.expires = expires.toUTCString();
	}

	value = encodeURIComponent(value);

	var updatedCookie = name + "=" + value;

	for (var propName in options) {
		updatedCookie += "; " + propName;
		var propValue = options[propName];
		if (propValue !== true) {
			updatedCookie += "=" + propValue;
		}
	}

	document.cookie = updatedCookie;
}

if ([].indexOf) {

	var arrayFind = function arrayFind(array, value) {
		return array.indexOf(value);
	};
} else {
	var arrayFind = function arrayFind(array, value) {
		for (var i = 0; i < array.length; i++) {
			if (array[i] === value) return i;
		}

		return -1;
	};
}
/*!
 * jquery.sumoselect - v3.0.2
 * http://hemantnegi.github.io/jquery.sumoselect
 * 2014-04-08
 *
 * Copyright 2015 Hemant Negi
 * Email : hemant.frnz@gmail.com
 * Compressor http://refresh-sf.com/
 */

(function ($) {

	'namespace sumo';

	$.fn.SumoSelect = function (options) {

		// This is the easiest way to have default options.
		var settings = $.extend({
			placeholder: 'Select Here', // Dont change it here.
			csvDispCount: 3, // display no. of items in multiselect. 0 to display all.
			captionFormat: '{0} Selected', // format of caption text. you can set your locale.
			captionFormatAllSelected: '{0} all selected!', // format of caption text when all elements are selected. set null to use captionFormat. It will not work if there are disabled elements in select.
			floatWidth: 400, // Screen width of device at which the list is rendered in floating popup fashion.
			forceCustomRendering: false, // force the custom modal on all devices below floatWidth resolution.
			nativeOnDevice: ['Android', 'BlackBerry', 'iPhone', 'iPad', 'iPod', 'Opera Mini', 'IEMobile', 'Silk'], //
			outputAsCSV: false, // true to POST data as csv ( false for Html control array ie. default select )
			csvSepChar: ',', // separation char in csv mode
			okCancelInMulti: false, // display ok cancel buttons in desktop mode multiselect also.
			triggerChangeCombined: true, // im multi select mode wether to trigger change event on individual selection or combined selection.
			selectAll: false, // to display select all button in multiselect mode.|| also select all will not be available on mobile devices.

			search: false, // to display input for filtering content. selectAlltext will be input text placeholder
			searchText: 'Search...', // placeholder for search input
			noMatch: 'No matches for "{0}"',
			prefix: '', // some prefix usually the field name. eg. '<b>Hello</b>'
			locale: ['OK', 'Cancel', 'Select All'], // all text that is used. don't change the index.
			up: false // set true to open upside.
		}, options);

		var ret = this.each(function () {
			var selObj = this; // the original select object.
			if (this.sumo || !$(this).is('select')) return; //already initialized

			this.sumo = {
				E: $(selObj), //the jquery object of original select element.
				is_multi: $(selObj).attr('multiple'), //if its a multiple select
				select: '',
				caption: '',
				placeholder: '',
				optDiv: '',
				CaptionCont: '',
				ul: '',
				is_floating: false,
				is_opened: false,
				//backdrop: '',
				mob: false, // if to open device default select
				Pstate: [],

				createElems: function createElems() {
					var O = this;
					O.E.wrap('<div class="SumoSelect" tabindex="0">');
					O.select = O.E.parent();
					O.caption = $('<span>');
					O.CaptionCont = $('<p class="CaptionCont"><label><i></i></label></p>').addClass('SelectBox').attr('style', O.E.attr('style')).prepend(O.caption);
					O.select.append(O.CaptionCont);

					// default turn off if no multiselect
					if (!O.is_multi) settings.okCancelInMulti = false;

					if (O.E.attr('disabled')) O.select.addClass('disabled').removeAttr('tabindex');

					//if output as csv and is a multiselect.
					if (settings.outputAsCSV && O.is_multi && O.E.attr('name')) {
						//create a hidden field to store csv value.
						O.select.append($('<input class="HEMANT123" type="hidden" />').attr('name', O.E.attr('name')).val(O.getSelStr()));

						// so it can not post the original select.
						O.E.removeAttr('name');
					}

					//break for mobile rendring.. if forceCustomRendering is false
					if (O.isMobile() && !settings.forceCustomRendering) {
						O.setNativeMobile();
						return;
					}

					// if there is a name attr in select add a class to container div
					if (O.E.attr('name')) O.select.addClass('sumo_' + O.E.attr('name'));

					//hide original select
					O.E.addClass('SumoUnder').attr('tabindex', '-1');

					//## Creating the list...
					O.optDiv = $('<div class="optWrapper ' + (settings.up ? 'up' : '') + '">');

					//branch for floating list in low res devices.
					O.floatingList();

					//Creating the markup for the available options
					O.ul = $('<ul class="options">');
					O.optDiv.append(O.ul);

					// Select all functionality
					if (settings.selectAll) O.SelAll();

					// search functionality
					if (settings.search) O.Search();

					O.ul.append(O.prepItems(O.E.children()));

					//if multiple then add the class multiple and add OK / CANCEL button
					if (O.is_multi) O.multiSelelect();

					O.select.append(O.optDiv);
					O.basicEvents();
					O.selAllState();
				},

				prepItems: function prepItems(opts, d) {
					var lis = [],
					    O = this;
					$(opts).each(function (i, opt) {
						// parsing options to li
						opt = $(opt);
						lis.push(opt.is('optgroup') ? $('<li class="group ' + (opt[0].disabled ? 'disabled' : '') + '"><label>' + opt.attr('label') + '</label><ul></ul><li>').find('ul').append(O.prepItems(opt.children(), opt[0].disabled)).end() : O.createLi(opt, d));
					});
					return lis;
				},

				//## Creates a LI element from a given option and binds events to it
				//## returns the jquery instance of li (not inserted in dom)
				createLi: function createLi(opt, d) {
					var O = this;

					if (!opt.attr('value')) opt.attr('value', opt.val());
					// todo: remove this data val 
					li = $('<li class="opt"><label>' + opt.text() + '</label></li>'); //.data('val',opt.val());
					li.data('opt', opt); // store a direct reference to option.
					opt.data('li', li); // store a direct reference to list item.
					if (O.is_multi) li.prepend('<span><i></i></span>');

					if (opt[0].disabled || d) li = li.addClass('disabled');

					O.onOptClick(li);

					if (opt[0].selected) li.addClass('selected');

					if (opt.attr('class')) li.addClass(opt.attr('class'));

					return li;
				},

				//## Returns the selected items as string in a Multiselect.
				getSelStr: function getSelStr() {
					// get the pre selected items.
					sopt = [];
					this.E.find('option:selected').each(function () {
						sopt.push($(this).val());
					});
					return sopt.join(settings.csvSepChar);
				},

				//## THOSE OK/CANCEL BUTTONS ON MULTIPLE SELECT.
				multiSelelect: function multiSelelect() {
					var O = this;
					O.optDiv.addClass('multiple');
					O.okbtn = $('<p class="btnOk">' + settings.locale[0] + '</p>').click(function () {

						//if combined change event is set.
						if (settings.triggerChangeCombined) {

							//check for a change in the selection.
							changed = false;
							if (O.E.find('option:selected').length != O.Pstate.length) {
								changed = true;
							} else {
								O.E.find('option').each(function (i, e) {
									if (e.selected && O.Pstate.indexOf(i) < 0) changed = true;
								});
							}

							if (changed) {
								O.callChange();
								O.setText();
							}
						}
						O.hideOpts();
					});
					O.cancelBtn = $('<p class="btnCancel">' + settings.locale[1] + '</p>').click(function () {
						O._cnbtn();
						O.hideOpts();
						O.setText();
					});
					O.optDiv.append($('<div class="MultiControls">').append(O.okbtn).append(O.cancelBtn));
				},

				_cnbtn: function _cnbtn() {
					var O = this;
					//remove all selections
					O.E.find('option:selected').each(function () {
						this.selected = false;
					});
					O.optDiv.find('li.selected').removeClass('selected');

					//restore selections from saved state.
					for (var i = 0; i < O.Pstate.length; i++) {
						O.E.find('option')[O.Pstate[i]].selected = true;
						O.ul.find('li.opt').eq(O.Pstate[i]).addClass('selected');
					}
					O.selAllState();
				},

				SelAll: function SelAll() {
					var O = this;
					if (!O.is_multi) return;
					O.selAll = $('<p class="select-all"><span><i></i></span><label>' + settings.locale[2] + '</label></p>');
					O.selAll.on('click', function () {
						//O.toggSelAll(!);
						O.selAll.toggleClass('selected');
						O.optDiv.find('li.opt').not('.hidden').each(function (ix, e) {
							e = $(e);
							if (O.selAll.hasClass('selected')) {
								if (!e.hasClass('selected')) e.trigger('click');
							} else if (e.hasClass('selected')) e.trigger('click');
						});
					});

					O.optDiv.prepend(O.selAll);
				},

				// search module (can be removed if not required.)
				Search: function Search() {
					var O = this,
					    cc = O.CaptionCont.addClass('search'),
					    P = $('<p class="no-match">');

					O.ftxt = $('<input type="text" class="search-txt" value="" placeholder="' + settings.searchText + '">').on('click', function (e) {
						e.stopPropagation();
					});
					cc.append(O.ftxt);
					O.optDiv.children('ul').after(P);

					O.ftxt.on('keyup.sumo', function () {
						var hid = O.optDiv.find('ul.options li.opt').each(function (ix, e) {
							e = $(e);
							if (e.text().toLowerCase().indexOf(O.ftxt.val().toLowerCase()) > -1) e.removeClass('hidden');else e.addClass('hidden');
						}).not('.hidden');

						P.html(settings.noMatch.replace(/\{0\}/g, O.ftxt.val())).toggle(!hid.length);

						O.selAllState();
					});
				},

				selAllState: function selAllState() {

					var O = this;
					if (settings.selectAll) {
						var sc = 0,
						    vc = 0;
						O.optDiv.find('li.opt').not('.hidden').each(function (ix, e) {
							if ($(e).hasClass('selected')) sc++;
							if (!$(e).hasClass('disabled')) vc++;
						});
						//select all checkbox state change.
						// console.log(O.selAll,'O.selAll')

						if (sc == vc) O.selAll.removeClass('partial').addClass('selected');else if (sc == 0) O.selAll.removeClass('selected partial');else O.selAll.addClass('partial'); //.removeClass('selected');
					}
				},

				showOpts: function showOpts() {
					var O = this;
					if (O.E.attr('disabled')) return; // if select is disabled then retrun
					O.is_opened = true;
					O.select.addClass('open');

					if (O.ftxt) O.ftxt.focus();else O.select.focus();

					// hide options on click outside.
					$(document).on('click.sumo', function (e) {
						if (!O.select.is(e.target) // if the target of the click isn't the container...
						&& O.select.has(e.target).length === 0) {
							// ... nor a descendant of the container
							if (!O.is_opened) return;
							O.hideOpts();
							if (settings.okCancelInMulti) O._cnbtn();
						}
					});

					if (O.is_floating) {
						H = O.optDiv.children('ul').outerHeight() + 2; // +2 is clear fix
						if (O.is_multi) H = H + parseInt(O.optDiv.css('padding-bottom'));
						O.optDiv.css('height', H);
						$('body').addClass('sumoStopScroll');
					}

					O.setPstate();

					// if ( $('.section__bottom').length ) {
					var props = positionCalc(O.CaptionCont, O.optDiv);
					var pos = props.targetAt.split(' ')[0];
					if (pos == "top") {
						pos = "bottom";
					} else {
						pos = "top";
					}
					// setTimeout(function(){TweenMax.fromTo(O.optDiv, 0.2,{scale:0,opacity:0, transformOrigin:"top center"}, {scale:1,opacity:1})},10)
					TweenMax.fromTo(O.optDiv, 0.2, { scale: 0, opacity: 0, transformOrigin: pos + " center" }, { scale: 1, opacity: 1 });
					// }
				},

				//maintain state when ok/cancel buttons are available storing the indexes.
				setPstate: function setPstate() {
					var O = this;
					if (O.is_multi && (O.is_floating || settings.okCancelInMulti)) {
						O.Pstate = [];
						// assuming that find returns elements in tree order
						O.E.find('option').each(function (i, e) {
							if (e.selected) O.Pstate.push(i);
						});
					}
				},

				callChange: function callChange() {
					this.E.trigger('change').trigger('click');
				},

				hideOpts: function hideOpts() {
					var O = this;
					if (O.is_opened) {

						// positionCalc(O.CaptionCont,O.optDiv);
						TweenMax.fromTo(O.optDiv, 0.2, { scale: 1, opacity: 1 }, { clearProps: "all", scale: 0, opacity: 0, onComplete: function onComplete() {

								O.is_opened = false;
								O.select.removeClass('open').find('ul li.sel').removeClass('sel');
								$(document).off('click.sumo');
								// O.select.focus();
								$('body').removeClass('sumoStopScroll');

								// clear the search
								if (settings.search) {
									O.ftxt.val('');
									O.optDiv.find('ul.options li').removeClass('hidden');
									O.optDiv.find('.no-match').toggle(false);
								}
							} });
					}
				},
				setOnOpen: function setOnOpen() {
					var O = this,
					    li = O.optDiv.find('li.opt:not(.hidden)').eq(settings.search ? 0 : O.E[0].selectedIndex);

					O.optDiv.find('li.sel').removeClass('sel');
					li.addClass('sel');
					O.showOpts();
				},
				nav: function nav(up) {
					var O = this,
					    c,
					    s = O.ul.find('li.opt:not(.disabled, .hidden)'),
					    sel = O.ul.find('li.opt.sel:not(.hidden)'),
					    idx = s.index(sel);
					if (O.is_opened && sel.length) {

						if (up && idx > 0) c = s.eq(idx - 1);else if (!up && idx < s.length - 1 && idx > -1) c = s.eq(idx + 1);else return; // if no items before or after

						sel.removeClass('sel');
						sel = c.addClass('sel');

						// setting sel item to visible view.
						var ul = O.ul,
						    st = ul.scrollTop(),
						    t = sel.position().top + st;
						if (t >= st + ul.height() - sel.outerHeight()) ul.scrollTop(t - ul.height() + sel.outerHeight());
						if (t < st) ul.scrollTop(t);
					} else O.setOnOpen();
				},

				basicEvents: function basicEvents() {
					var O = this;
					O.CaptionCont.click(function (evt) {
						O.E.trigger('click');
						if (O.is_opened) O.hideOpts();else O.showOpts();
						evt.stopPropagation();
					});

					O.select.on('keydown.sumo', function (e) {
						switch (e.which) {
							case 38:
								// up
								O.nav(true);
								break;

							case 40:
								// down
								O.nav(false);
								break;

							case 32:
								// space
								if (settings.search && O.ftxt.is(e.target)) return;
							case 13:
								// enter
								if (O.is_opened) O.optDiv.find('ul li.sel').trigger('click');else O.setOnOpen();
								break;
							case 9: //tab
							case 27:
								// esc
								if (settings.okCancelInMulti) O._cnbtn();
								O.hideOpts();
								return;

							default:
								return; // exit this handler for other keys
						}
						e.preventDefault(); // prevent the default action (scroll / move caret)
					});

					$(window).on('resize.sumo', function () {
						O.floatingList();
					});
				},

				onOptClick: function onOptClick(li) {
					var O = this;
					li.click(function () {
						var li = $(this);
						if (li.hasClass('disabled')) return;
						txt = "";
						if (O.is_multi) {
							li.toggleClass('selected');
							li.data('opt')[0].selected = li.hasClass('selected');
							O.selAllState();
						} else {
							li.parent().find('li.selected').removeClass('selected'); //if not multiselect then remove all selections from this list
							li.toggleClass('selected');
							li.data('opt')[0].selected = true;
						}

						//branch for combined change event.
						if (!(O.is_multi && settings.triggerChangeCombined && (O.is_floating || settings.okCancelInMulti))) {
							O.setText();
							O.callChange();
						}

						if (!O.is_multi) O.hideOpts(); //if its not a multiselect then hide on single select.
					});
				},

				setText: function setText() {
					var O = this;
					O.placeholder = "";
					if (O.is_multi) {
						sels = O.E.find(':selected').not(':disabled'); //selected options.

						for (i = 0; i < sels.length; i++) {
							if (i + 1 >= settings.csvDispCount && settings.csvDispCount) {
								if (sels.length == O.E.find('option').length && settings.captionFormatAllSelected) {
									O.placeholder = settings.captionFormatAllSelected.replace(/\{0\}/g, sels.length) + ',';
								} else {
									O.placeholder = settings.captionFormat.replace(/\{0\}/g, sels.length) + ',';
								}

								break;
							} else O.placeholder += $(sels[i]).text() + ", ";
						}
						O.placeholder = O.placeholder.replace(/,([^,]*)$/, '$1'); //remove unexpected "," from last.
					} else {
						O.placeholder = O.E.find(':selected').not(':disabled').text();
					}

					is_placeholder = false;

					if (!O.placeholder) {

						is_placeholder = true;

						O.placeholder = O.E.attr('placeholder');
						if (!O.placeholder) //if placeholder is there then set it
							O.placeholder = O.E.find('option:disabled:selected').text();
					}

					O.placeholder = O.placeholder ? settings.prefix + ' ' + O.placeholder : settings.placeholder;

					//set display text
					O.caption.html(O.placeholder);
					O.CaptionCont.attr('title', O.placeholder);

					//set the hidden field if post as csv is true.
					csvField = O.select.find('input.HEMANT123');
					if (csvField.length) csvField.val(O.getSelStr());

					//add class placeholder if its a placeholder text.
					if (is_placeholder) O.caption.addClass('placeholder');else O.caption.removeClass('placeholder');
					return O.placeholder;
				},

				isMobile: function isMobile() {

					// Adapted from http://www.detectmobilebrowsers.com
					var ua = navigator.userAgent || navigator.vendor || window.opera;

					// Checks for iOs, Android, Blackberry, Opera Mini, and Windows mobile devices
					for (var i = 0; i < settings.nativeOnDevice.length; i++) {
						if (ua.toString().toLowerCase().indexOf(settings.nativeOnDevice[i].toLowerCase()) > 0) return settings.nativeOnDevice[i];
					}return false;
				},

				setNativeMobile: function setNativeMobile() {
					var O = this;
					O.E.addClass('SelectClass'); //.css('height', O.select.outerHeight());
					O.mob = true;
					O.E.change(function () {
						O.setText();
					});
				},

				floatingList: function floatingList() {
					var O = this;
					//called on init and also on resize.
					//O.is_floating = true if window width is < specified float width
					O.is_floating = $(window).width() <= settings.floatWidth;

					//set class isFloating
					O.optDiv.toggleClass('isFloating', O.is_floating);

					//remove height if not floating
					if (!O.is_floating) O.optDiv.css('height', '');

					//toggle class according to okCancelInMulti flag only when it is not floating
					O.optDiv.toggleClass('okCancelInMulti', settings.okCancelInMulti && !O.is_floating);
				},

				//HELPERS FOR OUTSIDERS
				// validates range of given item operations
				vRange: function vRange(i) {
					var O = this;
					opts = O.E.find('option');
					if (opts.length <= i || i < 0) throw "index out of bounds";
					return O;
				},

				//toggles selection on c as boolean.
				toggSel: function toggSel(c, i) {
					var O = this;
					if (typeof i === "number") {
						O.vRange(i);
						opt = O.E.find('option')[i];
					} else {
						opt = O.E.find('option[value="' + i + '"]')[0] || 0;
					}
					if (!opt || opt.disabled) return;

					if (opt.selected != c) {
						opt.selected = c;
						if (!O.mob) $(opt).data('li').toggleClass('selected', c);

						O.callChange();
						O.setPstate();
						O.setText();
						O.selAllState();
					}
				},

				//toggles disabled on c as boolean.
				toggDis: function toggDis(c, i) {
					var O = this.vRange(i);
					O.E.find('option')[i].disabled = c;
					if (c) O.E.find('option')[i].selected = false;
					if (!O.mob) O.optDiv.find('ul.options li').eq(i).toggleClass('disabled', c).removeClass('selected');
					O.setText();
				},

				// toggle disable/enable on complete select control
				toggSumo: function toggSumo(val) {
					var O = this;
					O.enabled = val;
					O.select.toggleClass('disabled', val);

					if (val) {
						O.E.attr('disabled', 'disabled');
						O.select.removeAttr('tabindex');
					} else {
						O.E.removeAttr('disabled');
						O.select.attr('tabindex', '0');
					}

					return O;
				},

				//toggles alloption on c as boolean.
				toggSelAll: function toggSelAll(c) {
					var O = this;
					O.E.find('option').each(function (ix, el) {
						if (O.E.find('option')[$(this).index()].disabled) return;
						O.E.find('option')[$(this).index()].selected = c;
						if (!O.mob) O.optDiv.find('ul.options li').eq($(this).index()).toggleClass('selected', c);
						O.setText();
					});
					if (!O.mob && O.selAll) O.selAll.removeClass('partial').toggleClass('selected', c);
					O.callChange();
					O.setPstate();
				},

				/* outside accessibility options
       which can be accessed from the element instance.
    */
				reload: function reload() {
					var elm = this.unload();
					return $(elm).SumoSelect(settings);
				},

				unload: function unload() {
					var O = this;
					O.select.before(O.E);
					O.E.show();

					if (settings.outputAsCSV && O.is_multi && O.select.find('input.HEMANT123').length) {
						O.E.attr('name', O.select.find('input.HEMANT123').attr('name')); // restore the name;
					}
					O.select.remove();
					delete selObj.sumo;
					return selObj;
				},

				//## add a new option to select at a given index.
				add: function add(val, txt, i) {
					if (typeof val == "undefined") throw "No value to add";

					var O = this;
					opts = O.E.find('option');
					if (typeof txt == "number") {
						i = txt;txt = val;
					}
					if (typeof txt == "undefined") {
						txt = val;
					}

					opt = $("<option></option>").val(val).html(txt);

					if (opts.length < i) throw "index out of bounds";

					if (typeof i == "undefined" || opts.length == i) {
						// add it to the last if given index is last no or no index provides.
						O.E.append(opt);
						if (!O.mob) O.ul.append(O.createLi(opt));
					} else {
						opts.eq(i).before(opt);
						if (!O.mob) O.ul.find('li.opt').eq(i).before(O.createLi(opt));
					}

					return selObj;
				},

				//## removes an item at a given index.
				remove: function remove(i) {
					var O = this.vRange(i);
					O.E.find('option').eq(i).remove();
					if (!O.mob) O.optDiv.find('ul.options li').eq(i).remove();
					O.setText();
				},

				//## Select an item at a given index.
				selectItem: function selectItem(i) {
					this.toggSel(true, i);
				},

				//## UnSelect an iten at a given index.
				unSelectItem: function unSelectItem(i) {
					this.toggSel(false, i);
				},

				//## Select all items  of the select.
				selectAll: function selectAll() {
					this.toggSelAll(true);
				},

				//## UnSelect all items of the select.
				unSelectAll: function unSelectAll() {
					this.toggSelAll(false);
				},

				//## Disable an iten at a given index.
				disableItem: function disableItem(i) {
					this.toggDis(true, i);
				},

				//## Removes disabled an iten at a given index.
				enableItem: function enableItem(i) {
					this.toggDis(false, i);
				},

				//## New simple methods as getter and setter are not working fine in ie8-
				//## variable to check state of control if enabled or disabled.
				enabled: true,
				//## Enables the control
				enable: function enable() {
					return this.toggSumo(false);
				},

				//## Disables the control
				disable: function disable() {
					return this.toggSumo(true);
				},

				init: function init() {
					var O = this;
					O.createElems();
					O.setText();
					return O;
				}

			};

			selObj.sumo.init();
		});

		return ret.length == 1 ? ret[0] : ret;
	};
})(jQuery);
(function (root, factory) {

	root.debounce = factory();
})(this, function () {
	'use strict';

	return function (callback, delay) {
		var timeout;

		return function () {
			var context = this,
			    args = arguments;

			clearTimeout(timeout);

			timeout = setTimeout(function () {
				callback.apply(context, args);
			}, delay);
		};
	};
});
// gstatic

(function () {
	var a = "\n//# sourceURL=",
	    k = "' of type ",
	    n = '<script type="text/javascript" src="',
	    p = "SCRIPT",
	    r = "array",
	    t = "complete",
	    u = "function",
	    v = "google.charts.load",
	    w = "hasOwnProperty",
	    x = "number",
	    y = "object",
	    z = "pre-45",
	    A = "propertyIsEnumerable",
	    B = "string",
	    C = "text/javascript",
	    D = "toLocaleString";function E() {
		return function (b) {
			return b;
		};
	}function F() {
		return function () {};
	}function G(b) {
		return function () {
			return this[b];
		};
	}var I,
	    J = J || {};J.scope = {};
	J.Tp = function (b, c, d) {
		if (null == b) throw new TypeError("The 'this' value for String.prototype." + d + " must not be null or undefined");if (c instanceof RegExp) throw new TypeError("First argument to String.prototype." + d + " must not be a regular expression");return b + "";
	};J.Gh = !1;J.fm = !1;J.gm = !1;J.defineProperty = J.Gh || _typeof(Object.defineProperties) == u ? Object.defineProperty : function (b, c, d) {
		b != Array.prototype && b != Object.prototype && (b[c] = d.value);
	};
	J.Ij = function (b) {
		return "undefined" != typeof window && window === b ? b : "undefined" != typeof global && null != global ? global : b;
	};J.global = J.Ij(this);J.Sk = function (b) {
		if (b) {
			for (var c = J.global, d = ["Promise"], e = 0; e < d.length - 1; e++) {
				var f = d[e];f in c || (c[f] = {});c = c[f];
			}d = d[d.length - 1];e = c[d];b = b(e);b != e && null != b && J.defineProperty(c, d, { configurable: !0, writable: !0, value: b });
		}
	};
	J.Eq = function (b, c, d) {
		b instanceof String && (b = String(b));for (var e = b.length, f = 0; f < e; f++) {
			var g = b[f];if (c.call(d, g, f, b)) return { Zj: f, Ll: g };
		}return { Zj: -1, Ll: void 0 };
	};J.yi = "jscomp_symbol_";J.rg = function () {
		J.rg = F();J.global.Symbol || (J.global.Symbol = J.Symbol);
	};J.Symbol = function () {
		var b = 0;return function (c) {
			return J.yi + (c || "") + b++;
		};
	}();
	J.Fd = function () {
		J.rg();var b = J.global.Symbol.iterator;b || (b = J.global.Symbol.iterator = J.global.Symbol("iterator"));_typeof(Array.prototype[b]) != u && J.defineProperty(Array.prototype, b, { configurable: !0, writable: !0, value: function value() {
				return J.df(this);
			} });J.Fd = F();
	};J.df = function (b) {
		var c = 0;return J.uk(function () {
			return c < b.length ? { done: !1, value: b[c++] } : { done: !0 };
		});
	};J.uk = function (b) {
		J.Fd();b = { next: b };b[J.global.Symbol.iterator] = function () {
			return this;
		};return b;
	};
	J.Qg = function (b) {
		J.Fd();var c = b[Symbol.iterator];return c ? c.call(b) : J.df(b);
	};J.Yh = !1;
	J.Sk(function (b) {
		function c(b) {
			this.$ = g.wa;this.ia = void 0;this.Ub = [];var c = this.gd();try {
				b(c.resolve, c.reject);
			} catch (q) {
				c.reject(q);
			}
		}function d() {
			this.Ma = null;
		}function e(b) {
			return b instanceof c ? b : new c(function (c) {
				c(b);
			});
		}if (b && !J.Yh) return b;d.prototype.ef = function (b) {
			null == this.Ma && (this.Ma = [], this.Ni());this.Ma.push(b);
		};d.prototype.Ni = function () {
			var b = this;this.ff(function () {
				b.uj();
			});
		};var f = J.global.setTimeout;d.prototype.ff = function (b) {
			f(b, 0);
		};d.prototype.uj = function () {
			for (; this.Ma && this.Ma.length;) {
				var b = this.Ma;this.Ma = [];for (var c = 0; c < b.length; ++c) {
					var d = b[c];delete b[c];try {
						d();
					} catch (H) {
						this.Oi(H);
					}
				}
			}this.Ma = null;
		};d.prototype.Oi = function (b) {
			this.ff(function () {
				throw b;
			});
		};var g = { wa: 0, Ja: 1, ja: 2 };c.prototype.gd = function () {
			function b(b) {
				return function (e) {
					d || (d = !0, b.call(c, e));
				};
			}var c = this,
			    d = !1;return { resolve: b(this.Xk), reject: b(this.Yd) };
		};c.prototype.Xk = function (b) {
			if (b === this) this.Yd(new TypeError("A Promise cannot resolve to itself"));else if (b instanceof c) this.pl(b);else {
				a: switch (typeof b === "undefined" ? "undefined" : _typeof(b)) {case y:
						var d = null != b;break a;case u:
						d = !0;break a;default:
						d = !1;}d ? this.Wk(b) : this.If(b);
			}
		};c.prototype.Wk = function (b) {
			var c = void 0;try {
				c = b.then;
			} catch (q) {
				this.Yd(q);return;
			}(typeof c === "undefined" ? "undefined" : _typeof(c)) == u ? this.ql(c, b) : this.If(b);
		};c.prototype.Yd = function (b) {
			this.mh(g.ja, b);
		};c.prototype.If = function (b) {
			this.mh(g.Ja, b);
		};c.prototype.mh = function (b, c) {
			if (this.$ != g.wa) throw Error("Cannot settle(" + b + ", " + c | "): Promise already settled in state" + this.$);this.$ = b;this.ia = c;this.wj();
		};c.prototype.wj = function () {
			if (null != this.Ub) {
				for (var b = this.Ub, c = 0; c < b.length; ++c) {
					b[c].call(), b[c] = null;
				}this.Ub = null;
			}
		};var h = new d();c.prototype.pl = function (b) {
			var c = this.gd();b.fc(c.resolve, c.reject);
		};c.prototype.ql = function (b, c) {
			var d = this.gd();try {
				b.call(c, d.resolve, d.reject);
			} catch (H) {
				d.reject(H);
			}
		};c.prototype.then = function (b, d) {
			function e(b, c) {
				return (typeof b === "undefined" ? "undefined" : _typeof(b)) == u ? function (c) {
					try {
						f(b(c));
					} catch (ca) {
						g(ca);
					}
				} : c;
			}var f,
			    g,
			    h = new c(function (b, c) {
				f = b;g = c;
			});this.fc(e(b, f), e(d, g));return h;
		};c.prototype["catch"] = function (b) {
			return this.then(void 0, b);
		};c.prototype.fc = function (b, c) {
			function d() {
				switch (e.$) {case g.Ja:
						b(e.ia);break;case g.ja:
						c(e.ia);break;default:
						throw Error("Unexpected state: " + e.$);}
			}var e = this;null == this.Ub ? h.ef(d) : this.Ub.push(function () {
				h.ef(d);
			});
		};c.resolve = e;c.reject = function (b) {
			return new c(function (c, d) {
				d(b);
			});
		};c.race = function (b) {
			return new c(function (c, d) {
				for (var f = J.Qg(b), g = f.next(); !g.done; g = f.next()) {
					e(g.value).fc(c, d);
				}
			});
		};c.all = function (b) {
			var d = J.Qg(b),
			    f = d.next();return f.done ? e([]) : new c(function (b, c) {
				function g(c) {
					return function (d) {
						h[c] = d;l--;
						0 == l && b(h);
					};
				}var h = [],
				    l = 0;do {
					h.push(void 0), l++, e(f.value).fc(g(h.length - 1), c), f = d.next();
				} while (!f.done);
			});
		};return c;
	});var K = K || {};K.global = this;K.R = function (b) {
		return void 0 !== b;
	};K.L = function (b) {
		return (typeof b === "undefined" ? "undefined" : _typeof(b)) == B;
	};K.ck = function (b) {
		return "boolean" == typeof b;
	};K.Rb = function (b) {
		return (typeof b === "undefined" ? "undefined" : _typeof(b)) == x;
	};
	K.md = function (b, c, d) {
		b = b.split(".");d = d || K.global;b[0] in d || !d.execScript || d.execScript("var " + b[0]);for (var e; b.length && (e = b.shift());) {
			!b.length && K.R(c) ? d[e] = c : d = d[e] && d[e] !== Object.prototype[e] ? d[e] : d[e] = {};
		}
	};K.define = function (b, c) {
		K.md(b, c);
	};K.ea = !0;K.ba = "en";K.$c = !0;K.wi = !1;K.Uh = !K.ea;K.De = !1;K.Ds = function (b) {
		if (K.Kd()) throw Error("goog.provide can not be used within a goog.module.");K.qf(b);
	};K.qf = function (b, c) {
		K.md(b, c);
	};K.Di = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
	K.Td = function (b) {
		if (!K.L(b) || !b || -1 == b.search(K.Di)) throw Error("Invalid module identifier");if (!K.Kd()) throw Error("Module " + b + " has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
		if (K.ma.Ud) throw Error("goog.module may only be called once per module.");K.ma.Ud = b;
	};K.Td.get = function () {
		return null;
	};K.Td.Zq = function () {
		return null;
	};K.ma = null;K.Kd = function () {
		return null != K.ma;
	};K.Td.jd = function () {
		K.ma.jd = !0;
	};K.qt = function (b) {
		if (K.Uh) throw b = b || "", Error("Importing test-only code into non-debug environment" + (b ? ": " + b : "."));
	};K.Kq = F();K.rb = function (b) {
		b = b.split(".");for (var c = K.global, d = 0; d < b.length; d++) {
			if (c = c[b[d]], !K.cb(c)) return null;
		}return c;
	};
	K.jr = function (b, c) {
		c = c || K.global;for (var d in b) {
			c[d] = b[d];
		}
	};K.hp = function (b, c, d, e) {
		if (K.Ae) {
			var f;b = b.replace(/\\/g, "/");var g = K.ka;e && "boolean" !== typeof e || (e = e ? { module: "goog" } : {});for (var h = 0; f = c[h]; h++) {
				g.Sb[f] = b, g.Od[b] = e;
			}for (e = 0; c = d[e]; e++) {
				b in g.gb || (g.gb[b] = {}), g.gb[b][c] = !0;
			}
		}
	};K.Tt = !1;K.Xm = !0;K.Ek = function (b) {
		K.global.console && K.global.console.error(b);
	};K.Ps = F();K.La = "";K.eb = F();K.gp = function () {
		throw Error("unimplemented abstract method");
	};
	K.ip = function (b) {
		b.Gd = void 0;b.Yq = function () {
			if (b.Gd) return b.Gd;K.ea && (K.wg[K.wg.length] = b);return b.Gd = new b();
		};
	};K.wg = [];K.fi = !0;K.ti = K.ea;K.Ck = {};K.Ae = !1;K.Ve = "detect";K.zi = "transpile.js";
	K.Ae && (K.ka = { Od: {}, Sb: {}, gb: {}, zh: {}, je: {}, pb: {} }, K.qg = function () {
		var b = K.global.document;return null != b && "write" in b;
	}, K.xj = function () {
		if (K.R(K.global.ye) && K.L(K.global.ye)) K.La = K.global.ye;else if (K.qg()) {
			var b = K.global.document,
			    c = b.currentScript;b = c ? [c] : b.getElementsByTagName(p);for (c = b.length - 1; 0 <= c; --c) {
				var d = b[c].src,
				    e = d.lastIndexOf("?");e = -1 == e ? d.length : e;if ("base.js" == d.substr(e - 7, 7)) {
					K.La = d.substr(0, e - 7);break;
				}
			}
		}
	}, K.Ed = function (b, c) {
		(K.global.zm || K.Tl)(b, c) && (K.ka.je[b] = !0);
	}, K.di = !(K.global.atob || !K.global.document || !K.global.document.all), K.$g = !1, K.ak = function (b, c, d) {
		K.Ed("", 'goog.retrieveAndExec_("' + b + '", ' + c + ", " + d + ");");
	}, K.Wd = [], K.Xt = function (b, c) {
		return K.fi && K.R(K.global.JSON) ? "goog.loadModule(" + K.global.JSON.stringify(c + a + b + "\n") + ");" : 'goog.loadModule(function(exports) {"use strict";' + c + "\n;return exports});\n//# sourceURL=" + b + "\n";
	}, K.Ak = function () {
		var b = K.Wd.length;if (0 < b) {
			var c = K.Wd;K.Wd = [];for (var d = 0; d < b; d++) {
				K.Tg(c[d]);
			}
		}K.$g = !1;
	}, K.js = function (b) {
		K.Bg(b) && K.Ji(b) && K.Tg(K.La + K.zd(b));
	}, K.Bg = function (b) {
		var c = (b = K.zd(b)) && K.ka.Od[b] || {},
		    d = c.lang || "es3";return b && ("goog" == c.module || K.Xg(d)) ? K.La + b in K.ka.pb : !1;
	}, K.Ji = function (b) {
		if ((b = K.zd(b)) && b in K.ka.gb) for (var c in K.ka.gb[b]) {
			if (!K.mk(c) && !K.Bg(c)) return !1;
		}return !0;
	}, K.Tg = function (b) {
		if (b in K.ka.pb) {
			var c = K.ka.pb[b];delete K.ka.pb[b];K.Tj(c);
		}
	}, K.ds = F(), K.Sl = function (b) {
		K.global.document.write(n + b + '">\x3c/script>');
	}, K.Ki = function (b) {
		var c = K.global.document,
		    d = c.createElement("script");d.type = C;d.src = b;d.defer = !1;d.async = !1;c.head.appendChild(d);
	}, K.Tl = function (b, c) {
		if (K.qg()) {
			var d = K.global.document;if (!K.De && d.readyState == t) {
				if (/\bdeps.js$/.test(b)) return !1;throw Error('Cannot write "' + b + '" after document load');
			}void 0 === c ? K.di ? (K.$g = !0, c = " onreadystatechange='goog.onScriptLoad_(this, " + ++K.Pg + ")' ", d.write(n + b + '"' + c + ">\x3c/script>")) : K.De ? K.Ki(b) : K.Sl(b) : d.write('<script type="text/javascript">' + K.Tk(c) + "\x3c/script>");return !0;
		}return !1;
	}, K.Tk = function (b) {
		return b.replace(/<\/(SCRIPT)/ig, "\\x3c/$1");
	}, K.Xg = function (b) {
		if ("always" == K.Ve) return !0;
		if ("never" == K.Ve) return !1;K.Dc || (K.Dc = K.ej());if (b in K.Dc) return K.Dc[b];throw Error("Unknown language mode: " + b);
	}, K.Dc = null, K.Pg = 0, K.xs = function (b, c) {
		b.readyState == t && K.Pg == c && K.Ak();return !0;
	}, K.Yt = function (b) {
		function c(b) {
			if (!(b in f.je || b in f.zh)) {
				f.zh[b] = !0;if (b in f.gb) for (var g in f.gb[b]) {
					if (!K.mk(g)) if (g in f.Sb) c(f.Sb[g]);else throw Error("Undefined nameToPath for " + g);
				}b in e || (e[b] = !0, d.push(b));
			}
		}var d = [],
		    e = {},
		    f = K.ka;c(b);for (b = 0; b < d.length; b++) {
			var g = d[b];K.ka.je[g] = !0;
		}var h = K.ma;K.ma = null;for (b = 0; b < d.length; b++) {
			if (g = d[b]) {
				var l = f.Od[g] || {},
				    m = K.Xg(l.lang || "es3");"goog" == l.module || m ? K.ak(K.La + g, "goog" == l.module, m) : K.Ed(K.La + g);
			} else throw K.ma = h, Error("Undefined script input");
		}K.ma = h;
	}, K.zd = function (b) {
		return b in K.ka.Sb ? K.ka.Sb[b] : null;
	}, K.xj(), K.global.Am || K.Ed(K.La + "deps.js"));K.Cd = null;K.Jl = function () {
		if (null == K.Cd) {
			try {
				var b = !eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";');
			} catch (c) {
				b = !1;
			}K.Cd = b;
		}return K.Cd;
	};
	K.Ql = function (b) {
		return "(function(){" + b + "\n;})();\n";
	};K.cs = function (b) {
		var c = K.ma;try {
			K.ma = { Ud: void 0, jd: !1 };if (K.xa(b)) var d = b.call(void 0, {});else if (K.L(b)) K.Jl() && (b = K.Ql(b)), d = K.zk.call(void 0, b);else throw Error("Invalid module definition");var e = K.ma.Ud;if (!K.L(e) || !e) throw Error('Invalid module name "' + e + '"');K.ma.jd ? K.qf(e, d) : K.ti && Object.seal && (typeof d === "undefined" ? "undefined" : _typeof(d)) == y && null != d && Object.seal(d);K.Ck[e] = d;
		} finally {
			K.ma = c;
		}
	};K.zk = function (b) {
		eval(b);return {};
	};
	K.qs = function (b) {
		b = b.split("/");for (var c = 0; c < b.length;) {
			"." == b[c] ? b.splice(c, 1) : c && ".." == b[c] && b[c - 1] && ".." != b[c - 1] ? b.splice(--c, 2) : c++;
		}return b.join("/");
	};K.xk = function (b) {
		if (K.global.Ph) return K.global.Ph(b);try {
			var c = new K.global.XMLHttpRequest();c.open("get", b, !1);c.send();return 0 == c.status || 200 == c.status ? c.responseText : null;
		} catch (d) {
			return null;
		}
	};K.Rs = F();
	K.Kt = function (b, c) {
		var d = K.global.$jscomp;d || (K.global.$jscomp = d = {});var e = d.he;if (!e) {
			var f = K.La + K.zi,
			    g = K.xk(f);if (g) {
				eval(g + a + f);if (K.global.$gwtExport && K.global.$gwtExport.$jscomp && !K.global.$gwtExport.$jscomp.transpile) throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: ' + JSON.stringify(K.global.$gwtExport));K.global.$jscomp.he = K.global.$gwtExport.$jscomp.transpile;d = K.global.$jscomp;e = d.he;
			}
		}if (!e) {
			var h = " requires transpilation but no transpiler was found.";
			h += ' Please add "//javascript/closure:transpiler" as a data dependency to ensure it is included.';e = d.he = function (b, c) {
				K.Ek(c + h);return b;
			};
		}return e(b, c);
	};
	K.aa = function (b) {
		var c = typeof b === "undefined" ? "undefined" : _typeof(b);if (c == y) {
			if (b) {
				if (b instanceof Array) return r;if (b instanceof Object) return c;var d = Object.prototype.toString.call(b);if ("[object Window]" == d) return y;if ("[object Array]" == d || _typeof(b.length) == x && "undefined" != typeof b.splice && "undefined" != typeof b.propertyIsEnumerable && !b.propertyIsEnumerable("splice")) return r;if ("[object Function]" == d || "undefined" != typeof b.call && "undefined" != typeof b.propertyIsEnumerable && !b.propertyIsEnumerable("call")) return u;
			} else return "null";
		} else if (c == u && "undefined" == typeof b.call) return y;return c;
	};K.Or = function (b) {
		return null === b;
	};K.cb = function (b) {
		return null != b;
	};K.isArray = function (b) {
		return K.aa(b) == r;
	};K.Nb = function (b) {
		var c = K.aa(b);return c == r || c == y && _typeof(b.length) == x;
	};K.Ar = function (b) {
		return K.ha(b) && _typeof(b.getFullYear) == u;
	};K.xa = function (b) {
		return K.aa(b) == u;
	};K.ha = function (b) {
		var c = typeof b === "undefined" ? "undefined" : _typeof(b);return c == y && null != b || c == u;
	};K.kg = function (b) {
		return b[K.Va] || (b[K.Va] = ++K.Cl);
	};K.mr = function (b) {
		return !!b[K.Va];
	};
	K.Uk = function (b) {
		null !== b && "removeAttribute" in b && b.removeAttribute(K.Va);try {
			delete b[K.Va];
		} catch (c) {}
	};K.Va = "closure_uid_" + (1E9 * Math.random() >>> 0);K.Cl = 0;K.Xq = K.kg;K.Ls = K.Uk;K.aj = function (b) {
		var c = K.aa(b);if (c == y || c == r) {
			if (b.clone) return b.clone();c = c == r ? [] : {};for (var d in b) {
				c[d] = K.aj(b[d]);
			}return c;
		}return b;
	};K.Si = function (b, c, d) {
		return b.call.apply(b.bind, arguments);
	};
	K.Ri = function (b, c, d) {
		if (!b) throw Error();if (2 < arguments.length) {
			var e = Array.prototype.slice.call(arguments, 2);return function () {
				var d = Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(d, e);return b.apply(c, d);
			};
		}return function () {
			return b.apply(c, arguments);
		};
	};K.bind = function (b, c, d) {
		K.bind = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? K.Si : K.Ri;return K.bind.apply(null, arguments);
	};
	K.fb = function (b, c) {
		var d = Array.prototype.slice.call(arguments, 1);return function () {
			var c = d.slice();c.push.apply(c, arguments);return b.apply(this, c);
		};
	};K.ls = function (b, c) {
		for (var d in c) {
			b[d] = c[d];
		}
	};K.now = K.$c && Date.now || function () {
		return +new Date();
	};
	K.Tj = function (b) {
		if (K.global.execScript) K.global.execScript(b, "JavaScript");else if (K.global.eval) {
			if (null == K.lc) if (K.global.eval("var _evalTest_ = 1;"), "undefined" != typeof K.global._evalTest_) {
				try {
					delete K.global._evalTest_;
				} catch (e) {}K.lc = !0;
			} else K.lc = !1;if (K.lc) K.global.eval(b);else {
				var c = K.global.document,
				    d = c.createElement(p);d.type = C;d.defer = !1;d.appendChild(c.createTextNode(b));c.body.appendChild(d);c.body.removeChild(d);
			}
		} else throw Error("goog.globalEval not available");
	};K.lc = null;
	K.Vq = function (b, c) {
		function d(b) {
			b = b.split("-");for (var c = [], d = 0; d < b.length; d++) {
				c.push(e(b[d]));
			}return c.join("-");
		}function e(b) {
			return K.uf[b] || b;
		}if ("." == String(b).charAt(0)) throw Error('className passed in goog.getCssName must not start with ".". You passed: ' + b);var f = K.uf ? "BY_WHOLE" == K.kj ? e : d : E();b = c ? b + "-" + f(c) : f(b);return K.global.Oh ? K.global.Oh(b) : b;
	};K.at = function (b, c) {
		K.uf = b;K.kj = c;
	};K.$q = function (b, c) {
		c && (b = b.replace(/\{\$([^}]+)}/g, function (b, e) {
			return null != c && e in c ? c[e] : b;
		}));return b;
	};
	K.ar = E();K.zf = function (b, c) {
		K.md(b, c, void 0);
	};K.Dq = function (b, c, d) {
		b[c] = d;
	};K.ab = function (b, c) {
		function d() {}d.prototype = c.prototype;b.Lc = c.prototype;b.prototype = new d();b.prototype.constructor = b;b.Qi = function (b, d, g) {
			for (var e = Array(arguments.length - 2), f = 2; f < arguments.length; f++) {
				e[f - 2] = arguments[f];
			}return c.prototype[d].apply(b, e);
		};
	};
	K.Qi = function (b, c, d) {
		var e = arguments.callee.caller;if (K.wi || K.ea && !e) throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");if (e.Lc) {
			for (var f = Array(arguments.length - 1), g = 1; g < arguments.length; g++) {
				f[g - 1] = arguments[g];
			}return e.Lc.constructor.apply(b, f);
		}f = Array(arguments.length - 2);for (g = 2; g < arguments.length; g++) {
			f[g - 2] = arguments[g];
		}g = !1;for (var h = b.constructor; h; h = h.Lc && h.Lc.constructor) {
			if (h.prototype[c] === e) g = !0;else if (g) return h.prototype[c].apply(b, f);
		}if (b[c] === e) return b.constructor.prototype[c].apply(b, f);throw Error("goog.base called from a method of one name to a method of a different name");
	};K.scope = function (b) {
		if (K.Kd()) throw Error("goog.scope is not supported within a goog.module.");b.call(K.global);
	};
	K.oa = function (b, c) {
		var d = c.constructor,
		    e = c.ul;d && d != Object.prototype.constructor || (d = function d() {
			throw Error("cannot instantiate an interface (no constructor defined).");
		});d = K.oa.fj(d, b);b && K.ab(d, b);delete c.constructor;delete c.ul;K.oa.cf(d.prototype, c);null != e && (e instanceof Function ? e(d) : K.oa.cf(d, e));return d;
	};K.oa.si = K.ea;
	K.oa.fj = function (b, c) {
		function d() {
			var c = b.apply(this, arguments) || this;c[K.Va] = c[K.Va];this.constructor === d && e && Object.seal instanceof Function && Object.seal(c);return c;
		}if (!K.oa.si) return b;var e = !K.oa.qk(c);return d;
	};K.oa.qk = function (b) {
		return b && b.prototype && b.prototype[K.Bi];
	};K.oa.Me = ["constructor", w, "isPrototypeOf", A, D, "toString", "valueOf"];
	K.oa.cf = function (b, c) {
		for (var d in c) {
			Object.prototype.hasOwnProperty.call(c, d) && (b[d] = c[d]);
		}for (var e = 0; e < K.oa.Me.length; e++) {
			d = K.oa.Me[e], Object.prototype.hasOwnProperty.call(c, d) && (b[d] = c[d]);
		}
	};K.Dt = F();K.Bi = "goog_defineClass_legacy_unsealable";
	K.ej = function () {
		function b(b, c) {
			e ? d[b] = !0 : c() ? d[b] = !1 : e = d[b] = !0;
		}function c(b) {
			try {
				return !!eval(b);
			} catch (h) {
				return !1;
			}
		}var d = { es3: !1 },
		    e = !1,
		    f = K.global.navigator && K.global.navigator.userAgent ? K.global.navigator.userAgent : "";b("es5", function () {
			return c("[1,].length==1");
		});b("es6", function () {
			var b = f.match(/Edge\/(\d+)(\.\d)*/i);return b && 15 > Number(b[1]) ? !1 : c('(()=>{"use strict";class X{constructor(){if(new.target!=String)throw 1;this.x=42}}let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof String))throw 1;for(const a of[2,3]){if(a==2)continue;function f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()==3}})()');
		});
		b("es6-impl", function () {
			return !0;
		});b("es7", function () {
			return c("2 ** 2 == 4");
		});b("es8", function () {
			return c("async () => 1, true");
		});return d;
	};K.debug = {};K.debug.Error = function (b) {
		if (Error.captureStackTrace) Error.captureStackTrace(this, K.debug.Error);else {
			var c = Error().stack;c && (this.stack = c);
		}b && (this.message = String(b));
	};K.ab(K.debug.Error, Error);K.debug.Error.prototype.name = "CustomError";K.a = {};K.a.fa = { Ia: 1, hm: 2, cc: 3, wm: 4, Zm: 5, Ym: 6, oo: 7, Fm: 8, Xc: 9, Rm: 10, Vh: 11, bo: 12 };K.f = {};K.f.Wc = !1;K.f.Xh = !1;K.f.Ye = { Ke: "\xA0" };K.f.startsWith = function (b, c) {
		return 0 == b.lastIndexOf(c, 0);
	};K.f.endsWith = function (b, c) {
		var d = b.length - c.length;return 0 <= d && b.indexOf(c, d) == d;
	};K.f.Zi = function (b) {
		return 0 == K.f.jf("tel:", b.substr(0, 4));
	};K.f.Rp = function (b, c) {
		return 0 == K.f.jf(c, b.substr(b.length - c.length, c.length));
	};K.f.Sp = function (b, c) {
		return b.toLowerCase() == c.toLowerCase();
	};
	K.f.wl = function (b, c) {
		for (var d = b.split("%s"), e = "", f = Array.prototype.slice.call(arguments, 1); f.length && 1 < d.length;) {
			e += d.shift() + f.shift();
		}return e + d.join("%s");
	};K.f.Yp = function (b) {
		return b.replace(/[\s\xa0]+/g, " ").replace(/^\s+|\s+$/g, "");
	};K.f.Id = function (b) {
		return (/^[\s\xa0]*$/.test(b)
		);
	};K.f.Dr = function (b) {
		return 0 == b.length;
	};K.f.Qb = K.f.Id;K.f.ek = function (b) {
		return K.f.Id(K.f.Jk(b));
	};K.f.Cr = K.f.ek;K.f.yr = function (b) {
		return !/[^\t\n\r ]/.test(b);
	};K.f.vr = function (b) {
		return !/[^a-zA-Z]/.test(b);
	};
	K.f.Pr = function (b) {
		return !/[^0-9]/.test(b);
	};K.f.wr = function (b) {
		return !/[^a-zA-Z0-9]/.test(b);
	};K.f.Vr = function (b) {
		return " " == b;
	};K.f.Wr = function (b) {
		return 1 == b.length && " " <= b && "~" >= b || "\x80" <= b && "\uFFFD" >= b;
	};K.f.Bt = function (b) {
		return b.replace(/(\r\n|\r|\n)+/g, " ");
	};K.f.Yi = function (b) {
		return b.replace(/(\r\n|\r|\n)/g, "\n");
	};K.f.ss = function (b) {
		return b.replace(/\xa0|\s/g, " ");
	};K.f.rs = function (b) {
		return b.replace(/\xa0|[ \t]+/g, " ");
	};
	K.f.Xp = function (b) {
		return b.replace(/[\t\r\n ]+/g, " ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, "");
	};K.f.trim = K.$c && String.prototype.trim ? function (b) {
		return b.trim();
	} : function (b) {
		return b.replace(/^[\s\xa0]+|[\s\xa0]+$/g, "");
	};K.f.trimLeft = function (b) {
		return b.replace(/^[\s\xa0]+/, "");
	};K.f.trimRight = function (b) {
		return b.replace(/[\s\xa0]+$/, "");
	};K.f.jf = function (b, c) {
		b = String(b).toLowerCase();c = String(c).toLowerCase();return b < c ? -1 : b == c ? 0 : 1;
	};
	K.f.Zg = function (b, c, d) {
		if (b == c) return 0;if (!b) return -1;if (!c) return 1;for (var e = b.toLowerCase().match(d), f = c.toLowerCase().match(d), g = Math.min(e.length, f.length), h = 0; h < g; h++) {
			d = e[h];var l = f[h];if (d != l) return b = parseInt(d, 10), !isNaN(b) && (c = parseInt(l, 10), !isNaN(c) && b - c) ? b - c : d < l ? -1 : 1;
		}return e.length != f.length ? e.length - f.length : b < c ? -1 : 1;
	};K.f.tr = function (b, c) {
		return K.f.Zg(b, c, /\d+|\D+/g);
	};K.f.Aj = function (b, c) {
		return K.f.Zg(b, c, /\d+|\.\d+|\D+/g);
	};K.f.vs = K.f.Aj;K.f.St = function (b) {
		return encodeURIComponent(String(b));
	};
	K.f.Rt = function (b) {
		return decodeURIComponent(b.replace(/\+/g, " "));
	};K.f.Yg = function (b, c) {
		return b.replace(/(\r\n|\r|\n)/g, c ? "<br />" : "<br>");
	};
	K.f.ta = function (b, c) {
		if (c) b = b.replace(K.f.ke, "&amp;").replace(K.f.Je, "&lt;").replace(K.f.Ge, "&gt;").replace(K.f.Qe, "&quot;").replace(K.f.Te, "&#39;").replace(K.f.Le, "&#0;"), K.f.Wc && (b = b.replace(K.f.Ee, "&#101;"));else {
			if (!K.f.Eh.test(b)) return b;-1 != b.indexOf("&") && (b = b.replace(K.f.ke, "&amp;"));-1 != b.indexOf("<") && (b = b.replace(K.f.Je, "&lt;"));-1 != b.indexOf(">") && (b = b.replace(K.f.Ge, "&gt;"));-1 != b.indexOf('"') && (b = b.replace(K.f.Qe, "&quot;"));-1 != b.indexOf("'") && (b = b.replace(K.f.Te, "&#39;"));-1 != b.indexOf("\x00") && (b = b.replace(K.f.Le, "&#0;"));K.f.Wc && -1 != b.indexOf("e") && (b = b.replace(K.f.Ee, "&#101;"));
		}return b;
	};K.f.ke = /&/g;K.f.Je = /</g;K.f.Ge = />/g;K.f.Qe = /"/g;K.f.Te = /'/g;K.f.Le = /\x00/g;K.f.Ee = /e/g;K.f.Eh = K.f.Wc ? /[\x00&<>"'e]/ : /[\x00&<>"']/;K.f.vh = function (b) {
		return K.f.contains(b, "&") ? !K.f.Xh && "document" in K.global ? K.f.wh(b) : K.f.Fl(b) : b;
	};K.f.Ot = function (b, c) {
		return K.f.contains(b, "&") ? K.f.wh(b, c) : b;
	};
	K.f.wh = function (b, c) {
		var d = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"' };var e = c ? c.createElement("div") : K.global.document.createElement("div");return b.replace(K.f.bi, function (b, c) {
			var f = d[b];if (f) return f;"#" == c.charAt(0) && (c = Number("0" + c.substr(1)), isNaN(c) || (f = String.fromCharCode(c)));f || (e.innerHTML = b + " ", f = e.firstChild.nodeValue.slice(0, -1));return d[b] = f;
		});
	};
	K.f.Fl = function (b) {
		return b.replace(/&([^;]+);/g, function (b, d) {
			switch (d) {case "amp":
					return "&";case "lt":
					return "<";case "gt":
					return ">";case "quot":
					return '"';default:
					return "#" != d.charAt(0) || (d = Number("0" + d.substr(1)), isNaN(d)) ? b : String.fromCharCode(d);}
		});
	};K.f.bi = /&([^;\s<&]+);?/g;K.f.Ol = function (b) {
		return K.f.Yg(b.replace(/  /g, " &#160;"), void 0);
	};K.f.Cs = function (b) {
		return b.replace(/(^|[\n ]) /g, "$1" + K.f.Ye.Ke);
	};
	K.f.Ct = function (b, c) {
		for (var d = c.length, e = 0; e < d; e++) {
			var f = 1 == d ? c : c.charAt(e);if (b.charAt(0) == f && b.charAt(b.length - 1) == f) return b.substring(1, b.length - 1);
		}return b;
	};K.f.truncate = function (b, c, d) {
		d && (b = K.f.vh(b));b.length > c && (b = b.substring(0, c - 3) + "...");d && (b = K.f.ta(b));return b;
	};K.f.Mt = function (b, c, d, e) {
		d && (b = K.f.vh(b));e && b.length > c ? (e > c && (e = c), b = b.substring(0, c - e) + "..." + b.substring(b.length - e)) : b.length > c && (e = Math.floor(c / 2), b = b.substring(0, e + c % 2) + "..." + b.substring(b.length - e));d && (b = K.f.ta(b));return b;
	};
	K.f.de = { "\x00": "\\0", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "\t": "\\t", "\x0B": "\\x0B", '"': '\\"', "\\": "\\\\", "<": "<" };K.f.vc = { "'": "\\'" };K.f.quote = function (b) {
		b = String(b);for (var c = ['"'], d = 0; d < b.length; d++) {
			var e = b.charAt(d),
			    f = e.charCodeAt(0);c[d + 1] = K.f.de[e] || (31 < f && 127 > f ? e : K.f.xf(e));
		}c.push('"');return c.join("");
	};K.f.Cq = function (b) {
		for (var c = [], d = 0; d < b.length; d++) {
			c[d] = K.f.xf(b.charAt(d));
		}return c.join("");
	};
	K.f.xf = function (b) {
		if (b in K.f.vc) return K.f.vc[b];if (b in K.f.de) return K.f.vc[b] = K.f.de[b];var c = b.charCodeAt(0);if (31 < c && 127 > c) var d = b;else {
			if (256 > c) {
				if (d = "\\x", 16 > c || 256 < c) d += "0";
			} else d = "\\u", 4096 > c && (d += "0");d += c.toString(16).toUpperCase();
		}return K.f.vc[b] = d;
	};K.f.contains = function (b, c) {
		return -1 != b.indexOf(c);
	};K.f.kf = function (b, c) {
		return K.f.contains(b.toLowerCase(), c.toLowerCase());
	};K.f.fq = function (b, c) {
		return b && c ? b.split(c).length - 1 : 0;
	};
	K.f.yb = function (b, c, d) {
		var e = b;0 <= c && c < b.length && 0 < d && (e = b.substr(0, c) + b.substr(c + d, b.length - c - d));return e;
	};K.f.remove = function (b, c) {
		return b.replace(c, "");
	};K.f.Is = function (b, c) {
		c = new RegExp(K.f.Xd(c), "g");return b.replace(c, "");
	};K.f.Os = function (b, c, d) {
		c = new RegExp(K.f.Xd(c), "g");return b.replace(c, d.replace(/\$/g, "$$$$"));
	};K.f.Xd = function (b) {
		return String(b).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
	};
	K.f.repeat = String.prototype.repeat ? function (b, c) {
		return b.repeat(c);
	} : function (b, c) {
		return Array(c + 1).join(b);
	};K.f.As = function (b, c, d) {
		b = K.R(d) ? b.toFixed(d) : String(b);d = b.indexOf(".");-1 == d && (d = b.length);return K.f.repeat("0", Math.max(0, c - d)) + b;
	};K.f.Jk = function (b) {
		return null == b ? "" : String(b);
	};K.f.Mp = function (b) {
		return Array.prototype.join.call(arguments, "");
	};K.f.er = function () {
		return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ K.now()).toString(36);
	};
	K.f.Eb = function (b, c) {
		var d = 0;b = K.f.trim(String(b)).split(".");c = K.f.trim(String(c)).split(".");for (var e = Math.max(b.length, c.length), f = 0; 0 == d && f < e; f++) {
			var g = b[f] || "",
			    h = c[f] || "";do {
				g = /(\d*)(\D*)(.*)/.exec(g) || ["", "", "", ""];h = /(\d*)(\D*)(.*)/.exec(h) || ["", "", "", ""];if (0 == g[0].length && 0 == h[0].length) break;d = K.f.dd(0 == g[1].length ? 0 : parseInt(g[1], 10), 0 == h[1].length ? 0 : parseInt(h[1], 10)) || K.f.dd(0 == g[2].length, 0 == h[2].length) || K.f.dd(g[2], h[2]);g = g[3];h = h[3];
			} while (0 == d);
		}return d;
	};
	K.f.dd = function (b, c) {
		return b < c ? -1 : b > c ? 1 : 0;
	};K.f.nr = function (b) {
		for (var c = 0, d = 0; d < b.length; ++d) {
			c = 31 * c + b.charCodeAt(d) >>> 0;
		}return c;
	};K.f.Gl = 2147483648 * Math.random() | 0;K.f.oq = function () {
		return "goog_" + K.f.Gl++;
	};K.f.Gt = function (b) {
		var c = Number(b);return 0 == c && K.f.Id(b) ? NaN : c;
	};K.f.Ir = function (b) {
		return (/^[a-z]+([A-Z][a-z]*)*$/.test(b)
		);
	};K.f.Xr = function (b) {
		return (/^([A-Z][a-z]*)+$/.test(b)
		);
	};K.f.Ft = function (b) {
		return String(b).replace(/\-([a-z])/g, function (b, d) {
			return d.toUpperCase();
		});
	};
	K.f.It = function (b) {
		return String(b).replace(/([A-Z])/g, "-$1").toLowerCase();
	};K.f.Jt = function (b, c) {
		c = K.L(c) ? K.f.Xd(c) : "\\s";return b.replace(new RegExp("(^" + (c ? "|[" + c + "]+" : "") + ")([a-z])", "g"), function (b, c, f) {
			return c + f.toUpperCase();
		});
	};K.f.Qp = function (b) {
		return String(b.charAt(0)).toUpperCase() + String(b.substr(1)).toLowerCase();
	};K.f.parseInt = function (b) {
		isFinite(b) && (b = String(b));return K.L(b) ? /^\s*-?0x/i.test(b) ? parseInt(b, 16) : parseInt(b, 10) : NaN;
	};
	K.f.wt = function (b, c, d) {
		b = b.split(c);for (var e = []; 0 < d && b.length;) {
			e.push(b.shift()), d--;
		}b.length && e.push(b.join(c));return e;
	};K.f.$r = function (b, c) {
		if (c) (typeof c === "undefined" ? "undefined" : _typeof(c)) == B && (c = [c]);else return b;for (var d = -1, e = 0; e < c.length; e++) {
			if ("" != c[e]) {
				var f = b.lastIndexOf(c[e]);f > d && (d = f);
			}
		}return -1 == d ? b : b.slice(d + 1);
	};
	K.f.wq = function (b, c) {
		var d = [],
		    e = [];if (b == c) return 0;if (!b.length || !c.length) return Math.max(b.length, c.length);for (var f = 0; f < c.length + 1; f++) {
			d[f] = f;
		}for (f = 0; f < b.length; f++) {
			e[0] = f + 1;for (var g = 0; g < c.length; g++) {
				e[g + 1] = Math.min(e[g] + 1, d[g + 1] + 1, d[g] + Number(b[f] != c[g]));
			}for (g = 0; g < d.length; g++) {
				d[g] = e[g];
			}
		}return e[c.length];
	};K.m = {};K.m.na = K.ea;K.m.Xb = function (b, c) {
		c.unshift(b);K.debug.Error.call(this, K.f.wl.apply(null, c));c.shift();
	};K.ab(K.m.Xb, K.debug.Error);K.m.Xb.prototype.name = "AssertionError";K.m.Sh = function (b) {
		throw b;
	};K.m.kd = K.m.Sh;K.m.Fa = function (b, c, d, e) {
		var f = "Assertion failed";if (d) {
			f += ": " + d;var g = e;
		} else b && (f += ": " + b, g = c);b = new K.m.Xb("" + f, g || []);K.m.kd(b);
	};K.m.et = function (b) {
		K.m.na && (K.m.kd = b);
	};K.m.assert = function (b, c, d) {
		K.m.na && !b && K.m.Fa("", null, c, Array.prototype.slice.call(arguments, 2));return b;
	};
	K.m.la = function (b, c) {
		K.m.na && K.m.kd(new K.m.Xb("Failure" + (b ? ": " + b : ""), Array.prototype.slice.call(arguments, 1)));
	};K.m.Dp = function (b, c, d) {
		K.m.na && !K.Rb(b) && K.m.Fa("Expected number but got %s: %s.", [K.aa(b), b], c, Array.prototype.slice.call(arguments, 2));return b;
	};K.m.Gp = function (b, c, d) {
		K.m.na && !K.L(b) && K.m.Fa("Expected string but got %s: %s.", [K.aa(b), b], c, Array.prototype.slice.call(arguments, 2));return b;
	};
	K.m.rp = function (b, c, d) {
		K.m.na && !K.xa(b) && K.m.Fa("Expected function but got %s: %s.", [K.aa(b), b], c, Array.prototype.slice.call(arguments, 2));return b;
	};K.m.Ep = function (b, c, d) {
		K.m.na && !K.ha(b) && K.m.Fa("Expected object but got %s: %s.", [K.aa(b), b], c, Array.prototype.slice.call(arguments, 2));return b;
	};K.m.op = function (b, c, d) {
		K.m.na && !K.isArray(b) && K.m.Fa("Expected array but got %s: %s.", [K.aa(b), b], c, Array.prototype.slice.call(arguments, 2));return b;
	};
	K.m.pp = function (b, c, d) {
		K.m.na && !K.ck(b) && K.m.Fa("Expected boolean but got %s: %s.", [K.aa(b), b], c, Array.prototype.slice.call(arguments, 2));return b;
	};K.m.qp = function (b, c, d) {
		!K.m.na || K.ha(b) && b.nodeType == K.a.fa.Ia || K.m.Fa("Expected Element but got %s: %s.", [K.aa(b), b], c, Array.prototype.slice.call(arguments, 2));return b;
	};K.m.sp = function (b, c, d, e) {
		!K.m.na || b instanceof c || K.m.Fa("Expected instanceof %s but got %s.", [K.m.jg(c), K.m.jg(b)], d, Array.prototype.slice.call(arguments, 3));return b;
	};
	K.m.Fp = function () {
		for (var b in Object.prototype) {
			K.m.la(b + " should not be enumerable in Object.prototype.");
		}
	};K.m.jg = function (b) {
		return b instanceof Function ? b.displayName || b.name || "unknown type name" : b instanceof Object ? b.constructor.displayName || b.constructor.name || Object.prototype.toString.call(b) : null === b ? "null" : typeof b === "undefined" ? "undefined" : _typeof(b);
	};K.f.Yo = F();K.f.I = function () {
		this.Kc = "";this.xi = K.f.I.We;
	};K.f.I.prototype.ua = !0;K.f.I.prototype.ga = G("Kc");K.f.I.prototype.toString = function () {
		return "Const{" + this.Kc + "}";
	};K.f.I.u = function (b) {
		if (b instanceof K.f.I && b.constructor === K.f.I && b.xi === K.f.I.We) return b.Kc;K.m.la("expected object of type Const, got '" + b + "'");return "type_error:Const";
	};K.f.I.from = function (b) {
		return K.f.I.jj(b);
	};K.f.I.We = {};K.f.I.jj = function (b) {
		var c = new K.f.I();c.Kc = b;return c;
	};K.f.I.EMPTY = K.f.I.from("");K.j = {};K.Ba = K.$c;K.j.ya = !1;K.j.Rk = function (b) {
		return b[b.length - 1];
	};K.j.Zr = K.j.Rk;K.j.indexOf = K.Ba && (K.j.ya || Array.prototype.indexOf) ? function (b, c, d) {
		return Array.prototype.indexOf.call(b, c, d);
	} : function (b, c, d) {
		d = null == d ? 0 : 0 > d ? Math.max(0, b.length + d) : d;if (K.L(b)) return K.L(c) && 1 == c.length ? b.indexOf(c, d) : -1;for (; d < b.length; d++) {
			if (d in b && b[d] === c) return d;
		}return -1;
	};
	K.j.lastIndexOf = K.Ba && (K.j.ya || Array.prototype.lastIndexOf) ? function (b, c, d) {
		return Array.prototype.lastIndexOf.call(b, c, null == d ? b.length - 1 : d);
	} : function (b, c, d) {
		d = null == d ? b.length - 1 : d;0 > d && (d = Math.max(0, b.length + d));if (K.L(b)) return K.L(c) && 1 == c.length ? b.lastIndexOf(c, d) : -1;for (; 0 <= d; d--) {
			if (d in b && b[d] === c) return d;
		}return -1;
	};
	K.j.forEach = K.Ba && (K.j.ya || Array.prototype.forEach) ? function (b, c, d) {
		Array.prototype.forEach.call(b, c, d);
	} : function (b, c, d) {
		for (var e = b.length, f = K.L(b) ? b.split("") : b, g = 0; g < e; g++) {
			g in f && c.call(d, f[g], g, b);
		}
	};K.j.Gf = function (b, c) {
		for (var d = K.L(b) ? b.split("") : b, e = b.length - 1; 0 <= e; --e) {
			e in d && c.call(void 0, d[e], e, b);
		}
	};
	K.j.filter = K.Ba && (K.j.ya || Array.prototype.filter) ? function (b, c, d) {
		return Array.prototype.filter.call(b, c, d);
	} : function (b, c, d) {
		for (var e = b.length, f = [], g = 0, h = K.L(b) ? b.split("") : b, l = 0; l < e; l++) {
			if (l in h) {
				var m = h[l];c.call(d, m, l, b) && (f[g++] = m);
			}
		}return f;
	};K.j.map = K.Ba && (K.j.ya || Array.prototype.map) ? function (b, c, d) {
		return Array.prototype.map.call(b, c, d);
	} : function (b, c, d) {
		for (var e = b.length, f = Array(e), g = K.L(b) ? b.split("") : b, h = 0; h < e; h++) {
			h in g && (f[h] = c.call(d, g[h], h, b));
		}return f;
	};
	K.j.reduce = K.Ba && (K.j.ya || Array.prototype.reduce) ? function (b, c, d, e) {
		e && (c = K.bind(c, e));return Array.prototype.reduce.call(b, c, d);
	} : function (b, c, d, e) {
		var f = d;K.j.forEach(b, function (d, h) {
			f = c.call(e, f, d, h, b);
		});return f;
	};K.j.reduceRight = K.Ba && (K.j.ya || Array.prototype.reduceRight) ? function (b, c, d, e) {
		e && (c = K.bind(c, e));return Array.prototype.reduceRight.call(b, c, d);
	} : function (b, c, d, e) {
		var f = d;K.j.Gf(b, function (d, h) {
			f = c.call(e, f, d, h, b);
		});return f;
	};
	K.j.some = K.Ba && (K.j.ya || Array.prototype.some) ? function (b, c, d) {
		return Array.prototype.some.call(b, c, d);
	} : function (b, c, d) {
		for (var e = b.length, f = K.L(b) ? b.split("") : b, g = 0; g < e; g++) {
			if (g in f && c.call(d, f[g], g, b)) return !0;
		}return !1;
	};K.j.every = K.Ba && (K.j.ya || Array.prototype.every) ? function (b, c, d) {
		return Array.prototype.every.call(b, c, d);
	} : function (b, c, d) {
		for (var e = b.length, f = K.L(b) ? b.split("") : b, g = 0; g < e; g++) {
			if (g in f && !c.call(d, f[g], g, b)) return !1;
		}return !0;
	};
	K.j.count = function (b, c, d) {
		var e = 0;K.j.forEach(b, function (b, g, h) {
			c.call(d, b, g, h) && ++e;
		}, d);return e;
	};K.j.find = function (b, c, d) {
		c = K.j.findIndex(b, c, d);return 0 > c ? null : K.L(b) ? b.charAt(c) : b[c];
	};K.j.findIndex = function (b, c, d) {
		for (var e = b.length, f = K.L(b) ? b.split("") : b, g = 0; g < e; g++) {
			if (g in f && c.call(d, f[g], g, b)) return g;
		}return -1;
	};K.j.Fq = function (b, c, d) {
		c = K.j.yj(b, c, d);return 0 > c ? null : K.L(b) ? b.charAt(c) : b[c];
	};
	K.j.yj = function (b, c, d) {
		for (var e = K.L(b) ? b.split("") : b, f = b.length - 1; 0 <= f; f--) {
			if (f in e && c.call(d, e[f], f, b)) return f;
		}return -1;
	};K.j.contains = function (b, c) {
		return 0 <= K.j.indexOf(b, c);
	};K.j.Qb = function (b) {
		return 0 == b.length;
	};K.j.clear = function (b) {
		if (!K.isArray(b)) for (var c = b.length - 1; 0 <= c; c--) {
			delete b[c];
		}b.length = 0;
	};K.j.qr = function (b, c) {
		K.j.contains(b, c) || b.push(c);
	};K.j.sg = function (b, c, d) {
		K.j.splice(b, d, 0, c);
	};K.j.sr = function (b, c, d) {
		K.fb(K.j.splice, b, d, 0).apply(null, c);
	};
	K.j.insertBefore = function (b, c, d) {
		var e;2 == arguments.length || 0 > (e = K.j.indexOf(b, d)) ? b.push(c) : K.j.sg(b, c, e);
	};K.j.remove = function (b, c) {
		c = K.j.indexOf(b, c);var d;(d = 0 <= c) && K.j.yb(b, c);return d;
	};K.j.Ns = function (b, c) {
		c = K.j.lastIndexOf(b, c);return 0 <= c ? (K.j.yb(b, c), !0) : !1;
	};K.j.yb = function (b, c) {
		return 1 == Array.prototype.splice.call(b, c, 1).length;
	};K.j.Ms = function (b, c, d) {
		c = K.j.findIndex(b, c, d);return 0 <= c ? (K.j.yb(b, c), !0) : !1;
	};
	K.j.Js = function (b, c, d) {
		var e = 0;K.j.Gf(b, function (f, g) {
			c.call(d, f, g, b) && K.j.yb(b, g) && e++;
		});return e;
	};K.j.concat = function (b) {
		return Array.prototype.concat.apply([], arguments);
	};K.j.join = function (b) {
		return Array.prototype.concat.apply([], arguments);
	};K.j.th = function (b) {
		var c = b.length;if (0 < c) {
			for (var d = Array(c), e = 0; e < c; e++) {
				d[e] = b[e];
			}return d;
		}return [];
	};K.j.clone = K.j.th;
	K.j.extend = function (b, c) {
		for (var d = 1; d < arguments.length; d++) {
			var e = arguments[d];if (K.Nb(e)) {
				var f = b.length || 0,
				    g = e.length || 0;b.length = f + g;for (var h = 0; h < g; h++) {
					b[f + h] = e[h];
				}
			} else b.push(e);
		}
	};K.j.splice = function (b, c, d, e) {
		return Array.prototype.splice.apply(b, K.j.slice(arguments, 1));
	};K.j.slice = function (b, c, d) {
		return 2 >= arguments.length ? Array.prototype.slice.call(b, c) : Array.prototype.slice.call(b, c, d);
	};
	K.j.Ks = function (b, c, d) {
		function e(b) {
			return K.ha(b) ? "o" + K.kg(b) : (typeof b === "undefined" ? "undefined" : _typeof(b)).charAt(0) + b;
		}c = c || b;d = d || e;for (var f = {}, g = 0, h = 0; h < b.length;) {
			var l = b[h++],
			    m = d(l);Object.prototype.hasOwnProperty.call(f, m) || (f[m] = !0, c[g++] = l);
		}c.length = g;
	};K.j.gf = function (b, c, d) {
		return K.j.hf(b, d || K.j.Pa, !1, c);
	};K.j.Jp = function (b, c, d) {
		return K.j.hf(b, c, !0, void 0, d);
	};K.j.hf = function (b, c, d, e, f) {
		for (var g = 0, h = b.length, l; g < h;) {
			var m = g + h >> 1;var q = d ? c.call(f, b[m], m, b) : c(e, b[m]);0 < q ? g = m + 1 : (h = m, l = !q);
		}return l ? g : ~g;
	};
	K.j.sort = function (b, c) {
		b.sort(c || K.j.Pa);
	};K.j.yt = function (b, c) {
		for (var d = Array(b.length), e = 0; e < b.length; e++) {
			d[e] = { index: e, value: b[e] };
		}var f = c || K.j.Pa;K.j.sort(d, function (b, c) {
			return f(b.value, c.value) || b.index - c.index;
		});for (e = 0; e < b.length; e++) {
			b[e] = d[e].value;
		}
	};K.j.sl = function (b, c, d) {
		var e = d || K.j.Pa;K.j.sort(b, function (b, d) {
			return e(c(b), c(d));
		});
	};K.j.vt = function (b, c, d) {
		K.j.sl(b, function (b) {
			return b[c];
		}, d);
	};
	K.j.Ur = function (b, c, d) {
		c = c || K.j.Pa;for (var e = 1; e < b.length; e++) {
			var f = c(b[e - 1], b[e]);if (0 < f || 0 == f && d) return !1;
		}return !0;
	};K.j.Ib = function (b, c, d) {
		if (!K.Nb(b) || !K.Nb(c) || b.length != c.length) return !1;var e = b.length;d = d || K.j.lj;for (var f = 0; f < e; f++) {
			if (!d(b[f], c[f])) return !1;
		}return !0;
	};K.j.Zp = function (b, c, d) {
		d = d || K.j.Pa;for (var e = Math.min(b.length, c.length), f = 0; f < e; f++) {
			var g = d(b[f], c[f]);if (0 != g) return g;
		}return K.j.Pa(b.length, c.length);
	};K.j.Pa = function (b, c) {
		return b > c ? 1 : b < c ? -1 : 0;
	};
	K.j.ur = function (b, c) {
		return -K.j.Pa(b, c);
	};K.j.lj = function (b, c) {
		return b === c;
	};K.j.Hp = function (b, c, d) {
		d = K.j.gf(b, c, d);return 0 > d ? (K.j.sg(b, c, -(d + 1)), !0) : !1;
	};K.j.Ip = function (b, c, d) {
		c = K.j.gf(b, c, d);return 0 <= c ? K.j.yb(b, c) : !1;
	};K.j.Lp = function (b, c, d) {
		for (var e = {}, f = 0; f < b.length; f++) {
			var g = b[f],
			    h = c.call(d, g, f, b);K.R(h) && (e[h] || (e[h] = [])).push(g);
		}return e;
	};K.j.Ht = function (b, c, d) {
		var e = {};K.j.forEach(b, function (f, g) {
			e[c.call(d, f, g, b)] = f;
		});return e;
	};
	K.j.Fs = function (b, c, d) {
		var e = [],
		    f = 0,
		    g = b;d = d || 1;void 0 !== c && (f = b, g = c);if (0 > d * (g - f)) return [];if (0 < d) for (b = f; b < g; b += d) {
			e.push(b);
		} else for (b = f; b > g; b += d) {
			e.push(b);
		}return e;
	};K.j.repeat = function (b, c) {
		for (var d = [], e = 0; e < c; e++) {
			d[e] = b;
		}return d;
	};K.j.flatten = function (b) {
		for (var c = [], d = 0; d < arguments.length; d++) {
			var e = arguments[d];if (K.isArray(e)) for (var f = 0; f < e.length; f += 8192) {
				for (var g = K.j.flatten.apply(null, K.j.slice(e, f, f + 8192)), h = 0; h < g.length; h++) {
					c.push(g[h]);
				}
			} else c.push(e);
		}return c;
	};
	K.j.rotate = function (b, c) {
		b.length && (c %= b.length, 0 < c ? Array.prototype.unshift.apply(b, b.splice(-c, c)) : 0 > c && Array.prototype.push.apply(b, b.splice(0, -c)));return b;
	};K.j.ns = function (b, c, d) {
		c = Array.prototype.splice.call(b, c, 1);Array.prototype.splice.call(b, d, 0, c[0]);
	};
	K.j.Zt = function (b) {
		if (!arguments.length) return [];for (var c = [], d = arguments[0].length, e = 1; e < arguments.length; e++) {
			arguments[e].length < d && (d = arguments[e].length);
		}for (e = 0; e < d; e++) {
			for (var f = [], g = 0; g < arguments.length; g++) {
				f.push(arguments[g][e]);
			}c.push(f);
		}return c;
	};K.j.ut = function (b, c) {
		c = c || Math.random;for (var d = b.length - 1; 0 < d; d--) {
			var e = Math.floor(c() * (d + 1)),
			    f = b[d];b[d] = b[e];b[e] = f;
		}
	};K.j.eq = function (b, c) {
		var d = [];K.j.forEach(c, function (c) {
			d.push(b[c]);
		});return d;
	};
	K.j.aq = function (b, c, d) {
		return K.j.concat.apply([], K.j.map(b, c, d));
	};K.h = {};K.h.i = {};K.h.i.Zh = !1;
	K.h.i.Ie = K.h.i.Zh || ("ar" == K.ba.substring(0, 2).toLowerCase() || "fa" == K.ba.substring(0, 2).toLowerCase() || "he" == K.ba.substring(0, 2).toLowerCase() || "iw" == K.ba.substring(0, 2).toLowerCase() || "ps" == K.ba.substring(0, 2).toLowerCase() || "sd" == K.ba.substring(0, 2).toLowerCase() || "ug" == K.ba.substring(0, 2).toLowerCase() || "ur" == K.ba.substring(0, 2).toLowerCase() || "yi" == K.ba.substring(0, 2).toLowerCase()) && (2 == K.ba.length || "-" == K.ba.substring(2, 3) || "_" == K.ba.substring(2, 3)) || 3 <= K.ba.length && "ckb" == K.ba.substring(0, 3).toLowerCase() && (3 == K.ba.length || "-" == K.ba.substring(3, 4) || "_" == K.ba.substring(3, 4));K.h.i.mb = { gi: "\u202A", ji: "\u202B", Oe: "\u202C", hi: "\u200E", ki: "\u200F" };K.h.i.O = { Ta: 1, Ua: -1, qa: 0 };K.h.i.bc = "right";K.h.i.$b = "left";K.h.i.yn = K.h.i.Ie ? K.h.i.$b : K.h.i.bc;K.h.i.xn = K.h.i.Ie ? K.h.i.bc : K.h.i.$b;K.h.i.Al = function (b) {
		return (typeof b === "undefined" ? "undefined" : _typeof(b)) == x ? 0 < b ? K.h.i.O.Ta : 0 > b ? K.h.i.O.Ua : K.h.i.O.qa : null == b ? null : b ? K.h.i.O.Ua : K.h.i.O.Ta;
	};K.h.i.vb = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";
	K.h.i.zb = "\u0591-\u06EF\u06FA-\u07FF\u200F\uFB1D-\uFDFF\uFE70-\uFEFC";K.h.i.Yj = /<[^>]*>|&[^;]+;/g;K.h.i.Sa = function (b, c) {
		return c ? b.replace(K.h.i.Yj, "") : b;
	};K.h.i.$k = new RegExp("[" + K.h.i.zb + "]");K.h.i.Fk = new RegExp("[" + K.h.i.vb + "]");K.h.i.Bd = function (b, c) {
		return K.h.i.$k.test(K.h.i.Sa(b, c));
	};K.h.i.lr = K.h.i.Bd;K.h.i.og = function (b) {
		return K.h.i.Fk.test(K.h.i.Sa(b, void 0));
	};K.h.i.Ik = new RegExp("^[" + K.h.i.vb + "]");K.h.i.el = new RegExp("^[" + K.h.i.zb + "]");K.h.i.nk = function (b) {
		return K.h.i.el.test(b);
	};
	K.h.i.jk = function (b) {
		return K.h.i.Ik.test(b);
	};K.h.i.Mr = function (b) {
		return !K.h.i.jk(b) && !K.h.i.nk(b);
	};K.h.i.Gk = new RegExp("^[^" + K.h.i.zb + "]*[" + K.h.i.vb + "]");K.h.i.bl = new RegExp("^[^" + K.h.i.vb + "]*[" + K.h.i.zb + "]");K.h.i.nh = function (b, c) {
		return K.h.i.bl.test(K.h.i.Sa(b, c));
	};K.h.i.Sr = K.h.i.nh;K.h.i.tl = function (b, c) {
		return K.h.i.Gk.test(K.h.i.Sa(b, c));
	};K.h.i.Kr = K.h.i.tl;K.h.i.Jg = /^http:\/\/.*/;K.h.i.Nr = function (b, c) {
		b = K.h.i.Sa(b, c);return K.h.i.Jg.test(b) || !K.h.i.og(b) && !K.h.i.Bd(b);
	};
	K.h.i.Hk = new RegExp("[" + K.h.i.vb + "][^" + K.h.i.zb + "]*$");K.h.i.cl = new RegExp("[" + K.h.i.zb + "][^" + K.h.i.vb + "]*$");K.h.i.rj = function (b, c) {
		return K.h.i.Hk.test(K.h.i.Sa(b, c));
	};K.h.i.Jr = K.h.i.rj;K.h.i.sj = function (b, c) {
		return K.h.i.cl.test(K.h.i.Sa(b, c));
	};K.h.i.Qr = K.h.i.sj;K.h.i.dl = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Arab|Hebr|Thaa|Nkoo|Tfng))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;K.h.i.Rr = function (b) {
		return K.h.i.dl.test(b);
	};K.h.i.Ui = /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;
	K.h.i.kr = function (b, c) {
		c = (void 0 === c ? K.h.i.Bd(b) : c) ? K.h.i.mb.ki : K.h.i.mb.hi;return b.replace(K.h.i.Ui, c + "$&" + c);
	};K.h.i.zq = function (b) {
		return "<" == b.charAt(0) ? b.replace(/<\w+/, "$& dir=rtl") : "\n<span dir=rtl>" + b + "</span>";
	};K.h.i.Aq = function (b) {
		return K.h.i.mb.ji + b + K.h.i.mb.Oe;
	};K.h.i.xq = function (b) {
		return "<" == b.charAt(0) ? b.replace(/<\w+/, "$& dir=ltr") : "\n<span dir=ltr>" + b + "</span>";
	};K.h.i.yq = function (b) {
		return K.h.i.mb.gi + b + K.h.i.mb.Oe;
	};K.h.i.pj = /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;
	K.h.i.vk = /left/gi;K.h.i.Zk = /right/gi;K.h.i.yl = /%%%%/g;K.h.i.ks = function (b) {
		return b.replace(K.h.i.pj, ":$1 $4 $3 $2").replace(K.h.i.vk, "%%%%").replace(K.h.i.Zk, K.h.i.$b).replace(K.h.i.yl, K.h.i.bc);
	};K.h.i.qj = /([\u0591-\u05f2])"/g;K.h.i.rl = /([\u0591-\u05f2])'/g;K.h.i.ps = function (b) {
		return b.replace(K.h.i.qj, "$1\u05F4").replace(K.h.i.rl, "$1\u05F3");
	};K.h.i.Pl = /\s+/;K.h.i.Xj = /[\d\u06f0-\u06f9]/;K.h.i.al = .4;
	K.h.i.yf = function (b, c) {
		var d = 0,
		    e = 0,
		    f = !1;b = K.h.i.Sa(b, c).split(K.h.i.Pl);for (c = 0; c < b.length; c++) {
			var g = b[c];K.h.i.nh(g) ? (d++, e++) : K.h.i.Jg.test(g) ? f = !0 : K.h.i.og(g) ? e++ : K.h.i.Xj.test(g) && (f = !0);
		}return 0 == e ? f ? K.h.i.O.Ta : K.h.i.O.qa : d / e > K.h.i.al ? K.h.i.O.Ua : K.h.i.O.Ta;
	};K.h.i.sq = function (b, c) {
		return K.h.i.yf(b, c) == K.h.i.O.Ua;
	};K.h.i.bt = function (b, c) {
		b && (c = K.h.i.Al(c)) && (b.style.textAlign = c == K.h.i.O.Ua ? K.h.i.bc : K.h.i.$b, b.dir = c == K.h.i.O.Ua ? "rtl" : "ltr");
	};
	K.h.i.ct = function (b, c) {
		switch (K.h.i.yf(c)) {case K.h.i.O.Ta:
				b.dir = "ltr";break;case K.h.i.O.Ua:
				b.dir = "rtl";break;default:
				b.removeAttribute("dir");}
	};K.h.i.Tm = F();K.b = {};K.b.C = function () {
		this.Bc = "";this.Ai = K.b.C.ca;
	};K.b.C.prototype.ua = !0;K.b.C.prototype.ga = G("Bc");K.b.C.prototype.Dd = !0;K.b.C.prototype.$a = function () {
		return K.h.i.O.Ta;
	};K.ea && (K.b.C.prototype.toString = function () {
		return "TrustedResourceUrl{" + this.Bc + "}";
	});K.b.C.u = function (b) {
		if (b instanceof K.b.C && b.constructor === K.b.C && b.Ai === K.b.C.ca) return b.Bc;K.m.la("expected object of type TrustedResourceUrl, got '" + b + k + K.aa(b));return "type_error:TrustedResourceUrl";
	};
	K.b.C.format = function (b, c) {
		b = K.b.C.Hf(b, c);return K.b.C.Hb(b);
	};K.b.C.Hf = function (b, c) {
		var d = K.f.I.u(b);if (!K.b.C.Ih.test(d)) throw Error("Invalid TrustedResourceUrl format: " + d);return d.replace(K.b.C.$h, function (b, f) {
			if (!Object.prototype.hasOwnProperty.call(c, f)) throw Error('Found marker, "' + f + '", in format string, "' + d + '", but no valid label mapping found in args: ' + JSON.stringify(c));b = c[f];return b instanceof K.f.I ? K.f.I.u(b) : encodeURIComponent(String(b));
		});
	};K.b.C.$h = /%{(\w+)}/g;K.b.C.Ih = /^(?:https:)?\/\/[0-9a-z.:[\]-]+\/|^\/[^\/\\]|^about:blank(#|$)/i;
	K.b.C.Jq = function (b, c, d) {
		b = K.b.C.Hf(b, c);c = /\?/.test(b) ? "&" : "?";for (var e in d) {
			for (var f = K.isArray(d[e]) ? d[e] : [d[e]], g = 0; g < f.length; g++) {
				null != f[g] && (b += c + encodeURIComponent(e) + "=" + encodeURIComponent(String(f[g])), c = "&");
			}
		}return K.b.C.Hb(b);
	};K.b.C.mc = function (b) {
		return K.b.C.Hb(K.f.I.u(b));
	};K.b.C.Mq = function (b) {
		for (var c = "", d = 0; d < b.length; d++) {
			c += K.f.I.u(b[d]);
		}return K.b.C.Hb(c);
	};K.b.C.ca = {};K.b.C.Hb = function (b) {
		var c = new K.b.C();c.Bc = b;return c;
	};K.async = {};K.async.Zb = function (b, c, d) {
		this.wk = d;this.ij = b;this.Vk = c;this.xc = 0;this.tc = null;
	};K.async.Zb.prototype.get = function () {
		if (0 < this.xc) {
			this.xc--;var b = this.tc;this.tc = b.next;b.next = null;
		} else b = this.ij();return b;
	};K.async.Zb.prototype.put = function (b) {
		this.Vk(b);this.xc < this.wk && (this.xc++, b.next = this.tc, this.tc = b);
	};K.debug.Z = {};K.debug.$m = F();K.debug.Z.xb = [];K.debug.Z.Vd = [];K.debug.Z.Wg = !1;K.debug.Z.register = function (b) {
		K.debug.Z.xb[K.debug.Z.xb.length] = b;if (K.debug.Z.Wg) for (var c = K.debug.Z.Vd, d = 0; d < c.length; d++) {
			b(K.bind(c[d].Rl, c[d]));
		}
	};K.debug.Z.ms = function (b) {
		K.debug.Z.Wg = !0;for (var c = K.bind(b.Rl, b), d = 0; d < K.debug.Z.xb.length; d++) {
			K.debug.Z.xb[d](c);
		}K.debug.Z.Vd.push(b);
	};K.debug.Z.Qt = function (b) {
		var c = K.debug.Z.Vd;b = K.bind(b.u, b);for (var d = 0; d < K.debug.Z.xb.length; d++) {
			K.debug.Z.xb[d](b);
		}c.length--;
	};K.a.vn = F();K.a.c = function (b) {
		this.xl = b;
	};K.a.c.prototype.toString = G("xl");K.a.c.Ul = new K.a.c("A");K.a.c.Vl = new K.a.c("ABBR");K.a.c.Xl = new K.a.c("ACRONYM");K.a.c.Yl = new K.a.c("ADDRESS");K.a.c.bm = new K.a.c("APPLET");K.a.c.cm = new K.a.c("AREA");K.a.c.dm = new K.a.c("ARTICLE");K.a.c.em = new K.a.c("ASIDE");K.a.c.im = new K.a.c("AUDIO");K.a.c.jm = new K.a.c("B");K.a.c.km = new K.a.c("BASE");K.a.c.lm = new K.a.c("BASEFONT");K.a.c.mm = new K.a.c("BDI");K.a.c.nm = new K.a.c("BDO");K.a.c.qm = new K.a.c("BIG");K.a.c.rm = new K.a.c("BLOCKQUOTE");
	K.a.c.sm = new K.a.c("BODY");K.a.c.we = new K.a.c("BR");K.a.c.tm = new K.a.c("BUTTON");K.a.c.um = new K.a.c("CANVAS");K.a.c.vm = new K.a.c("CAPTION");K.a.c.xm = new K.a.c("CENTER");K.a.c.ym = new K.a.c("CITE");K.a.c.Bm = new K.a.c("CODE");K.a.c.Cm = new K.a.c("COL");K.a.c.Dm = new K.a.c("COLGROUP");K.a.c.Em = new K.a.c("COMMAND");K.a.c.Gm = new K.a.c("DATA");K.a.c.Hm = new K.a.c("DATALIST");K.a.c.Im = new K.a.c("DD");K.a.c.Jm = new K.a.c("DEL");K.a.c.Km = new K.a.c("DETAILS");K.a.c.Lm = new K.a.c("DFN");K.a.c.Mm = new K.a.c("DIALOG");
	K.a.c.Nm = new K.a.c("DIR");K.a.c.Om = new K.a.c("DIV");K.a.c.Pm = new K.a.c("DL");K.a.c.Sm = new K.a.c("DT");K.a.c.Vm = new K.a.c("EM");K.a.c.Wm = new K.a.c("EMBED");K.a.c.bn = new K.a.c("FIELDSET");K.a.c.cn = new K.a.c("FIGCAPTION");K.a.c.dn = new K.a.c("FIGURE");K.a.c.en = new K.a.c("FONT");K.a.c.fn = new K.a.c("FOOTER");K.a.c.gn = new K.a.c("FORM");K.a.c.hn = new K.a.c("FRAME");K.a.c.jn = new K.a.c("FRAMESET");K.a.c.kn = new K.a.c("H1");K.a.c.ln = new K.a.c("H2");K.a.c.mn = new K.a.c("H3");K.a.c.nn = new K.a.c("H4");K.a.c.on = new K.a.c("H5");
	K.a.c.pn = new K.a.c("H6");K.a.c.qn = new K.a.c("HEAD");K.a.c.rn = new K.a.c("HEADER");K.a.c.sn = new K.a.c("HGROUP");K.a.c.tn = new K.a.c("HR");K.a.c.un = new K.a.c("HTML");K.a.c.wn = new K.a.c("I");K.a.c.zn = new K.a.c("IFRAME");K.a.c.An = new K.a.c("IMG");K.a.c.Bn = new K.a.c("INPUT");K.a.c.Cn = new K.a.c("INS");K.a.c.Hn = new K.a.c("ISINDEX");K.a.c.Jn = new K.a.c("KBD");K.a.c.Kn = new K.a.c("KEYGEN");K.a.c.Ln = new K.a.c("LABEL");K.a.c.Nn = new K.a.c("LEGEND");K.a.c.On = new K.a.c("LI");K.a.c.Pn = new K.a.c("LINK");K.a.c.Sn = new K.a.c("MAP");
	K.a.c.Tn = new K.a.c("MARK");K.a.c.Un = new K.a.c("MATH");K.a.c.Vn = new K.a.c("MENU");K.a.c.Wn = new K.a.c("META");K.a.c.Xn = new K.a.c("METER");K.a.c.Zn = new K.a.c("NAV");K.a.c.$n = new K.a.c("NOFRAMES");K.a.c.ao = new K.a.c("NOSCRIPT");K.a.c.eo = new K.a.c("OBJECT");K.a.c.fo = new K.a.c("OL");K.a.c.ho = new K.a.c("OPTGROUP");K.a.c.io = new K.a.c("OPTION");K.a.c.jo = new K.a.c("OUTPUT");K.a.c.ko = new K.a.c("P");K.a.c.lo = new K.a.c("PARAM");K.a.c.no = new K.a.c("PRE");K.a.c.po = new K.a.c("PROGRESS");K.a.c.Q = new K.a.c("Q");
	K.a.c.qo = new K.a.c("RP");K.a.c.ro = new K.a.c("RT");K.a.c.so = new K.a.c("RUBY");K.a.c.uo = new K.a.c("S");K.a.c.wo = new K.a.c("SAMP");K.a.c.xo = new K.a.c(p);K.a.c.yo = new K.a.c("SECTION");K.a.c.zo = new K.a.c("SELECT");K.a.c.Ao = new K.a.c("SMALL");K.a.c.Bo = new K.a.c("SOURCE");K.a.c.Co = new K.a.c("SPAN");K.a.c.Do = new K.a.c("STRIKE");K.a.c.Eo = new K.a.c("STRONG");K.a.c.Fo = new K.a.c("STYLE");K.a.c.Go = new K.a.c("SUB");K.a.c.Ho = new K.a.c("SUMMARY");K.a.c.Io = new K.a.c("SUP");K.a.c.Jo = new K.a.c("SVG");K.a.c.Ko = new K.a.c("TABLE");
	K.a.c.Lo = new K.a.c("TBODY");K.a.c.Mo = new K.a.c("TD");K.a.c.No = new K.a.c("TEMPLATE");K.a.c.Oo = new K.a.c("TEXTAREA");K.a.c.Po = new K.a.c("TFOOT");K.a.c.Qo = new K.a.c("TH");K.a.c.Ro = new K.a.c("THEAD");K.a.c.So = new K.a.c("TIME");K.a.c.To = new K.a.c("TITLE");K.a.c.Uo = new K.a.c("TR");K.a.c.Vo = new K.a.c("TRACK");K.a.c.Xo = new K.a.c("TT");K.a.c.Zo = new K.a.c("U");K.a.c.$o = new K.a.c("UL");K.a.c.ap = new K.a.c("VAR");K.a.c.bp = new K.a.c("VIDEO");K.a.c.cp = new K.a.c("WBR");K.J = {};K.J.ic = function (b) {
		return function () {
			return b;
		};
	};K.J.an = K.J.ic(!1);K.J.Wo = K.J.ic(!0);K.J.co = K.J.ic(null);K.J.$j = E();K.J.error = function (b) {
		return function () {
			throw Error(b);
		};
	};K.J.la = function (b) {
		return function () {
			throw b;
		};
	};K.J.lock = function (b, c) {
		c = c || 0;return function () {
			return b.apply(this, Array.prototype.slice.call(arguments, 0, c));
		};
	};K.J.us = function (b) {
		return function () {
			return arguments[b];
		};
	};
	K.J.Bs = function (b, c) {
		var d = Array.prototype.slice.call(arguments, 1);return function () {
			var c = Array.prototype.slice.call(arguments);c.push.apply(c, d);return b.apply(this, c);
		};
	};K.J.Wt = function (b, c) {
		return K.J.ll(b, K.J.ic(c));
	};K.J.Bq = function (b, c) {
		return function (d) {
			return c ? b == d : b === d;
		};
	};K.J.$p = function (b, c) {
		var d = arguments,
		    e = d.length;return function () {
			var b;e && (b = d[e - 1].apply(this, arguments));for (var c = e - 2; 0 <= c; c--) {
				b = d[c].call(this, b);
			}return b;
		};
	};
	K.J.ll = function (b) {
		var c = arguments,
		    d = c.length;return function () {
			for (var b, f = 0; f < d; f++) {
				b = c[f].apply(this, arguments);
			}return b;
		};
	};K.J.kp = function (b) {
		var c = arguments,
		    d = c.length;return function () {
			for (var b = 0; b < d; b++) {
				if (!c[b].apply(this, arguments)) return !1;
			}return !0;
		};
	};K.J.zs = function (b) {
		var c = arguments,
		    d = c.length;return function () {
			for (var b = 0; b < d; b++) {
				if (c[b].apply(this, arguments)) return !0;
			}return !1;
		};
	};K.J.ts = function (b) {
		return function () {
			return !b.apply(this, arguments);
		};
	};
	K.J.create = function (b, c) {
		function d() {}d.prototype = b.prototype;var e = new d();b.apply(e, Array.prototype.slice.call(arguments, 1));return e;
	};K.J.Kh = !0;K.J.Np = function (b) {
		var c = !1,
		    d;return function () {
			if (!K.J.Kh) return b();c || (d = b(), c = !0);return d;
		};
	};K.J.once = function (b) {
		var c = b;return function () {
			if (c) {
				var b = c;c = null;b();
			}
		};
	};K.J.qq = function (b, c, d) {
		var e = 0;return function (f) {
			K.global.clearTimeout(e);var g = arguments;e = K.global.setTimeout(function () {
				b.apply(d, g);
			}, c);
		};
	};
	K.J.Et = function (b, c, d) {
		function e() {
			g = K.global.setTimeout(f, c);b.apply(d, l);
		}function f() {
			g = 0;h && (h = !1, e());
		}var g = 0,
		    h = !1,
		    l = [];return function (b) {
			l = arguments;g ? h = !0 : e();
		};
	};K.J.Gs = function (b, c, d) {
		function e() {
			f = 0;
		}var f = 0;return function (g) {
			f || (f = K.global.setTimeout(e, c), b.apply(d, arguments));
		};
	};K.g = {};K.g.userAgent = {};K.g.userAgent.A = {};K.g.userAgent.A.Xf = function () {
		var b = K.g.userAgent.A.Kj();return b && (b = b.userAgent) ? b : "";
	};K.g.userAgent.A.Kj = function () {
		return K.global.navigator;
	};K.g.userAgent.A.xh = K.g.userAgent.A.Xf();K.g.userAgent.A.st = function (b) {
		K.g.userAgent.A.xh = b || K.g.userAgent.A.Xf();
	};K.g.userAgent.A.sb = function () {
		return K.g.userAgent.A.xh;
	};K.g.userAgent.A.K = function (b) {
		return K.f.contains(K.g.userAgent.A.sb(), b);
	};
	K.g.userAgent.A.Pk = function () {
		return K.f.kf(K.g.userAgent.A.sb(), "WebKit");
	};K.g.userAgent.A.Af = function (b) {
		for (var c = /(\w[\w ]+)\/([^\s]+)\s*(?:\((.*?)\))?/g, d = [], e; e = c.exec(b);) {
			d.push([e[1], e[2], e[3] || void 0]);
		}return d;
	};K.object = {};K.object.is = function (b, c) {
		return b === c ? 0 !== b || 1 / b === 1 / c : b !== b && c !== c;
	};K.object.forEach = function (b, c, d) {
		for (var e in b) {
			c.call(d, b[e], e, b);
		}
	};K.object.filter = function (b, c, d) {
		var e = {},
		    f;for (f in b) {
			c.call(d, b[f], f, b) && (e[f] = b[f]);
		}return e;
	};K.object.map = function (b, c, d) {
		var e = {},
		    f;for (f in b) {
			e[f] = c.call(d, b[f], f, b);
		}return e;
	};K.object.some = function (b, c, d) {
		for (var e in b) {
			if (c.call(d, b[e], e, b)) return !0;
		}return !1;
	};K.object.every = function (b, c, d) {
		for (var e in b) {
			if (!c.call(d, b[e], e, b)) return !1;
		}return !0;
	};
	K.object.Uq = function (b) {
		var c = 0,
		    d;for (d in b) {
			c++;
		}return c;
	};K.object.Sq = function (b) {
		for (var c in b) {
			return c;
		}
	};K.object.Tq = function (b) {
		for (var c in b) {
			return b[c];
		}
	};K.object.contains = function (b, c) {
		return K.object.cj(b, c);
	};K.object.ir = function (b) {
		var c = [],
		    d = 0,
		    e;for (e in b) {
			c[d++] = b[e];
		}return c;
	};K.object.Vf = function (b) {
		var c = [],
		    d = 0,
		    e;for (e in b) {
			c[d++] = e;
		}return c;
	};K.object.gr = function (b, c) {
		var d = K.Nb(c),
		    e = d ? c : arguments;for (d = d ? 0 : 1; d < e.length; d++) {
			if (null == b) return;b = b[e[d]];
		}return b;
	};
	K.object.bj = function (b, c) {
		return null !== b && c in b;
	};K.object.cj = function (b, c) {
		for (var d in b) {
			if (b[d] == c) return !0;
		}return !1;
	};K.object.zj = function (b, c, d) {
		for (var e in b) {
			if (c.call(d, b[e], e, b)) return e;
		}
	};K.object.Gq = function (b, c, d) {
		return (c = K.object.zj(b, c, d)) && b[c];
	};K.object.Qb = function (b) {
		for (var c in b) {
			return !1;
		}return !0;
	};K.object.clear = function (b) {
		for (var c in b) {
			delete b[c];
		}
	};K.object.remove = function (b, c) {
		var d;(d = c in b) && delete b[c];return d;
	};
	K.object.add = function (b, c, d) {
		if (null !== b && c in b) throw Error('The object already contains the key "' + c + '"');K.object.set(b, c, d);
	};K.object.get = function (b, c, d) {
		return null !== b && c in b ? b[c] : d;
	};K.object.set = function (b, c, d) {
		b[c] = d;
	};K.object.gt = function (b, c, d) {
		return c in b ? b[c] : b[c] = d;
	};K.object.tt = function (b, c, d) {
		if (c in b) return b[c];d = d();return b[c] = d;
	};K.object.Ib = function (b, c) {
		for (var d in b) {
			if (!(d in c) || b[d] !== c[d]) return !1;
		}for (d in c) {
			if (!(d in b)) return !1;
		}return !0;
	};
	K.object.clone = function (b) {
		var c = {},
		    d;for (d in b) {
			c[d] = b[d];
		}return c;
	};K.object.Hl = function (b) {
		var c = K.aa(b);if (c == y || c == r) {
			if (K.xa(b.clone)) return b.clone();c = c == r ? [] : {};for (var d in b) {
				c[d] = K.object.Hl(b[d]);
			}return c;
		}return b;
	};K.object.Lt = function (b) {
		var c = {},
		    d;for (d in b) {
			c[b[d]] = d;
		}return c;
	};K.object.Pe = ["constructor", w, "isPrototypeOf", A, D, "toString", "valueOf"];
	K.object.extend = function (b, c) {
		for (var d, e, f = 1; f < arguments.length; f++) {
			e = arguments[f];for (d in e) {
				b[d] = e[d];
			}for (var g = 0; g < K.object.Pe.length; g++) {
				d = K.object.Pe[g], Object.prototype.hasOwnProperty.call(e, d) && (b[d] = e[d]);
			}
		}
	};K.object.create = function (b) {
		var c = arguments.length;if (1 == c && K.isArray(arguments[0])) return K.object.create.apply(null, arguments[0]);if (c % 2) throw Error("Uneven number of arguments");for (var d = {}, e = 0; e < c; e += 2) {
			d[arguments[e]] = arguments[e + 1];
		}return d;
	};
	K.object.gj = function (b) {
		var c = arguments.length;if (1 == c && K.isArray(arguments[0])) return K.object.gj.apply(null, arguments[0]);for (var d = {}, e = 0; e < c; e++) {
			d[arguments[e]] = !0;
		}return d;
	};K.object.hq = function (b) {
		var c = b;Object.isFrozen && !Object.isFrozen(b) && (c = Object.create(b), Object.freeze(c));return c;
	};K.object.Fr = function (b) {
		return !!Object.isFrozen && Object.isFrozen(b);
	};
	K.object.Rq = function (b, c, d) {
		if (!b) return [];if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) return K.object.Vf(b);for (var e = {}; b && (b !== Object.prototype || c) && (b !== Function.prototype || d);) {
			for (var f = Object.getOwnPropertyNames(b), g = 0; g < f.length; g++) {
				e[f[g]] = !0;
			}b = Object.getPrototypeOf(b);
		}return K.object.Vf(e);
	};K.g.userAgent.v = {};K.g.userAgent.v.Rg = function () {
		return K.g.userAgent.A.K("Opera");
	};K.g.userAgent.v.Nk = function () {
		return K.g.userAgent.A.K("Trident") || K.g.userAgent.A.K("MSIE");
	};K.g.userAgent.v.Sd = function () {
		return K.g.userAgent.A.K("Edge");
	};K.g.userAgent.v.Mk = function () {
		return K.g.userAgent.A.K("Firefox");
	};K.g.userAgent.v.Sg = function () {
		return K.g.userAgent.A.K("Safari") && !(K.g.userAgent.v.Qd() || K.g.userAgent.v.Rd() || K.g.userAgent.v.Rg() || K.g.userAgent.v.Sd() || K.g.userAgent.v.Kg() || K.g.userAgent.A.K("Android"));
	};
	K.g.userAgent.v.Rd = function () {
		return K.g.userAgent.A.K("Coast");
	};K.g.userAgent.v.Ok = function () {
		return (K.g.userAgent.A.K("iPad") || K.g.userAgent.A.K("iPhone")) && !K.g.userAgent.v.Sg() && !K.g.userAgent.v.Qd() && !K.g.userAgent.v.Rd() && K.g.userAgent.A.K("AppleWebKit");
	};K.g.userAgent.v.Qd = function () {
		return (K.g.userAgent.A.K("Chrome") || K.g.userAgent.A.K("CriOS")) && !K.g.userAgent.v.Sd();
	};
	K.g.userAgent.v.Lk = function () {
		return K.g.userAgent.A.K("Android") && !(K.g.userAgent.v.zg() || K.g.userAgent.v.fk() || K.g.userAgent.v.Nd() || K.g.userAgent.v.Kg());
	};K.g.userAgent.v.Nd = K.g.userAgent.v.Rg;K.g.userAgent.v.uc = K.g.userAgent.v.Nk;K.g.userAgent.v.Ra = K.g.userAgent.v.Sd;K.g.userAgent.v.fk = K.g.userAgent.v.Mk;K.g.userAgent.v.Tr = K.g.userAgent.v.Sg;K.g.userAgent.v.zr = K.g.userAgent.v.Rd;K.g.userAgent.v.Hr = K.g.userAgent.v.Ok;K.g.userAgent.v.zg = K.g.userAgent.v.Qd;K.g.userAgent.v.xr = K.g.userAgent.v.Lk;
	K.g.userAgent.v.Kg = function () {
		return K.g.userAgent.A.K("Silk");
	};K.g.userAgent.v.Lb = function () {
		function b(b) {
			b = K.j.find(b, e);return d[b] || "";
		}var c = K.g.userAgent.A.sb();if (K.g.userAgent.v.uc()) return K.g.userAgent.v.Jj(c);c = K.g.userAgent.A.Af(c);var d = {};K.j.forEach(c, function (b) {
			d[b[0]] = b[1];
		});var e = K.fb(K.object.bj, d);return K.g.userAgent.v.Nd() ? b(["Version", "Opera"]) : K.g.userAgent.v.Ra() ? b(["Edge"]) : K.g.userAgent.v.zg() ? b(["Chrome", "CriOS"]) : (c = c[2]) && c[1] || "";
	};
	K.g.userAgent.v.va = function (b) {
		return 0 <= K.f.Eb(K.g.userAgent.v.Lb(), b);
	};K.g.userAgent.v.Jj = function (b) {
		var c = /rv: *([\d\.]*)/.exec(b);if (c && c[1]) return c[1];c = "";var d = /MSIE +([\d\.]+)/.exec(b);if (d && d[1]) if (b = /Trident\/(\d.\d)/.exec(b), "7.0" == d[1]) {
			if (b && b[1]) switch (b[1]) {case "4.0":
					c = "8.0";break;case "5.0":
					c = "9.0";break;case "6.0":
					c = "10.0";break;case "7.0":
					c = "11.0";} else c = "7.0";
		} else c = d[1];return c;
	};K.g.userAgent.U = {};K.g.userAgent.U.lk = function () {
		return K.g.userAgent.A.K("Presto");
	};K.g.userAgent.U.pk = function () {
		return K.g.userAgent.A.K("Trident") || K.g.userAgent.A.K("MSIE");
	};K.g.userAgent.U.Ra = function () {
		return K.g.userAgent.A.K("Edge");
	};K.g.userAgent.U.Mg = function () {
		return K.g.userAgent.A.Pk() && !K.g.userAgent.U.Ra();
	};K.g.userAgent.U.gk = function () {
		return K.g.userAgent.A.K("Gecko") && !K.g.userAgent.U.Mg() && !K.g.userAgent.U.pk() && !K.g.userAgent.U.Ra();
	};
	K.g.userAgent.U.Lb = function () {
		var b = K.g.userAgent.A.sb();if (b) {
			b = K.g.userAgent.A.Af(b);var c = K.g.userAgent.U.Hj(b);if (c) return "Gecko" == c[0] ? K.g.userAgent.U.Rj(b) : c[1];b = b[0];var d;if (b && (d = b[2]) && (d = /Trident\/([^\s;]+)/.exec(d))) return d[1];
		}return "";
	};K.g.userAgent.U.Hj = function (b) {
		if (!K.g.userAgent.U.Ra()) return b[1];for (var c = 0; c < b.length; c++) {
			var d = b[c];if ("Edge" == d[0]) return d;
		}
	};K.g.userAgent.U.va = function (b) {
		return 0 <= K.f.Eb(K.g.userAgent.U.Lb(), b);
	};
	K.g.userAgent.U.Rj = function (b) {
		return (b = K.j.find(b, function (b) {
			return "Firefox" == b[0];
		})) && b[1] || "";
	};K.async.qh = function (b) {
		K.global.setTimeout(function () {
			throw b;
		}, 0);
	};K.async.pa = function (b, c, d) {
		var e = b;c && (e = K.bind(b, c));e = K.async.pa.Ah(e);K.xa(K.global.setImmediate) && (d || K.async.pa.Kl()) ? K.global.setImmediate(e) : (K.async.pa.kh || (K.async.pa.kh = K.async.pa.Nj()), K.async.pa.kh(e));
	};K.async.pa.Kl = function () {
		return K.global.Window && K.global.Window.prototype && !K.g.userAgent.v.Ra() && K.global.Window.prototype.setImmediate == K.global.setImmediate ? !1 : !0;
	};
	K.async.pa.Nj = function () {
		var b = K.global.MessageChannel;"undefined" === typeof b && "undefined" !== typeof window && window.postMessage && window.addEventListener && !K.g.userAgent.U.lk() && (b = function b() {
			var b = document.createElement("IFRAME");b.style.display = "none";b.src = "";document.documentElement.appendChild(b);var c = b.contentWindow;b = c.document;b.open();b.write("");b.close();var d = "callImmediate" + Math.random(),
			    e = "file:" == c.location.protocol ? "*" : c.location.protocol + "//" + c.location.host;b = K.bind(function (b) {
				if (("*" == e || b.origin == e) && b.data == d) this.port1.onmessage();
			}, this);c.addEventListener("message", b, !1);this.port1 = {};this.port2 = { postMessage: function postMessage() {
					c.postMessage(d, e);
				} };
		});if ("undefined" !== typeof b && !K.g.userAgent.v.uc()) {
			var c = new b(),
			    d = {},
			    e = d;c.port1.onmessage = function () {
				if (K.R(d.next)) {
					d = d.next;var b = d.lf;d.lf = null;b();
				}
			};return function (b) {
				e.next = { lf: b };e = e.next;c.port2.postMessage(0);
			};
		}return "undefined" !== typeof document && "onreadystatechange" in document.createElement(p) ? function (b) {
			var c = document.createElement(p);
			c.onreadystatechange = function () {
				c.onreadystatechange = null;c.parentNode.removeChild(c);c = null;b();b = null;
			};document.documentElement.appendChild(c);
		} : function (b) {
			K.global.setTimeout(b, 0);
		};
	};K.async.pa.Ah = K.J.$j;K.debug.Z.register(function (b) {
		K.async.pa.Ah = b;
	});K.async.Da = function () {
		this.Qc = this.Ab = null;
	};K.async.Da.Vc = 100;K.async.Da.Kb = new K.async.Zb(function () {
		return new K.async.ad();
	}, function (b) {
		b.reset();
	}, K.async.Da.Vc);K.async.Da.prototype.add = function (b, c) {
		var d = K.async.Da.Kb.get();d.set(b, c);this.Qc ? this.Qc.next = d : this.Ab = d;this.Qc = d;
	};K.async.Da.prototype.remove = function () {
		var b = null;this.Ab && (b = this.Ab, this.Ab = this.Ab.next, this.Ab || (this.Qc = null), b.next = null);return b;
	};K.async.ad = function () {
		this.next = this.scope = this.od = null;
	};
	K.async.ad.prototype.set = function (b, c) {
		this.od = b;this.scope = c;this.next = null;
	};K.async.ad.prototype.reset = function () {
		this.next = this.scope = this.od = null;
	};K.async.M = function (b, c) {
		K.async.M.Hc || K.async.M.bk();K.async.M.Pc || (K.async.M.Hc(), K.async.M.Pc = !0);K.async.M.ie.add(b, c);
	};K.async.M.bk = function () {
		if (-1 != String(K.global.Promise).indexOf("[native code]")) {
			var b = K.global.Promise.resolve(void 0);K.async.M.Hc = function () {
				b.then(K.async.M.Cc);
			};
		} else K.async.M.Hc = function () {
			K.async.pa(K.async.M.Cc);
		};
	};K.async.M.Iq = function (b) {
		K.async.M.Hc = function () {
			K.async.pa(K.async.M.Cc);b && b(K.async.M.Cc);
		};
	};K.async.M.Pc = !1;K.async.M.ie = new K.async.Da();
	K.ea && (K.async.M.Qs = function () {
		K.async.M.Pc = !1;K.async.M.ie = new K.async.Da();
	});K.async.M.Cc = function () {
		for (var b; b = K.async.M.ie.remove();) {
			try {
				b.od.call(b.scope);
			} catch (c) {
				K.async.qh(c);
			}K.async.Da.Kb.put(b);
		}K.async.M.Pc = !1;
	};K.a.m = {};K.a.m.Bp = F();K.a.m.tp = F();K.a.m.yp = F();K.a.m.xp = F();K.a.m.up = F();K.a.m.vp = F();K.a.m.wp = F();K.a.m.zp = F();K.a.m.Ap = F();K.a.m.rq = function (b) {
		return K.ha(b) ? b.constructor.displayName || b.constructor.name || Object.prototype.toString.call(b) : void 0 === b ? "undefined" : null === b ? "null" : typeof b === "undefined" ? "undefined" : _typeof(b);
	};K.a.m.qc = function (b) {
		return (b = b && b.ownerDocument) && (b.defaultView || b.parentWindow) || K.global;
	};K.g.userAgent.platform = {};K.g.userAgent.platform.yg = function () {
		return K.g.userAgent.A.K("Android");
	};K.g.userAgent.platform.Hg = function () {
		return K.g.userAgent.A.K("iPod");
	};K.g.userAgent.platform.Gg = function () {
		return K.g.userAgent.A.K("iPhone") && !K.g.userAgent.A.K("iPod") && !K.g.userAgent.A.K("iPad");
	};K.g.userAgent.platform.Fg = function () {
		return K.g.userAgent.A.K("iPad");
	};K.g.userAgent.platform.Eg = function () {
		return K.g.userAgent.platform.Gg() || K.g.userAgent.platform.Fg() || K.g.userAgent.platform.Hg();
	};
	K.g.userAgent.platform.Ig = function () {
		return K.g.userAgent.A.K("Macintosh");
	};K.g.userAgent.platform.ik = function () {
		return K.g.userAgent.A.K("Linux");
	};K.g.userAgent.platform.Og = function () {
		return K.g.userAgent.A.K("Windows");
	};K.g.userAgent.platform.Ag = function () {
		return K.g.userAgent.A.K("CrOS");
	};
	K.g.userAgent.platform.Lb = function () {
		var b = K.g.userAgent.A.sb(),
		    c = "";K.g.userAgent.platform.Og() ? (c = /Windows (?:NT|Phone) ([0-9.]+)/, c = (b = c.exec(b)) ? b[1] : "0.0") : K.g.userAgent.platform.Eg() ? (c = /(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/, c = (b = c.exec(b)) && b[1].replace(/_/g, ".")) : K.g.userAgent.platform.Ig() ? (c = /Mac OS X ([0-9_.]+)/, c = (b = c.exec(b)) ? b[1].replace(/_/g, ".") : "10") : K.g.userAgent.platform.yg() ? (c = /Android\s+([^\);]+)(\)|;)/, c = (b = c.exec(b)) && b[1]) : K.g.userAgent.platform.Ag() && (c = /(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/, c = (b = c.exec(b)) && b[1]);return c || "";
	};K.g.userAgent.platform.va = function (b) {
		return 0 <= K.f.Eb(K.g.userAgent.platform.Lb(), b);
	};K.Ha = {};K.Ha.object = function (b, c) {
		return c;
	};K.Ha.ce = function (b) {
		K.Ha.ce[" "](b);return b;
	};K.Ha.ce[" "] = K.eb;K.Ha.Op = function (b, c) {
		try {
			return K.Ha.ce(b[c]), !0;
		} catch (d) {}return !1;
	};K.Ha.cache = function (b, c, d, e) {
		e = e ? e(c) : c;return Object.prototype.hasOwnProperty.call(b, e) ? b[e] : b[e] = d(c);
	};K.userAgent = {};K.userAgent.oe = !1;K.userAgent.me = !1;K.userAgent.ne = !1;K.userAgent.te = !1;K.userAgent.Uc = !1;K.userAgent.re = !1;K.userAgent.Fh = !1;K.userAgent.Bb = K.userAgent.oe || K.userAgent.me || K.userAgent.ne || K.userAgent.Uc || K.userAgent.te || K.userAgent.re;K.userAgent.Qj = function () {
		return K.g.userAgent.A.sb();
	};K.userAgent.Yf = function () {
		return K.global.navigator || null;
	};K.userAgent.Ne = K.userAgent.Bb ? K.userAgent.re : K.g.userAgent.v.Nd();K.userAgent.Y = K.userAgent.Bb ? K.userAgent.oe : K.g.userAgent.v.uc();
	K.userAgent.Ce = K.userAgent.Bb ? K.userAgent.me : K.g.userAgent.U.Ra();K.userAgent.Um = K.userAgent.Ce || K.userAgent.Y;K.userAgent.Yc = K.userAgent.Bb ? K.userAgent.ne : K.g.userAgent.U.gk();K.userAgent.Cb = K.userAgent.Bb ? K.userAgent.te || K.userAgent.Uc : K.g.userAgent.U.Mg();K.userAgent.kk = function () {
		return K.userAgent.Cb && K.g.userAgent.A.K("Mobile");
	};K.userAgent.Yn = K.userAgent.Uc || K.userAgent.kk();K.userAgent.vo = K.userAgent.Cb;K.userAgent.nj = function () {
		var b = K.userAgent.Yf();return b && b.platform || "";
	};
	K.userAgent.mo = K.userAgent.nj();K.userAgent.qe = !1;K.userAgent.ue = !1;K.userAgent.pe = !1;K.userAgent.ve = !1;K.userAgent.le = !1;K.userAgent.Sc = !1;K.userAgent.Rc = !1;K.userAgent.Tc = !1;K.userAgent.Ca = K.userAgent.qe || K.userAgent.ue || K.userAgent.pe || K.userAgent.ve || K.userAgent.le || K.userAgent.Sc || K.userAgent.Rc || K.userAgent.Tc;K.userAgent.Rn = K.userAgent.Ca ? K.userAgent.qe : K.g.userAgent.platform.Ig();K.userAgent.ep = K.userAgent.Ca ? K.userAgent.ue : K.g.userAgent.platform.Og();
	K.userAgent.hk = function () {
		return K.g.userAgent.platform.ik() || K.g.userAgent.platform.Ag();
	};K.userAgent.Qn = K.userAgent.Ca ? K.userAgent.pe : K.userAgent.hk();K.userAgent.tk = function () {
		var b = K.userAgent.Yf();return !!b && K.f.contains(b.appVersion || "", "X11");
	};K.userAgent.fp = K.userAgent.Ca ? K.userAgent.ve : K.userAgent.tk();K.userAgent.am = K.userAgent.Ca ? K.userAgent.le : K.g.userAgent.platform.yg();K.userAgent.Fn = K.userAgent.Ca ? K.userAgent.Sc : K.g.userAgent.platform.Gg();
	K.userAgent.En = K.userAgent.Ca ? K.userAgent.Rc : K.g.userAgent.platform.Fg();K.userAgent.Gn = K.userAgent.Ca ? K.userAgent.Tc : K.g.userAgent.platform.Hg();K.userAgent.Dn = K.userAgent.Ca ? K.userAgent.Sc || K.userAgent.Rc || K.userAgent.Tc : K.g.userAgent.platform.Eg();K.userAgent.oj = function () {
		var b = "",
		    c = K.userAgent.Sj();c && (b = c ? c[1] : "");return K.userAgent.Y && (c = K.userAgent.Of(), null != c && c > parseFloat(b)) ? String(c) : b;
	};
	K.userAgent.Sj = function () {
		var b = K.userAgent.Qj();if (K.userAgent.Yc) return (/rv\:([^\);]+)(\)|;)/.exec(b)
		);if (K.userAgent.Ce) return (/Edge\/([\d\.]+)/.exec(b)
		);if (K.userAgent.Y) return (/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(b)
		);if (K.userAgent.Cb) return (/WebKit\/(\S+)/.exec(b)
		);if (K.userAgent.Ne) return (/(?:Version)[ \/]?(\S+)/.exec(b)
		);
	};K.userAgent.Of = function () {
		var b = K.global.document;return b ? b.documentMode : void 0;
	};K.userAgent.VERSION = K.userAgent.oj();K.userAgent.compare = function (b, c) {
		return K.f.Eb(b, c);
	};
	K.userAgent.rk = {};K.userAgent.va = function (b) {
		return K.userAgent.Fh || K.Ha.cache(K.userAgent.rk, b, function () {
			return 0 <= K.f.Eb(K.userAgent.VERSION, b);
		});
	};K.userAgent.Yr = K.userAgent.va;K.userAgent.Pb = function (b) {
		return Number(K.userAgent.Wh) >= b;
	};K.userAgent.Br = K.userAgent.Pb;var L;var M = K.global.document,
	    aa = K.userAgent.Of();L = M && K.userAgent.Y ? aa || ("CSS1Compat" == M.compatMode ? parseInt(K.userAgent.VERSION, 10) : 5) : void 0;K.userAgent.Wh = L;K.a.ib = { Lh: !K.userAgent.Y || K.userAgent.Pb(9), Mh: !K.userAgent.Yc && !K.userAgent.Y || K.userAgent.Y && K.userAgent.Pb(9) || K.userAgent.Yc && K.userAgent.va("1.9.1"), xe: K.userAgent.Y && !K.userAgent.va("9"), Nh: K.userAgent.Y || K.userAgent.Ne || K.userAgent.Cb, ci: K.userAgent.Y, Mn: K.userAgent.Y && !K.userAgent.Pb(9) };K.a.Mc = {};K.a.Mc.Hi = { area: !0, base: !0, br: !0, col: !0, command: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 };K.a.Mc.sk = function (b) {
		return !0 === K.a.Mc.Hi[b];
	};K.b.V = function () {
		this.yc = "";this.ni = K.b.V.ca;
	};K.b.V.prototype.ua = !0;K.b.V.ca = {};K.b.V.mc = function (b) {
		b = K.f.I.u(b);return 0 === b.length ? K.b.V.EMPTY : K.b.V.hd(b);
	};K.b.V.prototype.ga = G("yc");K.ea && (K.b.V.prototype.toString = function () {
		return "SafeScript{" + this.yc + "}";
	});K.b.V.u = function (b) {
		if (b instanceof K.b.V && b.constructor === K.b.V && b.ni === K.b.V.ca) return b.yc;K.m.la("expected object of type SafeScript, got '" + b + k + K.aa(b));return "type_error:SafeScript";
	};K.b.V.hd = function (b) {
		return new K.b.V().bb(b);
	};
	K.b.V.prototype.bb = function (b) {
		this.yc = b;return this;
	};K.b.V.EMPTY = K.b.V.hd("");K.sa = {};K.sa.url = {};K.sa.url.dj = function (b) {
		return K.sa.url.lg().createObjectURL(b);
	};K.sa.url.Ss = function (b) {
		K.sa.url.lg().revokeObjectURL(b);
	};K.sa.url.lg = function () {
		var b = K.sa.url.Ef();if (null != b) return b;throw Error("This browser doesn't seem to support blob URLs");
	};K.sa.url.Ef = function () {
		return K.R(K.global.URL) && K.R(K.global.URL.createObjectURL) ? K.global.URL : K.R(K.global.webkitURL) && K.R(K.global.webkitURL.createObjectURL) ? K.global.webkitURL : K.R(K.global.createObjectURL) ? K.global : null;
	};
	K.sa.url.Kp = function () {
		return null != K.sa.url.Ef();
	};K.b.o = function () {
		this.Ga = "";this.ri = K.b.o.ca;
	};K.b.o.Ka = "about:invalid#zClosurez";K.b.o.prototype.ua = !0;K.b.o.prototype.ga = G("Ga");K.b.o.prototype.Dd = !0;K.b.o.prototype.$a = function () {
		return K.h.i.O.Ta;
	};K.ea && (K.b.o.prototype.toString = function () {
		return "SafeUrl{" + this.Ga + "}";
	});K.b.o.u = function (b) {
		if (b instanceof K.b.o && b.constructor === K.b.o && b.ri === K.b.o.ca) return b.Ga;K.m.la("expected object of type SafeUrl, got '" + b + k + K.aa(b));return "type_error:SafeUrl";
	};K.b.o.mc = function (b) {
		return K.b.o.Ea(K.f.I.u(b));
	};
	K.b.Re = /^(?:audio\/(?:3gpp|3gpp2|aac|midi|mp4|mpeg|ogg|x-m4a|x-wav|webm)|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|text\/csv|video\/(?:mpeg|mp4|ogg|webm))$/i;K.b.o.Lq = function (b) {
		b = K.b.Re.test(b.type) ? K.sa.url.dj(b) : K.b.o.Ka;return K.b.o.Ea(b);
	};K.b.Rh = /^data:([^;,]*);base64,[a-z0-9+\/]+=*$/i;K.b.o.Nq = function (b) {
		var c = b.match(K.b.Rh);c = c && K.b.Re.test(c[1]);return K.b.o.Ea(c ? b : K.b.o.Ka);
	};K.b.o.Pq = function (b) {
		K.f.Zi(b) || (b = K.b.o.Ka);return K.b.o.Ea(b);
	};K.b.o.Qq = function (b) {
		return K.b.o.Ea(K.b.C.u(b));
	};
	K.b.Se = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;K.b.o.Gc = function (b) {
		if (b instanceof K.b.o) return b;b = b.ua ? b.ga() : String(b);K.b.Se.test(b) || (b = K.b.o.Ka);return K.b.o.Ea(b);
	};K.b.o.Vb = function (b) {
		if (b instanceof K.b.o) return b;b = b.ua ? b.ga() : String(b);K.b.Se.test(b) || (b = K.b.o.Ka);return K.b.o.Ea(b);
	};K.b.o.ca = {};K.b.o.Ea = function (b) {
		var c = new K.b.o();c.Ga = b;return c;
	};K.b.o.Wl = K.b.o.Ea("about:blank");K.b.B = function () {
		this.Ac = "";this.pi = K.b.B.ca;
	};K.b.B.prototype.ua = !0;K.b.B.ca = {};K.b.B.mc = function (b) {
		b = K.f.I.u(b);return 0 === b.length ? K.b.B.EMPTY : K.b.B.Fb(b);
	};K.b.B.Up = F();K.b.B.prototype.ga = G("Ac");K.ea && (K.b.B.prototype.toString = function () {
		return "SafeStyle{" + this.Ac + "}";
	});K.b.B.u = function (b) {
		if (b instanceof K.b.B && b.constructor === K.b.B && b.pi === K.b.B.ca) return b.Ac;K.m.la("expected object of type SafeStyle, got '" + b + k + K.aa(b));return "type_error:SafeStyle";
	};K.b.B.Fb = function (b) {
		return new K.b.B().bb(b);
	};
	K.b.B.prototype.bb = function (b) {
		this.Ac = b;return this;
	};K.b.B.EMPTY = K.b.B.Fb("");K.b.B.Ka = "zClosurez";K.b.B.create = function (b) {
		var c = "",
		    d;for (d in b) {
			if (!/^[-_a-zA-Z0-9]+$/.test(d)) throw Error("Name allows only [-_a-zA-Z0-9], got: " + d);var e = b[d];null != e && (e = K.isArray(e) ? K.j.map(e, K.b.B.gh).join(" ") : K.b.B.gh(e), c += d + ":" + e + ";");
		}return c ? K.b.B.Fb(c) : K.b.B.EMPTY;
	};
	K.b.B.gh = function (b) {
		return b instanceof K.b.o ? 'url("' + K.b.o.u(b).replace(/</g, "%3c").replace(/[\\"]/g, "\\$&") + '")' : b instanceof K.f.I ? K.f.I.u(b) : K.b.B.il(String(b));
	};K.b.B.il = function (b) {
		var c = b.replace(K.b.o.ai, "$1").replace(K.b.o.Xe, "url");return K.b.B.Ei.test(c) ? K.b.B.Vj(b) ? K.b.B.jl(b) : (K.m.la("String value requires balanced quotes, got: " + b), K.b.B.Ka) : (K.m.la("String value allows only " + K.b.B.$e + " and simple functions, got: " + b), K.b.B.Ka);
	};
	K.b.B.Vj = function (b) {
		for (var c = !0, d = !0, e = 0; e < b.length; e++) {
			var f = b.charAt(e);"'" == f && d ? c = !c : '"' == f && c && (d = !d);
		}return c && d;
	};K.b.B.$e = "[-,.\"'%_!# a-zA-Z0-9]";K.b.B.Ei = new RegExp("^" + K.b.B.$e + "+$");K.b.o.Xe = /\b(url\([ \t\n]*)('[ -&(-\[\]-~]*'|"[ !#-\[\]-~]*"|[!#-&*-\[\]-~]*)([ \t\n]*\))/g;K.b.o.ai = /\b(hsl|hsla|rgb|rgba|(rotate|scale|translate)(X|Y|Z|3d)?)\([-0-9a-z.%, ]+\)/g;
	K.b.B.jl = function (b) {
		return b.replace(K.b.o.Xe, function (b, d, e, f) {
			var c = "";e = e.replace(/^(['"])(.*)\1$/, function (b, d, e) {
				c = d;return e;
			});b = K.b.o.Gc(e).ga();return d + c + b + c + f;
		});
	};K.b.B.concat = function (b) {
		function c(b) {
			K.isArray(b) ? K.j.forEach(b, c) : d += K.b.B.u(b);
		}var d = "";K.j.forEach(arguments, c);return d ? K.b.B.Fb(d) : K.b.B.EMPTY;
	};K.b.N = function () {
		this.zc = "";this.oi = K.b.N.ca;
	};K.b.N.prototype.ua = !0;K.b.N.ca = {};
	K.b.N.jq = function (b, c) {
		if (K.f.contains(b, "<")) throw Error("Selector does not allow '<', got: " + b);var d = b.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g, "");if (!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(d)) throw Error("Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and strings, got: " + b);if (!K.b.N.Uj(d)) throw Error("() and [] in selector must be balanced, got: " + b);c instanceof K.b.B || (c = K.b.B.create(c));b = b + "{" + K.b.B.u(c) + "}";return K.b.N.Gb(b);
	};
	K.b.N.Uj = function (b) {
		for (var c = { "(": ")", "[": "]" }, d = [], e = 0; e < b.length; e++) {
			var f = b[e];if (c[f]) d.push(c[f]);else if (K.object.contains(c, f) && d.pop() != f) return !1;
		}return 0 == d.length;
	};K.b.N.concat = function (b) {
		function c(b) {
			K.isArray(b) ? K.j.forEach(b, c) : d += K.b.N.u(b);
		}var d = "";K.j.forEach(arguments, c);return K.b.N.Gb(d);
	};K.b.N.mc = function (b) {
		b = K.f.I.u(b);return 0 === b.length ? K.b.N.EMPTY : K.b.N.Gb(b);
	};K.b.N.prototype.ga = G("zc");K.ea && (K.b.N.prototype.toString = function () {
		return "SafeStyleSheet{" + this.zc + "}";
	});
	K.b.N.u = function (b) {
		if (b instanceof K.b.N && b.constructor === K.b.N && b.oi === K.b.N.ca) return b.zc;K.m.la("expected object of type SafeStyleSheet, got '" + b + k + K.aa(b));return "type_error:SafeStyleSheet";
	};K.b.N.Gb = function (b) {
		return new K.b.N().bb(b);
	};K.b.N.prototype.bb = function (b) {
		this.zc = b;return this;
	};K.b.N.EMPTY = K.b.N.Gb("");K.b.l = function () {
		this.Ga = "";this.mi = K.b.l.ca;this.kc = null;
	};K.b.l.prototype.Dd = !0;K.b.l.prototype.$a = G("kc");K.b.l.prototype.ua = !0;K.b.l.prototype.ga = G("Ga");K.ea && (K.b.l.prototype.toString = function () {
		return "SafeHtml{" + this.Ga + "}";
	});K.b.l.u = function (b) {
		if (b instanceof K.b.l && b.constructor === K.b.l && b.mi === K.b.l.ca) return b.Ga;K.m.la("expected object of type SafeHtml, got '" + b + k + K.aa(b));return "type_error:SafeHtml";
	};
	K.b.l.ta = function (b) {
		if (b instanceof K.b.l) return b;var c = null;b.Dd && (c = b.$a());return K.b.l.ra(K.f.ta(b.ua ? b.ga() : String(b)), c);
	};K.b.l.or = function (b) {
		if (b instanceof K.b.l) return b;b = K.b.l.ta(b);return K.b.l.ra(K.f.Yg(K.b.l.u(b)), b.$a());
	};K.b.l.pr = function (b) {
		if (b instanceof K.b.l) return b;b = K.b.l.ta(b);return K.b.l.ra(K.f.Ol(K.b.l.u(b)), b.$a());
	};K.b.l.from = K.b.l.ta;K.b.l.Ze = /^[a-zA-Z0-9-]+$/;K.b.l.Ci = { action: !0, cite: !0, data: !0, formaction: !0, href: !0, manifest: !0, poster: !0, src: !0 };
	K.b.l.ii = { APPLET: !0, BASE: !0, EMBED: !0, IFRAME: !0, LINK: !0, MATH: !0, META: !0, OBJECT: !0, SCRIPT: !0, STYLE: !0, SVG: !0, TEMPLATE: !0 };K.b.l.create = function (b, c, d) {
		K.b.l.Ml(String(b));return K.b.l.Ya(String(b), c, d);
	};K.b.l.Ml = function (b) {
		if (!K.b.l.Ze.test(b)) throw Error("Invalid tag name <" + b + ">.");if (b.toUpperCase() in K.b.l.ii) throw Error("Tag name <" + b + "> is not allowed for SafeHtml.");
	};
	K.b.l.gq = function (b, c, d, e) {
		b && K.b.C.u(b);var f = {};f.src = b || null;f.srcdoc = c && K.b.l.u(c);b = K.b.l.hc(f, { sandbox: "" }, d);return K.b.l.Ya("iframe", b, e);
	};K.b.l.kq = function (b, c, d, e) {
		if (!K.b.l.Wi()) throw Error("The browser does not support sandboxed iframes.");var f = {};f.src = b ? K.b.o.u(K.b.o.Gc(b)) : null;f.srcdoc = c || null;f.sandbox = "";b = K.b.l.hc(f, {}, d);return K.b.l.Ya("iframe", b, e);
	};K.b.l.Wi = function () {
		return K.global.HTMLIFrameElement && "sandbox" in K.global.HTMLIFrameElement.prototype;
	};
	K.b.l.mq = function (b, c) {
		K.b.C.u(b);b = K.b.l.hc({ src: b }, {}, c);return K.b.l.Ya("script", b);
	};K.b.l.lq = function (b, c) {
		for (var d in c) {
			var e = d.toLowerCase();if ("language" == e || "src" == e || "text" == e || "type" == e) throw Error('Cannot set "' + e + '" attribute');
		}d = "";b = K.j.concat(b);for (e = 0; e < b.length; e++) {
			d += K.b.V.u(b[e]);
		}b = K.b.l.ra(d, K.h.i.O.qa);return K.b.l.Ya("script", c, b);
	};
	K.b.l.nq = function (b, c) {
		c = K.b.l.hc({ type: "text/css" }, {}, c);var d = "";b = K.j.concat(b);for (var e = 0; e < b.length; e++) {
			d += K.b.N.u(b[e]);
		}b = K.b.l.ra(d, K.h.i.O.qa);return K.b.l.Ya("style", c, b);
	};K.b.l.iq = function (b, c) {
		b = K.b.o.u(K.b.o.Gc(b));(K.g.userAgent.v.uc() || K.g.userAgent.v.Ra()) && K.f.contains(b, ";") && (b = "'" + b.replace(/'/g, "%27") + "'");return K.b.l.Ya("meta", { "http-equiv": "refresh", content: (c || 0) + "; url=" + b });
	};
	K.b.l.Cj = function (b, c, d) {
		if (d instanceof K.f.I) d = K.f.I.u(d);else if ("style" == c.toLowerCase()) d = K.b.l.Oj(d);else {
			if (/^on/i.test(c)) throw Error('Attribute "' + c + '" requires goog.string.Const value, "' + d + '" given.');if (c.toLowerCase() in K.b.l.Ci) if (d instanceof K.b.C) d = K.b.C.u(d);else if (d instanceof K.b.o) d = K.b.o.u(d);else if (K.L(d)) d = K.b.o.Gc(d).ga();else throw Error('Attribute "' + c + '" on tag "' + b + '" requires goog.html.SafeUrl, goog.string.Const, or string, value "' + d + '" given.');
		}d.ua && (d = d.ga());
		return c + '="' + K.f.ta(String(d)) + '"';
	};K.b.l.Oj = function (b) {
		if (!K.ha(b)) throw Error('The "style" attribute requires goog.html.SafeStyle or map of style properties, ' + (typeof b === "undefined" ? "undefined" : _typeof(b)) + " given: " + b);b instanceof K.b.B || (b = K.b.B.create(b));return K.b.B.u(b);
	};K.b.l.pq = function (b, c, d, e) {
		c = K.b.l.create(c, d, e);c.kc = b;return c;
	};
	K.b.l.concat = function (b) {
		function c(b) {
			K.isArray(b) ? K.j.forEach(b, c) : (b = K.b.l.ta(b), e += K.b.l.u(b), b = b.$a(), d == K.h.i.O.qa ? d = b : b != K.h.i.O.qa && d != b && (d = null));
		}var d = K.h.i.O.qa,
		    e = "";K.j.forEach(arguments, c);return K.b.l.ra(e, d);
	};K.b.l.bq = function (b, c) {
		var d = K.b.l.concat(K.j.slice(arguments, 1));d.kc = b;return d;
	};K.b.l.ca = {};K.b.l.ra = function (b, c) {
		return new K.b.l().bb(b, c);
	};K.b.l.prototype.bb = function (b, c) {
		this.Ga = b;this.kc = c;return this;
	};
	K.b.l.Ya = function (b, c, d) {
		var e = null;var f = "<" + b + K.b.l.vl(b, c);K.cb(d) ? K.isArray(d) || (d = [d]) : d = [];K.a.Mc.sk(b.toLowerCase()) ? f += ">" : (e = K.b.l.concat(d), f += ">" + K.b.l.u(e) + "</" + b + ">", e = e.$a());(b = c && c.dir) && (e = /^(ltr|rtl|auto)$/i.test(b) ? K.h.i.O.qa : null);return K.b.l.ra(f, e);
	};K.b.l.vl = function (b, c) {
		var d = "";if (c) for (var e in c) {
			if (!K.b.l.Ze.test(e)) throw Error('Invalid attribute name "' + e + '".');var f = c[e];K.cb(f) && (d += " " + K.b.l.Cj(b, e, f));
		}return d;
	};
	K.b.l.hc = function (b, c, d) {
		var e = {},
		    f;for (f in b) {
			e[f] = b[f];
		}for (f in c) {
			e[f] = c[f];
		}for (f in d) {
			var g = f.toLowerCase();if (g in b) throw Error('Cannot override "' + g + '" attribute, got "' + f + '" with value "' + d[f] + '"');g in c && delete e[g];e[f] = d[f];
		}return e;
	};K.b.l.Qm = K.b.l.ra("<!DOCTYPE html>", K.h.i.O.qa);K.b.l.EMPTY = K.b.l.ra("", K.h.i.O.qa);K.b.l.we = K.b.l.ra("<br>", K.h.i.O.qa);K.a.S = {};K.a.S.In = { Zl: "afterbegin", $l: "afterend", om: "beforebegin", pm: "beforeend" };K.a.S.rr = function (b, c, d) {
		b.insertAdjacentHTML(c, K.b.l.u(d));
	};K.a.S.ui = { MATH: !0, SCRIPT: !0, STYLE: !0, SVG: !0, TEMPLATE: !0 };K.a.S.lh = function (b, c) {
		if (K.m.na && K.a.S.ui[b.tagName.toUpperCase()]) throw Error("goog.dom.safe.setInnerHtml cannot be used to set content of " + b.tagName + ".");b.innerHTML = K.b.l.u(c);
	};K.a.S.nt = function (b, c) {
		b.outerHTML = K.b.l.u(c);
	};K.a.S.pt = function (b, c) {
		b.style.cssText = K.b.B.u(c);
	};K.a.S.vq = function (b, c) {
		b.write(K.b.l.u(c));
	};
	K.a.S.$s = function (b, c) {
		c = c instanceof K.b.o ? c : K.b.o.Vb(c);b.href = K.b.o.u(c);
	};K.a.S.jt = function (b, c) {
		c = c instanceof K.b.o ? c : K.b.o.Vb(c);b.src = K.b.o.u(c);
	};K.a.S.dt = function (b, c) {
		b.src = K.b.C.u(c);
	};K.a.S.ft = function (b, c) {
		b.src = K.b.C.u(c);
	};K.a.S.ht = function (b, c) {
		b.src = K.b.C.u(c);
	};K.a.S.it = function (b, c) {
		b.srcdoc = K.b.l.u(c);
	};K.a.S.kt = function (b, c, d) {
		b.rel = d;K.f.kf(d, "stylesheet") ? b.href = K.b.C.u(c) : b.href = c instanceof K.b.C ? K.b.C.u(c) : c instanceof K.b.o ? K.b.o.u(c) : K.b.o.Vb(c).ga();
	};
	K.a.S.mt = function (b, c) {
		b.data = K.b.C.u(c);
	};K.a.S.ol = function (b, c) {
		b.src = K.b.C.u(c);
	};K.a.S.ot = function (b, c) {
		b.text = K.b.V.u(c);
	};K.a.S.lt = function (b, c) {
		c = c instanceof K.b.o ? c : K.b.o.Vb(c);b.href = K.b.o.u(c);
	};K.a.S.ys = function (b, c, d, e, f) {
		b = b instanceof K.b.o ? b : K.b.o.Vb(b);return (c || window).open(K.b.o.u(b), d ? K.f.I.u(d) : "", e, f);
	};K.b.hb = {};K.b.hb.fl = function (b, c) {
		return K.b.l.ra(c, null);
	};K.b.hb.Ws = function (b, c) {
		return K.b.V.hd(c);
	};K.b.hb.Xs = function (b, c) {
		return K.b.B.Fb(c);
	};K.b.hb.Ys = function (b, c) {
		return K.b.N.Gb(c);
	};K.b.hb.Zs = function (b, c) {
		return K.b.o.Ea(c);
	};K.b.hb.Nt = function (b, c) {
		return K.b.C.Hb(c);
	};K.s = {};K.s.Es = function (b) {
		return Math.floor(Math.random() * b);
	};K.s.Pt = function (b, c) {
		return b + Math.random() * (c - b);
	};K.s.Vp = function (b, c, d) {
		return Math.min(Math.max(b, c), d);
	};K.s.Vg = function (b, c) {
		b %= c;return 0 > b * c ? b + c : b;
	};K.s.as = function (b, c, d) {
		return b + d * (c - b);
	};K.s.os = function (b, c, d) {
		return Math.abs(b - c) <= (d || 1E-6);
	};K.s.fe = function (b) {
		return K.s.Vg(b, 360);
	};K.s.zt = function (b) {
		return K.s.Vg(b, 2 * Math.PI);
	};K.s.uh = function (b) {
		return b * Math.PI / 180;
	};K.s.zl = function (b) {
		return 180 * b / Math.PI;
	};
	K.s.mp = function (b, c) {
		return c * Math.cos(K.s.uh(b));
	};K.s.np = function (b, c) {
		return c * Math.sin(K.s.uh(b));
	};K.s.angle = function (b, c, d, e) {
		return K.s.fe(K.s.zl(Math.atan2(e - c, d - b)));
	};K.s.lp = function (b, c) {
		b = K.s.fe(c) - K.s.fe(b);180 < b ? b -= 360 : -180 >= b && (b = 360 + b);return b;
	};K.s.sign = function (b) {
		return 0 < b ? 1 : 0 > b ? -1 : b;
	};
	K.s.fs = function (b, c, d, e) {
		d = d || function (b, c) {
			return b == c;
		};e = e || function (c) {
			return b[c];
		};for (var f = b.length, g = c.length, h = [], l = 0; l < f + 1; l++) {
			h[l] = [], h[l][0] = 0;
		}for (var m = 0; m < g + 1; m++) {
			h[0][m] = 0;
		}for (l = 1; l <= f; l++) {
			for (m = 1; m <= g; m++) {
				d(b[l - 1], c[m - 1]) ? h[l][m] = h[l - 1][m - 1] + 1 : h[l][m] = Math.max(h[l - 1][m], h[l][m - 1]);
			}
		}var q = [];l = f;for (m = g; 0 < l && 0 < m;) {
			d(b[l - 1], c[m - 1]) ? (q.unshift(e(l - 1, m - 1)), l--, m--) : h[l - 1][m] > h[l][m - 1] ? l-- : m--;
		}return q;
	};K.s.ge = function (b) {
		return K.j.reduce(arguments, function (b, d) {
			return b + d;
		}, 0);
	};
	K.s.Pi = function (b) {
		return K.s.ge.apply(null, arguments) / arguments.length;
	};K.s.hl = function (b) {
		var c = arguments.length;if (2 > c) return 0;var d = K.s.Pi.apply(null, arguments);return K.s.ge.apply(null, K.j.map(arguments, function (b) {
			return Math.pow(b - d, 2);
		})) / (c - 1);
	};K.s.At = function (b) {
		return Math.sqrt(K.s.hl.apply(null, arguments));
	};K.s.Gr = function (b) {
		return isFinite(b) && 0 == b % 1;
	};K.s.Er = function (b) {
		return isFinite(b);
	};K.s.Lr = function (b) {
		return 0 == b && 0 > 1 / b;
	};
	K.s.es = function (b) {
		if (0 < b) {
			var c = Math.round(Math.log(b) * Math.LOG10E);return c - (parseFloat("1e" + c) > b ? 1 : 0);
		}return 0 == b ? -Infinity : NaN;
	};K.s.Us = function (b, c) {
		return Math.floor(b + (c || 2E-15));
	};K.s.Ts = function (b, c) {
		return Math.ceil(b - (c || 2E-15));
	};K.s.W = function (b, c) {
		this.x = K.R(b) ? b : 0;this.y = K.R(c) ? c : 0;
	};K.s.W.prototype.clone = function () {
		return new K.s.W(this.x, this.y);
	};K.ea && (K.s.W.prototype.toString = function () {
		return "(" + this.x + ", " + this.y + ")";
	});K.s.W.prototype.Ib = function (b) {
		return b instanceof K.s.W && K.s.W.Ib(this, b);
	};K.s.W.Ib = function (b, c) {
		return b == c ? !0 : b && c ? b.x == c.x && b.y == c.y : !1;
	};K.s.W.uq = function (b, c) {
		var d = b.x - c.x;b = b.y - c.y;return Math.sqrt(d * d + b * b);
	};K.s.W.gs = function (b) {
		return Math.sqrt(b.x * b.x + b.y * b.y);
	};
	K.s.W.azimuth = function (b) {
		return K.s.angle(0, 0, b.x, b.y);
	};K.s.W.xt = function (b, c) {
		var d = b.x - c.x;b = b.y - c.y;return d * d + b * b;
	};K.s.W.tq = function (b, c) {
		return new K.s.W(b.x - c.x, b.y - c.y);
	};K.s.W.ge = function (b, c) {
		return new K.s.W(b.x + c.x, b.y + c.y);
	};I = K.s.W.prototype;I.ceil = function () {
		this.x = Math.ceil(this.x);this.y = Math.ceil(this.y);return this;
	};I.floor = function () {
		this.x = Math.floor(this.x);this.y = Math.floor(this.y);return this;
	};I.round = function () {
		this.x = Math.round(this.x);this.y = Math.round(this.y);return this;
	};
	I.translate = function (b, c) {
		b instanceof K.s.W ? (this.x += b.x, this.y += b.y) : (this.x += Number(b), K.Rb(c) && (this.y += c));return this;
	};I.scale = function (b, c) {
		c = K.Rb(c) ? c : b;this.x *= b;this.y *= c;return this;
	};K.s.nb = function (b, c) {
		this.width = b;this.height = c;
	};K.s.nb.Ib = function (b, c) {
		return b == c ? !0 : b && c ? b.width == c.width && b.height == c.height : !1;
	};K.s.nb.prototype.clone = function () {
		return new K.s.nb(this.width, this.height);
	};K.ea && (K.s.nb.prototype.toString = function () {
		return "(" + this.width + " x " + this.height + ")";
	});I = K.s.nb.prototype;I.Li = function () {
		return this.width * this.height;
	};I.aspectRatio = function () {
		return this.width / this.height;
	};I.Qb = function () {
		return !this.Li();
	};
	I.ceil = function () {
		this.width = Math.ceil(this.width);this.height = Math.ceil(this.height);return this;
	};I.floor = function () {
		this.width = Math.floor(this.width);this.height = Math.floor(this.height);return this;
	};I.round = function () {
		this.width = Math.round(this.width);this.height = Math.round(this.height);return this;
	};I.scale = function (b, c) {
		c = K.Rb(c) ? c : b;this.width *= b;this.height *= c;return this;
	};K.a.Hh = !1;K.a.se = !1;K.a.Qh = K.a.Hh || K.a.se;K.a.td = function (b) {
		return b ? new K.a.lb(K.a.Qa(b)) : K.a.mj || (K.a.mj = new K.a.lb());
	};K.a.Dj = function () {
		return document;
	};K.a.ud = function (b) {
		return K.a.xd(document, b);
	};K.a.xd = function (b, c) {
		return K.L(c) ? b.getElementById(c) : c;
	};K.a.Lj = function (b) {
		return K.a.ig(document, b);
	};K.a.ig = function (b, c) {
		return K.a.xd(b, c);
	};K.a.Bh = K.a.ud;K.a.getElementsByTagName = function (b, c) {
		return (c || document).getElementsByTagName(String(b));
	};
	K.a.yd = function (b, c, d) {
		return K.a.nc(document, b, c, d);
	};K.a.Gj = function (b, c, d) {
		return K.a.wd(document, b, c, d);
	};K.a.Rf = function (b, c) {
		var d = c || document;return K.a.cd(d) ? d.querySelectorAll("." + b) : K.a.nc(document, "*", b, c);
	};K.a.vd = function (b, c) {
		var d = c || document;return (d.getElementsByClassName ? d.getElementsByClassName(b)[0] : K.a.wd(document, "*", b, c)) || null;
	};K.a.hg = function (b, c) {
		return K.a.vd(b, c);
	};K.a.cd = function (b) {
		return !(!b.querySelectorAll || !b.querySelector);
	};
	K.a.nc = function (b, c, d, e) {
		b = e || b;c = c && "*" != c ? String(c).toUpperCase() : "";if (K.a.cd(b) && (c || d)) return b.querySelectorAll(c + (d ? "." + d : ""));if (d && b.getElementsByClassName) {
			b = b.getElementsByClassName(d);if (c) {
				e = {};for (var f = 0, g = 0, h; h = b[g]; g++) {
					c == h.nodeName && (e[f++] = h);
				}e.length = f;return e;
			}return b;
		}b = b.getElementsByTagName(c || "*");if (d) {
			e = {};for (g = f = 0; h = b[g]; g++) {
				c = h.className, _typeof(c.split) == u && K.j.contains(c.split(/\s+/), d) && (e[f++] = h);
			}e.length = f;return e;
		}return b;
	};
	K.a.wd = function (b, c, d, e) {
		var f = e || b,
		    g = c && "*" != c ? String(c).toUpperCase() : "";return K.a.cd(f) && (g || d) ? f.querySelector(g + (d ? "." + d : "")) : K.a.nc(b, c, d, e)[0] || null;
	};K.a.Ch = K.a.yd;K.a.Jc = function (b, c) {
		K.object.forEach(c, function (c, e) {
			c && c.ua && (c = c.ga());"style" == e ? b.style.cssText = c : "class" == e ? b.className = c : "for" == e ? b.htmlFor = c : K.a.Be.hasOwnProperty(e) ? b.setAttribute(K.a.Be[e], c) : K.f.startsWith(e, "aria-") || K.f.startsWith(e, "data-") ? b.setAttribute(e, c) : b[e] = c;
		});
	};
	K.a.Be = { cellpadding: "cellPadding", cellspacing: "cellSpacing", colspan: "colSpan", frameborder: "frameBorder", height: "height", maxlength: "maxLength", nonce: "nonce", role: "role", rowspan: "rowSpan", type: "type", usemap: "useMap", valign: "vAlign", width: "width" };K.a.mg = function (b) {
		return K.a.ng(b || window);
	};K.a.ng = function (b) {
		b = b.document;b = K.a.Ob(b) ? b.documentElement : b.body;return new K.s.nb(b.clientWidth, b.clientHeight);
	};K.a.Ej = function () {
		return K.a.rd(window);
	};K.a.Wq = function (b) {
		return K.a.rd(b);
	};
	K.a.rd = function (b) {
		var c = b.document,
		    d = 0;if (c) {
			d = c.body;var e = c.documentElement;if (!e || !d) return 0;b = K.a.ng(b).height;if (K.a.Ob(c) && e.scrollHeight) d = e.scrollHeight != b ? e.scrollHeight : e.offsetHeight;else {
				c = e.scrollHeight;var f = e.offsetHeight;e.clientHeight != f && (c = d.scrollHeight, f = d.offsetHeight);d = c > b ? c > f ? c : f : c < f ? c : f;
			}
		}return d;
	};K.a.cr = function (b) {
		return K.a.td((b || K.global || window).document).Pf();
	};K.a.Pf = function () {
		return K.a.Qf(document);
	};
	K.a.Qf = function (b) {
		var c = K.a.sd(b);b = K.a.qc(b);return K.userAgent.Y && K.userAgent.va("10") && b.pageYOffset != c.scrollTop ? new K.s.W(c.scrollLeft, c.scrollTop) : new K.s.W(b.pageXOffset || c.scrollLeft, b.pageYOffset || c.scrollTop);
	};K.a.Fj = function () {
		return K.a.sd(document);
	};K.a.sd = function (b) {
		return b.scrollingElement ? b.scrollingElement : !K.userAgent.Cb && K.a.Ob(b) ? b.documentElement : b.body || b.documentElement;
	};K.a.tb = function (b) {
		return b ? K.a.qc(b) : window;
	};K.a.qc = function (b) {
		return b.parentWindow || b.defaultView;
	};
	K.a.fd = function (b, c, d) {
		return K.a.sf(document, arguments);
	};K.a.sf = function (b, c) {
		var d = String(c[0]),
		    e = c[1];if (!K.a.ib.Lh && e && (e.name || e.type)) {
			d = ["<", d];e.name && d.push(' name="', K.f.ta(e.name), '"');if (e.type) {
				d.push(' type="', K.f.ta(e.type), '"');var f = {};K.object.extend(f, e);delete f.type;e = f;
			}d.push(">");d = d.join("");
		}d = b.createElement(d);e && (K.L(e) ? d.className = e : K.isArray(e) ? d.className = e.join(" ") : K.a.Jc(d, e));2 < c.length && K.a.bf(b, d, c, 2);return d;
	};
	K.a.bf = function (b, c, d, e) {
		function f(d) {
			d && c.appendChild(K.L(d) ? b.createTextNode(d) : d);
		}for (; e < d.length; e++) {
			var g = d[e];K.Nb(g) && !K.a.Ld(g) ? K.j.forEach(K.a.Md(g) ? K.j.th(g) : g, f) : f(g);
		}
	};K.a.Dh = K.a.fd;K.a.createElement = function (b) {
		return K.a.Oa(document, b);
	};K.a.Oa = function (b, c) {
		return b.createElement(String(c));
	};K.a.createTextNode = function (b) {
		return document.createTextNode(String(b));
	};K.a.hj = function (b, c, d) {
		return K.a.tf(document, b, c, !!d);
	};
	K.a.tf = function (b, c, d, e) {
		for (var f = K.a.Oa(b, "TABLE"), g = f.appendChild(K.a.Oa(b, "TBODY")), h = 0; h < c; h++) {
			for (var l = K.a.Oa(b, "TR"), m = 0; m < d; m++) {
				var q = K.a.Oa(b, "TD");e && K.a.ae(q, K.f.Ye.Ke);l.appendChild(q);
			}g.appendChild(l);
		}return f;
	};K.a.cq = function (b) {
		var c = K.j.map(arguments, K.f.I.u);c = K.b.hb.fl(K.f.I.from("Constant HTML string, that gets turned into a Node later, so it will be automatically balanced."), c.join(""));return K.a.eh(c);
	};K.a.eh = function (b) {
		return K.a.fh(document, b);
	};
	K.a.fh = function (b, c) {
		var d = K.a.Oa(b, "DIV");K.a.ib.ci ? (K.a.S.lh(d, K.b.l.concat(K.b.l.we, c)), d.removeChild(d.firstChild)) : K.a.S.lh(d, c);return K.a.$i(b, d);
	};K.a.$i = function (b, c) {
		if (1 == c.childNodes.length) return c.removeChild(c.firstChild);for (b = b.createDocumentFragment(); c.firstChild;) {
			b.appendChild(c.firstChild);
		}return b;
	};K.a.dk = function () {
		return K.a.Ob(document);
	};K.a.Ob = function (b) {
		return K.a.Qh ? K.a.se : "CSS1Compat" == b.compatMode;
	};K.a.canHaveChildren = function (b) {
		if (b.nodeType != K.a.fa.Ia) return !1;switch (b.tagName) {case "APPLET":case "AREA":case "BASE":case "BR":case "COL":case "COMMAND":case "EMBED":case "FRAME":case "HR":case "IMG":case "INPUT":case "IFRAME":case "ISINDEX":case "KEYGEN":case "LINK":case "NOFRAMES":case "NOSCRIPT":case "META":case "OBJECT":case "PARAM":case p:case "SOURCE":case "STYLE":case "TRACK":case "WBR":
				return !1;}return !0;
	};
	K.a.appendChild = function (b, c) {
		b.appendChild(c);
	};K.a.append = function (b, c) {
		K.a.bf(K.a.Qa(b), b, arguments, 1);
	};K.a.Zd = function (b) {
		for (var c; c = b.firstChild;) {
			b.removeChild(c);
		}
	};K.a.vg = function (b, c) {
		c.parentNode && c.parentNode.insertBefore(b, c);
	};K.a.ug = function (b, c) {
		c.parentNode && c.parentNode.insertBefore(b, c.nextSibling);
	};K.a.tg = function (b, c, d) {
		b.insertBefore(c, b.childNodes[d] || null);
	};K.a.removeNode = function (b) {
		return b && b.parentNode ? b.parentNode.removeChild(b) : null;
	};
	K.a.dh = function (b, c) {
		var d = c.parentNode;d && d.replaceChild(b, c);
	};K.a.Ff = function (b) {
		var c,
		    d = b.parentNode;if (d && d.nodeType != K.a.fa.Vh) {
			if (b.removeNode) return b.removeNode(!1);for (; c = b.firstChild;) {
				d.insertBefore(c, b);
			}return K.a.removeNode(b);
		}
	};K.a.Nf = function (b) {
		return K.a.ib.Mh && void 0 != b.children ? b.children : K.j.filter(b.childNodes, function (b) {
			return b.nodeType == K.a.fa.Ia;
		});
	};K.a.Sf = function (b) {
		return K.R(b.firstElementChild) ? b.firstElementChild : K.a.oc(b.firstChild, !0);
	};
	K.a.Wf = function (b) {
		return K.R(b.lastElementChild) ? b.lastElementChild : K.a.oc(b.lastChild, !1);
	};K.a.Zf = function (b) {
		return K.R(b.nextElementSibling) ? b.nextElementSibling : K.a.oc(b.nextSibling, !0);
	};K.a.fg = function (b) {
		return K.R(b.previousElementSibling) ? b.previousElementSibling : K.a.oc(b.previousSibling, !1);
	};K.a.oc = function (b, c) {
		for (; b && b.nodeType != K.a.fa.Ia;) {
			b = c ? b.nextSibling : b.previousSibling;
		}return b;
	};
	K.a.$f = function (b) {
		if (!b) return null;if (b.firstChild) return b.firstChild;for (; b && !b.nextSibling;) {
			b = b.parentNode;
		}return b ? b.nextSibling : null;
	};K.a.gg = function (b) {
		if (!b) return null;if (!b.previousSibling) return b.parentNode;for (b = b.previousSibling; b && b.lastChild;) {
			b = b.lastChild;
		}return b;
	};K.a.Ld = function (b) {
		return K.ha(b) && 0 < b.nodeType;
	};K.a.Hd = function (b) {
		return K.ha(b) && b.nodeType == K.a.fa.Ia;
	};K.a.Ng = function (b) {
		return K.ha(b) && b.window == b;
	};
	K.a.eg = function (b) {
		var c;if (K.a.ib.Nh && !(K.userAgent.Y && K.userAgent.va("9") && !K.userAgent.va("10") && K.global.SVGElement && b instanceof K.global.SVGElement) && (c = b.parentElement)) return c;c = b.parentNode;return K.a.Hd(c) ? c : null;
	};K.a.contains = function (b, c) {
		if (!b || !c) return !1;if (b.contains && c.nodeType == K.a.fa.Ia) return b == c || b.contains(c);if ("undefined" != typeof b.compareDocumentPosition) return b == c || !!(b.compareDocumentPosition(c) & 16);for (; c && b != c;) {
			c = c.parentNode;
		}return c == b;
	};
	K.a.mf = function (b, c) {
		if (b == c) return 0;if (b.compareDocumentPosition) return b.compareDocumentPosition(c) & 2 ? 1 : -1;if (K.userAgent.Y && !K.userAgent.Pb(9)) {
			if (b.nodeType == K.a.fa.Xc) return -1;if (c.nodeType == K.a.fa.Xc) return 1;
		}if ("sourceIndex" in b || b.parentNode && "sourceIndex" in b.parentNode) {
			var d = b.nodeType == K.a.fa.Ia,
			    e = c.nodeType == K.a.fa.Ia;if (d && e) return b.sourceIndex - c.sourceIndex;var f = b.parentNode,
			    g = c.parentNode;return f == g ? K.a.pf(b, c) : !d && K.a.contains(f, c) ? -1 * K.a.nf(b, c) : !e && K.a.contains(g, b) ? K.a.nf(c, b) : (d ? b.sourceIndex : f.sourceIndex) - (e ? c.sourceIndex : g.sourceIndex);
		}e = K.a.Qa(b);d = e.createRange();d.selectNode(b);d.collapse(!0);b = e.createRange();b.selectNode(c);b.collapse(!0);return d.compareBoundaryPoints(K.global.Range.START_TO_END, b);
	};K.a.nf = function (b, c) {
		var d = b.parentNode;if (d == c) return -1;for (; c.parentNode != d;) {
			c = c.parentNode;
		}return K.a.pf(c, b);
	};K.a.pf = function (b, c) {
		for (; c = c.previousSibling;) {
			if (c == b) return -1;
		}return 1;
	};
	K.a.Bf = function (b) {
		var c,
		    d = arguments.length;if (!d) return null;if (1 == d) return arguments[0];var e = [],
		    f = Infinity;for (c = 0; c < d; c++) {
			for (var g = [], h = arguments[c]; h;) {
				g.unshift(h), h = h.parentNode;
			}e.push(g);f = Math.min(f, g.length);
		}g = null;for (c = 0; c < f; c++) {
			h = e[0][c];for (var l = 1; l < d; l++) {
				if (h != e[l][c]) return g;
			}g = h;
		}return g;
	};K.a.Qa = function (b) {
		return b.nodeType == K.a.fa.Xc ? b : b.ownerDocument || b.document;
	};K.a.Tf = function (b) {
		return b.contentDocument || b.contentWindow.document;
	};
	K.a.Uf = function (b) {
		try {
			return b.contentWindow || (b.contentDocument ? K.a.tb(b.contentDocument) : null);
		} catch (c) {}return null;
	};K.a.ae = function (b, c) {
		if ("textContent" in b) b.textContent = c;else if (b.nodeType == K.a.fa.cc) b.data = String(c);else if (b.firstChild && b.firstChild.nodeType == K.a.fa.cc) {
			for (; b.lastChild != b.firstChild;) {
				b.removeChild(b.lastChild);
			}b.firstChild.data = String(c);
		} else {
			K.a.Zd(b);var d = K.a.Qa(b);b.appendChild(d.createTextNode(String(c)));
		}
	};
	K.a.dg = function (b) {
		if ("outerHTML" in b) return b.outerHTML;var c = K.a.Qa(b);c = K.a.Oa(c, "DIV");c.appendChild(b.cloneNode(!0));return c.innerHTML;
	};K.a.Cf = function (b, c) {
		var d = [];return K.a.nd(b, c, d, !0) ? d[0] : void 0;
	};K.a.Df = function (b, c) {
		var d = [];K.a.nd(b, c, d, !1);return d;
	};K.a.nd = function (b, c, d, e) {
		if (null != b) for (b = b.firstChild; b;) {
			if (c(b) && (d.push(b), e) || K.a.nd(b, c, d, e)) return !0;b = b.nextSibling;
		}return !1;
	};K.a.Ue = { SCRIPT: 1, STYLE: 1, HEAD: 1, IFRAME: 1, OBJECT: 1 };K.a.ac = { IMG: " ", BR: "\n" };
	K.a.Jd = function (b) {
		return K.a.pg(b) && K.a.Lg(b);
	};K.a.jh = function (b, c) {
		c ? b.tabIndex = 0 : (b.tabIndex = -1, b.removeAttribute("tabIndex"));
	};K.a.Cg = function (b) {
		var c;return (c = K.a.Qk(b) ? !b.disabled && (!K.a.pg(b) || K.a.Lg(b)) : K.a.Jd(b)) && K.userAgent.Y ? K.a.Wj(b) : c;
	};K.a.pg = function (b) {
		return K.userAgent.Y && !K.userAgent.va("9") ? (b = b.getAttributeNode("tabindex"), K.cb(b) && b.specified) : b.hasAttribute("tabindex");
	};K.a.Lg = function (b) {
		b = b.tabIndex;return K.Rb(b) && 0 <= b && 32768 > b;
	};
	K.a.Qk = function (b) {
		return "A" == b.tagName || "INPUT" == b.tagName || "TEXTAREA" == b.tagName || "SELECT" == b.tagName || "BUTTON" == b.tagName;
	};K.a.Wj = function (b) {
		b = !K.xa(b.getBoundingClientRect) || K.userAgent.Y && null == b.parentElement ? { height: b.offsetHeight, width: b.offsetWidth } : b.getBoundingClientRect();return K.cb(b) && 0 < b.height && 0 < b.width;
	};
	K.a.pc = function (b) {
		if (K.a.ib.xe && null !== b && "innerText" in b) b = K.f.Yi(b.innerText);else {
			var c = [];K.a.Ad(b, c, !0);b = c.join("");
		}b = b.replace(/ \xAD /g, " ").replace(/\xAD/g, "");b = b.replace(/\u200B/g, "");K.a.ib.xe || (b = b.replace(/ +/g, " "));" " != b && (b = b.replace(/^\s*/, ""));return b;
	};K.a.fr = function (b) {
		var c = [];K.a.Ad(b, c, !1);return c.join("");
	};
	K.a.Ad = function (b, c, d) {
		if (!(b.nodeName in K.a.Ue)) if (b.nodeType == K.a.fa.cc) d ? c.push(String(b.nodeValue).replace(/(\r\n|\r|\n)/g, "")) : c.push(b.nodeValue);else if (b.nodeName in K.a.ac) c.push(K.a.ac[b.nodeName]);else for (b = b.firstChild; b;) {
			K.a.Ad(b, c, d), b = b.nextSibling;
		}
	};K.a.bg = function (b) {
		return K.a.pc(b).length;
	};K.a.cg = function (b, c) {
		c = c || K.a.Qa(b).body;for (var d = []; b && b != c;) {
			for (var e = b; e = e.previousSibling;) {
				d.unshift(K.a.pc(e));
			}b = b.parentNode;
		}return K.f.trimLeft(d.join("")).replace(/ +/g, " ").length;
	};
	K.a.ag = function (b, c, d) {
		b = [b];for (var e = 0, f = null; 0 < b.length && e < c;) {
			if (f = b.pop(), !(f.nodeName in K.a.Ue)) if (f.nodeType == K.a.fa.cc) {
				var g = f.nodeValue.replace(/(\r\n|\r|\n)/g, "").replace(/ +/g, " ");e += g.length;
			} else if (f.nodeName in K.a.ac) e += K.a.ac[f.nodeName].length;else for (g = f.childNodes.length - 1; 0 <= g; g--) {
				b.push(f.childNodes[g]);
			}
		}K.ha(d) && (d.Hs = f ? f.nodeValue.length + c - e - 1 : 0, d.node = f);return f;
	};
	K.a.Md = function (b) {
		if (b && _typeof(b.length) == x) {
			if (K.ha(b)) return _typeof(b.item) == u || _typeof(b.item) == B;if (K.xa(b)) return _typeof(b.item) == u;
		}return !1;
	};K.a.qd = function (b, c, d, e) {
		if (!c && !d) return null;var f = c ? String(c).toUpperCase() : null;return K.a.pd(b, function (b) {
			return (!f || b.nodeName == f) && (!d || K.L(b.className) && K.j.contains(b.className.split(/\s+/), d));
		}, !0, e);
	};K.a.Kf = function (b, c, d) {
		return K.a.qd(b, null, c, d);
	};
	K.a.pd = function (b, c, d, e) {
		b && !d && (b = b.parentNode);for (d = 0; b && (null == e || d <= e);) {
			if (c(b)) return b;b = b.parentNode;d++;
		}return null;
	};K.a.Jf = function (b) {
		try {
			return b && b.activeElement;
		} catch (c) {}return null;
	};K.a.dr = function () {
		var b = K.a.tb();return K.R(b.devicePixelRatio) ? b.devicePixelRatio : b.matchMedia ? K.a.wc(3) || K.a.wc(2) || K.a.wc(1.5) || K.a.wc(1) || .75 : 1;
	};
	K.a.wc = function (b) {
		return K.a.tb().matchMedia("(min-resolution: " + b + "dppx),(min--moz-device-pixel-ratio: " + b + "),(min-resolution: " + 96 * b + "dpi)").matches ? b : 0;
	};K.a.Mf = function (b) {
		return b.getContext("2d");
	};K.a.lb = function (b) {
		this.X = b || K.global.document || document;
	};I = K.a.lb.prototype;I.td = K.a.td;I.Dj = G("X");I.ud = function (b) {
		return K.a.xd(this.X, b);
	};I.Lj = function (b) {
		return K.a.ig(this.X, b);
	};I.Bh = K.a.lb.prototype.ud;I.getElementsByTagName = function (b, c) {
		return (c || this.X).getElementsByTagName(String(b));
	};
	I.yd = function (b, c, d) {
		return K.a.nc(this.X, b, c, d);
	};I.Gj = function (b, c, d) {
		return K.a.wd(this.X, b, c, d);
	};I.Rf = function (b, c) {
		return K.a.Rf(b, c || this.X);
	};I.vd = function (b, c) {
		return K.a.vd(b, c || this.X);
	};I.hg = function (b, c) {
		return K.a.hg(b, c || this.X);
	};I.Ch = K.a.lb.prototype.yd;I.Jc = K.a.Jc;I.mg = function (b) {
		return K.a.mg(b || this.tb());
	};I.Ej = function () {
		return K.a.rd(this.tb());
	};I.fd = function (b, c, d) {
		return K.a.sf(this.X, arguments);
	};I.Dh = K.a.lb.prototype.fd;I.createElement = function (b) {
		return K.a.Oa(this.X, b);
	};
	I.createTextNode = function (b) {
		return this.X.createTextNode(String(b));
	};I.hj = function (b, c, d) {
		return K.a.tf(this.X, b, c, !!d);
	};I.eh = function (b) {
		return K.a.fh(this.X, b);
	};I.dk = function () {
		return K.a.Ob(this.X);
	};I.tb = function () {
		return K.a.qc(this.X);
	};I.Fj = function () {
		return K.a.sd(this.X);
	};I.Pf = function () {
		return K.a.Qf(this.X);
	};I.Jf = function (b) {
		return K.a.Jf(b || this.X);
	};I.appendChild = K.a.appendChild;I.append = K.a.append;I.canHaveChildren = K.a.canHaveChildren;I.Zd = K.a.Zd;I.vg = K.a.vg;I.ug = K.a.ug;I.tg = K.a.tg;
	I.removeNode = K.a.removeNode;I.dh = K.a.dh;I.Ff = K.a.Ff;I.Nf = K.a.Nf;I.Sf = K.a.Sf;I.Wf = K.a.Wf;I.Zf = K.a.Zf;I.fg = K.a.fg;I.$f = K.a.$f;I.gg = K.a.gg;I.Ld = K.a.Ld;I.Hd = K.a.Hd;I.Ng = K.a.Ng;I.eg = K.a.eg;I.contains = K.a.contains;I.mf = K.a.mf;I.Bf = K.a.Bf;I.Qa = K.a.Qa;I.Tf = K.a.Tf;I.Uf = K.a.Uf;I.ae = K.a.ae;I.dg = K.a.dg;I.Cf = K.a.Cf;I.Df = K.a.Df;I.Jd = K.a.Jd;I.jh = K.a.jh;I.Cg = K.a.Cg;I.pc = K.a.pc;I.bg = K.a.bg;I.cg = K.a.cg;I.ag = K.a.ag;I.Md = K.a.Md;I.qd = K.a.qd;I.Kf = K.a.Kf;I.pd = K.a.pd;I.Mf = K.a.Mf;K.bh = {};K.bh.to = F();K.Thenable = F();K.Thenable.prototype.then = F();K.Thenable.He = "$goog_Thenable";K.Thenable.af = function (b) {
		b.prototype.then = b.prototype.then;b.prototype[K.Thenable.He] = !0;
	};K.Thenable.Dg = function (b) {
		if (!b) return !1;try {
			return !!b[K.Thenable.He];
		} catch (c) {
			return !1;
		}
	};K.Promise = function (b, c) {
		this.$ = K.Promise.P.wa;this.ia = void 0;this.ob = this.Na = this.da = null;this.ld = !1;0 < K.Promise.Wa ? this.Oc = 0 : 0 == K.Promise.Wa && (this.rc = !1);K.Promise.za && (this.ee = [], N(this, Error("created")), this.vf = 0);if (b != K.eb) try {
			var d = this;b.call(c, function (b) {
				O(d, K.Promise.P.Ja, b);
			}, function (b) {
				if (K.ea && !(b instanceof K.Promise.kb)) try {
					if (b instanceof Error) throw b;throw Error("Promise rejected.");
				} catch (f) {}O(d, K.Promise.P.ja, b);
			});
		} catch (e) {
			O(this, K.Promise.P.ja, e);
		}
	};K.Promise.za = !1;
	K.Promise.Wa = 0;K.Promise.P = { wa: 0, Jh: 1, Ja: 2, ja: 3 };K.Promise.ze = function () {
		this.next = this.context = this.wb = this.Tb = this.Xa = null;this.dc = !1;
	};K.Promise.ze.prototype.reset = function () {
		this.context = this.wb = this.Tb = this.Xa = null;this.dc = !1;
	};K.Promise.Vc = 100;K.Promise.Kb = new K.async.Zb(function () {
		return new K.Promise.ze();
	}, function (b) {
		b.reset();
	}, K.Promise.Vc);K.Promise.Lf = function (b, c, d) {
		var e = K.Promise.Kb.get();e.Tb = b;e.wb = c;e.context = d;return e;
	};K.Promise.Yk = function (b) {
		K.Promise.Kb.put(b);
	};
	K.Promise.resolve = function (b) {
		if (b instanceof K.Promise) return b;var c = new K.Promise(K.eb);O(c, K.Promise.P.Ja, b);return c;
	};K.Promise.reject = function (b) {
		return new K.Promise(function (c, d) {
			d(b);
		});
	};K.Promise.Ec = function (b, c, d) {
		K.Promise.Ug(b, c, d, null) || K.async.M(K.fb(c, b));
	};K.Promise.race = function (b) {
		return new K.Promise(function (c, d) {
			b.length || c(void 0);for (var e = 0, f; e < b.length; e++) {
				f = b[e], K.Promise.Ec(f, c, d);
			}
		});
	};
	K.Promise.all = function (b) {
		return new K.Promise(function (c, d) {
			var e = b.length,
			    f = [];if (e) for (var g = function g(b, d) {
				e--;f[b] = d;0 == e && c(f);
			}, h = function h(b) {
				d(b);
			}, l = 0, m; l < b.length; l++) {
				m = b[l], K.Promise.Ec(m, K.fb(g, l), h);
			} else c(f);
		});
	};K.Promise.jp = function (b) {
		return new K.Promise(function (c) {
			var d = b.length,
			    e = [];if (d) for (var f = function (_f) {
				function f(_x10, _x11, _x12) {
					return _f.apply(this, arguments);
				}

				f.toString = function () {
					return _f.toString();
				};

				return f;
			}(function (b, f, g) {
				d--;e[b] = f ? { Bj: !0, value: g } : { Bj: !1, reason: g };0 == d && c(e);
			}), g = 0, h; g < b.length; g++) {
				h = b[g], K.Promise.Ec(h, K.fb(f, g, !0), K.fb(f, g, !1));
			} else c(e);
		});
	};
	K.Promise.Hq = function (b) {
		return new K.Promise(function (c, d) {
			var e = b.length,
			    f = [];if (e) for (var g = function g(b) {
				c(b);
			}, h = function h(b, c) {
				e--;f[b] = c;0 == e && d(f);
			}, l = 0, m; l < b.length; l++) {
				m = b[l], K.Promise.Ec(m, g, K.fb(h, l));
			} else c(void 0);
		});
	};K.Promise.Vt = function () {
		var b,
		    c,
		    d = new K.Promise(function (d, f) {
			b = d;c = f;
		});return new K.Promise.li(d, b, c);
	};K.Promise.prototype.then = function (b, c, d) {
		K.Promise.za && N(this, Error("then"));return ba(this, K.xa(b) ? b : null, K.xa(c) ? c : null, d);
	};K.Thenable.af(K.Promise);
	K.Promise.prototype.cancel = function (b) {
		this.$ == K.Promise.P.wa && K.async.M(function () {
			var c = new K.Promise.kb(b);P(this, c);
		}, this);
	};function P(b, c) {
		if (b.$ == K.Promise.P.wa) if (b.da) {
			var d = b.da;if (d.Na) {
				for (var e = 0, f = null, g = null, h = d.Na; h && (h.dc || (e++, h.Xa == b && (f = h), !(f && 1 < e))); h = h.next) {
					f || (g = h);
				}f && (d.$ == K.Promise.P.wa && 1 == e ? P(d, c) : (g ? (e = g, e.next == d.ob && (d.ob = e), e.next = e.next.next) : Q(d), R(d, f, K.Promise.P.ja, c)));
			}b.da = null;
		} else O(b, K.Promise.P.ja, c);
	}
	function S(b, c) {
		b.Na || b.$ != K.Promise.P.Ja && b.$ != K.Promise.P.ja || T(b);b.ob ? b.ob.next = c : b.Na = c;b.ob = c;
	}function ba(b, c, d, e) {
		var f = K.Promise.Lf(null, null, null);f.Xa = new K.Promise(function (b, h) {
			f.Tb = c ? function (d) {
				try {
					var f = c.call(e, d);b(f);
				} catch (q) {
					h(q);
				}
			} : b;f.wb = d ? function (c) {
				try {
					var f = d.call(e, c);!K.R(f) && c instanceof K.Promise.kb ? h(c) : b(f);
				} catch (q) {
					h(q);
				}
			} : h;
		});f.Xa.da = b;S(b, f);return f.Xa;
	}K.Promise.prototype.Dl = function (b) {
		this.$ = K.Promise.P.wa;O(this, K.Promise.P.Ja, b);
	};
	K.Promise.prototype.El = function (b) {
		this.$ = K.Promise.P.wa;O(this, K.Promise.P.ja, b);
	};function O(b, c, d) {
		b.$ == K.Promise.P.wa && (b === d && (c = K.Promise.P.ja, d = new TypeError("Promise cannot resolve to itself")), b.$ = K.Promise.P.Jh, K.Promise.Ug(d, b.Dl, b.El, b) || (b.ia = d, b.$ = c, b.da = null, T(b), c != K.Promise.P.ja || d instanceof K.Promise.kb || K.Promise.Ii(b, d)));
	}
	K.Promise.Ug = function (b, c, d, e) {
		if (b instanceof K.Promise) return K.Promise.za && N(b, Error("then")), S(b, K.Promise.Lf(c || K.eb, d || null, e)), !0;if (K.Thenable.Dg(b)) return b.then(c, d, e), !0;if (K.ha(b)) try {
			var f = b.then;if (K.xa(f)) return K.Promise.Bl(b, f, c, d, e), !0;
		} catch (g) {
			return d.call(e, g), !0;
		}return !1;
	};K.Promise.Bl = function (b, c, d, e, f) {
		function g(b) {
			l || (l = !0, e.call(f, b));
		}function h(b) {
			l || (l = !0, d.call(f, b));
		}var l = !1;try {
			c.call(b, h, g);
		} catch (m) {
			g(m);
		}
	};function T(b) {
		b.ld || (b.ld = !0, K.async.M(b.vj, b));
	}
	function Q(b) {
		var c = null;b.Na && (c = b.Na, b.Na = c.next, c.next = null);b.Na || (b.ob = null);return c;
	}K.Promise.prototype.vj = function () {
		for (var b; b = Q(this);) {
			K.Promise.za && this.vf++, R(this, b, this.$, this.ia);
		}this.ld = !1;
	};
	function R(b, c, d, e) {
		if (d == K.Promise.P.ja && c.wb && !c.dc) if (0 < K.Promise.Wa) for (; b && b.Oc; b = b.da) {
			K.global.clearTimeout(b.Oc), b.Oc = 0;
		} else if (0 == K.Promise.Wa) for (; b && b.rc; b = b.da) {
			b.rc = !1;
		}if (c.Xa) c.Xa.da = null, K.Promise.xg(c, d, e);else try {
			c.dc ? c.Tb.call(c.context) : K.Promise.xg(c, d, e);
		} catch (f) {
			K.Promise.sc.call(null, f);
		}K.Promise.Yk(c);
	}K.Promise.xg = function (b, c, d) {
		c == K.Promise.P.Ja ? b.Tb.call(b.context, d) : b.wb && b.wb.call(b.context, d);
	};
	function N(b, c) {
		if (K.Promise.za && K.L(c.stack)) {
			var d = c.stack.split("\n", 4)[3];c = c.message;c += Array(11 - c.length).join(" ");b.ee.push(c + d);
		}
	}function U(b, c) {
		if (K.Promise.za && c && K.L(c.stack) && b.ee.length) {
			for (var d = ["Promise trace:"], e = b; e; e = e.da) {
				for (var f = b.vf; 0 <= f; f--) {
					d.push(e.ee[f]);
				}d.push("Value: [" + (e.$ == K.Promise.P.ja ? "REJECTED" : "FULFILLED") + "] <" + String(e.ia) + ">");
			}c.stack += "\n\n" + d.join("\n");
		}
	}
	K.Promise.Ii = function (b, c) {
		0 < K.Promise.Wa ? b.Oc = K.global.setTimeout(function () {
			U(b, c);K.Promise.sc.call(null, c);
		}, K.Promise.Wa) : 0 == K.Promise.Wa && (b.rc = !0, K.async.M(function () {
			b.rc && (U(b, c), K.Promise.sc.call(null, c));
		}));
	};K.Promise.sc = K.async.qh;K.Promise.rt = function (b) {
		K.Promise.sc = b;
	};K.Promise.kb = function (b) {
		K.debug.Error.call(this, b);
	};K.ab(K.Promise.kb, K.debug.Error);K.Promise.kb.prototype.name = "cancel";K.Promise.li = function (b, c, d) {
		this.bh = b;this.resolve = c;this.reject = d;
	}; /*
    Portions of this code are from MochiKit, received by
    The Closure Authors under the MIT license. All other code is Copyright
    2005-2009 The Closure Authors. All Rights Reserved.
    */
	K.async.w = function (b, c) {
		this.Ic = [];this.ah = b;this.wf = c || null;this.ub = this.qb = !1;this.ia = void 0;this.be = this.Ti = this.bd = !1;this.Nc = 0;this.da = null;this.ec = 0;K.async.w.za && (this.ed = null, Error.captureStackTrace && (b = { stack: "" }, Error.captureStackTrace(b, K.async.w), _typeof(b.stack) == B && (this.ed = b.stack.replace(/^[^\n]*\n/, ""))));
	};K.async.w.vi = !1;K.async.w.za = !1;I = K.async.w.prototype;
	I.cancel = function (b) {
		if (this.qb) this.ia instanceof K.async.w && this.ia.cancel();else {
			if (this.da) {
				var c = this.da;delete this.da;b ? c.cancel(b) : (c.ec--, 0 >= c.ec && c.cancel());
			}this.ah ? this.ah.call(this.wf, this) : this.be = !0;this.qb || this.Za(new K.async.w.jb(this));
		}
	};I.rf = function (b, c) {
		this.bd = !1;V(this, b, c);
	};function V(b, c, d) {
		b.qb = !0;b.ia = d;b.ub = !c;W(b);
	}function X(b) {
		if (b.qb) {
			if (!b.be) throw new K.async.w.Wb(b);b.be = !1;
		}
	}I.Db = function (b) {
		X(this);V(this, !0, b);
	};I.Za = function (b) {
		X(this);da(this, b);V(this, !1, b);
	};
	function da(b, c) {
		K.async.w.za && b.ed && K.ha(c) && c.stack && /^[^\n]+(\n   [^\n]+)+/.test(c.stack) && (c.stack = c.stack + "\nDEFERRED OPERATION:\n" + b.ed);
	}function Y(b, c, d) {
		return Z(b, c, null, d);
	}function ea(b, c) {
		Z(b, null, c, void 0);
	}function Z(b, c, d, e) {
		b.Ic.push([c, d, e]);b.qb && W(b);return b;
	}I.then = function (b, c, d) {
		var e,
		    f,
		    g = new K.Promise(function (b, c) {
			e = b;f = c;
		});Z(this, e, function (b) {
			b instanceof K.async.w.jb ? g.cancel() : f(b);
		});return g.then(b, c, d);
	};K.Thenable.af(K.async.w);
	K.async.w.prototype.Vi = function () {
		var b = new K.async.w();Z(this, b.Db, b.Za, b);b.da = this;this.ec++;return b;
	};function fa(b) {
		return K.j.some(b.Ic, function (b) {
			return K.xa(b[1]);
		});
	}
	function W(b) {
		b.Nc && b.qb && fa(b) && (K.async.w.Il(b.Nc), b.Nc = 0);b.da && (b.da.ec--, delete b.da);for (var c = b.ia, d = !1, e = !1; b.Ic.length && !b.bd;) {
			var f = b.Ic.shift(),
			    g = f[0],
			    h = f[1];f = f[2];if (g = b.ub ? h : g) try {
				var l = g.call(f || b.wf, c);K.R(l) && (b.ub = b.ub && (l == c || l instanceof Error), b.ia = c = l);if (K.Thenable.Dg(c) || _typeof(K.global.Promise) === u && c instanceof K.global.Promise) e = !0, b.bd = !0;
			} catch (m) {
				c = m, b.ub = !0, da(b, c), fa(b) || (d = !0);
			}
		}b.ia = c;e ? (e = K.bind(b.rf, b, !0), l = K.bind(b.rf, b, !1), c instanceof K.async.w ? (Z(c, e, l), c.Ti = !0) : c.then(e, l)) : K.async.w.vi && c instanceof Error && !(c instanceof K.async.w.jb) && (d = b.ub = !0);d && (b.Nc = K.async.w.kl(c));
	}K.async.w.oh = function (b) {
		var c = new K.async.w();c.Db(b);return c;
	};K.async.w.Oq = function (b) {
		var c = new K.async.w();c.Db();Y(c, function () {
			return b;
		});return c;
	};K.async.w.la = function (b) {
		var c = new K.async.w();c.Za(b);return c;
	};K.async.w.Pp = function () {
		var b = new K.async.w();b.cancel();return b;
	};K.async.w.Ut = function (b, c, d) {
		return b instanceof K.async.w ? Y(b.Vi(), c, d) : Y(K.async.w.oh(b), c, d);
	};
	K.async.w.Wb = function (b) {
		K.debug.Error.call(this);this.pb = b;
	};K.ab(K.async.w.Wb, K.debug.Error);K.async.w.Wb.prototype.message = "Deferred has already fired";K.async.w.Wb.prototype.name = "AlreadyCalledError";K.async.w.jb = function (b) {
		K.debug.Error.call(this);this.pb = b;
	};K.ab(K.async.w.jb, K.debug.Error);K.async.w.jb.prototype.message = "Deferred was canceled";K.async.w.jb.prototype.name = "CanceledError";K.async.w.Fe = function (b) {
		this.Mb = K.global.setTimeout(K.bind(this.ph, this), 0);this.tj = b;
	};
	K.async.w.Fe.prototype.ph = function () {
		delete K.async.w.Jb[this.Mb];throw this.tj;
	};K.async.w.Jb = {};K.async.w.kl = function (b) {
		b = new K.async.w.Fe(b);K.async.w.Jb[b.Mb] = b;return b.Mb;
	};K.async.w.Il = function (b) {
		var c = K.async.w.Jb[b];c && (K.global.clearTimeout(c.Mb), delete K.async.w.Jb[b]);
	};K.async.w.Cp = function () {
		var b = K.async.w.Jb,
		    c;for (c in b) {
			var d = b[c];K.global.clearTimeout(d.Mb);d.ph();
		}
	};K.D = {};K.D.F = {};K.D.F.Zc = "closure_verification";K.D.F.Th = 5E3;K.D.F.$d = [];K.D.F.gl = function (b, c) {
		function d() {
			var e = b.shift();e = K.D.F.Fc(e, c);b.length && Z(e, d, d, void 0);return e;
		}if (!b.length) return K.async.w.oh(null);var e = K.D.F.$d.length;K.j.extend(K.D.F.$d, b);if (e) return K.D.F.hh;b = K.D.F.$d;K.D.F.hh = d();return K.D.F.hh;
	};
	K.D.F.Fc = function (b, c) {
		var d = c || {};c = d.document || document;var e = K.b.C.u(b),
		    f = K.a.createElement(p),
		    g = { ih: f, sh: void 0 },
		    h = new K.async.w(K.D.F.Xi, g),
		    l = null,
		    m = K.cb(d.timeout) ? d.timeout : K.D.F.Th;0 < m && (l = window.setTimeout(function () {
			K.D.F.gc(f, !0);h.Za(new K.D.F.Error(K.D.F.Yb.TIMEOUT, "Timeout reached for loading script " + e));
		}, m), g.sh = l);f.onload = f.onreadystatechange = function () {
			f.readyState && "loaded" != f.readyState && f.readyState != t || (K.D.F.gc(f, d.Wp || !1, l), h.Db(null));
		};f.onerror = function () {
			K.D.F.gc(f, !0, l);h.Za(new K.D.F.Error(K.D.F.Yb.ei, "Error while loading script " + e));
		};g = d.attributes || {};K.object.extend(g, { type: C, charset: "UTF-8" });K.a.Jc(f, g);K.a.S.ol(f, b);K.D.F.Mj(c).appendChild(f);return h;
	};
	K.D.F.Vs = function (b, c, d) {
		K.global[K.D.F.Zc] || (K.global[K.D.F.Zc] = {});var e = K.global[K.D.F.Zc],
		    f = K.b.C.u(b);if (K.R(e[c])) return K.async.w.la(new K.D.F.Error(K.D.F.Yb.Gi, "Verification object " + c + " already defined."));b = K.D.F.Fc(b, d);var g = new K.async.w(K.bind(b.cancel, b));Y(b, function () {
			var b = e[c];K.R(b) ? (g.Db(b), delete e[c]) : g.Za(new K.D.F.Error(K.D.F.Yb.Fi, "Script " + f + " loaded, but verification object " + c + " was not defined."));
		});ea(b, function (b) {
			K.R(e[c]) && delete e[c];g.Za(b);
		});return g;
	};
	K.D.F.Mj = function (b) {
		var c = K.a.getElementsByTagName("HEAD", b);return !c || K.j.Qb(c) ? b.documentElement : c[0];
	};K.D.F.Xi = function () {
		if (this && this.ih) {
			var b = this.ih;b && b.tagName == p && K.D.F.gc(b, !0, this.sh);
		}
	};K.D.F.gc = function (b, c, d) {
		K.cb(d) && K.global.clearTimeout(d);b.onload = K.eb;b.onerror = K.eb;b.onreadystatechange = K.eb;c && window.setTimeout(function () {
			K.a.removeNode(b);
		}, 0);
	};K.D.F.Yb = { ei: 0, TIMEOUT: 1, Fi: 2, Gi: 3 };
	K.D.F.Error = function (b, c) {
		var d = "Jsloader error (code #" + b + ")";c && (d += ": " + c);K.debug.Error.call(this, d);this.code = b;
	};K.ab(K.D.F.Error, K.debug.Error);var google = { G: {} };google.G.H = {};google.G.H.Aa = {};google.G.H.Aa.rh = 3E4;google.G.H.Aa.hs = function (b, c) {
		return { format: b, Mi: c };
	};google.G.H.Aa.Pj = function (b) {
		return K.b.C.format(b.format, b.Mi);
	};google.G.H.Aa.load = function (b, c) {
		b = K.b.C.format(b, c);var d = K.D.F.Fc(b, { timeout: google.G.H.Aa.rh, attributes: { async: !1, defer: !1 } });return new Promise(function (b) {
			Y(d, b);
		});
	};
	google.G.H.Aa.bs = function (b) {
		b = K.j.map(b, google.G.H.Aa.Pj);if (K.j.Qb(b)) return Promise.resolve();var c = { timeout: google.G.H.Aa.rh, attributes: { async: !1, defer: !1 } },
		    d = [];!K.userAgent.Y || K.userAgent.va(11) ? K.j.forEach(b, function (b) {
			d.push(K.D.F.Fc(b, c));
		}) : d.push(K.D.F.gl(b, c));return Promise.all(K.j.map(d, function (b) {
			return new Promise(function (c) {
				return Y(b, c);
			});
		}));
	};google.G.H.T = {};if (K.rb(v)) throw Error("Google Charts loader.js can only be loaded once.");google.G.H.T.Nl = { 41: z, 42: z, 43: z, 44: z, 1: "1.0", "1.0": "current", "1.1": "upcoming", current: "45.2", upcoming: "46" };google.G.H.T.Kk = function (b) {
		var c = b,
		    d = b.match(/^testing-/);d && (c = c.replace(/^testing-/, ""));b = c;do {
			var e = google.G.H.T.Nl[c];e && (c = e);
		} while (e);d = (d ? "testing-" : "") + c;return { version: c == z ? b : d, Dk: d };
	};google.G.H.T.yh = null;
	google.G.H.T.Bk = function (b) {
		var c = google.G.H.T.Kk(b),
		    d = K.f.I.from("https://www.gstatic.com/charts/%{version}/loader.js");return google.G.H.Aa.load(d, { version: c.Dk }).then(function () {
			var d = K.rb("google.charts.loader.VersionSpecific.load") || K.rb("google.charts.loader.publicLoad") || K.rb("google.charts.versionSpecific.load");if (!d) throw Error("Bad version: " + b);google.G.H.T.yh = function (b) {
				b = d(c.version, b);if (null == b || null == b.then) {
					var e = K.rb("google.charts.loader.publicSetOnLoadCallback") || K.rb("google.charts.versionSpecific.setOnLoadCallback");
					b = new Promise(function (b) {
						e(b);
					});b.then = e;
				}return b;
			};
		});
	};google.G.H.T.Pd = null;google.G.H.T.jc = null;google.G.H.T.yk = function (b, c) {
		google.G.H.T.Pd || (google.G.H.T.Pd = google.G.H.T.Bk(b));return google.G.H.T.jc = google.G.H.T.Pd.then(function () {
			return google.G.H.T.yh(c);
		});
	};google.G.H.T.nl = function (b) {
		if (!google.G.H.T.jc) throw Error("Must call google.charts.load before google.charts.setOnLoadCallback");return b ? google.G.H.T.jc.then(b) : google.G.H.T.jc;
	};
	google.G.load = function (b) {
		for (var c = [], d = 0; d < arguments.length; ++d) {
			c[d - 0] = arguments[d];
		}d = 0;"visualization" === c[d] && d++;var e = "current";K.L(c[d]) && (e = c[d], d++);var f = {};K.ha(c[d]) && (f = c[d]);return google.G.H.T.yk(e, f);
	};K.zf(v, google.G.load);google.G.ml = google.G.H.T.nl;K.zf("google.charts.setOnLoadCallback", google.G.ml);
}).call(this);

(function ($) {
	$(document).ready(function () {
		(function ($) {

			$.fn.shuffle = function () {

				var allElems = this.get(),
				    getRandom = function getRandom(max) {
					return Math.floor(Math.random() * max);
				},
				    shuffled = $.map(allElems, function () {
					var random = getRandom(allElems.length),
					    randEl = $(allElems[random]).clone(true)[0];
					allElems.splice(random, 1);
					return randEl;
				});

				this.each(function (i) {
					$(this).replaceWith($(shuffled[i]));
				});

				return $(shuffled);
			};
		})(jQuery);
		window.demoDiv = function () {
			demoDiv = document.createElement('div');
			demoDiv.style.overflowY = 'scroll';
			demoDiv.style.width = '50px';
			demoDiv.style.height = '50px';
			demoDiv.style.visibility = 'hidden';
			document.body.appendChild(demoDiv);
			window.scrollWidth = demoDiv.offsetWidth - demoDiv.clientWidth;
			return document.body.removeChild(demoDiv);
		};

		demoDiv();

		window.getScroll = function (a) {
			var b, c, d, e;
			d = document;
			b = d.body;
			e = d.documentElement;
			c = 'client' + a;
			a = 'scroll' + a;
			if (/CSS/.test(d.compatMode)) {
				return e[c] < e[a];
			} else {
				return b[c] < b[a];
			}
		};

		window.getRealWidth = function () {
			var scrollFalse, scrollTrue;
			scrollTrue = scrollWidth + document.body.clientWidth;
			scrollFalse = document.body.clientWidth;
			if (getScroll('Height')) {
				return scrollTrue;
			} else {
				return scrollFalse;
			}
		};

		window.getRealHeight = function () {
			var scrollFalse, scrollTrue;
			scrollTrue = scrollWidth + document.body.clientHeight;
			scrollFalse = document.body.clientHeight;
			if (getScroll('Width')) {
				return scrollTrue;
			} else {
				return scrollFalse;
			}
		};

		window.getPrettyName = function (number, titles) {
			var cases;
			cases = [2, 0, 1, 1, 1, 2];
			return titles[number % 100 > 4 && number % 100 < 20 ? 2 : cases[number % 10 < 5 ? number % 10 : 5]];
		};

		window.isMobile = getRealWidth() < 992 ? true : false;
		$(window).on("resize", function () {
			isMobile = getRealWidth() < 992 ? true : false;
		});

		window.animationStatus = true;
		if (isMobile) {
			animationStatus = false;
		}

		window.imageLink = '/local/templates/main/assets/images/';
		if (location.port == "9000") {
			imageLink = '../assets/images/';
		}

		var bLazy = new Blazy({
			offset: 300,
			loadInvisible: true
		});
		// 
		// window.devLanding = [
		// 	{
		// 		"id": "li_slide_1",
		// 		"coords": [55.727653, 37.339939]
		// 	},
		// 	{
		// 		"id": "li_slide_2",
		// 		"coords": [55.665204, 37.739610]
		// 	},
		// 	{
		// 		"id": "li_slide_3",
		// 		"coords": [55.744687, 37.394914]
		// 	},
		// 	{
		// 		"id": "li_slide_4",
		// 		"coords": [55.667145, 37.552843]
		// 	}
		// ]
		//
		// window.devOffices = [
		// 	{
		// 		"addr": ". ,  ., .14 (.  )",
		// 		"coords": [55.769859, 37.637443]
		// 	},
		// 	{
		// 		"addr": ". , 1-  -, .14 (. ",
		// 		"coords": [55.675616, 37.632134]
		// 	},
		// 	{
		// 		"addr": "",
		// 		"coords": [55.702860, 37.767582]
		// 	},
		// 	{
		// 		"coords": [55.777373, 37.487568]
		// 	}
		//
		// ]

		$.fn.serializeObject = function () {
			var o = {};
			var a = this.serializeArray();
			$.each(a, function () {
				if (o[this.name]) {
					if (!o[this.name].push) {
						o[this.name] = [o[this.name]];
					}
					o[this.name].push(this.value || '');
				} else {
					o[this.name] = this.value || '';
				}
			});
			return o;
		};

		window.positionCalc = function (target, item) {

			item.css({ top: 0, left: 0 });

			var calculator = new $.PositionCalculator({
				item: item,
				target: target,
				itemAt: "top left",
				itemOffset: { y: 0, x: 0, mirror: true },
				targetAt: "bottom left",
				flip: "both"
			});
			var posResult = calculator.calculate();

			item.css({
				top: posResult.moveBy.y + "px",
				left: posResult.moveBy.x + "px"
			});

			return posResult;

			// setTimeout(function(){
			// TweenMax.fromTo(item, 0.2,{scale:0,opacity:0, transformOrigin:"top center"}, {scale:1,opacity:1})
			// },100)
		};

		// var sliders = $('.full-slider');
		// var blocks = $('.animation-up')
		// var controller = new ScrollMagic.Controller({loglevel: 3});
		// var tl = new TimelineMax();

		var loaderTimeout = undefined;
		var loader = false;

		if (location.hostname == "localhost") {
			loader = false;
		}
		// var loader = true;

		// function numbers(i,n){
		// 	if (i<n){
		// 		loaderTimeout = setTimeout((function() {
		// 			i++;
		// 			$('.loader__percent').text(i+'%')
		// 			$('.loader__line').css({
		// 				width: i+'%'
		// 			})
		// 			if(i==100){
		// 				$('.loader').addClass('loader_opacity')
		// 				if(animationStatus){
		// 					animationFactory.createAnimations(document.body);
		// 				}
		// 				// console.log('animation start')
		// 				setTimeout((function() {
		// 					$('.loader').remove();
		// 				}), 1100);
		// 			}
		// 			numbers(i,n)
		// 		}), 5);
		// 	}
		// }

		// tl.set(blocks, {yPercent: 100, opacity: 0});

		// blocks.each(function(index, element) {
		// element = $(element);

		// var splitAnimation = new TimelineMax({paused: true});
		// splitAnimation.to(blocks, 0.7, {yPercent: 0, opacity: 1, ease:Power4.easeOut}, "start")
		// })

		// 3. Scene
		// var scene = new ScrollMagic.Scene({
		// triggerElement: sliders,
		// 	triggerHook: 'onEnter',
		// 	offset: 0
		// })
		// .addTo(controller)
		// .setTween(splitAnimation.play());

		function AnimationFactory() {
			this.controller = new ScrollMagic.Controller();
			this.scenes = [];
		}

		AnimationFactory.prototype = {
			controller: null,
			scenes: null,
			constructor: AnimationFactory,
			setStyles: function setStyles(element, args) {
				element = typeof element === "string" ? document.getElementById(element) : element;

				var start = TweenMax.set(element, args.start.options);
			},
			createAnimation: function createAnimation(element, args) {
				element = typeof element === "string" ? document.getElementById(element) : element;

				// console.log(args.scene.options)

				if (args.scene.options) {
					args.scene.options.triggerElement = element;
				} else {
					args.scene.options.triggerElement = $('body')[0];
					args.scene.options.triggerHook = 'onEnter';
				}

				// console.log(element)

				var tween = TweenMax.to(element, args.tween.duration, args.tween.options);
				var scene = new ScrollMagic.Scene(args.scene.options);

				scene.addTo(this.controller);
				scene.setTween(tween);
				// scene.addIndicators();

				this.scenes.push(scene);

				// return this;
			},
			createAnimations: function createAnimations(element) {
				var tween = null,
				    scene = null,
				    elementsTags = element.querySelectorAll("[data-animation]"),
				    elementsClass = $('.animation-block'),
				    i = 0,
				    args;

				for (i; i < elementsTags.length; i++) {
					// console.log(elements[i])
					args1 = JSON.parse(elementsTags[i].getAttribute("data-animation"));
					this.setStyles(elementsTags[i], args1);
					this.createAnimation(elementsTags[i], args1);
				}

				for (i; i < elementsClass.length; i++) {
					// console.log(elements[i])
					// args2 = JSON.parse('{"start": {"options": {"opacity": 0,"y": "20px"}},"tween": {"duration": 0.7,"options": {"opacity": 1,"y": 0, "clearProps":"transformOrgin,transform,scale,opacity"}},"scene": {"options": {"triggerHook": "onEnter","offset": 0,"reverse": true}}}');
					args2 = JSON.parse('{"start": {"options": {"opacity": 0,"y": "20px"}},"tween": {"duration": 0.7,"options": {"opacity": 1,"y": 0, "clearProps":"transformOrgin,transform,scale,opacity"}},"scene": {"options": {"triggerHook": "onEnter","offset": 0,"reverse": false}}}');
					this.setStyles(elementsClass[i], args2);
					this.createAnimation(elementsClass[i], args2);
				}
			}
		};

		var animationFactory = new AnimationFactory();

		window.indexTimeline = new TimelineMax();

		window.indexAnimation = function () {
			indexSection = $('.section_index');
			indexSectionTop = indexSection.find('.section__top');
			indexSectionCenter = indexSection.find('.section__center');
			indexSectionBottom = indexSection.find('.section__bottom');

			// console.log(indexSectionTop)
			indexTimeline.fromTo(indexSectionTop, 1, { y: -20, opacity: 0 }, { y: 0, opacity: 1, clearProps: "all" });
			indexTimeline.fromTo(indexSectionCenter, 2, { opacity: 0 }, { opacity: 1, clearProps: "all" }, 0);
			indexTimeline.fromTo(indexSectionBottom, 1, { y: 20, opacity: 0 }, { y: 0, opacity: 1, clearProps: "all" }, 0);
		};

		if (loader) {
			// numbers(0,70)
		} else {
			// $('.loader').remove()
			// setTimeout(function(){
			$('.loader').remove();

			if (animationStatus) {
				// console.log('animationStatus')
				animationFactory.createAnimations(document.body);
				indexAnimation();
			}
			// },3000)
		}

		// $(window).on("load", function(){
		// 	if (loader){
		// 		clearTimeout(loaderTimeout)
		// 		numbers(70,100)
		// 	}
		// })
		// $(window).on('load', function(){
		// animationFactory.createAnimations(document.body);
		// })


		// iconTimeline.fromTo($('.icon-advantage path'), 1, {drawSVG:"0%"}, {drawSVG:"100%"})
		var advantageTimeline = [];
		window.animateAdvantage = function (icon, index) {
			if (advantageTimeline[index]) {
				// advantageTimeline[index].pause(0);
				// advantageTimeline[index].clear()
			}
			layers = icon.find('[class*=icon-advantage-layer]');
			rotate = icon.find('[class*=icon-advantage-layer-rotate]');
			move = icon.find('[class*=icon-advantage-layer-move]');
			fill = icon.find('[class*=icon-advantage-layer-fill]');
			advantageTimeline[index] = new TimelineMax({});

			// console.log(icon,rotate,move,fill,index)

			advantageTimeline[index].to(rotate, 1, { rotation: '35%', transformOrigin: "center", ease: Back.easeOut.config(1.7) }, '-=1.2');
			advantageTimeline[index].staggerFromTo(fill, 1, { drawSVG: "0%" }, { drawSVG: "100%" }, 0.2, '-=0.5');
			advantageTimeline[index].staggerFromTo(layers, 1.5, { scale: 0, transformOrigin: "center" }, { scale: 0.9, ease: Elastic.easeOut.config(1, 0.6) }, 0.3, 0);
			// iconTimeline.fromTo(move, 1, {scaleY:0, transformOrigin:"center"}, {scaleY:1.1, ease: Back.easeOut.config(1.7)})
			// iconTimeline.fromTo(move, 1, {scaleY:1.1, transformOrigin:"center"}, {scaleY:1.2, repeat:-1, yoyo: true, ease: Back.easeOut.config(1.7)}, '+=0.2')
		};

		// advantagesTimeline = new TimelineMax()
		// function advantagesAnimate(){
		// 	advantageIcon = $('.icon-advantage');

		// 	advantagesTimeline.staggerFromTo()
		// }

		// $('.icon-advantage').each(function(i,e){
		// 	console.log($(e).parents('.advantage').data('index'))
		// 	animateAdvantage($(e),$(e).parents('.advantage').data('index'))
		// })

		window.aeroTimeline = new TimelineMax({ repeat: -1 });
		window.lineTimeline = new TimelineMax({ repeat: -1 });

		window.animateAero = function (timeline, lineTimeline) {

			var aeroIcon = $('.aero-icon');
			// aeroIconLayers = aeroIcon.find('[class*=aero-icon-layer')
			var aeroIconWind = aeroIcon.find('[class*=aero-icon-wind]');
			var aeroIconLine = aeroIcon.find('[class*=aero-icon-line]');

			TweenMax.fromTo(aeroIcon, 2, { x: '107px' }, { x: '0', ease: Back.easeOut.config(1.7) });

			TweenMax.fromTo(aeroIcon, 1.5, { y: '7px' }, { y: '0', yoyo: true, repeat: -1, ease: Power0.easeNone });

			// console.log(timeline,'timeline')
			// console.log(aeroIconWind,'aeroIconWind')

			timeline.pause(0);
			timeline.clear();
			timeline.restart();

			timeline.staggerFromTo(aeroIconWind, 0.2, { drawSVG: "0% 0%" }, { drawSVG: "0% 100%" }, 0.1);
			timeline.staggerFromTo(aeroIconWind, 0.2, { drawSVG: "0% 100%" }, { drawSVG: "100% 100%" }, 0.1, '-=0.5');

			lineTimeline.pause(0);
			lineTimeline.clear();
			lineTimeline.restart();

			lineTimeline.fromTo(aeroIconLine, 0.1, { opacity: 0 }, { opacity: 1 });
			lineTimeline.fromTo(aeroIconLine, 1.5, { y: 0, scale: 1, opacity: 1, transformOrigin: "center" }, { y: '13px', scale: 1.1, opacity: 0 });
		};

		animateAero(aeroTimeline, lineTimeline);

		window.animateCamera = function () {

			// var aeroIcon = $('.aero-icon')
			var cameraIcon = $('.camera-icon');
			var leftBabina = cameraIcon.find('[class*=left-babina]');
			var rightBabina = cameraIcon.find('[class*=right-babina]');

			TweenMax.fromTo(leftBabina, 4, { rotation: "0%", transformOrigin: "center" }, { rotation: "360%", ease: Power0.easeNone, repeat: -1 }, 0);
			TweenMax.fromTo(rightBabina, 3.5, { rotation: "0%", transformOrigin: "center" }, { rotation: "360%", ease: Power0.easeNone, repeat: -1 }, 0);
		};

		animateCamera();

		buildingsTimeline = new TimelineMax({ ease: Power2.easeOut });
		function animateBuildings(timeline) {
			var buindingsIcon = $('.buildings-icon');
			var bIconWall = buindingsIcon.find('[class*=wall]');
			var bIconWindows = buindingsIcon.find('[class*=window]');
			var bIconAntena = buindingsIcon.find('[class=antena]');
			var bIconTrees = buindingsIcon.find('[class=tree]');
			var bIconEath = buindingsIcon.find('[class*=eath]');

			timeline.pause(0);
			timeline.clear();
			timeline.restart();

			timeline.set(buindingsIcon, { scale: 1, opacity: 1 });

			timeline.fromTo(bIconEath, 0.1, { opacity: 0 }, { opacity: 1 });
			timeline.fromTo(bIconWall, 0.3, { y: '30px' }, { y: '0' });
			timeline.fromTo(bIconAntena, 0.3, { scale: 0, transformOrigin: "bottom" }, { scale: 1 });
			timeline.staggerFromTo(bIconWindows, 0.1, { scale: 0 }, { scale: 1 }, 0.2, '-=0.3');
			timeline.staggerFromTo(bIconTrees, 0.5, { scale: 0, transformOrigin: "bottom" }, { scale: 1 }, 0.2, '-=0.4');
		}
		if (animationStatus) {
			animateBuildings(buildingsTimeline);
		}

		cottegesTimeline = new TimelineMax({ ease: Power2.easeOut });
		function animateCotteges(timeline) {
			var cottegeIcon = $('.cottege-icon');
			var cIconWall = cottegeIcon.find('[class=wall]');
			var cIconWindows = cottegeIcon.find('[class=window]');
			var cIconTrees = cottegeIcon.find('[class=tree]');
			var cIconRoof = cottegeIcon.find('[class=roof]');
			var cIconClouds = cottegeIcon.find('[class=cloud]');
			var cIconDoor = cottegeIcon.find('[class=door]');
			var cIconEath = cottegeIcon.find('[class=eath]');

			timeline.pause(0);
			timeline.clear();
			timeline.restart();

			timeline.set(cottegeIcon, { scale: 1, opacity: 1 });

			timeline.fromTo(cIconEath, 0.1, { opacity: 0 }, { opacity: 1 });
			timeline.fromTo(cIconWall, 0.5, { y: '30px' }, { y: '0' });
			timeline.fromTo(cIconRoof, 0.5, { y: '30px' }, { y: '0' }, '-=0.5');

			timeline.fromTo(cIconDoor, 0.3, { scale: 0, transformOrigin: "bottom" }, { scale: 1 });
			timeline.staggerFromTo(cIconWindows, 0.3, { scale: 0, transformOrigin: "center" }, { scale: 1 }, 0.2);

			timeline.fromTo(cIconTrees, 1, { scale: 0, transformOrigin: "bottom" }, { scale: 1 });

			timeline.fromTo(cIconClouds.eq(0), 1.5, { x: '-20px' }, { x: '0' }, 0);
			timeline.fromTo(cIconClouds.eq(1), 1.5, { x: '20px' }, { x: '0' }, 0);
		}
		if (animationStatus) {
			animateCotteges(cottegesTimeline);
		}

		developersTimeline = new TimelineMax({ ease: Power2.easeOut });
		function animateDevelopers(timeline) {
			var developersIcon = $('.developers-icon');
			var dIconLeg = developersIcon.find('[class=leg]');
			var dIconCabine = developersIcon.find('[class=cabine]');
			var dIconArrow = developersIcon.find('[class=arrow]');
			var dIconRope = developersIcon.find('[class=rope]');
			var dIconHouse = developersIcon.find('[class=house]');
			var dIconFoundation = developersIcon.find('[class=foundation]');
			var dIconEath = developersIcon.find('[class=eath]');

			timeline.pause(0);
			timeline.clear();
			timeline.restart();

			timeline.set(developersIcon, { scale: 1, opacity: 1 });

			timeline.fromTo(dIconEath, 0.1, { opacity: 0 }, { opacity: 1 });
			timeline.fromTo(dIconLeg, .6, { y: '30px' }, { y: '0' });
			timeline.fromTo(dIconCabine, 0.3, { scale: 0, transformOrigin: "bottom" }, { scale: 1 });
			timeline.fromTo(dIconArrow, 0.3, { scale: 0, x: '0px', transformOrigin: "left bottom" }, { scale: 1, x: 0 });

			timeline.fromTo(dIconRope, 0.3, { scale: 0, transformOrigin: "top" }, { scale: 1 });
			timeline.fromTo(dIconHouse, 0.3, { y: '-4px', scale: 0, transformOrigin: "top" }, { y: 0, scale: 1 }, '-=0.3');

			timeline.fromTo([dIconRope, dIconHouse], 0.2, { y: 0 }, { y: '1px' });

			timeline.fromTo(dIconFoundation, 0.6, { scale: 0, transformOrigin: "bottom left" }, { scale: 1, ease: Back.easeOut.config(1.7) }, 0);
		}
		if (animationStatus) {
			animateDevelopers(developersTimeline);
		}

		mouseTimeline = new TimelineMax({ ease: Power2.easeOut, repeat: -1 });

		function animateMouse(timeline) {
			var mouseIcon = $('.mouse-scroll');
			var mouseLeft = mouseIcon.find('[class=left]');
			var mouseRight = mouseIcon.find('[class=right]');
			var mouseBg = mouseIcon.find('[class=bottom]');
			var mouseCircle = mouseIcon.find('[class=circle]');

			timeline.pause(0);
			timeline.clear();
			timeline.restart();

			timeline.set(mouseIcon, { y: 0 });

			timeline.fromTo(mouseIcon, 1.5, { y: 0 }, { y: '7px' }, 0);

			timeline.fromTo([mouseLeft, mouseRight], 1.5, { drawSVG: "100% 0%" }, { drawSVG: "100% 100%" }, 0);

			timeline.fromTo(mouseCircle, 1.5, { y: '0px' }, { y: '25px' }, 0);
			timeline.fromTo(mouseCircle, 0.5, { scale: 1, transformOrigin: "center" }, { scale: 0 }, 1);

			timeline.fromTo(mouseCircle, 0.5, { y: '3px', transformOrigin: "center" }, { scale: 1, y: '0px' }, 1.5);

			timeline.fromTo(mouseBg, 0.5, { opacity: 0.5 }, { opacity: 1 }, 1.5);
			timeline.fromTo(mouseIcon, 0.5, { y: '7px' }, { y: 0 }, 1.5);

			mouseIcon.on('click', function (e) {
				e.preventDefault();
				TweenLite.to(window, 1, { scrollTo: { y: $('.section_index').outerHeight() }, ease: Power2.easeOut });
			});
		}
		// animateMouse(mouseTimeline)


		salesTimeline = new TimelineMax({ ease: Back.easeOut.config(1.1) });

		function animateSales(timeline) {
			var salesIcon = $('.sales-icon');
			var sIconCircle = salesIcon.find('[class=circle]');
			var sIconNulls = salesIcon.find('[class=null]');
			var sIconLine = salesIcon.find('[class=line]');

			timeline.pause(0);
			timeline.clear();
			timeline.restart();

			timeline.set(salesIcon, { scale: 1, opacity: 1 });

			timeline.fromTo(sIconCircle, 0.5, { scale: 0, rotation: "-90%", transformOrigin: "center" }, { scale: 1, rotation: 0 });
			timeline.staggerFromTo(sIconNulls, 0.1, { scale: 0, transformOrigin: "center" }, { scale: 1 }, 0.5);
			timeline.fromTo(sIconLine, 0.1, { scale: 0, transformOrigin: "center" }, { scale: 1 }, '-=0.5');
		}
		if (animationStatus) {
			animateSales(salesTimeline);
		}

		function reanimateIcon(icon) {

			TweenMax.to(icon, 0.5, {
				scale: 0,
				opacity: 0,
				ease: Power2.easeOut,
				onComplete: function onComplete() {
					if (icon.attr('class') == 'sales-icon') {
						// console.log('here')
						animateSales(salesTimeline);
					} else if (icon.attr('class') == 'developers-icon') {
						animateDevelopers(developersTimeline);
					} else if (icon.attr('class') == 'cottege-icon') {
						animateCotteges(cottegesTimeline);
					} else if (icon.attr('class') == 'buildings-icon') {
						animateBuildings(buildingsTimeline);
					}
				}
			});
		}

		$('.top-menu__link:not(.top-menu__link_no-animate)').hover(function () {

			icon = $(this).find('svg');
			reanimateIcon(icon);
		}, function () {
			// $( this ).find( "span:last" ).remove();
		});

		function animateEye() {

			var eyeIcon = $(".eye-icon");
			var eyePupils = eyeIcon.find('[class=pupil]');

			eyePupils.each(function (i, element) {
				var eyePupil = $(element);

				var eyePupilCenter = [eyePupil.offset().left + 8, eyePupil.offset().top + 8];

				$(document).mousemove(function (e) {
					var angle = Math.atan2(e.pageX - eyePupilCenter[0], -(e.pageY - eyePupilCenter[1])) * (180 / Math.PI);

					TweenLite.to(eyePupil, 0.2, { rotation: angle + "_short", transformOrigin: "50% 50%", ease: Power0.easeNone });
				});
			});
		}

		var animationTimeout = undefined;

		$(window).on("load", function () {
			animateEye();
		}).on("resize scroll", function () {

			clearTimeout(animationTimeout);
			animationTimeout = setTimeout(animateEye, 1000);
		});

		callbackTimeline = new TimelineMax({ ease: Back.easeOut.config(1.1) });
		$('.slider-callback').hover(function () {

			// callbackTimeline.fromTo($(this), 1, {transform: "rotate(-15deg)"}, {transform: "rotate(15deg)", transformOrigin:"50% 100%"})
			// callbackTimeline.to($(this), 1, {transform: "rotate(0deg)", transformOrigin:"50% 100%"})
			// callbackTimeline.fromTo($(this), 0.5, {transform: "rotate(-6deg)"}, {transform: "rotate(3deg)", ease:RoughEase.ease.config({strength:8, points:4, template:Back.easeOut.config(1.1), randomize:false}) , clearProps:"x", transformOrigin:"50% 100%"})
		}, function () {});

		// var controller = new ScrollMagic({
		//   container: $(this)
		// });
		// var parallax = new ScrollScene({duration: $(window).height() - 60})
		// .addTo(controller)
		// .setTween(new TimelineMax().add([
		//   TweenMax.to("section .top", 1, {backgroundPositionY: "40%", ease: Linear.easeNone}),
		//   TweenMax.to("section .top .wrap", 1, {top: "70%", opacity: 0, ease: Linear.easeNone})
		// ]));

		var gameController = new ScrollMagic.Controller({
			globalSceneOptions: {
				triggerHook: "onEnter"
			}
		});

		$('.parallax-item').each(function () {

			TweenMax.set($(this), { yPercent: 25 });

			var tween = TweenMax.to($(this), 0.1, { yPercent: -25, ease: Power0.easeNone });

			var parallax = new ScrollMagic.Scene({ triggerElement: '.parallax-items', tweenChanges: true, duration: "150%", offset: $(this).offset().top }).setTween(tween).addTo(gameController);
		});

		$('.parallax-money').each(function () {

			TweenMax.set($(this), { yPercent: 25 });

			var tween = TweenMax.to($(this), 0.1, { yPercent: -5, ease: Power0.easeNone });

			var parallax = new ScrollMagic.Scene({ triggerElement: '.parallax-moneys', tweenChanges: true, duration: "150%", offset: $(this).position().top }).setTween(tween).addTo(gameController);
		});

		// iconTimeline.staggerFromTo($('.icon-advantage-layer-fill'), 1, {drawSVG:"0%"}, {drawSVG:"100%"},0.2, '-=1')
		// iconTimeline.fromTo($('.icon-advantage-move'), 1, {y: -10, opacity:0}, {y:0, opacity:1})
		// iconTimeline.fromTo($('.icon-advantage-layer-2'), 1, {scale:0,transformOrigin:"center"}, {scale:1,transformOrigin:"center", ease: Elastic.easeOut.config(1, 0.6)})
		// iconTimeline.fromTo($('.icon-advantage-layer-3'), 1, {scale:0,transformOrigin:"center"}, {scale:1,transformOrigin:"center", ease: Elastic.easeOut.config(1, 0.6)})
		var favoriteCheck = function favoriteCheck(element) {

			var arr = getCookie('favorites');
			var parsedArray = void 0;

			if (arr) {
				parsedArray = JSON.parse(arr);
				if (element) {
					if (parsedArray.length && arrayFind(parsedArray, element) !== -1) {
						return parsedArray.length;
					}
				} else {
					return parsedArray.length;
				}
			}

			return 0;
		};

		var favoriteAction = function favoriteAction(button) {
			// button = $(this);
			var buttonId = button.data('id');

			if (!buttonId) {
				return false;
			}

			var cookie = getCookie('favorites'),
			    parsedCookie = void 0;

			if (cookie) {
				parsedCookie = JSON.parse(cookie);
			}

			var timer = new Date(new Date().getTime() + 365 * 24 * 3600 * 1000).toUTCString();
			var settings = { expires: timer, path: "/", domain: location.hostname };

			if (button.hasClass('active')) {

				button.removeClass('active');

				if (parsedCookie) {
					if (parsedCookie.length) {
						if (arrayFind(parsedCookie, buttonId) != -1) {

							parsedCookie.splice(arrayFind(parsedCookie, buttonId), 1);
							parsedCookie = JSON.stringify(parsedCookie);
							setCookie("favorites", parsedCookie, settings);
						}
						// console.log(array)
					}
				}

				findFavorites();
			} else {
				button.addClass('active');

				if (parsedCookie) {
					if (parsedCookie.length) {
						if (arrayFind(parsedCookie, buttonId) == -1) {

							parsedCookie.push(buttonId);
							parsedCookie = JSON.stringify(parsedCookie);
							setCookie('favorites', parsedCookie, settings);
						}
					} else {
						setCookie("favorites", "[" + buttonId + "]", settings);
					}
				} else {
					setCookie("favorites", "[" + buttonId + "]", settings);
				}

				var clone = button.clone();

				clone.css({
					'position': 'absolute',
					top: button.offset().top,
					left: button.offset().left,
					'z-index': '20',
					"opacity": 1,
					"transition": !isMobile ? "top .65s linear, left .65s linear, opacity 0.65s ease-in" : "top .4s linear, left .4s linear, opacity 0.4s ease-in"
				}).appendTo("body").css({ opacity: 0.2,
					left: $(".sidebar-favorites").offset().left + 20,
					top: !isMobile ? $(".sidebar-favorites").offset().top + 20 : $(".sidebar-favorites").offset().top + 5
				});
				setTimeout(function () {
					clone.remove();
					findFavorites();
				}, !isMobile ? 660 : 410);
			}
		};

		$('.complex__favorite, .button_favorite').on("click", function (e) {
			e.preventDefault();
			favoriteAction($(this));
		});

		function findFavorites() {

			var sidebarWrapper = $('.sidebar-favorites'),
			    sidebarIcon = sidebarWrapper.find('.sidebar-favorites__icon'),
			    sidebarCnt = sidebarWrapper.find('.sidebar-favorites__cnt span'),
			    favLength = favoriteCheck();

			$('.complex__favorite, .button_favorite').each(function (i, element) {

				button = $(element);

				if (favoriteCheck(button.data('id'))) {

					button.addClass('active');

					if (button.hasClass('button_favorite')) {
						TweenLite.to(button.find('span'), 0.5, { text: ' ', ease: Linear.easeNone });
					}
				} else {
					button.removeClass('active');

					if (button.hasClass('button_favorite')) {
						TweenLite.to(button.find('span'), 0.5, { text: ' ', ease: Linear.easeNone });
					}
				}
			});

			if (favLength) {
				sidebarIcon.removeClass('sidebar-favorites__icon_active');
				setTimeout(function () {
					sidebarIcon.addClass('sidebar-favorites__icon_active');
				}, 50);
				sidebarCnt.html(favLength);
			} else {
				setTimeout(function () {
					sidebarIcon.removeClass('sidebar-favorites__icon_active');
				}, 60);
				sidebarCnt.html('0');
			}
			toggleSidebarButtons();
		}

		findFavorites();
		// if ($('.full-slider').length > 1) {
		$('.beautiful-slider .beautiful-slide').shuffle();

		$('.full-slider').each(function (_this) {

			return function (index, element) {

				var appender = $(element).siblings('.container').children('.slider-navigation');
				if (!appender.length) {
					appender = $(element).siblings('.slider-navigation');
				}
				var slickSlider = $(element).slick({
					cssEase: 'ease-out',
					infinite: true,
					// infinite: false,
					speed: 1000,
					// autoplay: true,
					// autoplaySpeed: 8000,
					centerMode: true,
					slidesToShow: 7,
					slidesToScroll: 7,
					variableWidth: true,
					arrows: false,
					lazyLoad: 'ondemand',
					// appendArrows: appender,
					// prevArrow: fullSliderNavLeft,
					// nextArrow: fullSliderNavRight,
					responsive: [{
						breakpoint: 1980,
						settings: {
							slidesToShow: 5,
							slidesToScroll: 5,
							speed: 600
						}
					}, {
						breakpoint: 1460,
						settings: {
							slidesToShow: 3,
							speed: 450
						}
					}, {
						breakpoint: 860,
						settings: {
							slidesToShow: 1,
							speed: 300
						}
					}]
				}).on('afterChange', function () {
					bLazy.revalidate();
				});;

				var changeInterval = setInterval(function () {
					slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').currentSlide + slickSlider.slick('getSlick').options.slidesToShow);
				}, 8000);

				var fullSliderNavLeft = $('<button>', {
					"type": "button",
					"data-role": "none",
					"class": "full-slider__arrow slick-prev",
					"aria-label": "Previous",
					"role": "button"
				}).append($('<i>', {
					"class": "fa fa-angle-left"
				})).on('click', function (e) {
					if (slickSlider.slick('getSlick').currentSlide < slickSlider.slick('getSlick').options.slidesToShow) {
						slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').slideCount - slickSlider.slick('getSlick').options.slidesToShow);
					} else {
						slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').currentSlide - slickSlider.slick('getSlick').options.slidesToShow);
					}
					clearInterval(changeInterval);
					changeInterval = setInterval(function () {
						slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').currentSlide + slickSlider.slick('getSlick').options.slidesToShow);
					}, 8000);
				});

				var fullSliderNavRight = $('<button>', {
					"type": "button",
					"data-role": "none",
					"class": "full-slider__arrow slick-next",
					"aria-label": "Previous",
					"role": "button"
				}).append($('<i>', {
					"class": "fa fa-angle-right"
				})).on('click', function (e) {
					slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').currentSlide + slickSlider.slick('getSlick').options.slidesToShow);
					clearInterval(changeInterval);
					changeInterval = setInterval(function () {
						slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').currentSlide + slickSlider.slick('getSlick').options.slidesToShow);
					}, 8000);
				});

				$(element).hover(function () {
					clearInterval(changeInterval);
				}, function () {
					changeInterval = setInterval(function () {
						slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').currentSlide + slickSlider.slick('getSlick').options.slidesToShow);
					}, 8000);
				});

				appender.append([fullSliderNavLeft, fullSliderNavRight]);
			};
		}(this));
		// } else {
		// 	$('.full-slider').slick({
		// 		cssEase: 'ease-out',
		// 		infinite: true,
		// 		speed: 300,
		// 		centerMode: true,
		// 		slidesToShow: 7,
		// 		variableWidth: true,
		// 		arrows: false,
		// 		// appendArrows: $('.slider-navigation'),
		// 		// prevArrow: '<button type="button" data-role="none" class="full-slider__arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
		// 		// nextArrow: '<button type="button" data-role="none" class="full-slider__arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>',
		// 		responsive: [
		// 			{
		// 				breakpoint: 1970,
		// 				settings: {
		// 					slidesToShow: 5
		// 				}
		// 			},{
		// 				breakpoint: 1460,
		// 				settings: {
		// 					slidesToShow: 3
		// 				}
		// 			},{
		// 				breakpoint: 860,
		// 				settings: {
		// 					slidesToShow: 1
		// 				}
		// 			}
		// 		]
		// 	});


		// }

		// $('.full-slider').on('afterChange', function () {
		// 	bLazy.revalidate();
		// });

		function fillRange(current, all) {
			var slideCurrent = $('.search-slider-info__current');
			var slideAll = $('.search-slider-info__all');

			slideCurrent.text(current);
			slideAll.text(all);
		}

		$('.search-slider').each(function (_this) {
			return function (index, element) {

				var appender = $(element).siblings('.slider-navigation');
				var searchSlider = $(element);

				searchSlider.on('init', function (slick) {
					var slider = $(this);
					setTimeout(function () {

						var active = slider.find('.slick-active').length;
						var all = Math.ceil(slider.find('.search-slider__item').length / active);

						fillRange(1, all);
					}, 10);
				});

				searchSlider.slick({
					cssEase: 'ease-out',
					infinite: false,
					// swipe: false,
					speed: 300,
					slidesToShow: 3,
					slidesToScroll: 3,
					appendArrows: appender,
					prevArrow: '<button type="button" data-role="none" class="full-slider__arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
					nextArrow: '<button type="button" data-role="none" class="full-slider__arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>',
					// lazyLoad: 'ondemand',
					// arrows: false,
					responsive: [{
						breakpoint: 1670,
						settings: {
							slidesToShow: 2,
							slidesToScroll: 2
						}
					}, {
						breakpoint: 1280,
						settings: {
							slidesToShow: 3,
							slidesToScroll: 3
						}
					}, {
						breakpoint: 992,
						settings: {
							slidesToShow: 2,
							slidesToScroll: 2
						}
					}, {
						breakpoint: 768,
						settings: {
							slidesToShow: 1,
							slidesToScroll: 1
						}
					}]
				}).on('afterChange reInit', function (event, slick, currentSlide, nextSlide) {

					var all = Math.ceil(slick.slideCount / slick.options.slidesToShow);
					var active = Math.ceil((slick.currentSlide + 1) / slick.options.slidesToShow);

					fillRange(active, all);
				});

				// .on('afterChange', function () {
				// 	bLazy.revalidate();
				// });
				// $(element).slick("setOption", 'appendArrows', appender, true);
			};
		}(this));

		gridSliderSettings = {
			cssEase: 'ease-out',
			infinite: false,
			speed: 300,
			slidesToShow: 4,
			prevArrow: '<button type="button" data-role="none" class="full-slider__arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
			nextArrow: '<button type="button" data-role="none" class="full-slider__arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>',
			responsive: [{
				breakpoint: 1280,
				settings: {
					slidesToShow: 3
				}
			}, {
				breakpoint: 992,
				settings: {
					slidesToShow: 2
				}
			}, {
				breakpoint: 768,
				settings: {
					slidesToShow: 1
				}
			}]
		};

		$('.grid-slider').each(function (_this) {
			return function (index, element) {
				var appender;
				appender = $(element).siblings('.slider-navigation');
				$(element).slick({
					cssEase: 'ease-out',
					infinite: false,
					speed: 300,
					slidesToShow: 4,
					appendArrows: appender,
					prevArrow: '<button type="button" data-role="none" class="full-slider__arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
					nextArrow: '<button type="button" data-role="none" class="full-slider__arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>',
					responsive: [{
						breakpoint: 1280,
						settings: {
							slidesToShow: 3
						}
					}, {
						breakpoint: 992,
						settings: {
							slidesToShow: 2
						}
					}, {
						breakpoint: 768,
						settings: {
							slidesToShow: 1
						}
					}]
				});
				// $(element).slick("setOption", 'appendArrows', appender, true);
			};
		}(this));

		settingsSlick = {
			cssEase: 'ease-out',
			infinite: true,
			speed: 300,
			slidesToShow: 4,
			appendArrows: $('.similar-slider-navigation'),
			prevArrow: '<button type="button" data-role="none" class="complex-similar__arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
			nextArrow: '<button type="button" data-role="none" class="complex-similar__arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>',
			responsive: [{
				breakpoint: 767,
				settings: {
					variableWidth: true
				}
			}, {
				breakpoint: 992,
				settings: {
					slidesToShow: 3
				}
			}]
		};

		var reviewAvatars = $('.review__avatars');
		var reviewItems = $('.review__items');

		reviewItems.slick({
			speed: 300,
			slidesToShow: 1,
			arrows: false,
			fade: true,
			swipe: false,
			adaptiveHeight: true
		});

		reviewAvatars.on('init', function (slick) {
			if (isMobile) {
				reviewItems.slick('slickPrev');
			}
		});

		reviewAvatars.slick({
			speed: 300,
			slidesToShow: 2,
			infinite: true,
			focusOnSelect: true,
			prevArrow: '<button type="button" data-role="none" class="review__arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
			nextArrow: false,
			responsive: [{
				breakpoint: 992,
				settings: {
					slidesToShow: 1,
					slidesToScroll: 1,
					arrows: false
				}
			}]
		}).on('beforeChange', function (event, slick, currentSlide, nextSlide) {
			if (isMobile) {
				$('.review__items').slick('slickGoTo', nextSlide - 1);
			} else {
				$('.review__items').slick('slickGoTo', nextSlide);
			}
		});

		// $('.gallery-slider').slick({
		// 	speed: 300,
		// 	slidesToShow: 1,
		// 	arrows: false,
		// 	fade: true,
		// 	asNavFor: '.gallery-slider-prevs',
		// 	adaptiveHeight: true
		// });

		// $('.gallery-slider-prevs').slick({
		// 	speed: 300,
		// 	slidesToShow: 4,
		// 	slidesToScroll: 4,
		// 	arrows: false,
		// 	focusOnSelect: true,
		// 	asNavFor: '.gallery-slider',
		// 	responsive: [
		// 		{
		// 			breakpoint: 767,
		// 			settings: {
		// 				slidesToShow: 4,
		// 				slidesToScroll: 1,
		// 				arrows: false
		// 			}
		// 		}
		// 	]
		// });

		$('.slider-plans').each(function () {
			var $this = $(this);
			$this.slick({
				speed: 300,
				slidesToShow: 3,
				slidesToScroll: 1,
				infinite: false,
				prevArrow: '<button type="button" data-role="none" class="slider-plans__arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
				nextArrow: '<button type="button" data-role="none" class="slider-plans__arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>',
				responsive: [{
					breakpoint: 768,
					settings: {
						slidesToShow: 2
					}
				}, {
					breakpoint: 500,
					settings: {
						slidesToShow: 1
					}
				}]
			});
		});

		// $('.slider-plans')

		$('.section-slider').on('init', function (event, slick) {
			if (slick.$slides.length < 2) {
				$('.section-slider-navigation').hide();
				$('.section-slider-thumbnails').hide();
			}
		});

		$('.section-slider').slick({
			slidesToShow: 1,
			centerMode: true,
			variableWidth: true,
			arrows: false,
			asNavFor: '.section-slider-thumbnails',
			lazyLoad: 'progressive'
		});

		// $('.section-slider-thumbnails, .section-slider, .section-slider-navigation').addClass('loading')
		var sliderTimeout;

		$('.section-slider').on('lazyLoaded', function (event, slick, image, imageSource) {
			var sliderNum = slick.$slides.length;
			var loadedImageNum = slick.$slides.find('img:not(.slick-loading)').length;

			if (sliderNum == loadedImageNum) {
				clearTimeout(sliderTimeout);
				sliderTimeout = setTimeout(slidesLoaded, 100);
			}
		});
		slidesLoaded();
		function slidesLoaded() {
			$('.section__preloader').addClass('section__preloader_hidden');
			$('.section-slider-thumbnails, .section-slider, .section-slider-navigation').addClass('loaded');

			// console.log('loaded!')
		}

		// function lazyLoader(event, slick, image, imageSource) {
		// 	console.log(slick);
		// };

		$('.section-slider-navigation .slick-arrow_left').on('click', function () {
			return $('.section-slider').slick('slickPrev');
		});

		$('.section-slider-navigation .slick-arrow_right').on('click', function () {
			return $('.section-slider').slick('slickNext');
		});

		$('.section-slider-thumbnails').slick({
			slidesToShow: 4,
			arrows: false,
			asNavFor: '.section-slider',
			focusOnSelect: true,
			swipe: false
		});

		$(window).resize(function () {
			var buttonItems, thumbnail;

			buttonItems = $('.section__bottom .col-md-11 .button');
			thumbnail = $('.section-slider-thumbnails');

			if (buttonItems.length > 3) {
				thumbnail.slick('slickSetOption', 'slidesToShow', 2, true);
				thumbnail.css({
					width: '230px'
				});
			} else {
				if ($(window).outerWidth(true) < 1360) {
					thumbnail.slick('slickSetOption', 'slidesToShow', 3, true);
				} else {
					thumbnail.slick('slickSetOption', 'slidesToShow', 4, true);
				}
			}
		}).resize();

		$('.section-slider').lightGallery({
			thumbnail: true,
			hash: false,
			download: false,
			loop: true,
			exThumbImage: 'data-src',
			selector: '.section-slider__item:not(.slick-cloned) .light-gallery'
		});

		$('.light-gallery-zoom').on('click', function (e) {
			e.preventDefault();
			$('.section-slider .slick-center .light-gallery').click();
		});

		$('.plans-cottege__container').lightGallery({
			thumbnail: false,
			hash: false,
			selector: '.light-zoom'
		});

		$('.complex__slider').slick({
			slidesToShow: 1,
			swipe: false,
			prevArrow: '<button type="button" data-role="none" class="slick-arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
			nextArrow: '<button type="button" data-role="none" class="slick-arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>',
			lazyLoad: 'ondemand'
		});

		$('.complex__slider .slick-arrow').on('click', function (e) {
			e.preventDefault();
		});

		// $('.overflow-line__slider').slick({
		// 	slidesToShow: 3,
		// 	arrows: false,
		// 	infinite: true,
		// 	responsive: [
		// 		{
		// 			breakpoint: 1880,
		// 			settings: {
		// 				slidesToShow: 5
		// 			}
		// 		}, {
		// 			breakpoint: 1580,
		// 			settings: {
		// 				slidesToShow: 4
		// 			}
		// 		}, {
		// 			breakpoint: 1330,
		// 			settings: {
		// 				slidesToShow: 3
		// 			}
		// 		}, {
		// 			breakpoint: 1110,
		// 			settings: {
		// 				slidesToShow: 2
		// 			}
		// 		}, {
		// 			breakpoint: 768,
		// 			settings: {
		// 				slidesToShow: 1
		// 			}
		// 		}
		// 	]
		// });

		$('.overflow-line__slider').each(function (index, element) {
			slider = $(element);
			slides = slider.find('.overflow-line__slider-item');

			if (slides.length >= 6) {
				slider.slick({
					slidesToShow: 6,
					arrows: false,
					infinite: true,
					responsive: [{
						breakpoint: 1880,
						settings: {
							slidesToShow: 5
						}
					}, {
						breakpoint: 1580,
						settings: {
							slidesToShow: 4
						}
					}, {
						breakpoint: 1330,
						settings: {
							slidesToShow: 3
						}
					}, {
						breakpoint: 1110,
						settings: {
							slidesToShow: 2
						}
					}, {
						breakpoint: 768,
						settings: {
							slidesToShow: 1
						}
					}]
				});
			} else {
				slider.slick({
					slidesToShow: slides.length > 1 ? slides.length : 1,
					arrows: false,
					infinite: true,
					responsive: [{
						breakpoint: 1880,
						settings: {
							slidesToShow: slides.length > 4 ? 5 : slides.length <= 4 ? slides.length : 1
						}
					}, {
						breakpoint: 1580,
						settings: {
							slidesToShow: slides.length > 3 ? 4 : slides.length <= 3 ? slides.length : 1
						}
					}, {
						breakpoint: 1330,
						settings: {
							slidesToShow: slides.length > 2 ? 3 : slides.length <= 2 ? slides.length : 1
						}
					}, {
						breakpoint: 1110,
						settings: {
							slidesToShow: slides.length > 1 ? 2 : slides.length <= 1 ? slides.length : 1
						}
					}, {
						breakpoint: 768,
						settings: {
							slidesToShow: 1
						}
					}]
				});
			}
		});

		var beautifulNames = [];

		$('.beautiful-slide').each(function (i, e) {
			var $el = $(e);
			var $name = $el.find('.beautiful-slide__header').html();

			beautifulNames.push($name);
		});

		beautifulNames.reverse();

		$('.beautiful-navigation__list li').each(function (i, e) {
			var $el = $(e);
			var $name = beautifulNames.pop();

			$el.empty().html($name);
		});

		beautifulSlick = $('.beautiful-slider').slick({
			slidesToShow: 1,
			fade: true,
			arrows: false,
			adaptiveHeight: true
		}).on('beforeChange', function (event, slick, currentSlide, nextSlide) {
			$('.beautiful-navigation__list li').removeClass('active').eq(nextSlide).addClass('active');
		});

		$('.beautiful-navigation__list li').on('click', function (e) {
			// console.log($(this).index())
			// $(this).addClass('active')
			beautifulSlick.slick('slickGoTo', $(this).index());
		});

		//    

		$('.game-partner-slider').slick({
			slidesToShow: 7,
			slidesToScroll: 7,
			variableWidth: true,
			// arrows: false
			prevArrow: '<button type="button" data-role="none" class="full-slider__arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
			nextArrow: '<button type="button" data-role="none" class="full-slider__arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>'
		});

		if ($('.game-rating-slider').hasClass('game-rating-slider_full')) {
			var gameSlides = $('.game-rating-slider__item').length;

			$('.game-rating-slider').slick({
				vertical: true,
				slidesToShow: gameSlides,
				infinite: false,
				arrows: false
			});
		} else {
			$('.game-rating-slider').slick({
				vertical: true,
				slidesToShow: 11,
				slidesToScroll: 7,
				infinite: false,
				prevArrow: '<button type="button" data-role="none" class="game-rating-slider-navigation__arrow game-rating-slider-navigation__arrow_prev slick-prev" aria-label="Previous" role="button"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 53.9 25.8" style="enable-background:new 0 0 53.9 25.8;" xml:space="preserve"><path style="fill:#080808;" d="M27,0l26.6,24c0.4,0.4,0.4,1,0.1,1.4c-0.4,0.4-1,0.4-1.4,0.1L27,2.7L1.7,25.5c-0.4,0.4-1,0.3-1.4-0.1c-0.4-0.4-0.3-1,0.1-1.4L27,0z"/></svg></button>',
				nextArrow: '<button type="button" data-role="none" class="game-rating-slider-navigation__arrow game-rating-slider-navigation__arrow_next slick-next" aria-label="Next" role="button"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 53.9 25.8" style="enable-background:new 0 0 53.9 25.8;" xml:space="preserve"><path style="fill:#080808;" d="M27,25.8L0.3,1.7c-0.4-0.4-0.4-1-0.1-1.4c0.4-0.4,1-0.4,1.4-0.1L27,23.1L52.3,0.3c0.4-0.4,1-0.3,1.4,0.1c0.4,0.4,0.3,1-0.1,1.4L27,25.8z"/></svg></button>',
				arrows: true
			});
		}

		// $('.game-rating-slider').slick({
		// 	vertical: true,
		// 	slidesToShow: 11,
		// 	slidesToScroll: 7,
		// 	infinite: false,
		// 	prevArrow: '<button type="button" data-role="none" class="game-rating-slider-navigation__arrow game-rating-slider-navigation__arrow_prev slick-prev" aria-label="Previous" role="button"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 53.9 25.8" style="enable-background:new 0 0 53.9 25.8;" xml:space="preserve"><path style="fill:#080808;" d="M27,0l26.6,24c0.4,0.4,0.4,1,0.1,1.4c-0.4,0.4-1,0.4-1.4,0.1L27,2.7L1.7,25.5c-0.4,0.4-1,0.3-1.4-0.1c-0.4-0.4-0.3-1,0.1-1.4L27,0z"/></svg></button>',
		// 	nextArrow: '<button type="button" data-role="none" class="game-rating-slider-navigation__arrow game-rating-slider-navigation__arrow_next slick-next" aria-label="Next" role="button"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 53.9 25.8" style="enable-background:new 0 0 53.9 25.8;" xml:space="preserve"><path style="fill:#080808;" d="M27,25.8L0.3,1.7c-0.4-0.4-0.4-1-0.1-1.4c0.4-0.4,1-0.4,1.4-0.1L27,23.1L52.3,0.3c0.4-0.4,1-0.3,1.4,0.1c0.4,0.4,0.3,1-0.1,1.4L27,25.8z"/></svg></button>',
		// 	arrows: true
		// });

		$('.game-rating-slider').on('afterChange', function (event, slick, currentSlide) {
			// console.log()
		});

		var gameTimeline = new TimelineMax();

		$('.game-slider').on('init', function (event, slick) {
			var currentSlide = slick.$slides.eq(0);
			var currentPrize = currentSlide.find('.game-slide__prize');
			var currentAnimation = JSON.parse(JSON.stringify(currentPrize.data('game-animation')));

			gameTimeline.pause(0);
			gameTimeline.clear();
			gameTimeline.restart();
			gameTimeline.fromTo(currentPrize, 0.7, currentAnimation, { x: 0, y: 0, opacity: 1 });
		});

		$('.game-slider').slick({
			slidesToShow: 1,
			autoplay: true,
			autoplaySpeed: 5000,
			fade: true,
			waitForAnimate: true,
			speed: 700,
			prevArrow: '<button type="button" data-role="none" class="game-slider-navigation__arrow game-slider-navigation__arrow_prev slick-prev" aria-label="Previous" role="button"><img src="/local/templates/main/assets/images/icon-left.png"></button>',
			nextArrow: '<button type="button" data-role="none" class="game-slider-navigation__arrow game-slider-navigation__arrow_next slick-next" aria-label="Next" role="button"><img src="/local/templates/main/assets/images/icon-right.png"></i></button>',
			appendArrows: '.game-slider-navigation',
			asNavFor: '.game-slider-thumbnails'
		});

		$('.game-slider-thumbnails').slick({
			slidesToShow: 3,
			asNavFor: '.game-slider',
			focusOnSelect: true,
			arrows: false,
			infinite: $('.game-slider-thumbnails__item').length > 3
		});

		$('.game-slider').on('afterChange', function (event, slick, currentSlide) {
			var currentSlide = slick.$slides.eq(currentSlide % slick.$slides.length);
			var currentPrize = currentSlide.find('.game-slide__prize');
			var currentAnimation = JSON.parse(JSON.stringify(currentPrize.data('game-animation')));

			gameTimeline.pause(0);
			gameTimeline.clear();
			gameTimeline.restart();
			gameTimeline.fromTo(currentPrize, 1, currentAnimation, { x: 0, y: 0, opacity: 1 });
		}).on('beforeChange', function (event, slick, currentSlide, nextSlide) {
			var currentSlide = slick.$slides.eq(currentSlide % slick.$slides.length);
			var currentPrize = currentSlide.find('.game-slide__prize');
			var currentAnimation = JSON.parse(JSON.stringify(currentPrize.data('game-animation')));
			currentAnimation.opacity = 0;
			gameTimeline.to(currentPrize, 1, currentAnimation);

			var tooltip = currentSlide.find('.game-tooltip');
			hideTooltip(tooltip);
		});

		function showTooltip(tooltip) {
			TweenMax.to(tooltip, 0.7, {
				display: 'block',
				opacity: 1
			});
		}

		function hideTooltip(tooltip) {
			TweenMax.to(tooltip, 0.7, {
				display: 'none',
				opacity: 0
			});
		}

		$('.game-baloon__icon').on('click', function (e) {

			var tooltip = $(this).siblings('.game-tooltip');

			if (!tooltip.is(':visible')) {
				showTooltip(tooltip);
			} else {
				hideTooltip(tooltip);
			}
		});
		(function () {

			if ($('.complex-banner').length) {

				var $banner = $('.complex-banner');
				var $bannerTitle = $banner.find('.complex-banner__title');
				var $bannerMinimize = $banner.find('.complex-banner__minimize');
				var $bannerBtn = $banner.find('.complex-banner__btn .button');

				$bannerMinimize.on('click', function (e) {
					e.preventDefault();
					// const $target = $(e.target)
					// console.log($this);

					if ($bannerMinimize.hasClass('_toggled')) {
						$banner.removeClass('_minimized');
						$bannerMinimize.removeClass('_toggled');
						$bannerBtn.show();
						$bannerTitle.show();
						return;
					}

					$banner.addClass('_minimized');
					$bannerMinimize.addClass('_toggled');
					$bannerBtn.hide();
					$bannerTitle.hide();
				});

				if ($('#developer-descr').length) {
					var $descr = $('#developer-descr');
					var $descrCoords = $descr.offset().top;
					$(window).on('scroll', function () {
						if ($(window).scrollTop() + 90 > $descrCoords) {
							$banner.addClass('_show');
						} else {
							$banner.removeClass('_show');
						}
					});
				} else {
					$banner.addClass('_show');
				}
			}

			if ($('.js-navigate').length) {
				$('.js-navigate').on('click', function (e) {
					e.preventDefault();
					var $this = $(e.target);
					var $href = $this.attr('href');
					var $target = $($href);
					$('html, body').animate({ scrollTop: $target.offset().top }, 'slow');
				});
			}

			function randomInteger(min, max) {
				var rand = min - 0.5 + Math.random() * (max - min + 1);
				rand = Math.round(rand);
				return parseInt(rand);
			}

			var $lg, creativeIcon, galleryPopupSetting, initCacke, initializePanorama, navPopupSetting, panoramaInit, showButton;

			$('.js-tooltip').tooltipster({
				contentAsHTML: true,
				animation: 'fade',
				trigger: 'hover',
				maxWidth: 169,
				position: 'right',
				interactive: true
			});

			galleryPopupSetting = {
				infinite: true,
				speed: 300,
				slidesToShow: 1,
				asNavFor: '.js-popup-nav',
				prevArrow: '<button type="button" data-role="none" class="about__arrow slick-prev" aria-label="Previous" role="button"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 72" xml:space="preserve"><path d="M0,36L30,0h2L2,36H0z"/><path d="M2,36l30,36h-2L0,36H2z"/></svg></button>',
				nextArrow: '<button type="button" data-role="none" class="about__arrow slick-next" aria-label="Next" role="button"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 72" xml:space="preserve"><path d="M32,36L2,0H0l30,36H32z"/><path d="M30,36L0,72h2l30-36H30z"/></svg></button>'
			};

			navPopupSetting = {
				slidesToScroll: 1,
				infinite: true,
				dots: false,
				slidesToShow: 4,
				asNavFor: '.js-popup-gallery',
				arrows: false,
				focusOnSelect: true
			};

			$('.js-open-popup').on('click', function (e) {
				var body, dataUrl;
				e.preventDefault();
				dataUrl = $(this).attr('href');
				if ($(this).data('ajax-request')) {
					dataUrl += '&ajax=Y';
				}
				body = $('body');
				body.attr('data-scroll', 'false');
				body.css({
					marginRight: scrollWidth
				});
				return $.get(dataUrl, function (data) {
					var containerPopup, galleryPopup, navPopup, resizecontainer;
					body.append(data);
					containerPopup = $('.popup');
					galleryPopup = $('.js-popup-gallery');
					navPopup = $('.js-popup-nav');
					resizecontainer = function resizecontainer() {
						var popupheight, popupleft, popupwidth, scrollPopup, windowheight, windowwidth;
						popupwidth = $('.popup__container').outerWidth(true);
						popupleft = containerPopup.offset().left;
						popupheight = $('.popup__container').outerHeight(true);
						windowheight = $(window).outerHeight();
						windowwidth = $(window).outerWidth(true);
						if (popupwidth > windowwidth) {
							$('.popup__block').css({
								width: windowwidth - 40
							});
						} else if (popupwidth >= 1200) {
							$('.popup__block').css({
								width: 'auto'
							});
						} else {
							$('.popup__block').css({
								width: windowwidth - 40
							});
						}
						scrollPopup = function scrollPopup() {
							return $('.popup__top').css({
								top: containerPopup.scrollTop(),
								height: windowheight
							});
						};
						scrollPopup();
						containerPopup.scroll(function () {
							return scrollPopup();
						});
						return $(window).resize(function () {
							return scrollPopup();
						});
					};
					setTimeout(function () {
						resizecontainer();
						containerPopup.addClass('popup_active');
						galleryPopup.slick(galleryPopupSetting);
						navPopup.slick(navPopupSetting);
					}, 100);
					$('.js-close-popup').on('click', function (e) {
						e.preventDefault();
						body.attr('data-scroll', 'true');
						body.css({
							marginRight: 0
						});
						containerPopup.removeClass('popup_active');
						galleryPopup.slick('unslick');
						navPopup.slick('unslick');
						return setTimeout(function () {
							return containerPopup.remove();
						}, 600);
					});
					$('.js-top-popup').on('click', function (e) {
						e.preventDefault();
						return containerPopup.animate({
							scrollTop: 0
						}, 400);
					});
					return $(window).resize(function () {
						if ($('.popup').length) {
							return resizecontainer();
						}
					});
				});
			});

			$('.js-slider-plans').lightGallery({
				thumbnail: true,
				selector: '.slider-plans__item a',
				galleryId: $(this).attr('gallery-id'),
				hash: false
			});

			$('.js-show-plans').on('click', function (e) {
				e.preventDefault();
				$(this).closest('.object-plans').find('.slider-plans__item a').click();
			});

			$('.js-object-slider').lightGallery({
				thumbnail: false,
				selector: '.object-slider__img a',
				hash: false
			});

			$('.complex__open-gallery').on('click', function (e) {
				e.preventDefault();
				$('.object-slider__img a').click();
			});

			$('.js-infrastructure').on('click', function (e) {
				var currentTab, self, tab;
				e.preventDefault();
				self = $(this);
				tab = self.attr('href');
				self.parent().find('a').removeClass('infrastructure__title-link_current');
				self.addClass('infrastructure__title-link_current');
				currentTab = self.closest('.infrastructure').find('.infrastructure__item').not(tab);
				currentTab.removeClass('infrastructure__current');
				$(tab).addClass('infrastructure__current');
			});

			panoramaInit = false;

			initializePanorama = function initializePanorama() {
				var item;
				if (panoramaInit) {
					return false;
				}
				item = $('#street-complex');
				$('<iframe/>', {
					width: '100%',
					height: '100%',
					frameborder: '0',
					src: item.data('panorama-position')
				}).appendTo(item);
				return panoramaInit = true;
			};

			if ($('#street-complex:visible').length) {
				initializePanorama();
			}

			if (getRealWidth() > 1279 && $('.search-result__scroll').length) {
				$('.search-result__scroll').outerHeight($(window).height() - $('.filter').outerHeight());
				$('.search-map').outerHeight($(window).height() - $('.filter').outerHeight());
			}

			$(window).resize(function () {
				if (getRealWidth() > 1279 && $('.search-result__scroll').length) {
					$('.search-result__scroll').outerHeight($(window).height() - $('.filter').outerHeight());
					return $('.search-map').outerHeight($(window).height() - $('.filter').outerHeight());
				}
			});

			$('.js-object-slider').slick({
				slidesToShow: 1,
				slidesToScroll: 1,
				arrows: false,
				centerMode: true,
				focusOnSelect: true,
				variableWidth: true,
				asNavFor: '.js-object-nav'
			});

			$('.js-object-nav').slick({
				speed: 300,
				slidesToShow: 4,
				slidesToScroll: 1,
				arrows: false,
				focusOnSelect: true,
				variableWidth: true,
				asNavFor: '.js-object-slider'
			});

			$('.slider-object-navigation .slider-text__arrow_left').on('click', function () {
				return $('.js-object-slider').slick('slickPrev');
			});

			$('.slider-object-navigation .slider-text__arrow_right').on('click', function () {
				return $('.js-object-slider').slick('slickNext');
			});

			$('input.styler').styler();

			$('.search-result__button').on("click", function (e) {
				var $leftSide, $rightSide, direction, element;
				e.preventDefault();
				element = $(this);
				$leftSide = $('.search-result');
				$rightSide = $('.search-map');
				direction = void 0;
				if (element.hasClass('active')) {
					direction = 'right';
					element.removeClass('active');
				} else {
					direction = 'left';
					element.addClass('active');
				}
				TweenMax.to($leftSide, 0.5, {
					x: direction === 'left' ? '-100%' : '0%',
					onStart: function onStart() {
						return element.addClass('disabled');
					},
					onUpdate: function onUpdate() {
						return bigMap.container.fitToViewport();
					},
					onComplete: function onComplete() {
						return element.removeClass('disabled');
					}
				});
				return TweenMax.to($rightSide, 0.5, {
					width: direction === 'left' ? '100%' : '50%'
				});
			});

			function lightGalleryInit() {
				$lg = $('.light_gallery');
				var lightGalleryParams = {
					selector: 'this',
					iframeMaxWidth: '90%',
					videoMaxWidth: '90%',
					hash: false,
					zoom: false,
					download: false,
					height: '100%',
					fullScreen: false,
					videojs: true
				};
				var windowHeight = $(window).outerHeight();

				if (600 <= windowHeight && windowHeight < 720) {
					lightGalleryParams.videoMaxWidth = '1024px';
				} else if (720 <= windowHeight && windowHeight < 900) {
					lightGalleryParams.videoMaxWidth = '1280px';
				} else if (900 <= windowHeight) {
					lightGalleryParams.videoMaxWidth = '1600px';
				}
				$lg.lightGallery(lightGalleryParams);
			}
			lightGalleryInit();

			$(window).on('resize', function () {
				lightGalleryInit();
			});

			$('select.styled').styler({
				singleSelectzIndex: 11,
				selectSmartPositioning: false
			});

			if ($('select#developers_order_select').val() == 'default') {
				$('select#developers_order_select').next(".jq-selectbox__select").addClass('jq-selectbox__select_default');
			}

			showButton = function showButton() {
				var button, footerPosition, position, windowHeight;
				button = void 0;
				footerPosition = void 0;
				position = void 0;
				windowHeight = void 0;
				position = $(window).scrollTop();
				windowHeight = $(window).height();
				button = $('.sidebar__up');
				if (position > 200) {
					return button.removeClass('sidebar__up_hidden');
				} else {
					return button.addClass('sidebar__up_hidden');
				}
			};

			$(window).on("scroll", function (e) {
				return showButton();
			}).scroll();

			$('.sidebar__up').on("click", function (e) {
				e.preventDefault();
				return TweenLite.to(window, 1.5, {
					scrollTo: {
						y: 0
					},
					ease: Power2.easeOut
				});
			});

			creativeIcon = function creativeIcon() {
				var tl;
				tl = new TimelineMax({
					repeat: -1
				});
				tl.set('#outline', {
					drawSVG: '0%'
				});
				tl.to('#outline', 0.2, {
					drawSVG: '11% 25%',
					ease: Linear.easeNone
				});
				tl.to('#outline', 0.5, {
					drawSVG: '35% 70%',
					ease: Linear.easeNone
				});
				return tl.to('#outline', 0.9, {
					drawSVG: '99% 100%',
					ease: Linear.easeNone
				});
			};

			creativeIcon();

			$('.tab-header__item').on('shown.bs.tab', function (e) {
				var idElem;
				idElem = $(this).children('a').attr('href');
				if ($(idElem).find('#street-complex').length) {
					initializePanorama();
				}
				if ($(idElem).find('.slick-slider').length) {
					return $(idElem).find('.slick-slider').each(function (_this) {
						return function (index, element) {
							var options, slider;
							slider = $(element);
							options = slider.slick("getSlick").options;
							slider.slick('unslick');
							slider.slick(options);
							slider.find('.slick-arrow').on('click', function (e) {
								return e.preventDefault();
							});
							if (slider.hasClass('grid-slider')) {
								// console.log(slider,slider.siblings('.slider-navigation'))
								// return slider.slick("setOption", 'appendArrows', slider.siblings('.slider-navigation'), true);
							}
						};
					}(this));
				}
			});

			$('.link-hook').on('click', function (e) {
				var target;
				var top;
				e.preventDefault();

				target = $(this).attr('href');

				if (!$(target).length) {
					return;
				};

				$('.modal').modal('hide');

				if ($('.game-fixed-header').length) {
					top = $(target).offset().top - $('.game-fixed-header').height();
				} else {
					top = $(target).offset().top;
				};

				return TweenLite.to(window, 1.5, {
					scrollTo: {
						y: top
					},
					ease: Power2.easeOut
				});
			});

			initCacke = function initCacke() {
				var mc, s;
				window.cackle_widget = [];
				cackle_widget.push({
					widget: 'Review',
					countContainer: 'count_from_cackle',
					id: 46226
				});
				mc = document.createElement('script');
				mc.type = 'text/javascript';
				mc.async = true;
				mc.src = (document.location.protocol === 'https' ? 'https' : 'http') + '://cackle.me/widget.js';
				s = document.getElementsByTagName('script')[0];
				return s.parentNode.insertBefore(mc, s.nextSibling);
			};

			if ($('#mc-review').length) {
				initCacke();
			}

			//========== object-params__show-all:
			var $paramsBtnShowAll = $('.object-params__show-all');

			if ($paramsBtnShowAll.length) {
				var $paramsShowTarget = $($paramsBtnShowAll.attr('href'));
				var paramsTargetOffsetTop = $paramsBtnShowAll.offset().top;

				$paramsShowTarget.on('shown.bs.collapse', function (e) {
					return $paramsBtnShowAll.text('- C  ');
				}).on('hidden.bs.collapse', function (e) {
					$('html, body').animate({
						scrollTop: paramsTargetOffsetTop - 200
					}, 200);

					return $paramsBtnShowAll.text('+   ');
				});
			}
			//========== object-params__show-all;

			var $paramsBtnProcess = $('.developer-process-btn');

			if ($paramsBtnProcess.length) {
				var $paramsProcessTarget = $($paramsBtnProcess.attr('href'));
				var paramsTargetOffsetTop = $paramsBtnProcess.offset().top;

				$paramsProcessTarget.on('hidden.bs.collapse', function (e) {
					$('html, body').animate({
						scrollTop: paramsTargetOffsetTop - 200
					}, 200);
				});
			}

			$('.object-quality__stars').each(function (_this) {
				return function (index, element) {
					var rating, wrapper;
					wrapper = $(element);
					rating = wrapper.data('quality');
					return wrapper.rateYo({
						numStars: 10,
						maxValue: 10,
						spacing: '8px',
						starWidth: "15px",
						ratedFill: '#333333',
						rating: rating,
						readOnly: true
					});
				};
			}(this));

			$("#developers_order_select, #developers_order_select_by").on("change", function () {
				return $("#developers_filter").submit();
			});

			$('a[data-toggle="collapse"]').each(function (_this) {
				return function (index, element) {
					var elementText, target;
					element = $(element);
					target = element.attr('href');
					elementText = element.text();

					$(target).on('show.bs.collapse', function (e) {
						if (element.data('toggle-element')) {
							$(element.data('toggle-element')).collapse('toggle');
						}
					});

					$(target).on('shown.bs.collapse', function (e) {
						$(target).find($('.complex__slider')).slick('setPosition');
						if (element.data('toggle-text')) {
							return TweenLite.to(element, 0.5, {
								text: element.data('toggle-text'),
								ease: Linear.easeNone
							});
						}
					});

					return $(target).on('hide.bs.collapse', function (e) {
						if (element.data('toggle-element')) {
							$(element.data('toggle-element')).collapse('toggle');
						}
						if (element.data('toggle-text')) {
							return TweenLite.to(element, 0.5, {
								text: elementText,
								ease: Linear.easeNone
							});
						}
					});
				};
			}(this));

			$('#sort_select, #sort_select_by').on('change', function () {
				return $("#sort_form").submit();
			});

			$('.ns-logotype_hoverable').bind('mouseenter', function (e) {

				if ($('.menu__container_active').length) {
					return;
				}
				TweenMax.to($('.ns-logotype__text', e.currentTarget), .375, {
					opacity: 1,
					x: $('.sidebar .ns-logotype').outerWidth(),
					ease: Expo.easeOut,
					onStart: function onStart() {
						$('.ns-logotype__text', e.currentTarget).css({ visibility: 'visible' });
					}
				});
			}).bind('mouseleave', function (e) {

				// if($('.menu__container_active').length){
				//  return;
				// }
				TweenMax.to($('.ns-logotype__text', e.currentTarget), .375, {
					opacity: 0,
					x: 0,
					ease: Expo.easeOut,
					onComplete: function onComplete() {
						$('.ns-logotype__text', e.currentTarget).css({ visibility: 'hidden' });
					}
				});
			});

			var morphEl = $('#morph-shape');
			var morphPath = morphEl.find('path');
			var openPath = morphEl.data('morph-open');
			var initialPath = morphPath.attr('d');
			// s = Snap(morphEl.find('svg')[0]);
			// path = s.select('path');
			// initialPath = path.attr('d');
			// steps = morphEl.data('morph-open').split(';');


			menuHide = function menuHide(e) {
				TweenMax.set($('.menu__close'), {
					opacity: 0
				});
				TweenMax.set($(".menu__list .panel"), {
					opacity: 0,
					y: 20
				});

				TweenMax.to($('.menu'), 0.4, {
					x: '-100%',
					ease: Power2.easeOut,
					onStart: function onStart() {
						return $('.menu-link').removeClass('menu-link_active');
					},
					onComplete: function onComplete() {
						$('.menu').removeClass('menu_active');
						$('.menu__container').removeClass('menu__container_active');
						morphEl.removeClass('morph-shape_active');
						morphPath.attr('d', initialPath);
						$('.sidebar__up').removeClass('sidebar__up_hidden_yet');
					}
				});
			};

			menuShow = function menuShow(e) {
				var timeline;
				timeline = new TimelineMax();
				timeline.pause(0);
				timeline.play();

				timeline.fromTo($('.menu'), 0.4, {
					x: '-100%',
					y: isMobile ? 60 : 0
				}, {
					x: '0%',
					y: isMobile ? 60 : 0,
					ease: Power3.easeOut,
					onStart: function onStart() {
						$('.menu-link').addClass('menu-link_active');
						$('.menu').toggleClass('menu_active');
						$('.sidebar__up').addClass('sidebar__up_hidden_yet');
					}
				});

				timeline.to(morphPath, 0.4, {
					morphSVG: { shape: openPath },
					onComplete: function onComplete() {
						$('.menu__container').addClass('menu__container_active');
						morphEl.addClass('morph-shape_active');
					}
				}, '-=0.4');

				timeline.fromTo($('.menu__close'), 0.2, {
					opacity: 0
				}, {
					opacity: 1,
					ease: Power3.easeOut
				});

				timeline.staggerFromTo($(".menu__list .panel"), 0.4, {
					opacity: 0,
					y: 20
				}, {
					opacity: 1,
					y: 0,
					ease: Power3.easeOut
				}, 0.1, '-=0.25');
			};

			$('.menu-link').on("click", function (e) {
				e.preventDefault();

				if ($(this).hasClass('menu-link_active')) {
					menuHide();
				} else {
					menuShow();
				}
			});

			$('.menu__close').on("click", function (e) {
				e.preventDefault();
				menuHide();
			});

			$('.menu__header').on("click", function (e) {
				// e.preventDefault();
				var menu_wrap = $('.menu__container');
				var menu_item = $(this);
				var scroll = menu_item.offset().top - $('.menu__container').offset().top;

				if (scroll <= 10) {
					scroll = 0;
				}

				menu_item.closest('.panel').find('.panel-collapse').on('shown.bs.collapse', function () {
					menu_wrap.animate({
						scrollTop: scroll
					}, 0);
				});
			});

			$(document).on('click', function (e) {

				if (!$('.menu').is(e.target) && $('.menu').has(e.target).length === 0) {

					if ($('.menu').hasClass('menu_active')) {
						// console.log('clicked')
						menuHide();
					}
				}
			});

			$.widget("custom.catcomplete", $.ui.autocomplete, {
				_create: function _create() {
					this._super();
					this.widget().menu("option", "items", "> :not(.ui-autocomplete-category)");
				},
				_renderMenu: function _renderMenu(ul, items) {
					var that = this,
					    currentCategory = "";
					if (!items) {
						return;
					}
					$.each(items, function (index, item) {
						var li;

						if ($('.library').length) {
							ul.append("<li class='ui-autocomplete-category'>" + item.book_author + "</li>");
						}

						if (item.type_name != currentCategory && item.type_name) {
							ul.append("<li class='ui-autocomplete-category'>" + item.type_name + "</li>");
							currentCategory = item.type_name;
						}

						li = that._renderItemData(ul, item);

						if (item.type_name && item.url) {
							if ($('.map-search').length) {

								var span = $("<span/>", {
									html: item.label
								});
								li.html(span);
							} else {

								var link = $("<a/>", {
									href: item.url,
									html: item.label
								});

								if (item.type == "aero") {
									link.lightGallery({
										selector: 'this',
										iframeMaxWidth: '90%',
										videoMaxWidth: '90%',
										hash: false,
										zoom: false,
										download: false,
										height: '100%',
										fullScreen: false,
										videojs: true
									});
								} else if (item.type == "panorama") {
									link.attr('data-iframe', 'true');
									link.lightGallery({
										selector: 'this',
										iframeMaxWidth: '90%',
										videoMaxWidth: '90%',
										hash: false,
										zoom: false,
										download: false,
										height: '100%',
										fullScreen: false,
										videojs: true
									});
								}

								li.html(link);
							}

							li.attr("aria-label", item.type_name + " : " + item.label);
						} else if (item.type_name) {
							li.attr("aria-label", item.type_name + " : " + item.label);
						} else if (item.book_name) {
							var span = $("<span/>", {
								html: item.book_name
							});
							li.html(span);

							li.attr("aria-label", item.book_author + " : " + item.book_name);
						}
					});
				}
			});

			var itemsData;

			$(".input-autocomplete").each(function (i, el) {

				var element = $(el),
				    dropdown = element.siblings('.input-dropdown'),
				    list = dropdown.find('.input-dropdown__list'),
				    wrapper = element.closest('.input-wrapper'),
				    icon = element.siblings('.filter-input__icon');

				element.catcomplete(_defineProperty({
					delay: 250,
					source: itemsData,
					appendTo: list,
					minLength: 0,
					open: function open(event, ui) {
						wrapper.addClass('active');
						positionCalc(element, dropdown);
						TweenMax.fromTo(dropdown, 0.2, { scale: 0, opacity: 0, transformOrigin: "top center" }, { scale: 1, opacity: 1 });
					},
					close: function close(event, ui) {
						TweenMax.fromTo(dropdown, 0.2, { scale: 1, opacity: 1, transformOrigin: "top center" }, {
							clearProps: "all", scale: 0, opacity: 0, onComplete: function onComplete() {
								wrapper.removeClass('active');
							}
						});
					},
					select: function select(event, ui) {
						if (element.closest('.library-search').length) {
							element.val(ui.item.value);
						}
						if (element.closest('.filter_high').length) {
							element.val(ui.item.value);
							filter.submit();
						}
						if (element.closest('#compare-form').length) {
							element.attr("data-building", ui.item.id);
							compareSearch.getObject(ui.item.id);
						}
					}
				}, "source", function source(request, response) {

					if (element.val() != "") {
						$.ajax({
							dataType: 'html',
							url: element.data('search-url'),
							// dataType: "jsonp",
							data: {
								q: request.term,
								t: element.data('type-search')
							},
							success: function success(data) {
								data = JSON.parse(data);
								response(data.length === 1 && data[0].length === 0 ? [] : data);
								if (element.is('[data-building]')) {
									if (data.length === 1) {
										element.attr('data-building', data[0].id);
									} else element.attr('data-building', '');
								}
							}
						});
					} else if (element.data('search-empty-url')) {
						$.ajax({
							dataType: 'html',
							url: element.data('search-empty-url'),
							// dataType: "jsonp",
							data: {
								q: request.term,
								t: element.data('type-search')
							},
							success: function success(data) {
								data = JSON.parse(data);
								response(data.length === 1 && data[0].length === 0 ? [] : data);
							}
						});
					}
				}));

				element.on('focus', function () {
					element.catcomplete("search");
					// }
				}).on('input', function () {
					if (element.val() != "") {
						icon.addClass('filter-input__icon_active').on('click', function (e) {
							e.preventDefault();
							element.val('');
							icon.removeClass('filter-input__icon_active');
						});
					} else {
						icon.removeClass('filter-input__icon_active').off();
					}
				});
			});
			// .on( "autocompleteselect", function( event, ui ) {
			// 	console.log(event,ui)
			// } );

			seoBlockStart = $('#seo-text-start');
			seoBlockEnd = $('#seo-text-end');
			seoBlockEnd.html(seoBlockStart.detach());

			var roundTimeline = new TimelineMax(),
			    headerSplitText,
			    textSplitText,
			    linkSplitText,
			    blagoslovenieNaAnimation = true;

			window.showOverlay = function (button) {

				if (!blagoslovenieNaAnimation) {
					return;
				}
				var roundOverlay = button.parents('.round-overlay'),
				    roundButton = roundOverlay.find('.round-overlay__button-info'),
				    roundClose = roundOverlay.find('.round-overlay__button-close'),
				    roundWrapper = roundOverlay.find('.round-overlay__wrapper'),
				    roundHeader = roundOverlay.find('.round-overlay__header'),
				    roundText = roundOverlay.find('.round-overlay__text'),
				    roundLink = roundOverlay.find('.round-overlay__link'),
				    roundBackground = roundOverlay.find('.round-overlay__background');

				blagoslovenieNaAnimation = false;

				roundTimeline.clear().time(0);

				roundOverlay.addClass('round-overlay_active');
				TweenLite.set(roundWrapper, { display: "block", opacity: 1 });

				headerSplitText = new SplitText(roundHeader, { type: "lines" });
				textSplitText = new SplitText(roundText, { type: "lines" });
				linkSplitText = new SplitText(roundLink, { type: "lines" });
				// console.log(headerSplitText)

				headerChars = headerSplitText.lines;
				textChars = textSplitText.lines;
				linkChars = linkSplitText.lines;

				var diameterValue = Math.sqrt(Math.pow(roundOverlay.height(), 2) + Math.pow(roundOverlay.width(), 2)) * 2;

				roundTimeline.to(roundBackground, 0.5, {
					width: diameterValue,
					height: diameterValue,
					right: -(diameterValue / 2),
					bottom: -(diameterValue / 2)
				});

				roundTimeline.to(roundButton, 0.3, { scale: 0 }, '-=0.5');
				roundTimeline.to(roundClose, 0.3, { scale: 1 }, '-=0.3');

				roundTimeline.staggerFrom(headerChars, 0.3, { opacity: 0, scale: 0, rotationX: -120, force3D: true, transformOrigin: "center left -30" }, 0.1, '-=0.2').staggerFrom(textChars, 0.2, { opacity: 0, scale: 0, rotationX: -120, force3D: true, transformOrigin: "center left -30" }, 0.1).staggerFrom(linkChars, 0.3, { opacity: 0, scale: 0, rotationX: -120, force3D: true, transformOrigin: "center left -30", onComplete: function onComplete() {
						headerSplitText.revert();
						textSplitText.revert();
						linkSplitText.revert();
						blagoslovenieNaAnimation = true;
					} }, 0.1);
			};

			window.hideOverlay = function (button) {

				if (!blagoslovenieNaAnimation) {
					return;
				}
				var roundOverlay = button.parents('.round-overlay'),
				    roundButton = roundOverlay.find('.round-overlay__button-info'),
				    roundClose = roundOverlay.find('.round-overlay__button-close'),
				    roundWrapper = roundOverlay.find('.round-overlay__wrapper'),
				    roundHeader = roundOverlay.find('.round-overlay__header'),
				    roundText = roundOverlay.find('.round-overlay__text'),
				    roundLink = roundOverlay.find('.round-overlay__link'),
				    roundBackground = roundOverlay.find('.round-overlay__background');

				blagoslovenieNaAnimation = false;

				roundTimeline.clear().time(0);

				TweenLite.set(roundWrapper, { display: "block" });
				roundTimeline.to(roundWrapper, 0.2, { opacity: 0 });

				roundTimeline.to(roundBackground, 0.3, {
					width: '0px',
					height: '0px',
					right: '20px',
					bottom: '20px',
					onComplete: function onComplete() {
						roundOverlay.removeClass('round-overlay_active');
					}
				});

				roundTimeline.to(roundButton, 0.3, { scale: 1 }, '-=0.3');
				roundTimeline.to(roundClose, 0.3, { scale: 0, onComplete: function onComplete() {
						blagoslovenieNaAnimation = true;
					} }, '-=0.3');
			};

			$('.round-overlay__button-info').on('click', function () {
				showOverlay($(this));
			});

			$('.round-overlay__button-close').on('click', function () {
				hideOverlay($(this));
			});

			$('.navigation').on('click', function (e) {
				// console.log(e.target)

				if (!$(e.target).is('.ns-logotype') && !$(e.target).parents('.ns-logotype').length && !$(e.target).is('.menu-link') && !$(e.target).parents('.menu-link').length) {

					if (isMobile) {
						return TweenLite.to(window, 1.5, {
							scrollTo: {
								y: 0
							},
							ease: Power2.easeOut
						});
					}
				}
			});

			var fixedSection = $('.section_fixed-head');
			var sectionFull = $('.section_full-height');
			var sectionFuller = $('.button_small.button_transparent-animate');

			function fixedMenu() {
				if (isMobile) return;

				if ($(window).scrollTop() > 0) {
					fixedSection.addClass('scroll');
					fixedSection.addClass('active');

					// if($(window).scrollTop() > sectionFull.outerHeight()){
					//  fixedSection.addClass('active')
					//  sectionFuller.addClass('showbtn')
					// }else{
					//  fixedSection.removeClass('active')
					//  sectionFuller.removeClass('showbtn')
					// }
				} else {
					fixedSection.removeClass('scroll');
					fixedSection.removeClass('active');
					sectionFuller.removeClass('showbtn');
				}
			}
			fixedMenu();

			$(window).on("resize", function (e) {
				fixedSection = $('.section_fixed-head');
			});

			$(window).on("scroll", function (e) {
				fixedMenu();
			});

			// function

			$('.button_scroller').each(function (index, element) {
				var element = $(element);
				var collapser = element.attr('href');
				// console.log($(collapser).offset().top)

				$(collapser).on('show.bs.collapse', function () {
					setTimeout(function () {
						TweenLite.to(window, 1.5, {
							scrollTo: {
								y: $(collapser).offset().top - 80
							},
							ease: Power2.easeOut
						});
					}, 10);
				});
			});

			$('.btn-scroll-to').each(function (index, element) {
				var $el = $(element);
				var $target = $($el.attr('href'));

				$el.on('click', function (e) {
					e.preventDefault();

					$('.wrapper, body, html').animate({
						scrollTop: $target.offset().top - 80
					}, 1500);
				});
			});

			$('.text-block img[title]').each(function (index, element) {
				var element = $(element);
				var title = element.attr('title');

				var titleImage = $('<div>', {
					class: 'title-image'
				});

				titleImage.insertBefore(element);
				element = element.detach();
				titleImage.append(element);

				var titleImageText = $('<div>', {
					class: 'title-image__text',
					html: title
				}).appendTo(titleImage);
			});

			$('.game-links label').on('click', function (e) {
				TweenLite.to(window, 1.5, {
					scrollTo: {
						y: 0
					},
					ease: Power2.easeOut
				});
			});

			$('.presentation-modal__close').on('click', function (e) {
				var preW = $('.presentation-link').width();
				var preH = $('.presentation-link').height();
				var posT = $('.presentation-link')[0].style.top;
				var posL = $('.presentation-link')[0].style.left;

				TweenMax.to($('.presentation-modal'), 1, {
					top: posT,
					left: posL,
					scale: 0,
					opacity: 0
				});
			});

			$('.presentation-link').on('click', function (e) {
				e.preventDefault();

				TweenMax.to($('.presentation-modal'), 1, {
					top: 100,
					left: 297,
					scale: 1,
					opacity: 1
				});
			});

			// function showModal(modal){

			//  $('html').addClass('modal-open')

			//  TweenMax.to(modal, 1, {
			//      opacity: 1,
			//      display: 'block'
			//  })
			// }

			// function closeModal(modal){

			//  $('html').removeClass('modal-open')

			//  TweenMax.to(modal, 1, {
			//      opacity: 0,
			//      display: 'none'
			//  })
			// }

			// $('.game-modal__close').on('click', function(e){
			//  e.preventDefault();
			// })

			$('.game-account-user__name').on('click', function (e) {
				var dropdown = $(this).siblings('.game-account-user__dropdown').toggleClass('game-account-user__dropdown_active');
			});
			$('.game-account-balance__place').on('click', function (e) {
				var dropdown = $(this).siblings('.game-account-balance__dropdown').toggleClass('game-account-balance__dropdown_active');
			});

			function _showMoneyModal(type, coins, message, total_coins, rating_place, headerMessage) {
				var modalHeader = headerMessage ? headerMessage : coins + ' ' + getPrettyName(coins, ['', '', '']) + ' ' + getPrettyName(coins, ['!', '!', '!']);
				var modalBody = message;
				var totalCoins = '';
				var modalId = '#modal-money';

				if (type === 'hoard') {
					modalId = '#modal-hoard';
				}

				if (typeof total_coins !== 'undefined' && total_coins) {
					totalCoins = total_coins + ' ';
					$('.game-account-balance__num').text(totalCoins);
				}
				$(modalId).find('.game-modal__header').html(modalHeader);
				$(modalId).find('.game-modal__body').html(modalBody);
				$(modalId).modal('show');
			}

			function showMoneyModal(coins, message, total_coins, rating_place, headerMessage) {
				_showMoneyModal('money', coins, message, total_coins, rating_place, headerMessage);
			}

			function showHoardModal(coins, message, total_coins, rating_place, headerMessage) {
				_showMoneyModal('hoard', coins, message, total_coins, rating_place, headerMessage);
			}

			function showModal(id, message, headerMessage) {

				var modalBody = message;
				$(id).find('.game-modal__body').html(modalBody);
				if (headerMessage) {
					$(id).find('.game-modal__header').html(headerMessage);
				}
				$(id).modal('show');
			}

			$('.game-action').on('click', function (e) {
				e.preventDefault();
				var currentActionButton = $(this);
				var gameActionUrl = currentActionButton.data('action-url');
				var gameTask = $(this).parents('.game-task');

				$.ajax({
					method: "POST",
					dataType: 'json',
					url: gameActionUrl,
					success: function success(response, textStatus, jqXHR) {

						var msgString;

						if (typeof response.status !== 'undefined' && response.status === true) {

							if (_typeof(response.data.message) === 'object') {
								msgString = response.data.message.join(' ');
							} else {
								msgString = response.data.message;
							}

							var msgHeader = null;
							if (response.data.header !== 'undefined' && response.data.header.length) {
								msgHeader = response.data.header;
							}

							gameTask.addClass('game-task_disabled');

							currentActionButton.addClass('_hidden');
							// showMoneyModal(response.data.coins,msgString,response.data.total_coins,response.data.rating_place)
							showMoneyModal(response.data.coins, msgString, response.data.total_coins, msgHeader);
						} else if (typeof response.status !== 'undefined') {

							if (typeof response.errors.type !== 'undefined' && response.errors.type.length) {

								if (response.errors.type == "reload") showModal('#modal-login', "  , ,  :");
								return;
							}

							if (typeof response.errors.message !== 'undefined' && response.errors.message.length) {

								if (_typeof(response.errors.message) === 'object') {
									msgString = response.errors.message.join(' ');
								} else {
									msgString = response.errors.message;
								}

								var msgHeader = null;
								if (typeof response.errors.header !== 'undefined' && response.errors.header.length) {
									msgHeader = response.errors.header;
								}

								showModal('#modal-error', msgString, msgHeader);
								return;
							}
						}
					}
				});
			});

			$('.game-modal-form').on('submit', function (e) {
				e.preventDefault();
				var formAction = $(this).attr('action'),
				    modalTarget = $(this).data('open-modal'),
				    data = new FormData(this);

				$.ajax({
					method: "POST",
					url: formAction,
					data: data,
					async: false,
					cache: false,
					contentType: false,
					processData: false,
					success: function success(data, textStatus, jqXHR) {

						var msgString;

						if (data.status) {
							$('.modal').modal('hide');
							if (modalTarget && $(modalTarget).length) {

								if (_typeof(data.data.message) === 'object') {
									msgString = data.data.message.join(' ');
								} else {
									msgString = data.data.message;
								}

								var msgHeader = null;
								if (typeof data.data.header !== 'undefined' && data.data.header.length) {
									msgHeader = data.data.header;
								}

								showModal(modalTarget, msgString, msgHeader);
							}
						} else {
							if (_typeof(data.errors.message) === 'object') {
								msgString = data.errors.message.join(' ');
							} else {
								msgString = data.errors.message;
							}

							var msgHeader = null;
							if (typeof data.errors.header !== 'undefined' && data.errors.header.length) {
								msgHeader = data.errors.header;
							}

							$('.modal').modal('hide');
							showModal('#modal-error', msgString, msgHeader);
						}
					}
				});
			});

			//  $('.game-modal-form').on('submit', function(e){
			//  e.preventDefault();
			//  var formAction = $(this).attr('action')
			//            , data = $(this).serialize()
			//            , modal = $(this).attr('data-modal-id')
			//  $.ajax({
			//      method: "POST",
			//      dataType: 'json',
			//      url: formAction,
			//            data: data,
			//      success: function(data, textStatus, jqXHR){
			//          if(data.status) {
			//              $('.modal').modal('hide')
			//                    if (typeof data.data.messages !== 'undefined'
			//                        && data.data.messages instanceof Array
			//                        && $(modal).length
			//                    ) {
			//                        $(modal).modal('show')
			//                    }
			//          }
			//      }
			//  })

			// })

			var client = new ZeroClipboard($('.button-copy'));

			client.on("ready", function (readyEvent) {

				client.on("aftercopy", function (event) {
					$(event.target).addClass('_pulse').text($(event.target).data('sucscess-copy'));
				});
			});

			$('.modal').on('show.bs.modal', function (e) {

				$('.game-fixed-header').css('marginRight', scrollWidth);
			}).on('hidden.bs.modal', function (e) {

				$('.game-fixed-header').css('marginRight', '');
			});
			// VK.init({apiId: 5887031, onlyWidgets: true});
			// VK.Widgets.Like("vk-button", {type: "button"});
			// VK.Observer.subscribe("widgets.like.shared", function f() {
			//  alert('!');
			// });
			// if (typeof VK !== 'undefined') {

			$('.social-button_game.social-button_vk').on('click', function () {
				var url = $(this).data('url'),
				    data = {
					id: $(this).data('id'),
					social: $(this).data('social')
				};

				$.ajax({
					type: 'POST',
					dataType: 'json',
					url: url,
					data: data,
					success: function success(response, textStatus, jqXHR) {
						var msgString;
						if (typeof response.status !== 'undefined' && response.status === true) {
							if (_typeof(response.data.message) === 'object') {
								msgString = response.data.message.join(' ');
							} else {
								msgString = response.data.message;
							}
							if (typeof gameTask !== "undefined") {
								gameTask.addClass('game-task_disabled');
							}
							if (typeof gameTask !== "undefined") {
								currentActionButton.addClass('_hidden');
							}
							// showMoneyModal(response.data.coins,msgString,response.data.total_coins,response.data.rating_place)
							showMoneyModal(response.data.coins, msgString, response.data.total_coins);
						} else if (typeof response.status !== 'undefined') {
							if (typeof response.errors.type !== 'undefined' && response.errors.type.length) {
								if (response.errors.type == "reload") showModal('#modal-login', "  , ,  :");
								return;
							}
							if (typeof response.errors.message !== 'undefined' && response.errors.message.length) {
								if (_typeof(response.errors.message) === 'object') {
									msgString = response.errors.message.join(' ');
								} else {
									msgString = response.errors.message;
								}
								var msgHeader = null;
								if (typeof response.errors.header !== 'undefined' && response.errors.header.length) {
									msgHeader = response.errors.header;
								}
								showModal('#modal-error', msgString, msgHeader);
								return;
							}
						}
					}
				});
			});
			// }

			$('.game-teaser__close').on('click', function () {
				setCookie('teaser', 'hidden', { path: '/', domain: location.hostname });
				teaserCheck();
			});

			function teaserCheck() {
				if (typeof getCookie('teaser') != 'undefined' && getCookie('teaser') == 'hidden') {
					$('.game-teaser').removeClass('game-teaser_visible');
				} else {
					$('.game-teaser').addClass('game-teaser_visible');
				}
			}
			teaserCheck();

			(function (d, s, id) {
				var js,
				    fjs = d.getElementsByTagName(s)[0];
				if (d.getElementById(id)) {
					return;
				}
				js = d.createElement(s);js.id = id;
				js.src = "//connect.facebook.net/en_US/sdk.js";
				fjs.parentNode.insertBefore(js, fjs);
			})(document, 'script', 'facebook-jssdk');

			window.fbAsyncInit = function () {
				FB.init({
					appId: '1750998848548912',
					status: true,
					cookie: true,
					xfbml: true,
					oauth: true,
					version: 'v2.8'
				});
			};

			$(document).on('click', '.social-button_facebook', function (e) {
				e.preventDefault();
				var btnHref = $(this).attr('href');
				var fhref = btnHref && btnHref !== '#' ? btnHref : location.href;
				var fquote = $(this).data('description') ? $(this).data('description') : null;
				var url = $(this).data('url');
				var data = {
					id: $(this).data('id'),
					social: $(this).data('social')
				};
				FB.ui({
					method: 'share',
					href: fhref,
					quote: fquote
				}, function (response) {
					if (response && !response.error_code) {
						$.ajax({
							type: 'POST',
							dataType: 'json',
							url: url,
							data: data,
							success: function success(response, textStatus, jqXHR) {
								var msgString;
								if (typeof response.status !== 'undefined' && response.status === true) {
									if (_typeof(response.data.message) === 'object') {
										msgString = response.data.message.join(' ');
									} else {
										msgString = response.data.message;
									}
									if (typeof gameTask !== "undefined") {
										gameTask.addClass('game-task_disabled');
									}
									if (typeof gameTask !== "undefined") {
										currentActionButton.addClass('_hidden');
									}
									// showMoneyModal(response.data.coins,msgString,response.data.total_coins,response.data.rating_place)
									showMoneyModal(response.data.coins, msgString, response.data.total_coins);
								} else if (typeof response.status !== 'undefined') {
									if (typeof response.errors.type !== 'undefined' && response.errors.type.length) {
										if (response.errors.type == "reload") showModal('#modal-login', "  , ,  :");
										return;
									}
									if (typeof response.errors.message !== 'undefined' && response.errors.message.length) {
										if (_typeof(response.errors.message) === 'object') {
											msgString = response.errors.message.join(' ');
										} else {
											msgString = response.errors.message;
										}
										var msgHeader = null;
										if (typeof response.errors.header !== 'undefined' && response.errors.header.length) {
											msgHeader = response.errors.header;
										}
										showModal('#modal-error', msgString, msgHeader);
										return;
									}
								}
							}
						});
					} else {

						console.log('error');
					}
				});
			});

			$('.map-header__btn-info').on('click', function (e) {
				e.preventDefault();
				$('#map-info-popup').fadeIn('fast');
			});
			$('.map-info-popup__btn-close').on('click', function (e) {
				e.preventDefault();
				$('#map-info-popup').fadeOut('fast');
			});

			//========== secrets bag:
			(function () {
				var bagClassName = 'secret-bag';
				var hoardClassName = 'secret-hoard';
				var bagApiUrl = '/api/game/secretbag/';
				var hoardApiUrl = '/api/game/secrethoard/';
				/*
     getParent: function -   jQuery- 
     position: object ({top: string, right: string, left: string, bottom: string}) -     
     {
         getParent: function(){
            return $('body');
         },
         position: {}
     }
     */
				var objectPointList = {
					'default': [{
						getParent: function getParent() {
							//return $('.footer > .container');
							return $('.point-bag-footer');
						},
						position: { left: '50%', top: '0px', marginLeft: '-27px' }
					}],
					'new_buliding': [{
						//1.     http://take.ms/lPoYw (         )
						getParent: function getParent() {
							//var $slideList = $('.building-content-corp:first-child .building-content-month:first-child .building-content-item');
							//var count = $slideList.length;
							//
							//if (count > 2) {
							//    return $($slideList[count - 1]);
							//}
							//
							//return $();
							return $('.point-bag-slider');
						},
						position: { right: '10px', bottom: '10px' }
					}, {
						//2.       http://take.ms/qAbC6
						getParent: function getParent() {
							//return $('.tab-pane#tab-2');
							return $('.point-bag-same-price');
						},
						position: { left: randomInteger(15, 85) + '%', bottom: '5px', marginLeft: '-27px' }
					}, {
						//3.   http://take.ms/iJXgx
						getParent: function getParent() {
							//return $('.footer > .container');
							return $('.point-bag-footer');
						},
						position: { left: '50%', top: '0px', marginLeft: '-27px' }
					},
					//4.        http://take.ms/Gxocy
					{
						//5.       
						getParent: function getParent() {
							//return $('.object-params__collapse');
							return $('.point-bag-characteristics');
						},
						position: { right: '0px', bottom: randomInteger(5, 50) + '%', marginTop: '-34px' }
					}, {
						//6.      http://novostroev.ru/novostroyki/moskva/zelao/kryukovo/zelenyy-bor/,            http://take.ms/SXOvr
						getParent: function getParent() {
							//var $tabList = $('.object-tabs-content .tab-pane');
							var $tabList = $('.point-bag-housing');
							var count = $tabList.length;

							if (count > 0) {
								return $($tabList[randomInteger(0, count - 1)]);
							}

							return $();
						},
						position: { left: '25px', bottom: '-350px' }
					}],
					'novostroyki': [{
						// :
						//7.   http://novostroev.ru/novostroyki/moskva/      (http://take.ms/rqLGl)        http://take.ms/5EksU
						// :
						//8.    .
						getParent: function getParent() {
							//return $('.section__content > .container > .row', $('.wrapper > .section')[8]);
							return $('.point-bag');
						},
						position: { top: '50%', right: '-20px', marginTop: '-34px' }
					}],
					'zastroyshchiki': [{
						//9.   http://novostroev.ru/zastroyshchiki/       http://take.ms/8mqIe            .
						getParent: function getParent() {
							//return $('.section__content .tgb-block');
							return $('.point-bag');
						},
						position: { left: '20px', bottom: '-50px' }
					}],
					'reviews': [{
						//10.     http://take.ms/kTQVm     , , .
						getParent: function getParent() {
							//return $('.section_yellow + .section .section__content > .container');
							return $('.point-bag');
						},
						position: { top: '0px', right: '0px' }
					}],
					'news': [{
						//11.       http://take.ms/W28AM        http://take.ms/W28AM
						getParent: function getParent() {
							//return $('.tgb-block');
							return $('.point-bag');
						},
						position: { top: '-40px', left: '0px' }
					}],
					'news-detail': [{
						//12.      http://take.ms/Kwy1u ,      
						//13.      http://take.ms/Kwy1u ,      
						getParent: function getParent() {
							return $('.like-it__buttons');
						},
						position: { top: '50px', left: '280px' }
					}],
					'search': [{
						//14.    http://take.ms/JZPFE
						getParent: function getParent() {
							//return $('.search-result__scroll .list-tags');
							return $('.point-bag-search-1');
						},
						position: { top: '40px', right: '25px' }
					}, {
						//15.   ,   http://take.ms/NAKtz
						getParent: function getParent() {
							//return $('.big-filter__body .big-filter__row')[7];
							return $('.point-bag-search-2');
						},
						position: { top: '100px', right: '50px' }
					}],
					'map-search': [{
						//15.   ,   http://take.ms/NAKtz
						getParent: function getParent() {
							//return $('.big-filter__body .big-filter__row')[7];
							return $('.point-bag-search-2');
						},
						position: { top: '100px', right: '50px' }
					}]
				};

				function checkObject() {
					/*
      response: [status: true/false, errors: [text, text, ... ], data: [url: __, new_buliding => true/false, is_hoard => true/false]]
      __: novostroev.ru/game
      */
					$.ajax({
						url: bagApiUrl,
						type: 'get',
						dataType: 'JSON',
						data: {},
						success: function success(response) {
							if (typeof response.status !== 'undefined' && response.status === true) {
								createObject(response.data);
							} else if (typeof response.status !== 'undefined') {
								if (typeof response.errors.message !== 'undefined' && response.errors.message.length) {
									var msgString;
									var msgHeader;
									if (_typeof(response.errors.message) === 'object') {
										msgString = response.errors.message.join(' ');
									} else {
										msgString = response.errors.message;
									}
									if (typeof response.errors.header !== 'undefined' && response.errors.header.length) {
										msgHeader = response.errors.header;
									}
									showModal('#modal-error', msgString, msgHeader);
								}
							}
						}
					});
				}

				function _validadePoint(point) {
					var result = false,
					    $parent;

					if ((typeof point === "undefined" ? "undefined" : _typeof(point)) === 'object') {
						if ('getParent' in point && typeof point.getParent === 'function') {
							if ('position' in point && _typeof(point.position) === 'object') {
								$parent = point.getParent();
								if ($parent.length) {
									result = true;
								}
							}
						}
					}

					return result;
				}

				function _getPoint(key, i) {
					var result, index, point, arr, count;

					if (key in objectPointList && objectPointList[key].length >= 1) {
						arr = objectPointList[key];
						count = arr.length;

						if (typeof i === 'number' && i >= 0 && i < count) {
							index = i;
						} else if (count === 1) {
							index = 0;
						} else {
							index = randomInteger(0, count - 1);
						}
						point = arr[index];
						if (_validadePoint(point)) {
							result = point;
						} else {
							result = _getPoint('default', 0);
						}
					}

					return result;
				}

				function getPoint(data, index) {
					var key = 'default',
					    url,
					    point;

					if (data.url in objectPointList) {
						key = data.url;
					} else if (data.new_building === true) {
						key = 'new_buliding';
					} else {
						url = data.url.split('/');
						switch (url[1]) {
							case 'novostroyki':
							case 'cottages':
								key = 'novostroyki';
								break;
							case 'zastroyshchiki':
								key = 'zastroyshchiki';
								break;
							case 'reviews':
							case 'aero':
							case 'panorama':
							case 'discounts':
								key = 'reviews';
								break;
							case 'news':
							case 'articles':
								key = 'news';
								break;
							case 'news-detail':
							case 'articles-detail':
								key = 'news-detail';
								break;
							case 'search':
								key = 'search';
								break;
							case 'map-search':
								key = 'map-search';
								break;
						}
					}

					point = _getPoint(key, index);
					if (!_validadePoint(point)) {
						point = _getPoint('default', 0);
					}

					return point;
				}

				function createObject(data) {
					var point, $parent, $object, type, className;

					type = data.is_hoard === true ? 'hoard' : 'bag';
					point = getPoint(data);
					$parent = point.getParent();
					switch (type) {
						case 'hoard':
							className = hoardClassName;
							break;
						default:
							className = bagClassName;
					}
					$object = $('<div>', {
						class: className,
						css: point.position,
						data: {
							url: data.url
						}
					});

					if ($parent.css('position') === 'static') {
						$parent.css('position', 'relative');
					}
					$parent.append($object);

					$(document).on('click', '.' + className, function () {
						useObject(type, $(this));
					});

					return true;
				}

				function useObject(type, $object) {
					var url = $object.data('url');
					var apiUrl;

					switch (type) {
						case 'hoard':
							apiUrl = hoardApiUrl;
							break;
						default:
							apiUrl = bagApiUrl;
					}
					$.ajax({
						url: apiUrl,
						type: 'post',
						dataType: 'JSON',
						data: {
							url: url
						},
						success: function success(response) {
							if (typeof response.status !== 'undefined' && response.status === true) {
								$object.remove();
								switch (type) {
									case 'hoard':
										showHoardModal(response.data.coins, response.data.message, response.data.total_coins, response.data.rating_place, response.data.header);
										break;
									default:
										showMoneyModal(response.data.coins, response.data.message, response.data.total_coins, response.data.rating_place, response.data.header);
								}
							} else if (typeof response.status !== 'undefined') {
								if (typeof response.errors.message !== 'undefined' && response.errors.message.length) {
									var msgString;
									var msgHeader;
									if (_typeof(response.errors.message) === 'object') {
										msgString = response.errors.message.join(' ');
									} else {
										msgString = response.errors.message;
									}
									if (typeof response.errors.header !== 'undefined' && response.errors.header.length) {
										msgHeader = response.errors.header;
									}
									showModal('#modal-error', msgString, msgHeader);
								}
							}
						}
					});
				}

				checkObject();
			})();
			//========== secrets bag;

			//========== panorama popup:
			if ($('.js-panorama-popup').length) {
				$('.js-panorama-popup').click();
			}
			//========== panorama popup;

			//========== links blank:
			(function () {
				if ($('.js-links-blank').length) {
					var $parent = $('.js-links-blank');
					var $links = $('a:not([target="_self"]):not([target="_blank"])', $parent);

					$links.attr('target', '_blank');
				}
			})();
			//========== links blank;


			//========== complex tooltip:
			$('.complex__info-label').tooltipster({
				contentAsHTML: true,
				animation: 'fade',
				trigger: 'hover',
				speed: 200,
				delay: 30,
				maxWidth: 169,
				position: 'right',
				interactive: false,
				functionBefore: function functionBefore(origin, continueTooltip) {
					continueTooltip();

					var style = 'tooltipster-label tooltipster-label_' + origin.data('style');
					if (!style) return false;

					$('.tooltipster-base').addClass(style);
				}
			});

			$('.complex__play-icon').tooltipster({
				contentAsHTML: true,
				animation: 'fade',
				speed: 200,
				delay: 30,
				trigger: 'hover',
				maxWidth: 169,
				position: 'left',
				interactive: false,
				functionBefore: function functionBefore(origin, continueTooltip) {
					continueTooltip();

					var style = 'tooltipster-label tooltipster-label_' + origin.data('style');
					if (!style) return false;

					$('.tooltipster-base').addClass(style);
				}
			});

			$('.complex__favorite').tooltipster({
				contentAsHTML: true,
				animation: 'fade',
				speed: 200,
				delay: 30,
				trigger: 'hover',
				maxWidth: 169,
				position: 'left',
				interactive: false,
				functionBefore: function functionBefore(origin, continueTooltip) {
					continueTooltip();

					var style = 'tooltipster-label tooltipster-label_' + origin.data('style');
					if (!style) return false;

					$('.tooltipster-base').addClass(style);
				}
			});
			//========== complex tooltip;
		}).call(this);

		(function () {

			//========== map structure:
			$('.map-filter__title, .map-filter__toggle', $('.map-structure')).on('click', function (e) {
				e.preventDefault();
				var $el = $(this);
				var $target = $($el.data('target'));

				if ($el.hasClass('map-filter__title_active')) {
					return false;
				}
				$('.map-filter__title_active').removeClass('map-filter__title_active');
				$('.map-filter__content').slideUp();
				if (!$el.hasClass('map-filter__toggle')) {
					$el.addClass('map-filter__title_active');
					$target.slideDown();
				}
			});
			//========== map structure;
		}).call(this);
		//========== complex button hide-show span:
		$('.spoiler-phone__btn').on('click', function (e) {
			$(this).hide();
			$(this).siblings('.spoiler-phone__local').show();
		});

		$('.spoiler-phone__btn').on('click', function (e) {
			e.preventDefault();
		});

		function getUrlVars() {
			var vars = [],
			    hash;
			var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
			for (var i = 0; i < hashes.length; i++) {
				hash = hashes[i].split('=');
				vars.push(hash[0]);
				vars[hash[0]] = hash[1];
			}
			return vars;
		}

		//banner
		var banner_offset;
		var banner_to;
		var banner_left;
		var win_inner_w = window.innerWidth;
		var win_scroll = $(window).scrollTop();
		var banner__scroll_top;

		$(window).on('load', function () {

			var change_banner_position = function change_banner_position() {
				if (win_inner_w > 991) {
					if (win_scroll > banner_offset && win_scroll < banner_to) {
						$('.banner__scroll .banner').removeAttr('style').css({ 'position': 'fixed', 'left': banner_left, 'top': 20 });
					} else {
						if (win_scroll >= banner_to) {
							$('.banner__scroll .banner').removeAttr('style').css({ 'position': 'fixed', 'left': banner_left, 'top': banner__scroll_top });
						} else {
							$('.banner__scroll .banner').removeAttr('style').css('position', 'static');
						}
					}
				} else {
					$('.banner__scroll .banner').removeAttr('style').css('position', 'static');
				}
			};

			if ($('.banner__scroll').length) {
				$('.banner__scroll').height($('.banner__scroll .banner').height());

				// banner_offset = $('.banner__scroll').offset().top;
				if ($('.banner__scroll-after').length) {
					banner_offset = $('.banner__scroll-after').offset().top + $('.banner__scroll-after').height();
				} else {
					banner_offset = $('.banner__scroll').offset().top;
				}
				banner_left = $('.banner__scroll').offset().left;
				banner_to = $('.banner__scroll').closest('.container').offset().top + $('.banner__scroll').closest('.container').height() - $('.banner__scroll .banner').height() - 44;
				win_inner_w = window.innerWidth;
				win_scroll = $(window).scrollTop();
				banner__scroll_top = banner_to - win_scroll;

				change_banner_position();
			}

			$(window).resize(function () {
				if ($('.banner__scroll').length) {
					win_scroll = $(window).scrollTop();
					win_inner_w = window.innerWidth;
					$('.banner__scroll').height($('.banner__scroll .banner').height());
					banner_left = $('.banner__scroll').offset().left;

					// banner_offset = $('.banner__scroll').offset().top;
					if ($('.banner__scroll-after').length) {
						banner_offset = $('.banner__scroll-after').offset().top + $('.banner__scroll-after').height();
					} else {
						banner_offset = $('.banner__scroll').offset().top;
					}
					banner_to = $('.banner__scroll').closest('.container').offset().top + $('.banner__scroll').closest('.container').height() - $('.banner__scroll .banner').height() - 44;
					banner__scroll_top = banner_to - win_scroll;

					change_banner_position();
				}
			});

			$(document).scroll(function () {
				if ($('.banner__scroll').length) {
					win_scroll = $(window).scrollTop();
					banner__scroll_top = banner_to - win_scroll;

					change_banner_position();
				}
			});
		});

		// console.log(getUrlVars(), getUrlVars()['direct']);
		// if (getUrlVars()['direct']) {
		//     $('.section__content a').removeAttr("onclick");
		//     $('.section__content a').attr('href', '/');
		//     console.log('links', $('.section__content a'));        
		// }
		$('.subscrube form').on('submit', function (e) {

			var dataForm, dataUrl, form, resultContainer, timeline;

			e.preventDefault();

			form = $(this);
			dataUrl = form.attr('action');
			dataForm = form.serialize();
			resultContainer = $('.subscrube__result');
			sendButton = form.find('input[type="send"], button');
			timeline = new TimelineMax();

			var email = form.find('.subscrube__input').val();

			function validateEmail(email) {
				var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
				return re.test(email);
			}

			console.log(email);

			sendButton.prop('disabled', true);

			if (!validateEmail(email)) {
				timeline.to(form, 0.7, {
					opacity: 0,
					yPercent: 20,
					display: 'none',
					onComplete: function onComplete() {
						resultContainer.empty();
						TweenLite.to(resultContainer, 0.5, { text: '  email', ease: Linear.easeNone });
						sendButton.prop('disabled', false);
						// return resultContainer.text('  ');
					}
				});

				timeline.to(resultContainer, 0.7, {
					opacity: 1,
					display: 'block'
				});

				timeline.to(resultContainer, 0.7, {
					delay: 3,
					opacity: 0,
					display: 'none'
				});

				timeline.to(form, 0.7, {
					opacity: 1,
					yPercent: 0,
					display: 'block'
				});

				return false;
			}

			// console.log(dataUrl);

			$.ajax({
				type: 'POST',
				url: dataUrl,
				data: dataForm,
				success: function success(data, textStatus, jqXHR) {
					timeline.to(form, 0.7, {
						opacity: 0,
						yPercent: 20,
						display: 'none',
						onComplete: function onComplete() {
							resultContainer.empty();
							TweenLite.to(resultContainer, 0.5, { text: '    ', ease: Linear.easeNone });
							sendButton.prop('disabled', false);
							// return resultContainer.text('    ');
						}
					});
					timeline.to(resultContainer, 0.7, {
						opacity: 1,
						display: 'block'
					});

					timeline.to(resultContainer, 0.7, {
						delay: 3,
						opacity: 0,
						display: 'none'
					});

					timeline.to(form, 0.7, {
						delay: 3,
						opacity: 1,
						yPercent: 0,
						display: 'block'
					});
					// return console.log(data, textStatus, jqXHR);
				},
				error: function error() {

					timeline.to(form, 0.7, {
						opacity: 0,
						yPercent: 20,
						display: 'none',
						onComplete: function onComplete() {
							resultContainer.empty();
							TweenLite.to(resultContainer, 0.5, { text: '  ', ease: Linear.easeNone });
							sendButton.prop('disabled', false);
							// return resultContainer.text('  ');
						}
					});

					timeline.to(resultContainer, 0.7, {
						opacity: 1,
						display: 'block'
					});

					timeline.to(resultContainer, 0.7, {
						delay: 3,
						opacity: 0,
						display: 'none'
					});

					timeline.to(form, 0.7, {
						opacity: 1,
						yPercent: 0,
						display: 'block'
					});
				}
			});
		});

		// $('.input-mask-phone').inputmask({"mask": "+7(999)999-99-99","placeholder": "+7(___)___-__-__"});

		function initCallback() {
			cb_day = $('#cb-day');
			cb_time = $('#cb-time');
			if (callback_days[cb_day.val()]) {
				cb_time.empty();
				$.each(callback_days[cb_day.val()]['hours'], function (index, hour) {
					cb_time.append($('<option>', {
						value: hour.timestamp,
						text: hour.title,
						selected: index == 0 ? 'selected' : null
					}));
				});
				cb_time.trigger('refresh');
			}
		}

		$(function () {
			if (typeof callback_days != 'undefined' && callback_days.length) {
				$('#cb-day').on('change', function () {
					initCallback();
				});
			}
		});

		$('.modal-callback-js').on('submit', function (e) {
			e.preventDefault();

			currentForm = $(this);
			currentButton = currentForm.find('button[type="send"]');
			currentModal = currentForm.parents('.modal');
			modalData = currentForm.serialize();
			modalUrl = currentForm.attr('action');
			modalStatus = $('#modal-callback-status-right');
			modalStatusText = modalStatus.find('.modal-form-js-status');
			modalDataArray = currentForm.serializeArray();

			currentButton.prop('disabled', true);

			phoneInput = currentForm.find('input[name=\'phone\']');
			if (phoneInput.length) {
				phoneInput.parent('.form-group').removeClass('has-error');
				if (phoneInput.val().indexOf('_') + 1 || phoneInput.val() == '') {
					phoneInput.parent('.form-group').addClass('has-error');
					currentButton.prop('disabled', false);
					return false;
				}
			}

			agreeInput = currentForm.find('input[name=\'agree\']');
			agreeInput.parent('.gh-form__group').removeClass('has-error');
			if (!agreeInput.prop('checked')) {
				agreeInput.parent('.gh-form__group').addClass('has-error');
				currentButton.prop('disabled', false);
				return false;
			}

			$.ajax({
				type: 'POST',
				url: modalUrl,
				data: modalData,
				success: function success(data, textStatus, jqXHR) {
					currentButton.prop('disabled', false);
					currentTimestamp = Math.floor(Date.now() / 1000);
					callbackTimestamp = parseInt(modalDataArray[1].value);
					if (data == 'success') {
						if (currentTimestamp > callbackTimestamp) {
							modalStatusText.html('<div class="h3">   !</div><div>      30 ,   <nobr>' + modalDataArray[2].value + '</nobr></div>');
						} else {
							modalStatusText.html('<div class="h3">   !</div><div>    ' + $('#cb-day option:selected').text().toLowerCase() + '<br/>  ' + $('#cb-time option:selected').text().toLowerCase() + ',   <nobr>' + modalDataArray[2].value + '.</nobr></div>');
						}

						setTimeout(function () {
							modalStatus.modal('hide');
						}, 7000);
					} else {
						modalStatusText.text('  ,      +7 (495) 662-97-55');
					}

					currentModal.modal('hide').on('hidden.bs.modal', function () {
						modalStatus.modal('show');
						currentModal.off();
					});
				},
				error: function error() {
					currentButton.prop('disabled', false);

					modalStatusText.text('  ,      +7 (495) 662-97-55');

					currentModal.modal('hide').on('hidden.bs.modal', function () {
						modalStatus.modal('show');
						currentModal.off();
					});
				}
			});
		});

		$(document).on('submit', '.modal-form-js', function (e) {
			e.preventDefault();

			currentForm = $(this);
			currentButton = currentForm.find('button[type="send"]');
			currentModal = currentForm.parents('.modal');
			modalData = currentForm.serialize();
			modalUrl = currentForm.attr('action');
			modalStatus = $('#modal-callback-status');
			modalStatusText = modalStatus.find('.modal-form-js-status');
			formName = currentForm.find('.h3').text().toLowerCase();

			currentButtonText = currentButton.text();
			currentButton.html('');
			currentButton.prop('disabled', true);

			currentButtonLoader = $('<span/>', {
				class: 'button_loader'
			}).appendTo(currentButton);

			currentButtonText = $('<span/>', {
				class: 'button_text',
				text: currentButtonText
			}).appendTo(currentButton);

			TweenMax.fromTo(currentButtonLoader, 4, { width: 0, backgroundColor: '#ab8d19' }, {
				width: '100%',
				backgroundColor: '#ffcb00'
			});

			$.ajax({
				type: 'POST',
				url: modalUrl,
				data: modalData,
				success: function success(data, textStatus, jqXHR) {
					TweenMax.to(currentButtonLoader, 0.5, { width: '100%', backgroundColor: '#ffcb00' });
					currentButton.prop('disabled', false);
					if (typeof grecaptcha != 'undefined') {
						grecaptcha.reset();
					}

					if (data == 'success') {
						modalStatusText.text(',  ' + formName + ' ,       ');

						setTimeout(function () {
							modalStatus.modal('hide');
						}, 5000);
					} else if (data == 'captcha') {
						modalStatusText.text('   ');
					} else {
						$currentModalContent = $(currentForm).parents('.modal-content-ajax');
						if ($currentModalContent.length) {
							$currentModalContent.html(data);
							// $('.input-mask-phone').inputmask({"mask": "+7(999)999-99-99","placeholder": "+7(___)___-__-__"});
						}
						modalStatusText.text('  ,      +7 (495) 662-97-55');
					}
					if (typeof $currentModalContent == 'undefined') {
						currentModal.modal('hide').on('hidden.bs.modal', function () {
							currentModal.off();
						});
						modalStatus.modal('show');
					}
				},
				error: function error() {

					if (typeof grecaptcha != 'undefined') {
						grecaptcha.reset();
					}

					TweenMax.to(currentButtonLoader, 0.5, { width: '100%', backgroundColor: '#ffcb00' });
					currentButton.prop('disabled', false);

					modalStatusText.text('  ,      +7 (495) 662-97-55');

					currentModal.modal('hide').on('hidden.bs.modal', function () {
						modalStatus.modal('show');
						currentModal.off();
					});
				}
			});
		});

		$('a[data-form="developer"]').on('click', function (e) {
			var callbackModal = $('.modal-callback-js');
			callbackModal.find('input[name="adv"]').val($(this).data('form-adv'));
			callbackModal.find('.h3').text($(this).data('form-title'));
			initCallback();
		});

		$('.modal').on('show.bs.modal', function (e) {
			// console.log(this,e.relatedTarget)
			var link = $(e.relatedTarget);

			if (link.data('form-title')) {
				$(this).find('.h3').text(link.data('form-title'));
			}

			if (link.data('form-adv')) {
				$(this).find('input[name="adv"]').val(link.data('form-adv'));
			}

			if (link.data('form')) {
				$(this).find('input[name="type"]').val(link.data('form'));
				if (link.data('form') == 'review') {
					$(this).find('input[name="new_building_place"]').removeAttr('required').closest('.form-group').addClass('hide');
					$(this).find('input[name="phone"]').removeAttr('required').closest('.form-group').addClass('hide');
					$(this).find('input[name="email"]').removeAttr('required').closest('.form-group').find('.help-block').html('   ,     ');
				} else {
					$(this).find('input[name="new_building_place"]').attr('required', 'required').closest('.form-group').removeClass('hide');
					$(this).find('input[name="phone"]').attr('required', 'required').closest('.form-group').removeClass('hide');
					$(this).find('input[name="email"]').attr('required', 'required').closest('.form-group').find('.help-block').html('       ');
				}
			}

			if (typeof grecaptcha != 'undefined') {
				grecaptcha.reset();
			}
		});
		var housesObjects = [];

		function renovationMapInit() {
			var mapRenov = new ymaps.Map('map-renovation', {
				center: [55.751244, 37.618423],
				zoom: 9,
				controls: ["zoomControl"]
			}, {
				searchControlProvider: 'yandex#search',
				projection: ymaps.projection.sphericalMercator
			});

			mapRenov.behaviors.disable('scrollZoom');

			var $map = $('#map-renovation');
			var $dataHref = $map.data('href');
			// const housesObjects = [];

			function getCoords(map) {
				return map.getBounds().reduce(function (prev, current, i) {
					return "" + prev + (i > 0 ? ',' : '') + current[0] + "," + current[1];
				}, '');
			}

			var coords = getCoords(mapRenov);

			$.get($dataHref, { coords: coords }).done(function (response) {
				var houses = response.features[""];

				renovationHint = ymaps.templateLayoutFactory.createClass("<div class='map-hint map-hint_width'>" + "<div>{{ properties.name }}</div>" + "<div>{{ properties.area_name }}</div>" + "<div>{{ properties.district_name }}</div>" + "</div>", {
					getShape: function getShape() {
						var el = this.getElement(),
						    result = null;
						if (el) {
							var firstChild = el.firstChild;
							result = new ymaps.shape.Rectangle(new ymaps.geometry.pixel.Rectangle([[0, 0], [firstChild.offsetWidth, firstChild.offsetHeight]]));
						}
						return result;
					}
				});

				for (var _i = 0; _i < houses.length; _i++) {

					var house = houses[_i];
					var coordinates = void 0;

					housesObjects[_i] = new ymaps.Placemark(house.center.coordinates, {
						name: house.properties.name,
						area_name: house.properties.area_name,
						district_name: house.properties.district_name
					}, {
						preset: 'islands#darkGreenIcon',
						hintLayout: renovationHint
					});
				}

				var clusterer = new ymaps.Clusterer({
					preset: 'islands#darkgreenClusterIcons'
				});

				clusterer.add(housesObjects);
				mapRenov.geoObjects.add(clusterer);

				// clusterer.getGeoObjects().each(function(obj) {
				//     if (obj.geometry.get('coordinates') == ["55.719602", "37.412801"]) {
				//       console.log(obj)
				//     }
				// });
			});

			return mapRenov;
		}

		if ($('#map-renovation').length) {
			ymaps.ready(function () {
				var mapRenov = renovationMapInit();
				if ($('.js-renovation-search').length) {
					var $form = $('.js-renovation-search');
					var $searchInput = $form.find('input');
					var $searchHref = $searchInput.data('href');
					var suggest = new ymaps.SuggestView($searchInput[0]);
					var $searchResult = $('.page-head__result');
					$form.on('submit', function (e) {
						e.preventDefault();

						var $this = $(e.currentTarget);
						var $searchQuery = $searchInput.val();

						var chosenMark = void 0; //    

						$.get('https://geocode-maps.yandex.ru/1.x/?format=json&amp;geocode=' + $searchQuery).done(function (response) {

							var firstPairCoords = response.response.GeoObjectCollection.featureMember[0].GeoObject.boundedBy.Envelope.lowerCorner.split(' ').reverse();
							var secondPairCoords = response.response.GeoObjectCollection.featureMember[0].GeoObject.boundedBy.Envelope.upperCorner.split(' ').reverse();
							var point = response.response.GeoObjectCollection.featureMember[0].GeoObject.Point.pos.split(' ').reverse().join(',');
							var coords = [firstPairCoords, secondPairCoords].join(',');
							var houseAddress = response.response.GeoObjectCollection.featureMember[0].GeoObject.name;

							$.get($searchHref, { coords: coords, point: point }).done(function (response) {
								if (response.features[""]) {
									$searchResult.empty().append('<i class="fa fa-check"></i>    <b>' + houseAddress + '</b>       . ');
									mapRenov.setBounds([firstPairCoords, secondPairCoords], 23);

									var placeMarkCoords = point.split(',');

									housesObjects.forEach(function (item) {

										if (item.options.get('id') == "redmark") {
											item.options.set('preset', "islands#darkGreenIcon");
											item.options.set('id', "");
										}

										if (placeMarkCoords[0] == item.geometry._coordinates[0] && placeMarkCoords[1] == item.geometry._coordinates[1]) {
											item.options.set('preset', "islands#redIcon");
											item.options.set('id', "redmark");
										}
									});
								} else {
									$searchResult.empty().append('<i class="fa fa-close"></i>    <b>' + houseAddress + '</b>        . ');
								}
							});
						});
					});
				}
			});
		}
		if ($('.js-load-more-btn').length) {
			var initialQuery = function initialQuery(num) {
				var $this = $('body .js-load-more-btn')[num];
				var $container = $($this).closest('.js-load-more-container');
				var $offset = $($this).data('offset');
				var $href = $($this).data('href') + '&offset=' + parseInt($offset);
				var step = $($this).data('step') || 20;
				$.get($href).done(function (response) {
					if (!$(response).length) {
						$($this).hide();
					}
				});
			};

			$('body .js-load-more-btn').on('click', function (e) {
				e.preventDefault();
				var $this = $(e.currentTarget);
				var $container = $this.closest('.js-load-more-container');
				var $offset = $this.data('offset');
				var $href = $this.data('href') + '&offset=' + parseInt($offset);
				var step = $this.data('step') || 20;
				$.get($href).done(function (response) {

					if ($(response).length) {
						$(response).insertBefore($this.parent());
						$this.data('offset', parseInt($offset) + step);
					} else {
						$this.hide();
					}
				});

				$href = $this.data('href') + '&offset=' + parseInt($offset + 20);
				$.get($href).done(function (response) {

					if ($(response).length) {} else {
						$this.hide();
					}
				});
			});

			initialQuery(0);
			initialQuery(1);
			initialQuery(2);
		}
		if ($('.renovation__review_slider').length) {
			$('.renovation__review_slider').slick({
				slidesToShow: 4,
				slidesToScroll: 1,
				centerPadding: '0',
				appendArrows: '.renovation__review_slider__nav',
				prevArrow: '<button type="button" class="full-slider__arrow slick-prev" ><i class="fa fa-angle-left"></i></button>',
				nextArrow: '<button type="button" class="full-slider__arrow slick-next" ><i class="fa fa-angle-right"></i></button>',
				dots: false,
				centerMode: false,
				responsive: [{
					breakpoint: 1366,
					settings: {
						slidesToShow: 3
					}
				}, {
					breakpoint: 910,
					settings: {
						slidesToShow: 2
					}
				}, {
					breakpoint: 640,
					settings: {
						slidesToShow: 1
					}
				}]
			});
		}
		function makeTabs(tabs) {

			var $panes = $(tabs).find('.js-tabs__pane');

			if ($panes.length <= 1) {
				$('.js-tabs__switchers').hide();
				return false;
			}

			var $switcher = $(tabs).find('.js-tabs__switcher');

			$switcher.on('click', function (e) {

				e.preventDefault();

				var $target = $(e.currentTarget);

				if ($target.hasClass('_current')) {
					return false;
				}

				var $switcherContainer = $target.closest('.js-tabs__switchers');
				var $prevSwitcher = $switcherContainer.find('.js-tabs__switcher._current');
				var $container = $target.closest('.js-tabs');
				var $currentTab = $container.find('.js-tabs__pane._current');
				var $nextTab = $target.data('href');
				$prevSwitcher.removeClass('_current');
				$currentTab.removeClass('_current');
				$($nextTab).addClass('_current');
				$target.addClass('_current');
				$('.slider-plans').slick('setPosition');
				return true;
			});
		}

		if ($('.js-tabs').length) {
			$('.js-tabs').each(function () {
				makeTabs(this);
			});
		}
		// Defines type of page
		var buildingType = ~window.location.search.indexOf("new_buildings") ? "new_buildings" : "cottages";

		/**
   * 
   * Counts everything and puts in object
   * which is descripted in constructor
   * @class ElementsCounter
   */

		var ElementsCounter = function () {
			/**
    * Creates an instance of ElementsCounter.
    * @param {object} obj Object of the type {key: it's count} or {}
    * @memberof ElementsCounter
    */
			function ElementsCounter(obj) {
				_classCallCheck(this, ElementsCounter);

				this.obj = obj;
			}

			/**
    * Writes opt as key of obj and counts its amount
    * @param {any} opt 
    * @memberof ElementsCounter
    */


			_createClass(ElementsCounter, [{
				key: "countOption",
				value: function countOption(opt) {
					this.obj[opt] = (this.obj[opt] || 0) + 1;
				}

				/**
     * @returns the most repeatable key of obj
     * @memberof ElementsCounter
     */

			}, {
				key: "countMostRepeatable",
				value: function countMostRepeatable() {
					var _this2 = this;

					var objKeys = Object.keys(this.obj);
					var sortedArr = objKeys.sort(function (a, b) {
						return _this2.obj[a] < _this2.obj[b];
					});
					return sortedArr[0];
				}

				/**
     * @param {number} index 
     * @returns key of obj by its index
     * @memberof ElementsCounter
     */

			}, {
				key: "getByIndex",
				value: function getByIndex(index) {
					var _this3 = this;

					var objKeys = Object.keys(this.obj);
					var sortedArr = objKeys.sort(function (a, b) {
						return _this3.obj[a] < _this3.obj[b];
					});
					return index + 1 > sortedArr.length ? false : sortedArr[index];
				}

				/**
     * Substracts any key option for 1
     * @param {any} opt 
     * @memberof ElementsCounter
     */

			}, {
				key: "subtractOption",
				value: function subtractOption(opt) {
					if (!this.obj[opt]) return;
					this.obj[opt] = this.obj[opt] - 1;
				}

				/**
     * Clears object
     * @memberof ElementsCounter
     */

			}, {
				key: "clear",
				value: function clear() {
					this.obj = {};
				}
			}]);

			return ElementsCounter;
		}();

		var housingClasses = new ElementsCounter({});
		var citiesCounter = new ElementsCounter({});
		var districtsCounter = new ElementsCounter({});
		var blocksCounter = new ElementsCounter({});

		var CompareStorage = function () {
			function CompareStorage(options) {
				_classCallCheck(this, CompareStorage);

				this.buttons = options.buttons;
				this.sidebarCompare = options.sidebarCompare;
				this.sidebarFavorites = options.sidebarFavorites;
				this.action = this.action.bind(this);
				this.setLink = this.setLink.bind(this);
				this.count = this.count.bind(this);
				this.adaptSidebarButtons = this.adaptSidebarButtons.bind(this);
				this.switchSidebarButtons = this.switchSidebarButtons.bind(this);
				this.bindEvents();
			}

			/**
    * Getter of parsed cookies
    */


			_createClass(CompareStorage, [{
				key: "checkCookies",


				/**
     * Check if cookie exists and return it's length.
     * With argment: check if cookie contains object
     * and return cookie length.
     * Yeah, it's crutch.
     * 
     * @param {string} obj 
     */
				value: function checkCookies(obj) {
					var array = getCookie('compare');
					var parsedArray = void 0;

					if (array) {
						parsedArray = JSON.parse(array);
						if (obj) {
							if (parsedArray.length && arrayFind(parsedArray, obj) != -1) {
								return parsedArray.length;
							}
						} else {
							return parsedArray.length;
						}
					}
					return 0;
				}

				/** 
     * Adds object to cookies
     * @param {string} obj 
     */

			}, {
				key: "addToCookies",
				value: function addToCookies(obj) {
					var cookie = getCookie('compare');
					var parsedCookie = cookie ? JSON.parse(cookie) : null;
					var timer = new Date(new Date().getTime() + 365 * 24 * 3600 * 1000).toUTCString();
					var settings = { expires: timer, path: "/", domain: location.hostname };

					if (parsedCookie) {
						if (arrayFind(parsedCookie, obj) === -1) {
							parsedCookie.push(obj);
							setCookie("compare", JSON.stringify(parsedCookie), settings);
						}
					} else {
						setCookie("compare", "[\"" + obj + "\"]", settings);
					}
				}

				/**
     * Removes object from cookies
     * @param {string} obj 
     */

			}, {
				key: "removeFromCookies",
				value: function removeFromCookies(obj) {
					var cookie = getCookie('compare');
					var parsedCookie = cookie ? JSON.parse(cookie) : null;
					var timer = new Date(new Date().getTime() + 365 * 24 * 3600 * 1000).toUTCString();
					var settings = { expires: timer, path: "/", domain: location.hostname };

					if (parsedCookie) {
						if (arrayFind(parsedCookie, obj) != -1) {
							parsedCookie.splice(arrayFind(parsedCookie, obj), 1);
							setCookie("compare", JSON.stringify(parsedCookie), settings);
						}
					}
				}

				/**
     * Show/hide sidebar buttons on mobile 
     * depending on the objects in cookies
     */

			}, {
				key: "switchSidebarButtons",
				value: function switchSidebarButtons() {
					if (isMobile) {
						!+$(this.sidebarCompare + " span").text() ? $("" + this.sidebarCompare).css("visibility", "hidden") : $("" + this.sidebarCompare).css("visibility", "visible");
					} else $(this.sidebarFavorites + ", " + this.sidebarCompare).css("visibility", "visible");
				}

				/**
     * Makes buttons fixed on display on mobile
     */

			}, {
				key: "adaptSidebarButtons",
				value: function adaptSidebarButtons() {
					if (isMobile && $(this.sidebarFavorites).closest($(".sidebar-interface")).length) {
						$(this.sidebarFavorites + ", " + this.sidebarCompare).appendTo(".wrapper");
					} else if (!isMobile && !$(this.sidebarFavorites).closest($(".sidebar-interface")).length) {
						$(this.sidebarFavorites + ", " + this.sidebarCompare).appendTo(".sidebar-interface");
					}
					this.switchSidebarButtons();
				}

				/**
     * Starts adding/removing object to/from comparison.
     * @param {event} e
     */

			}, {
				key: "action",
				value: function action(e) {
					var _this4 = this;

					var button = $(e.currentTarget);
					var buttonType = button.data('type');
					var buttonId = button.data('id');
					var cookieItem = buttonId + "&" + buttonType;

					if (!buttonId || !buttonType) {
						throw new ReferenceError('Button data is undefined!', 'compare.js');
					}

					if (button.hasClass('active')) {
						button.removeClass('active');
						this.removeFromCookies(cookieItem);
						this.count();
					} else {
						button.addClass('active');
						var clone = button.clone();
						clone.css({
							'position': 'absolute',
							top: button.offset().top,
							left: button.offset().left - 5,
							'z-index': '20',
							"opacity": 1,
							"transition": !isMobile ? "top .65s linear, left .65s linear, opacity 0.65s ease-in-out" : "top .4s linear, left .4s linear, opacity 0.4s ease-in"
						}).appendTo("body").css({
							opacity: 0.4,
							left: $(".sidebar-compare").offset().left + 20,
							top: $(".sidebar-compare").offset().top + 10
						});
						setTimeout(function () {
							clone.remove();
							_this4.count();
						}, !isMobile ? 660 : 410);
						this.addToCookies(cookieItem);
					}
				}

				/**
     * Counts objects in cookies, 
     * sets their amount in sidebar buttons
     */

			}, {
				key: "count",
				value: function count() {
					var _this5 = this;

					var sidebarIcon = $(this.sidebarCompare).find(this.sidebarCompare + "__icon");
					var sidebarCnt = $(this.sidebarCompare).find(this.sidebarCompare + "__cnt span");
					var cookiesLength = this.checkCookies();

					if ($(this.buttons).length) {
						$(this.buttons).each(function (i, element) {
							var button = $(element),
							    checkItem = button.data('id') + "&" + button.data('type');
							if (_this5.checkCookies(checkItem)) {
								button.addClass('active');
							} else {
								button.removeClass('active');
							}
						});
					}

					/** 
      * !TODO!
      */
					if (cookiesLength) {
						sidebarIcon.removeClass('sidebar-compare__icon_active');
						setTimeout(function () {
							sidebarIcon.addClass('sidebar-compare__icon_active');
						}, 50);
						sidebarCnt.html(cookiesLength);
					} else {
						setTimeout(function () {
							sidebarIcon.removeClass('sidebar-compare__icon_active');
						}, 60);
						sidebarCnt.html('0');
					}
					this.switchSidebarButtons();
				}

				/**
     * Sets href of sidebar button on mousedown
     * @param {event} e 
     */

			}, {
				key: "setLink",
				value: function setLink() {

					var button = $(this.sidebarCompare);

					if (this.checkCookies() === 0 || window.location.pathname === "/compare/") {
						button.attr('href', '/compare/');
					} else if (this.checkCookies() > 0) {
						var cookies = JSON.parse(getCookie('compare'));
						var cottages = '';
						var buildings = '';
						cookies.forEach(function (el, index) {
							var item = el;
							var ampersand = item.indexOf("&");
							var id = item.slice(0, ampersand);
							var type = item.slice(ampersand + 1);

							if (type === 'cottages') {
								if (!cottages.length) {
									cottages = id + '&type=' + type;
								} else {
									cottages = id + ',' + cottages;
								}
							}if (type === 'new_buildings') {
								if (!buildings.length) {
									buildings = id + '&type=' + type;
								} else {
									buildings = id + ',' + buildings;
								}
							}
						});

						if (cottages.length && buildings.length) {
							button.attr('href', '/compare/');
						} else if (buildings.length) {
							button.attr('href', '/compare/?ids=' + buildings);
						} else if (cottages.length) {
							button.attr('href', '/compare/?ids=' + cottages);
						}
					}
				}
			}, {
				key: "bindEvents",
				value: function bindEvents() {
					var _this6 = this;

					var self = this;
					$(document).on('click', self.buttons, function (event) {
						self.action(event);
					});
					$(this.sidebarCompare).on('mousedown', function (event) {
						event.preventDefault();
						_this6.setLink();
					});
					$(document).ready(function () {
						_this6.adaptSidebarButtons();
						_this6.count();
					});
					$(window).on("resize", this.adaptSidebarButtons);
				}
			}, {
				key: "cookies",
				get: function get() {
					return JSON.parse(getCookie('compare'));
				}
			}]);

			return CompareStorage;
		}();

		var compareStorage = new CompareStorage({
			buttons: '[data-compare]',
			sidebarCompare: '.sidebar-compare',
			sidebarFavorites: '.sidebar-favorites'
		});

		var Fixator = function () {
			function Fixator(options) {
				_classCallCheck(this, Fixator);

				this.options = {
					wrapper: options.wrapper || '',
					table: options.table || '',
					rows: options.rows || ''
				};
				this.$wrapper = $(this.options.wrapper);
				this.$table = $(this.options.table);
				this.rows = this.constructRows();
				this.$fixWrap = $("<div/>", { class: "row-fix" });
				this.$fixTable = $("<table/>", {}).appendTo(this.$fixWrap);
				this.$fixTbody = $("<tbody/>", {}).appendTo(this.$fixTable);
				this.bindEvents = this.bindEvents.bind(this);
			}

			_createClass(Fixator, [{
				key: "constructRows",
				value: function constructRows() {
					var rows = [];
					this.options.rows.forEach(function (el, i) {
						if ($(el).length) {
							rows.push({
								selector: el,
								origin: $(el),
								clone: $(el).clone().addClass('_cloned').height($(el).height()),
								coords: {
									position: $(el).position().top,
									offset: $(el).offset().top,
									height: $(el).height()
								}
							});
						}
					});
					return rows;
				}
			}, {
				key: "bindEvents",
				value: function bindEvents() {
					var _this7 = this;

					this.$wrapper.append(this.$fixWrap);
					this.$fixWrap.width(this.coords.wrapper.width);
					this.$fixTable.width(this.coords.table.width);
					$(window).on("scroll", function () {
						return _this7.render();
					});
					$(window).on("resize", function () {
						return _this7.update();
					});
					this.$wrapper.on("scroll", function () {
						return _this7.changePosition();
					});
				}
			}, {
				key: "update",
				value: function update() {
					var _this8 = this;

					this.rows.forEach(function (index, element) {
						var item = _this8.rows[element];
						item.origin = $(item.selector);
						item.clone.html(item.origin.html()).height(item.coords.height);
						item.coords = {
							position: item.origin.position().top,
							offset: item.origin.offset().top,
							height: item.origin.height()
						};
					});
					this.$wrapper = $(this.options.wrapper);
					this.$table = $(this.options.table);
					this.$fixWrap.width(this.coords.wrapper.width);
					this.$fixTable.width(this.coords.table.width);
				}
			}, {
				key: "render",
				value: function render() {
					var _this9 = this;

					this.rows.forEach(function (index, element) {
						var item = _this9.rows[element];
						var difference = !item.appended ? _this9.$fixWrap.height() : _this9.$fixWrap.height() - item.clone.height();

						if (_this9.coords.window.scrollTop + difference >= item.coords.offset && _this9.coords.window.scrollTop < _this9.coords.wrapper.offset + _this9.coords.wrapper.height - (item.coords.height + 120)) {
							if (!item.appended) {
								_this9.$fixTbody.append(item.clone);
								item.appended = true;
							}
						} else {
							item.clone.detach();
							item.appended = false;
						}
					});
				}
			}, {
				key: "changePosition",
				value: function changePosition() {
					this.$fixTable.css("margin-left", -this.coords.wrapper.scrollLeft);
				}
			}, {
				key: "coords",
				get: function get() {
					return {
						wrapper: {
							height: this.$wrapper.height(),
							width: this.$wrapper.width(),
							offset: this.$wrapper.offset().top,
							scrollLeft: this.$wrapper.scrollLeft()
						},
						table: {
							width: this.$table.width()
						},
						window: {
							scrollTop: $(window).scrollTop()
						}
					};
				}
			}]);

			return Fixator;
		}();

		// Slide the table


		var grabAndSlide = function () {
			function grabAndSlide(selector) {
				_classCallCheck(this, grabAndSlide);

				this.selector = selector;
				this.mousePosition = null;
				this.scrollPosition = null;
				this.scroll = null;
			}

			_createClass(grabAndSlide, [{
				key: "bindEvents",
				value: function bindEvents() {
					var _this10 = this;

					$(this.selector).on("mousedown", function (e) {
						return _this10.start(e);
					});
					$(this.selector).on("mousemove", function (e) {
						return _this10.onScroll(e);
					});
					$(this.selector).on("mouseup mouseleave", function () {
						return _this10.end();
					});
				}
			}, {
				key: "start",
				value: function start(e) {
					this.mousePosition = e.pageX;
					this.scrollPosition = $(this.selector).scrollLeft();
					this.scroll = true;
				}
			}, {
				key: "onScroll",
				value: function onScroll(e) {
					if (this.scroll === true) {
						e.preventDefault();
						if (e.pageX > this.mousePosition) {
							$(this.selector).scrollLeft(this.scrollPosition - (e.pageX - this.mousePosition));
						} else if (e.pageX < this.mousePosition) {
							$(this.selector).scrollLeft(this.scrollPosition + (this.mousePosition - e.pageX));
						}
					}
				}
			}, {
				key: "end",
				value: function end() {
					this.scroll = false;
				}
			}]);

			return grabAndSlide;
		}();

		var Table = function () {
			function Table(options) {
				_classCallCheck(this, Table);

				this.options = options;
				this.wrapper = options.wrapper;
				this.scrollWraper = options.scrollWraper;
				this.table = options.table;
				this.pinnedTable = options.pinnedTable;
				this.nameTable = options.nameTable;
				this.cells = options.cells;
				this.removeButton = options.removeButton;
				this.pinningButton = options.pinningButton;
				this.tab = options.tab;
				this.clearButton = options.clearButton;
				this.placehodler = options.placehodler;
				this.buttonsWrap = options.buttonsWrap;
				this.tip = options.tip;
				this.copyButton = options.copyButton;
				this.shareWrap = options.shareWrap;
				this.historyObjects = [];
				this.rowHover = this.rowHover.bind(this);
				this.setHeight = this.setHeight.bind(this);
				this.setTipOnTouch = this.setTipOnTouch.bind(this);
				this.pinObject = this.pinObject.bind(this);
				this.unpinObject = this.unpinObject.bind(this);
				this.shareDropdown = this.shareDropdown.bind(this);
				this.switchPlaceholder = this.switchPlaceholder.bind(this);
				this.clearTable = this.clearTable.bind(this);
				this.bindEvents = this.bindEvents.bind(this);
			}

			_createClass(Table, [{
				key: "render",
				value: function render(data) {
					var _this11 = this;

					data.forEach(function (item) {
						var objectId = item.id;
						var link = item.link;
						var devLink = item.developer_link;

						if ($("[data-cell-id=\"" + objectId + "\"]").length) {
							return;
						}

						for (var _opt in item) {
							var _element = $(".compare__table tr[data-row=\"" + _opt + "\"] td:first-child");

							if (_opt === "id") {
								$(".compare__table tr[data-row=\"options\"] td:first-child").after("<td data-cell-id=\"" + objectId + "\">\n\t\t                <div class=\"compare__table_infor\">\n\t\t                  <button class=\"compare__table_icon sindu_handle\" data-dnd-handler=\"\" href=\"#\">\n\t\t                    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"18\" height=\"6\"> <path fill-rule=\"evenodd\" d=\"M18 2.999a.9953.9953 0 0 1-.293.707l-2 2.001c-.181.18-.431.292-.707.292-.553 0-1.001-.447-1.001-1 0-.276.113-.526.294-.707l.292-.293H13c-.553 0-1.001-.448-1.001-1s.448-1 1.001-1h1.585l-.292-.293a.9942.9942 0 0 1-.294-.707c0-.552.448-1 1.001-1 .276 0 .526.112.707.293l2 2c.131.132.207.306.25.494.018.07.043.138.043.213zm-13.001-1c.553 0 1.001.448 1.001 1s-.448 1-1.001 1H3.414l.293.293a.996.996 0 0 1 .292.707c0 .553-.447 1-.999 1-.277 0-.527-.112-.708-.292l-2-2.001a.9969.9969 0 0 1-.293-.707c0-.276.112-.526.293-.707l2-2A.9975.9975 0 0 1 3-.001c.552 0 .999.448.999 1 0 .277-.111.527-.292.707l-.293.293h1.585zm4.001 2c-.553 0-1-.448-1-1s.447-1 1-1c.552 0 1 .448 1 1s-.448 1-1 1z\"/></svg>\n\t\t                  </button>\n\t\t                  <a class=\"compare__table_icon compare__table_icon_fix\" href=\"#\">&nbsp;</a>\n\t\t                  <a class=\"compare__table_icon compare__table_icon_close\" href=\"#\">&nbsp;</a>\n\t\t                </div>\n\t\t            </td>");
							} else if (_opt === "image") {
								$(_element).after("\n\t\t                        <td data-cell-id=\"" + objectId + "\">\n\t\t                            <div class=\"compare__slider\">\n\t\t                            </div>\n\t\t                        </td>");
								item[_opt].forEach(function (item) {
									$("[data-cell-id=\"" + objectId + "\"] .compare__slider").append("\n\t\t                            <a class=\"compare__table_img\" href=\"" + link + "\" target=\"_blank\">\n\t\t                                <img src=\"" + item + "\" alt=\"img\">\n\t\t                            </a>");
								});
								setTimeout(function () {
									if ($('.compare__slider').hasClass("slick-initialized")) {
										$('.compare__slider.slick-initialized').slick('unslick');
									}
									$('.compare__slider').slick({
										slidesToShow: 1,
										swipe: false,
										prevArrow: '<button type="button" data-role="none" class="slick-arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
										nextArrow: '<button type="button" data-role="none" class="slick-arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>',
										lazyLoad: 'ondemand'
									});
								}, 1);
							} else if (_opt === "label") {
								$(_element).after("\n\t\t                        <td data-cell-id=\"" + objectId + "\">\n\t\t                            <a class=\"compare__table_title\" \n\t\t                               href=\"" + link + "\" \n\t\t                               target=\"_blank\">\n\t\t                               " + item[_opt] + "\n\t\t                            </a>\n\t\t                        </td>");
								_this11.addToOg(item[_opt]);
							} else if (_opt === "link") {
								$(_element).after("\n\t\t                        <td data-cell-id=\"" + objectId + "\">\n\t\t                            <a class=\"button button_block button_yellow\" \n\t\t                               href=\"" + link + "\" \n\t\t                               type=\"button\" \n\t\t                               target=\"_blank\">\n\t\t                               \u041F\u043E\u0434\u0440\u043E\u0431\u043D\u0435\u0435\n\t\t                            </a>\n\t\t                        </td>");
							} else if (_opt === "developer_label") {
								if (item[_opt] === "") {
									$(_element).after("\n\t\t                            <td data-cell-id=\"" + objectId + "\">\n\t\t                                " + item[_opt] + "\n\t\t                            </td>");
								} else {
									$(_element).after("\n\t\t                            <td data-cell-id=\"" + objectId + "\">\n\t\t                                <a href=\"" + devLink + "\" \n\t\t                                   target=\"_blank\">\n\t\t                                   " + item[_opt] + "\n\t\t                                </a>\n\t\t                            </td>");
								}
							} else if (_opt === "from_mkad") {
								$(_element).after("\n\t\t                        <td data-cell-id=\"" + objectId + "\">\n\t\t                            " + item[_opt] + "\n\t\t                        </td>");
								if (item[_opt] !== "") {
									$(_element).siblings("[data-cell-id=\"" + objectId + "\"]").text(function (i, val) {
										return val + " ";
									});
								}
							} else if (~String(_opt).indexOf("price_")) {
								$(_element).after("\n\t\t                        <td data-cell-id=\"" + objectId + "\">\n\t\t                            " + item[_opt] + "\n\t\t                        </td>");
								if (item[_opt] !== "") {
									$(_element).siblings("[data-cell-id=\"" + objectId + "\"]").text(function (i, val) {
										return val + " . ";
									});
								}
							} else if (~String(_opt).indexOf("space_")) {
								$(_element).after("\n\t\t                        <td data-cell-id=\"" + objectId + "\">\n\t\t                            " + item[_opt] + "\n\t\t                        </td>");
								if (item[_opt] !== "") {
									$(_element).siblings("[data-cell-id=\"" + objectId + "\"]").html(function () {
										return $(_this11).text() + "<sup>2</sup>";
									});
								}
							} else if (_opt === "floor_height") {
								$(_element).after("\n\t\t                        <td data-cell-id=\"" + objectId + "\">\n\t\t                            " + item[_opt] + "\n\t\t                        </td>");
								if (item[_opt] !== "") {
									$(_element).siblings("[data-cell-id=\"" + objectId + "\"]").text(function (i, val) {
										return val + "";
									});
								}
							} else {
								$(_element).after("\n\t\t                        <td data-cell-id=\"" + objectId + "\">\n\t\t                            " + item[_opt] + "\n\t\t                        </td>");
							}
							if (_opt === "building_class" && item[_opt] !== "") {
								housingClasses.countOption(item[_opt]);
							}
							if (_opt === "city" && item[_opt] !== "") {
								citiesCounter.countOption(item[_opt]);
							}
							if (_opt === "city_district" && item[_opt] !== "") {
								districtsCounter.countOption(item[_opt]);
							}
							if (_opt === "city_block" && item[_opt] !== "") {
								blocksCounter.countOption(item[_opt]);
							}
						}

						$(_this11.table + " tr[data-row=\"price\"] td:first-child").after("<td data-cell-id=\"" + objectId + "\">&nbsp;</td>");
						$(_this11.table + " tr[data-row=\"space\"] td:first-child").after("<td data-cell-id=\"" + objectId + "\">&nbsp;</td>");

						var cookieItem = objectId + "&" + buildingType;
						compareStorage.addToCookies(cookieItem);
						_this11.changeHistory(objectId);
						_this11.switchTip();
						_this11.switchPlaceholder();
						_this11.alignTable();
						_this11.alignPinnedTable();
						_this11.setHeight();
						_this11.findDifferences();
						_this11.switchDifferences();
						_this11.checkIfEmpty();
						compareStorage.count();
						fixTableLabels.update();
						fixPinnedLabels.update();
						compareDnd.dragger.destroy();
						compareDnd.dragger = tableDragger($(_this11.table + " > table")[0], {
							mode: 'column',
							dragHandler: "[data-dnd-handler]",
							onlyBody: true,
							animation: 300
						});
						compareDnd.bindEvents();
					});
				}

				/**
     * D.R.Y. principle violated...
     *
     * @param {array} data
     * @memberof Table
     */

			}, {
				key: "renderRecommended",
				value: function renderRecommended(data) {
					var _this12 = this;

					data.forEach(function (item) {
						var objectId = item.id;
						var link = item.link;
						var devLink = item.developer_link;
						var phone = item.phone;
						if ($("[data-cell-id=\"" + objectId + "\"]").length) {
							return;
						}
						for (var _opt2 in item) {
							var _element2 = $(".compare__table tr[data-row=\"" + _opt2 + "\"]");
							if (_opt2 === "id") {
								$(".compare__table tr[data-row=\"options\"]").append("<td data-cell-id=\"" + objectId + "\">\n\t\t              <div class=\"compare__table_infor\">\n\t\t                <a class=\"compare__table_icon sindu_handle\" data-dnd-handler=\"\" href=\"#\">\n\t\t                  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"18\" height=\"6\"> <path fill-rule=\"evenodd\" d=\"M18 2.999a.9953.9953 0 0 1-.293.707l-2 2.001c-.181.18-.431.292-.707.292-.553 0-1.001-.447-1.001-1 0-.276.113-.526.294-.707l.292-.293H13c-.553 0-1.001-.448-1.001-1s.448-1 1.001-1h1.585l-.292-.293a.9942.9942 0 0 1-.294-.707c0-.552.448-1 1.001-1 .276 0 .526.112.707.293l2 2c.131.132.207.306.25.494.018.07.043.138.043.213zm-13.001-1c.553 0 1.001.448 1.001 1s-.448 1-1.001 1H3.414l.293.293a.996.996 0 0 1 .292.707c0 .553-.447 1-.999 1-.277 0-.527-.112-.708-.292l-2-2.001a.9969.9969 0 0 1-.293-.707c0-.276.112-.526.293-.707l2-2A.9975.9975 0 0 1 3-.001c.552 0 .999.448.999 1 0 .277-.111.527-.292.707l-.293.293h1.585zm4.001 2c-.553 0-1-.448-1-1s.447-1 1-1c.552 0 1 .448 1 1s-.448 1-1 1z\"/></svg>\n\t\t                </a>\n\t\t                <a class=\"compare__table_icon compare__table_icon_fix\" href=\"#\">&nbsp;</a>\n\t\t                <div class=\"compare__table_icon compare__table_icon_recomend\"> \u0420\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u0443\u0435\u043C </div>\n\t\t                <a class=\"compare__table_icon compare__table_icon_close\" href=\"#\">&nbsp;</a>\n\t\t              </div>\n\t\t            </td>");
							} else if (_opt2 === "image") {
								$(_element2).append("\n\t\t                        <td data-cell-id=\"" + objectId + "\">\n\t\t                            <div class=\"compare__slider\">\n\t\t                            </div>\n\t\t                        </td>");
								item[_opt2].forEach(function (item) {
									$("[data-cell-id=\"" + objectId + "\"] .compare__slider").append("\n\t\t              <a class=\"compare__table_img\" href=\"" + link + "\" target=\"_blank\">\n\t\t                  <img src=\"" + item + "\" alt=\"img\">\n\t\t              </a>");
								});
								setTimeout(function () {
									if ($('.compare__slider').hasClass("slick-initialized")) {
										$('.compare__slider.slick-initialized').slick('unslick');
									}
									$('.compare__slider').slick({
										slidesToShow: 1,
										swipe: false,
										prevArrow: '<button type="button" data-role="none" class="slick-arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
										nextArrow: '<button type="button" data-role="none" class="slick-arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>',
										lazyLoad: 'ondemand'
									});
								}, 1);
							} else if (_opt2 === "label") {
								$(_element2).append("\n\t\t                        <td data-cell-id=\"" + objectId + "\">\n\t\t                            <a class=\"compare__table_title\" href=\"" + link + "\" target=\"_blank\">" + item[_opt2] + "</a>\n\t\t                        </td>");
								if (phone !== "") {
									$(_element2).find("[data-cell-id=\"" + objectId + "\"]").append("<a href=\"tel:" + phone.split(/(?!\+)\D+/).join("") + "\" class=\"button button_on_compare\">\n\t\t                  <span></span>\n\t\t              </a>");
									$(_element2).find("[data-cell-id=\"" + objectId + "\"] span").html(phone.replace(/&lt;/g, '<').replace(/&gt;/g, '>'));
								}

								_this12.addToOg(item[_opt2]);
							} else if (_opt2 === "link") {

								$(_element2).append("\n\t\t            <td data-cell-id=\"" + objectId + "\">\n\t\t                <a class=\"button button_block button_yellow\" href=\"" + link + "\" type=\"button\" target=\"_blank\">\u041F\u043E\u0434\u0440\u043E\u0431\u043D\u0435\u0435</a>\n\t\t            </td>");
							} else if (_opt2 === "developer_label") {

								if (item[_opt2] === "") {
									$(_element2).append("\n\t\t              <td data-cell-id=\"" + objectId + "\">\n\t\t                  " + item[_opt2] + "\n\t\t              </td>");
								} else {
									$(_element2).append("\n\t\t              <td data-cell-id=\"" + objectId + "\">\n\t\t                  <a href=\"" + devLink + "\" \n\t\t                      target=\"_blank\">\n\t\t                      " + item[_opt2] + "\n\t\t                  </a>\n\t\t              </td>");
								}
							} else if (_opt2 === "from_mkad") {
								$(_element2).append("\n\t\t            <td data-cell-id=\"" + objectId + "\">\n\t\t                " + item[_opt2] + "\n\t\t            </td>");
								if (item[_opt2] !== "") {
									$(_element2).find("[data-cell-id=\"" + objectId + "\"]").text(function (i, val) {
										return val + " ";
									});
								}
							} else if (~String(_opt2).indexOf("price_")) {
								$(_element2).append("\n\t\t            <td data-cell-id=\"" + objectId + "\">\n\t\t                " + item[_opt2] + "\n\t\t            </td>");
								if (item[_opt2] !== "") {
									$(_element2).find("[data-cell-id=\"" + objectId + "\"]").text(function (i, val) {
										return val + " . ";
									});
								}
							} else if (~String(_opt2).indexOf("space_")) {
								$(_element2).append("\n\t\t                        <td data-cell-id=\"" + objectId + "\">\n\t\t                            " + item[_opt2] + "\n\t\t                        </td>");
								if (item[_opt2] !== "") {
									$(_element2).find("[data-cell-id=\"" + objectId + "\"]").html(function () {
										return $(_this12).text() + "<sup>2</sup>";
									});
								}
							} else if (_opt2 === "floor_height") {
								$(_element2).append("\n\t\t                        <td data-cell-id=\"" + objectId + "\">\n\t\t                            " + item[_opt2] + "\n\t\t                        </td>");
								if (item[_opt2] !== "") {
									$(_element2).find("[data-cell-id=\"" + objectId + "\"]").text(function (i, val) {
										return val + "";
									});
								}
							} else {
								$(_element2).append("\n\t\t            <td data-cell-id=\"" + objectId + "\">\n\t\t                " + item[_opt2] + "\n\t\t            </td>");
							}
						}
						$(_this12.table + " tr[data-row=\"price\"]").append("<td data-cell-id=\"" + objectId + "\">&nbsp;</td>");
						$(_this12.table + " tr[data-row=\"space\"]").append("<td data-cell-id=\"" + objectId + "\">&nbsp;</td>");

						_this12.switchTip();
						_this12.switchPlaceholder();
						_this12.alignTable();
						_this12.alignPinnedTable();
						_this12.setHeight();
						_this12.findDifferences();
						_this12.switchDifferences();
						_this12.checkIfEmpty();
						fixTableLabels.update();
						fixPinnedLabels.update();
						_this12.recommendedAdvert = false;
						compareDnd.dragger.destroy();
						compareDnd.dragger = tableDragger($(_this12.table + " > table")[0], {
							mode: 'column',
							dragHandler: "[data-dnd-handler]",
							onlyBody: true,
							animation: 300
						});
						compareDnd.bindEvents();
					});
				}

				/**
     * Hover effect
     * @param {event} event
     */

			}, {
				key: "rowHover",
				value: function rowHover(event) {
					var thisRow = $(event.currentTarget).data('row');

					if (thisRow === "options" || thisRow === "link" || thisRow === "image" || thisRow === "label" || thisRow === "space" || thisRow === "price") {
						return false;
					}

					$("[data-row=\"" + thisRow + "\"]").toggleClass('hover');
				}

				/** 
     * Equals rows height
     * I wrote such beautiful function with sorting,
     * But f***ing IE couldn't understand it,
     * So meet my fat function with push and Math.max.
     * p.s. may be I'm just stupid, meh...
     */

			}, {
				key: "setHeight",
				value: function setHeight() {
					$(this.wrapper + " tr").each(function (i, el) {
						$(el).css('height', 'auto');
					});

					$(this.table + " tr").each(function (i, el) {
						var rowAttr = $(el).data('row');
						var thisRow = $("[data-row=\"" + rowAttr + "\"]");
						var heights = [];
						thisRow.each(function (i2, el2) {
							heights.push($(el2).height());
						});
						thisRow.height(Math.max.apply(Math, heights));
					});
				}

				/**
     * Centers table (this is crutch)
     */

			}, {
				key: "alignTable",
				value: function alignTable() {
					var _this13 = this;

					$(this.wrapper).css({
						"padding-left": function () {
							var acc = 0;
							if ($(_this13.scrollWraper).outerWidth() > $(".container").outerWidth()) {
								acc = ($(_this13.scrollWraper).outerWidth() - $(".container").outerWidth()) / 2 + 12;
							}
							if ($(_this13.table).outerWidth() < $(_this13.table)[0].scrollWidth) {
								return 0;
							}
							return parseInt($('.container').css('marginLeft')) + parseInt($('.container').css('paddingLeft')) - acc;
						}() + "px"
					});
				}

				/**
     * Sets pinned table position
     */

			}, {
				key: "alignPinnedTable",
				value: function alignPinnedTable() {
					$(this.pinnedTable).css({
						left: $(this.nameTable).offset().left + $(this.nameTable).width() - $(".sidebar").width() + 2
					});
				}

				/**
     * Removes one object from table
     * @param {object} event 
     */

			}, {
				key: "removeObject",
				value: function removeObject(event) {
					event.preventDefault();
					var thisButton = $(event.currentTarget);
					var objectId = thisButton.closest('td').data('cell-id');
					var toRemove = $("[data-cell-id='" + objectId + "']");
					var objectLabel = toRemove.find('.compare__table_title').html();

					if (thisButton.closest(this.pinnedTable).length) {
						$(this.pinnedTable).removeClass('active');
						$(this.scrollWraper).removeClass('fix');
						$(this.table + " td").removeClass('hide');
						$(this.pinningButton).removeClass('active');
						$('.compare__table').css('padding-left', '0');
					}

					toRemove.remove();
					this.replaceFromOg(objectLabel);
					this.removeFromCookie(objectId);
					this.changeHistory(objectId);
					this.findDifferences();
					this.setHeight();
					this.alignTable();
					this.alignPinnedTable();
					this.switchPlaceholder();
					this.checkIfEmpty();
					/**
      * !TODO!
      */
					compareStorage.count();
					fixTableLabels.update();
					fixPinnedLabels.update();
				}

				/**
     * Removes all object from table
     */

			}, {
				key: "clearTable",
				value: function clearTable() {
					var _this14 = this;

					$("[data-row=\"label\"] " + this.cells).each(function (i, cell) {
						var objectLabel = $(cell).find('.compare__table_title').html();
						_this14.replaceFromOg(objectLabel);
						var objectId = $(cell).data('cell-id');
						_this14.removeFromCookie(objectId);
						compareStorage.count();
					});

					/** 
      * !TODO!
      */
					setTimeout(function () {
						$(_this14.pinnedTable).removeClass('active');
						$(_this14.scrollWraper).removeClass('fix');
						$(_this14.table).css('padding-left', 0);
						_this14.switchPlaceholder();
					}, $('[data-cell-id]').remove());

					history.replaceState({}, 'Compare', '?');
				}

				/**
     * Pins object on left side of table
     * @param {object} event 
     * !TODO!
     */

			}, {
				key: "pinObject",
				value: function pinObject(event) {
					var _this15 = this;

					event.preventDefault();
					var currentTarget = $(event.currentTarget);
					var button = void 0;
					var parentCell = $(event.currentTarget).closest('td');
					var objectId = $(parentCell).data('cell-id');

					if (currentTarget.closest($('.row-fix')).length) {
						if (currentTarget.closest($('.compare__table__fix')).length) {
							button = $(".compare__table__fix > table [data-row=\"options\"] [data-cell-id=\"" + objectId + "\"] .compare__table_icon_fix");
						} else {
							button = $(".compare__table > table [data-row=\"options\"] [data-cell-id=\"" + objectId + "\"] .compare__table_icon_fix");
						}
					} else {
						button = currentTarget;
					}

					if (!button.hasClass('active')) {
						this.alignPinnedTable();
						$(this.pinnedTable + " > table tbody").html('');
						$(this.table + " td").removeClass('hide');
						$("" + this.pinningButton).removeClass('active');

						setTimeout(function () {
							$("[data-cell-id=\"" + objectId + "\"] " + _this15.pinningButton).addClass('active');
							$("" + _this15.pinnedTable).addClass('active');
							$(_this15.scrollWraper).addClass('fix');
							$("" + _this15.table).css('padding-left', $(_this15.cells).outerWidth() + 'px');

							/** 
        * !TODO!
        */
							fixTableLabels.update();
							fixPinnedLabels.update();
						}, $(this.table + " > table tr").each(function (i, row) {
							var cells = $(row).find("[data-cell-id=\"" + objectId + "\"]");
							var rowHeight = $(row).height();
							var rowData = $(row).data('row');
							var rowClassList = $(row).attr('class') || "";
							var clone = $('<tr/>', {
								'data-row': rowData,
								'class': rowClassList
							});
							$(_this15.pinnedTable + " > table tbody").append(clone);
							clone.height(rowHeight);
							cells.clone().appendTo(clone);
							setTimeout(function () {
								cells.addClass('hide');
							}, 1);
						}));

						this.checkIfEmpty();
						this.setHeight();
						this.switchDifferences();
						fixPinnedLabels.render();
					}
				}

				/**
     * Unpins object from left side of table
     */

			}, {
				key: "unpinObject",
				value: function unpinObject() {
					$(this.pinnedTable).removeClass('active');
					$(this.scrollWraper).removeClass('fix');
					$(this.table + " tr td").removeClass('hide');
					$(this.pinningButton).removeClass('active');
					$(this.table).css('padding-left', '0');
					fixTableLabels.update();
					fixPinnedLabels.update();
				}

				/**
     * Checks if values in rows have differences
     */

			}, {
				key: "findDifferences",
				value: function findDifferences() {
					var _this16 = this;

					$(this.table + " tr").each(function (i, row) {
						if ($(row).data('row') === "options" || $(row).data('row') === "image" || $(row).data('row') === "label" || $(row).data('row') === "price" || $(row).data('row') === "space") return;

						var previousHtml = void 0;
						var isDifferent = void 0;

						$(row).find($(_this16.cells)).each(function (i2, cell) {
							var rowToSwitch = $(cell).parent().data('row');
							if (!previousHtml) {
								previousHtml = $(cell).html();
							} else if ($(cell).html() !== previousHtml) {
								$("[data-row=\"" + rowToSwitch + "\"]").addClass('different');
								isDifferent = true;
							} else if (!isDifferent) {
								$("[data-row=\"" + rowToSwitch + "\"]").removeClass('different');
							}
						});
					});
				}

				/**
     * Show/hide different rows
     * @param {object} event
     */

			}, {
				key: "switchDifferences",
				value: function switchDifferences(event) {
					$(this.tab).removeClass('active');
					if (event) {
						$(event.currentTarget).addClass('active');
					}
					// Return if table has only one object
					if ($(this.table + " [data-row=\"options\"]").children().length <= 2) {
						return false;
					}
					if ($(this.tab + ".active").is('[data-table-difference]')) {
						$('tr:not(.different)').hide();
					} else $('tr:not(.different)').show();
				}

				/**
     * Show/hide placehoder if table is empty
     */

			}, {
				key: "switchPlaceholder",
				value: function switchPlaceholder() {
					var tableContent = $(this.cells).length;
					var typeIsBuilding = buildingType === "new_buildings";
					var showable = $(this.placehodler).is(':hidden');

					if (!tableContent && showable) {
						$(this.wrapper + ", " + this.buttonsWrap).hide();
						if (typeIsBuilding) {
							$(this.placehodler).text("   ");
						} else $(this.placehodler).text("   ");
						$(this.placehodler).show();
					} else if (tableContent && !showable) {
						$(this.wrapper + ", " + this.buttonsWrap).show();
						$(this.placehodler).hide();
					}
					this.switchTip();
				}

				/**
     * Defines type of user device
     * And sets appropriate tip
     */

			}, {
				key: "setTip",
				value: function setTip() {
					var _this17 = this;

					if (isMobile) {
						$(this.tip + "__icon").hide();
						$(this.tip + "__text").text("     ");
					} else {
						$(this.tip + "__icon").show();
						$(this.tip + "__text").text("   ,      ");
					}
					var onFirstTouch = function onFirstTouch() {
						$(_this17.tip + "__icon").hide();
						$(_this17.tip + "__text").text("     ");
						$(window).off('touchstart', onFirstTouch);
					};
					$(window).on('touchstart', onFirstTouch);
				}

				/**
     * Set tip if device is exactly touch
     */

			}, {
				key: "setTipOnTouch",
				value: function setTipOnTouch() {
					$(this.tip + "__icon").hide();
					$(this.tip + "__text").text('     ');
					$(window).off('touchstart', this.setTipOnTouch);
				}

				/**
     * Show/hide control tip
     */

			}, {
				key: "switchTip",
				value: function switchTip() {
					if ($(this.table).outerWidth() < $(this.table)[0].scrollWidth) {
						$(this.tip).show();
						$(this.table).css('cursor', 'ew-resize');
					} else {
						$(this.tip).hide();
						$(this.table).css('cursor', 'default');
					}
				}

				/**
     * Show/hide row if it's empty
     */

			}, {
				key: "checkIfEmpty",
				value: function checkIfEmpty() {
					var _this18 = this;

					$(this.table + " > table tr").each(function (i, row) {
						var rowData = $(row).data('row');
						var allRows = $("[data-row=" + rowData + "]");
						var cells = $(row).find($(_this18.cells));
						var isEmpty = Array.prototype.every.call(cells, function (cell) {
							return ~$(cell).text().indexOf('');
						});
						isEmpty ? allRows.hide() : allRows.css("display", "table-row");
					});
				}

				/**
     * Changes history state and URL
     * @param {string} objectId 
     */

			}, {
				key: "changeHistory",
				value: function changeHistory(objectId) {
					if (objectId) {
						var index = this.historyObjects.indexOf(objectId);
						if (index !== -1) {
							this.historyObjects.splice(index, 1);
						} else {
							this.historyObjects.push(objectId);
						}
					}
					if ($('[data-cell-id]').length) {
						history.replaceState(this.historyObjects, 'Compare', "?ids=" + this.historyObjects.join(',') + "&type=" + buildingType);
					} else {
						history.replaceState(this.historyObjects, 'Compare', '?');
					}
				}

				/**
     * Removes object from cookies
     * @param {string} objectId 
     */

			}, {
				key: "removeFromCookie",
				value: function removeFromCookie(objectId) {
					var cookie = getCookie('compare');
					var cookieItem = objectId + "&" + buildingType;
					var parsedCookie = JSON.parse(cookie);
					var timer = new Date(new Date().getTime() + 365 * 24 * 3600 * 1000).toUTCString();
					var settings = { expires: timer, path: "/", domain: location.hostname };

					if (parsedCookie && parsedCookie.length) {
						if (arrayFind(parsedCookie, cookieItem) != -1) {
							parsedCookie.splice(arrayFind(parsedCookie, cookieItem), 1);
							setCookie("compare", JSON.stringify(parsedCookie), settings);
						}
					}
				}

				/**
     * Add object to meta og:title
     * @param {string} name 
     */

			}, {
				key: "addToOg",
				value: function addToOg(name) {
					var title = $('meta[property="og:title"]').attr('content');
					var newTitle = title.replace(/\ ?\|/g, ', ' + name + ' |');
					$('meta[property="og:title"]').attr('content', newTitle);
				}

				/**
     * Replace object from meta og:title
     * @param {string} name 
     */

			}, {
				key: "replaceFromOg",
				value: function replaceFromOg(name) {
					var title = $('meta[property="og:title"]').attr('content');
					var replacement = new RegExp('\ ?' + name + '\,?', "g");
					var newTitle = title.replace(replacement, '');
					$('meta[property="og:title"]').attr('content', newTitle);
				}

				/**
     * Copies current URL to clipboard
     */

			}, {
				key: "copyURL",
				value: function copyURL() {

					var textArea = document.createElement("textarea");
					textArea.style.position = 'fixed';
					textArea.style.top = 0;
					textArea.style.left = 0;
					textArea.style.width = '1px';
					textArea.style.height = '1px';
					textArea.style.padding = 0;
					textArea.style.border = 'none';
					textArea.style.outline = 'none';
					textArea.style.boxShadow = 'none';
					textArea.style.background = 'transparent';
					textArea.value = window.location.href;
					document.body.appendChild(textArea);

					textArea.focus();
					textArea.setSelectionRange(0, textArea.value.length);

					try {
						document.execCommand('copy');
					} catch (err) {
						console.log('Oops, unable to copy');
					}

					document.body.removeChild(textArea);

					var button = $(this.copyButton).find('span');
					button.text("!");
					setTimeout(function () {
						button.text(" ");
					}, 500);
				}

				/**
     * Toggle dropdown with sharing buttons
     * @param {event} event 
     */

			}, {
				key: "shareDropdown",
				value: function shareDropdown(event) {
					if (!$(event.target).closest($(this.shareWrap)).length) {
						$('.compare__list_share_dropdown').removeClass('open');
					} else if ($(event.target).is('.compare__list_share') || $(event.target).is('.compare__list_share_wrap')) {
						event.preventDefault();
						$('.compare__list_share_dropdown').toggleClass('open');
					}
				}

				/**
     * Bind all events
     */

			}, {
				key: "bindEvents",
				value: function bindEvents() {
					var _this19 = this;

					$(window).on('load', this.setHeight);
					$(window).on('touchstart', this.setTipOnTouch);
					$(window).on('resize', function () {
						_this19.alignTable();
						_this19.setTip();
						_this19.alignPinnedTable();
						_this19.switchTip();
					});
					$(document).on('click', function (e) {
						return _this19.shareDropdown(e);
					});
					$(document).ready(function () {
						_this19.findDifferences();
						_this19.alignTable();
						_this19.setTip();
					});
					$("body").on('mouseenter mouseleave', this.wrapper + " tr", function (e) {
						return _this19.rowHover(e);
					});
					$("body").on('click', this.removeButton, function (e) {
						return _this19.removeObject(e);
					});
					$("body").on('click', this.pinningButton, function (e) {
						return _this19.pinObject(e);
					});
					$("body").on('click', this.pinningButton + ".active", this.unpinObject);
					$(this.clearButton).on('click', this.clearTable);
					$(this.tab).on('click', function (e) {
						return _this19.switchDifferences(e);
					});
					$(this.copyButton).on('click', function (e) {
						e.preventDefault();
						_this19.copyURL();
					});
				}
			}]);

			return Table;
		}();

		var Search = function () {
			/**
    * Creates an instance of Search.
    * @param {object} options
    * @param {boolean} recommendedAdvert:
    * Variable to find out if we shoud 
    * show advertising object
    * @memberof Search
    */
			function Search(options) {
				_classCallCheck(this, Search);

				this.form = options.form;
				this.input = options.input;
				this.recommendedAdvert = buildingType === 'new_buildings' ? true : false;
				this.counter = 1;
				this.getObject = this.getObject.bind(this);
				this.parseCookies = this.parseCookies.bind(this);
			}

			_createClass(Search, [{
				key: "setEndPoint",
				value: function setEndPoint() {
					if (buildingType !== 'new_buildings') {
						$(this.input).attr('data-search-empty-url', '/ajax/text_search_compare_adv.php?type=cottages');
					}
				}
			}, {
				key: "getObject",
				value: function getObject(objectId) {
					var formAction = $(this.form).attr('action');
					var buildingId = objectId || $(this.input).attr('data-building');

					$.ajax({
						type: "GET",
						datatype: "JSON",
						url: formAction,
						data: "ids=" + buildingId + "&type=" + buildingType,
						success: function success(data, textStatus, jqXHR) {
							compareTable.render(data);
						}
					});
				}

				/**
     * Add object from search
     * @memberof Search
     */

			}, {
				key: "getRecommendedObject",
				value: function getRecommendedObject(value) {
					var _this20 = this;

					if (this.recommendedAdvert) {
						$.ajax({
							type: "GET",
							datatype: "JSON",
							url: "/ajax/compare_adv.php",
							data: "type=" + buildingType + ("&building_class=" + (value || "")) + ("&city=" + (citiesCounter.countMostRepeatable() || "")) + ("&city_district=" + (districtsCounter.countMostRepeatable() || "")) + ("&city_block=" + (blocksCounter.countMostRepeatable() || "")),
							success: function success(data, textStatus, jqXHR) {

								if (!data && housingClasses.getByIndex(_this20.counter) !== 0) {
									_this20.getRecommendedObject(housingClasses.getByIndex(_this20.counter));
									_this20.counter++;
								} else {
									compareTable.renderRecommended(data);
								}
							}
						});
					}
				}

				/**
     * Parse data from cookies
     * @memberof Search
     */

			}, {
				key: "parseCookies",
				value: function parseCookies() {
					var _this21 = this;

					if ($('#compare-form').length && compareStorage.checkCookies()) {
						var cookie = getCookie('compare');
						var parsedCookie = JSON.parse(cookie);

						parsedCookie.forEach(function (el) {
							var item = el;
							var ampersand = item.indexOf("&");
							var id = item.slice(0, ampersand);
							_this21.getObject(id);
						});
					}
				}
			}, {
				key: "bindEvents",
				value: function bindEvents() {
					var _this22 = this;

					$(this.form).on('submit', function (event) {
						event.preventDefault();
						_this22.getObject();
					});
					$(document).ready(this.setEndPoint);
				}
			}]);

			return Search;
		}();

		/**
   * Creates an instance of tableDragger.
   * https://github.com/sindu12jun/table-dragger
   * @class DragAndDrop
   */


		var DragAndDrop =
		/**
   * Creates an instance of DragAndDrop.
   * @param {object} options
   * @param {string} options.table
   * @param {object} options.draggerConfig
   * @memberof DragAndDrop
   */
		function DragAndDrop(options) {
			_classCallCheck(this, DragAndDrop);

			this.table = options.table;
			this.dragger = tableDragger($(options.table)[0], options.draggerConfig);
		};

		/**
   * Exetends simple drag and drop with
   * drag and scroll function: when you
   * drag element in wrapper with scrollbar,
   * dragging left or right will fire scrolling.
   *
   * @class DndWithScroll
   * @extends {DragAndDrop}
   */


		var DndWithScroll = function (_DragAndDrop) {
			_inherits(DndWithScroll, _DragAndDrop);

			/**
    * Creates an instance of DndWithScroll.
    * @param {object} options
    * @param {string} options.tableWrap wrapper with scroll
    * @param {string} options.draggerConfig.dragHandler drag handler from config
    * @memberof DndWithScroll
    */
			function DndWithScroll(options) {
				_classCallCheck(this, DndWithScroll);

				var _this23 = _possibleConstructorReturn(this, (DndWithScroll.__proto__ || Object.getPrototypeOf(DndWithScroll)).call(this, options));

				_this23.tableWrap = options.tableWrap;
				_this23.handler = options.draggerConfig.dragHandler;
				_this23.columnAvatar = '.gu-mirror';
				_this23.ignoreColumn = '.sindu_dragger li:first-child';
				_this23.ignoreClass = 'sindu_static';
				_this23.tableScroll = null;
				_this23.commitTableScroll = _this23.commitTableScroll.bind(_this23);
				_this23.scrollOnDrag = _this23.scrollOnDrag.bind(_this23);
				_this23.onDragStart = _this23.onDragStart.bind(_this23);
				_this23.onDrop = _this23.onDrop.bind(_this23);
				return _this23;
			}

			/**
    * Crutchy method to prevent library bug,
    * which scrolls wrapper back when you start
    * dragging and wrapper has some scroll left.
    *
    * @memberof DndWithScroll
    */


			_createClass(DndWithScroll, [{
				key: "commitTableScroll",
				value: function commitTableScroll() {
					this.tableScroll = $(this.tableWrap).scrollLeft();
					sliderForTable.scroll = false;
				}

				/**
     * Main method described in class declaration.
     *
     * @memberof DndWithScroll
     */

			}, {
				key: "scrollOnDrag",
				value: function scrollOnDrag() {
					var coords = this.coords;
					if (coords.columnAvatar.right > coords.tableWrap.right) {
						$(this.tableWrap).scrollLeft($(this.tableWrap).scrollLeft() + (coords.columnAvatar.right - coords.tableWrap.right));
					} else if (coords.columnAvatar.left < coords.tableWrap.left) {
						$(this.tableWrap).scrollLeft($(this.tableWrap).scrollLeft() - (coords.tableWrap.left - coords.columnAvatar.left));
					}
				}

				/**
     * Makes desired column ignorable
     *
     * @memberof DndWithScroll
     */

			}, {
				key: "onDragStart",
				value: function onDragStart() {
					sliderForTable.scroll = false;
					this.offConflictingEventListeners();
					$(this.tableWrap).scrollLeft(this.tableScroll);
					$(this.ignoreColumn).addClass(this.ignoreClass);
					$(document).on('mousemove', this.scrollOnDrag);
				}
			}, {
				key: "onDrop",
				value: function onDrop() {
					$(document).off('mousemove', this.scrollOnDrag);
					fixTableLabels.update();
					fixPinnedLabels.update();
					this.onConflictingEventListeners();
				}
			}, {
				key: "offConflictingEventListeners",
				value: function offConflictingEventListeners() {
					$('.compare__table').off();
					$("body").off('mouseenter mouseleave', compareTable.wrapper + " tr");
				}
			}, {
				key: "onConflictingEventListeners",
				value: function onConflictingEventListeners() {
					sliderForTable.bindEvents();
					$("body").on('mouseenter mouseleave', compareTable.wrapper + " tr", function (e) {
						return compareTable.rowHover(e);
					});
					fixTableLabels.$wrapper.on("scroll", function () {
						return fixTableLabels.changePosition();
					});
				}
			}, {
				key: "bindEvents",
				value: function bindEvents() {
					$(document).on('mousedown', "[data-dnd-handler]", this.commitTableScroll);
					this.dragger.on('drag', this.onDragStart);
					this.dragger.on('drop', this.onDrop);
				}
			}, {
				key: "coords",
				get: function get() {
					return {
						columnAvatar: {
							left: $(this.columnAvatar)[0].getBoundingClientRect().left,
							right: $(this.columnAvatar)[0].getBoundingClientRect().right
						},
						tableWrap: {
							left: $(this.tableWrap)[0].getBoundingClientRect().left,
							right: $(this.tableWrap)[0].getBoundingClientRect().right
						}
					};
				}
			}]);

			return DndWithScroll;
		}(DragAndDrop);

		var compareDnd = void 0;
		var fixTableLabels = void 0;
		var fixPinnedLabels = void 0;
		var sliderForTable = void 0;
		var compareTable = void 0;
		var compareSearch = void 0;

		if ($("#compare-form").length) {

			fixTableLabels = new Fixator({
				wrapper: ".compare__table",
				table: ".compare__table > table",
				rows: [".compare__table > table [data-row='options']", ".compare__table > table [data-row='label']"]
			});

			fixPinnedLabels = new Fixator({
				wrapper: ".compare__table__fix",
				table: ".compare__table__fix > table",
				rows: [".compare__table__fix > table [data-row='options']", ".compare__table__fix > table [data-row='label']"]
			});

			sliderForTable = new grabAndSlide(".compare__table");

			compareTable = new Table({
				wrapper: '.compare__table_wrap',
				scrollWraper: '.compare__table__wrap_scroll',
				table: '.compare__table',
				pinnedTable: '.compare__table__fix',
				nameTable: '.compare__table_name',
				cells: '[data-cell-id]',
				removeButton: '.compare__table_icon_close',
				pinningButton: '.compare__table_icon_fix',
				tab: '.compare__tab_item',
				clearButton: '.compare__list_clear',
				placehodler: '.compare-title',
				buttonsWrap: '.compare__top_line',
				tip: '.compare-tip',
				copyButton: '[data-copy-url]',
				shareWrap: '.compare__list_share_wrap'
			});

			compareSearch = new Search({
				form: '#compare-form',
				input: '#compare-form .input-autocomplete'
			});

			compareDnd = new DndWithScroll({
				tableWrap: '.compare__table',
				table: '.compare__table > table',
				draggerConfig: {
					mode: 'column',
					dragHandler: "[data-row='options'] td:first-child",
					onlyBody: true,
					animation: 300
				}
			});

			fixTableLabels.bindEvents();
			fixPinnedLabels.bindEvents();
			sliderForTable.bindEvents();
			compareTable.bindEvents();
			compareSearch.bindEvents();
			compareDnd.bindEvents();
		}

		/**
   * Parses inline JSON with data on buildings
   * recieved from server. Then parses cookies, 
   * and render all of this.
   */
		$(document).ready(function () {
			if ($("#compare-form").length) {
				if (window.compareData && window.compareData.length) {
					setTimeout(function () {
						compareSearch.getRecommendedObject(housingClasses.countMostRepeatable());
					}, setTimeout(function () {
						compareSearch.parseCookies();
					}, compareTable.render(window.compareData)));
				} else {
					compareSearch.parseCookies();
				}
			}
		});

		function toggleSidebarButtons() {
			if (isMobile) {
				!+$(".sidebar-compare__cnt span").text() ? $(".sidebar-compare").css("visibility", "hidden") : $(".sidebar-compare").css("visibility", "visible");
				!+$(".sidebar-favorites__cnt span").text() ? $(".sidebar-favorites").css("visibility", "hidden") : $(".sidebar-favorites").css("visibility", "visible");
			} else $(".sidebar-compare, .sidebar-favorites").css("visibility", "visible");
		}

		if ($('.advertise_return_call__form').length) {
			$('input, textarea').on('change', function () {
				if (!$(this).val() == '') {
					$(this).closest('.advertise_return_call__line').addClass('not_empty');
				} else {
					$(this).closest('.advertise_return_call__line').removeClass('not_empty');
				}
			});
		}

		if ($('.ajax-traffic').length) {
			var url = $('.ajax-traffic').data('href') || "",
			    options = {
				pieHole: 0.4,
				fontSize: 12,
				backgroundColor: 'transparent',
				pieSliceTextStyle: {
					color: '#fff'
				},
				chartArea: {
					left: 0,
					top: 25,
					width: '210',
					height: '210'
				},
				legend: {
					position: 'none'
				},
				slices: {
					0: { color: '#1c1f3e' },
					1: { color: '#292356' },
					2: { color: '#ff9e00' },
					3: { color: '#ffb900' },
					4: { color: '#808080' },
					5: { color: '#bcbebf' },
					6: { color: '#009688' },
					7: { color: '#9C27B0' },
					8: { color: '#3f51b5' },
					9: { color: '#ffeb3b' }
				},
				tooltip: {
					isHtml: true,
					text: 'percentage',
					left: 0,
					top: 0,
					textStyle: {
						fontSize: 28,
						bold: false,
						fontName: '"BebasWeb", Helvetica, Arial, sans-serif'
					}
				}
			};
			if (url.length) {
				var drawGoogleChart = function drawGoogleChart(data, options, key) {
					return function () {
						if (data instanceof Array) {
							var dataTable = google.visualization.arrayToDataTable(data),
							    chart = new google.visualization.PieChart(document.getElementById(key));
							chart.draw(dataTable, options);
						}
					};
				};
				var index = 0;
				$.get(url).done(function (traffic) {
					$('.ajax-traffic').empty();
					if (traffic instanceof Array) {
						google.charts.load("42", { packages: ["corechart"] });
						traffic.map(function (item) {
							var name = item.name || undefined,
							    elements = item.elements || undefined,
							    data = [['Effort', 'Amount given', { type: 'string', role: 'tooltip' }]],
							    key = 'advertise_structure__graph_' + index++;
							if (name && elements) {
								var $blockWrap = $('<div/>', { class: 'advertise_structure__block_wrap' }).appendTo('.ajax-traffic'),
								    $block = $('<div/>', { class: 'advertise_structure__block' }).appendTo($blockWrap);
								$('<div/>', { class: 'advertise_structure__title', text: name }).appendTo($block);
								var $graph = $('<div/>', { class: 'advertise_structure__graph' }).appendTo($block);
								$('<div/>', { class: 'advertise_structure__graph_item', id: key }).appendTo($graph);
								var classItemWrap = elements.length > 3 ? 'advertise_structure__item_wrap advertise_structure__item_wrap--col_2' : 'advertise_structure__item_wrap',
								    $itemWrap = $('<div/>', { class: classItemWrap }).appendTo($block);
								elements.map(function (element, indexOfElement) {
									var currentClass = 'advertise_structure__item advertise_structure__item--' + indexOfElement;
									$('<div/>', { class: currentClass, text: element.title }).appendTo($itemWrap);
									data.push([element.title, parseFloat(element.percent.replace('%', '')), element.percent]);
								});
								google.charts.setOnLoadCallback(drawGoogleChart(data, options, key));
							}
						});
					}
				});
			}
		}

		// $('.advertise_structure__graph_item svg g').hover(
		$("body").on("mouseenter", '.advertise_structure__graph_item svg g', function (e) {
			e.preventDefault();
			var this_num = $(this).closest('.advertise_structure__block').find('.advertise_structure__item').length >= 5 ? $(this).index() - 1 : $(this).index();

			$(this).closest('.advertise_structure__block').find('.advertise_structure__item:eq(-' + this_num + ')').addClass('hover');
		});

		$("body").on("mouseleave", '.advertise_structure__graph_item svg g', function (e) {
			e.preventDefault();
			var this_num = $(this).closest('.advertise_structure__block').find('.advertise_structure__item').length >= 5 ? $(this).index() - 1 : $(this).index();
			$(this).closest('.advertise_structure__block').find('.advertise_structure__item:eq(-' + this_num + ')').removeClass('hover');
		});

		$("body").on("mouseenter", '.advertise_structure__item', function (e) {
			e.preventDefault();
			var this_num = $(this).index() + 1;
			$(this).addClass('hover');
			$(this).closest('.advertise_structure__block').find('.advertise_structure__graph_item svg g:eq(' + this_num + ')');
			// dataTable.setSelection([{row: 1}]);
			var chart_name = '';
			google.visualization.events.addListener(chart_name, 'onmouseover', function () {
				chart_name.setSelection([{ row: this_num }]);
			});
		});
		$("body").on("mouseleave", '.advertise_structure__item', function (e) {
			e.preventDefault();
			var this_num = $(this).index() + 1;
			$(this).removeClass('hover');
		});
		//Begin block mainBanner
		var $mainBanner = $('.main-banner');
		var $mainBannerMinimize = $mainBanner.find('.main-banner__minimize');

		function hideBanners(article) {
			var content = article.find('.article-content');
			var sidebar = article.find('.article-banners');

			if ($(sidebar).height() > $(content).height()) {
				var banners = $(sidebar).find($('.article-banners__item:not(:first-child)'));
				var contentBottom = $(content).offset().top + $(content).height();

				banners.each(function (index, banner) {
					if ($(banner).offset().top + $(banner).height() > contentBottom) {
						$(banner).hide();
					}
				});
			}
		}

		$(window).on('load', function () {

			$('.articles__item').each(function (index, article) {
				hideBanners($(article));
			});
		});

		if (getCookie('banner') == 'small') {
			$mainBanner.addClass('_minimized');
		}

		$mainBannerMinimize.on('click', function (e) {
			e.preventDefault();

			if (!$mainBanner.hasClass("_minimized")) {
				$mainBanner.addClass('_minimized');
				setCookie('banner', 'small', { path: '/', domain: location.hostname });
			} else {
				$mainBanner.removeClass('_minimized');
				setCookie('banner', 'big', { path: '/', domain: location.hostname });
			}
		});

		if ($('.search-wrapper').length) {
			$mainBanner.addClass('_show');
		} else if ($('.section_index__content').length) {

			if ($('.footer').length) {
				$(window).on('scroll', function () {
					if ($(window).scrollTop() > $('.section_index__content').height() && $(window).scrollTop() + $(window).height() < $('.footer').offset().top) {
						$mainBanner.addClass('_show');
					} else {
						$mainBanner.removeClass('_show');
					}
				});
			}
		} else if ($('.lider_invest').length) {
			$mainBanner.removeClass('_show');
		} else {
			if ($('.footer').length) {
				$(window).on('scroll', function () {

					if ($(window).scrollTop() > 100 && $(window).scrollTop() + $(window).height() < $('.footer').offset().top) {
						$mainBanner.addClass('_show');
					} else {
						$mainBanner.removeClass('_show');
					}
				});
			}
		}
		$('.metro_tab__item').on('click', function (e) {
			e.preventDefault();
			var metro_tab = $(this);
			var metro_name = '.' + $(this).find('.metro_tab__link').attr('href');
			if (metro_tab.hasClass('active')) {
				metro_tab.removeClass('active');
				$(metro_name).removeClass('active');

				$('.metro_tab__item.active').each(function () {
					var metro_tab_act = '.' + $(this).children('.metro_tab__link').attr('href');
					$(metro_tab_act).addClass('active');
				});
			} else {
				// $('.metro_tab__item').removeClass('active');
				// $('.metro_list__item').removeClass('active');
				metro_tab.addClass('active');
				$(metro_name).addClass('active');
			}
			return false;
		});

		if ($('.slider-background').length) {
			// }

			var slidersHeight = function slidersHeight() {

				if (isMobile) {
					TweenMax.to(slidersBackground, 0.3, { height: sectionIndex.outerHeight() });
					// slidersBackground.height(sectionIndex.outerHeight())
				} else {
					slidersBackground.height('');
				}
			};

			var slidersInit = function slidersInit() {
				var textOptions;
				var backgroundOptions;

				if ($('.section_index').hasClass('geo')) {

					textOptions = {
						autoplay: true,
						autoplaySpeed: sliderDuration,
						speed: sliderChangeSpeed,
						arrows: false,
						fade: true,
						swipe: false,
						pauseOnFocus: false,
						pauseOnHover: false,
						asNavFor: '.slider-background',
						pauseOnDotsHover: false,
						centerMode: true, // f
						centerPadding: sliderText.find('.slider-text__item').outerWidth() / 2 + 'px', // f
						slidesToShow: 1 // f


					};
					backgroundOptions = {
						lazyLoad: 'ondemand',
						speed: sliderChangeSpeed,
						arrows: false,
						// fade: true,
						asNavFor: '.slider-text',
						waitForAnimate: false,
						centerMode: true, // f
						centerPadding: '150px', // f
						slidesToShow: 1, // f

						responsive: [
							// {
							//   breakpoint: 1024,
							//   settings: {
							//     slidesToShow: 3,
							//     slidesToScroll: 3,
							//     infinite: true,
							//     dots: true
							//   }
							// },
							// {
							//   breakpoint: 600,
							//   settings: {
							//     slidesToShow: 2,
							//     slidesToScroll: 2
							//   }
							// },
							// {
							// 	breakpoint: 992,
							// 	settings: {
							// 		centerPadding: '0px',
							// 	}
							// }
						]
					};
				} else {

					textOptions = {
						autoplay: true,
						autoplaySpeed: sliderDuration,
						speed: sliderChangeSpeed,
						adaptiveHeight: true,
						arrows: false,
						fade: true,
						swipe: false,
						pauseOnFocus: false,
						pauseOnHover: false,
						asNavFor: '.slider-background',
						pauseOnDotsHover: false,
						centerMode: true,
						centerPadding: sliderText.find('.slider-text__item').outerWidth() / 2 + 'px',
						slidesToShow: 1
					};

					backgroundOptions = {
						lazyLoad: 'ondemand',
						speed: sliderChangeSpeed,
						arrows: false,
						fade: true,
						asNavFor: '.slider-text',
						waitForAnimate: false
					};
				}

				sliderText.slick(textOptions).on('beforeChange', function (event, slick, currentSlide, nextSlide) {

					slideAnimation($(slick.$slides[nextSlide]));

					var licenseColor = $(".slider-text__item_default[data-slick-index=\"" + nextSlide + "\"]").data('license-color');
					var licenseText = $(".slider-text__item_default[data-slick-index=\"" + nextSlide + "\"]").data('license-text');
					$('.license-text').removeClass('white black').attr('style', "color: " + licenseColor).text(licenseText);
					// slideAnimation();
				});

				sliderBackground.on('init', function (event, slick) {
					if (slick.$slides.length < 2) {
						sliderNav.hide();
					}
				});

				sliderBackground.slick(backgroundOptions).on('beforeChange', function (event, slick, currentSlide, nextSlide) {
					// console.log(slick.$slides[nextSlide],'1')


					// console.log(sliderVideoStatus)

					progressAnimation();

					if (sliderVideo.length) {

						if (sliderVideoStatus) {
							// console.log('    ')
							sliderVideoHide();
						}
					}

					// slideAnimation();
				}).on('afterChange', function (event, slick, currentSlide) {
					// if (sliderVideoStatus){
					// 	sliderVideoHide();
					// }
					slidersHeight();
				});

				// animateMouse(mouseTimeline)
			};

			var slideAnimation = function slideAnimation(slide) {
				// console.log('slide',slide)
				if (!slide) {
					return false;
				}

				var slideHeader = slide.find('.slider-info__header').attr('style', '');
				var slideSubheader = slide.find('.slider-info__subheader').attr('style', '');
				var slideDescription = slide.find('.slider-info__description').attr('style', '');
				var slidePrice = slide.find('.slider-price').attr('style', '');
				var slideCallback = slide.find('.slider-callback').attr('style', '');

				// console.log('slideHeader',slideHeader)


				slideTimeline.pause(0);
				slideTimeline.clear();
				slideTimeline.restart();

				slideTimeline.fromTo(slideHeader, 0.7, { opacity: 0, y: "-20px" }, { opacity: 1, y: "0px", delay: 0.2, clearProps: "transformOrgin,transform,scale,opacity" });

				slideTimeline.fromTo(slideSubheader, 0.7, { opacity: 0, y: "20px" }, { opacity: 1, y: "0px", clearProps: "transformOrgin,transform,scale,opacity" }, '-=0.5');

				slideTimeline.fromTo(slideDescription, 0.7, { opacity: 0, y: "20px" }, { opacity: 1, y: "0px", clearProps: "transformOrgin,transform,scale,opacity" }, '-=0.5');

				slideTimeline.fromTo(slidePrice, 0.7, { opacity: 0, y: "20px" }, { opacity: 1, y: "0px", clearProps: "transformOrgin,transform,scale,opacity" }, '-=0.5');

				slideTimeline.fromTo(slideCallback, 0.7, { opacity: 0, y: "20px" }, { opacity: 1, y: "0px", clearProps: "transformOrgin,transform,scale,opacity" }, '-=0.5');
			};

			var progressAnimation = function progressAnimation(clear) {
				progressTimeline.clear();
				clear ? time = 0 : time = sliderText.slick('getOption', 'autoplaySpeed');
				// console.log('progressAnimation', time)

				progressTimeline.set(progressLine, { height: '4px', opacity: 1 });
				progressTimeline.fromTo(progressLine, (time - 0.5) / 1000, { width: 0 }, { width: '100%', ease: Power0.easeNone });
				progressTimeline.fromTo(progressLine, 0.5, { height: '4px', opacity: 1 }, { height: '0', opacity: 0 });
				// TweenMax.fromTo(progressLine, sliderDuration/1000, {width: 0}, {width: '100%'})
			};

			var advangatesAnimation = function advangatesAnimation(type) {
				// tl.pause(0);
				// console.log('advangatesAnimation',type)
				if (!animationStatus) {
					return;
				}
				advantageItemsTimeline.pause(0);
				advantageItemsTimeline.clear();
				advantageItemsTimeline.restart();

				if (type == "show") {
					advantageItemsTimeline.set(advantage, { className: "advantages" });
					// advantageItemsTimeline.to(advantage,0.3,{className: "advantages"})
					advantageItemsTimeline.staggerFromTo(advantageItems, 0.3, { y: "20px", opacity: 0 }, {
						y: 0,
						opacity: 1,
						ease: Back.easeOut.config(1.7),
						onStart: function onStart(e) {
							// console.log(this);
							animateAdvantage($(this.target).find('.icon-advantage'), $(this.target).data('index'));
						}
					}, 0.2, '-=0.9');
				} else {
					advantageItemsTimeline.staggerFromTo(advantageItems, 0.3, { y: 0, opacity: 1 }, { y: "20px", opacity: 0 }, 0.2);
					advantageItemsTimeline.set(advantage, { className: "advantages advantages_hidden" }, '-=0.9');
					// animateMouse()
					// advantageItemsTimeline.to(advantage,0.5,{className: "advantages advantages_hidden"},'-=0.9')
				}
			};

			var sliderVideoHide = function sliderVideoHide() {

				// console.log('here n k')
				// if(sliderVideoStatus){

				// console.log('  ')
				// console.log('sliderVideoHide')

				slidersFilter(true);
				sliderVideoCanPlay();
				advangatesAnimation("hide");
				sliderText.slick('setOption', 'autoplaySpeed', sliderDuration, true);
				progressAnimation();
				videoAction('hide');
				// slider-text__item slider-text__item_default slick-slide slick-current slick-active
				slideAnimation($('.slider-text .slick-current'));
				sliderVideoStatus = false;
				TweenMax.to(sliderNav, 0.2, { autoAlpha: 1 });
				$('.scroll-icon').removeClass('scroll-icon_hidden');
				animateMouse(mouseTimeline);
				// }
			};

			var sliderVideoShow = function sliderVideoShow() {

				console.log(videoDuration);
				// console.log('here k')
				// console.log('sliderVideoStatus',sliderVideoStatus)
				// if(!sliderVideoStatus){

				if (sliderVideo.length) {

					// console.log('  ')

					slidersFilter(false);
					sliderVideoPlay();
					advangatesAnimation("show");
					// sliderText.slick('setOption','autoplaySpeed',(videoDuration*1000),true)
					// progressAnimation();
					slideAnimation(indexSlide);
					videoAction('show');
					sliderVideoStatus = true;
					TweenMax.to(sliderNav, 0.2, { autoAlpha: 0 });
					$('.scroll-icon').addClass('scroll-icon_hidden');
				}

				// }
			};

			var sliderVideoPlay = function sliderVideoPlay() {
				// console.log('sliderVideoPlay')
				sliderButton.addClass('active');
				if (!isMobile && sliderVideo.length) {
					sliderVideo[0].play();
				}
				// TweenMax.to(videoPlayPath, 0.2, {morphSVG:{shape:videoClosePath, shapeIndex:3}})
				TweenMax.fromTo(videoPlayPath, 0.2, { opacity: 1, scale: 1, transformOrigin: "center" }, { opacity: 0, scale: 0 });
				TweenMax.fromTo(videoClosePath, 0.2, { opacity: 0, scale: 0, transformOrigin: "center" }, { opacity: 1, scale: 1 });
			};

			var sliderVideoCanPlay = function sliderVideoCanPlay() {
				// console.log('sliderVideoCanPlay')
				sliderButton.removeClass('active');

				if (!isMobile && sliderVideo.length) {
					sliderVideo[0].pause();
					if (!isNaN(sliderVideo[0].duration)) {
						sliderVideo[0].currentTime = 0;
					}
				}
				// TweenMax.to(videoPlayPath, 0.2, {morphSVG:{shape:videoPlayPath, shapeIndex:3}})
				TweenMax.fromTo(videoClosePath, 0.2, { opacity: 1, scale: 1, transformOrigin: "center" }, { opacity: 0, scale: 0 });
				TweenMax.fromTo(videoPlayPath, 0.2, { opacity: 0, scale: 0, transformOrigin: "center" }, { opacity: 1, scale: 1 });
				TweenMax.to(videoPgoressPath, 0.2, { drawSVG: "100% 100%", ease: Power0.easeNone });
			};

			// function sliderVideoPause(){
			// 	// console.log('sliderVideoPause')
			// 	sliderButton.removeClass('active');
			// 	if(!isMobile && sliderVideo.length){
			// 		sliderVideo[0].pause()
			// 	}
			// 	TweenMax.to(videoPlayPath, 0.2, {morphSVG:{shape:videoPlayPath, shapeIndex:2}})
			// }


			var slidersFilter = function slidersFilter(status) {
				// console.log('slidersFilter',status)
				clearTimeout(sliderTimeout);

				if (status) {
					sliderAction = 'filter';
					sliderBackground.slick('slickFilter', '.slider-background__item_default');
					sliderText.slick('slickFilter', '.slider-text__item_default');
				} else {
					sliderAction = 'unfilter';
					sliderText.slick('slickUnfilter');
					sliderBackground.slick('slickUnfilter');

					sliderBackground.slick('slickGoTo', sliderLength - 1);
				}
			};

			var indexSliderInit = function indexSliderInit() {
				// console.log('indexSliderInit')

				sliderVideoCanPlay();
				// sliderVideoHide();

				if (!sliderVideoHidden && sliderVideo.length) {
					sliderVideoShow();
					// console.log('')
				} else {
					sliderVideoHide();
					// console.log('')
				}
			};

			// $(".overflow-line__content")

			// if($(".overflow-line").length){
			// Draggable.create($(".overflow-line"), {type:"scrollLeft", edgeResistance:0.9, throwProps:true});
			// Draggable.create($(".overflow-line"), {type:"scrollLeft", edgeResistance:0.9});
			// }

			// var isMobile = getRealWidth()<992 ? true : false;
			// $(window).on("resize", function(){
			// isMobile = getRealWidth()<992 ? true : false;
			// draggableAction();
			// })
			// draggableAction();

			// function draggableAction(){
			// 	if(!$(".overflow-line").length){
			// 		return false;
			// 	}
			// 	if(isMobile){
			// 		Draggable.get(".overflow-line").disable();
			// 	}else{
			// 		Draggable.get(".overflow-line").enable();
			// 	}
			// }

			var sliderBackground = $('.slider-background');
			var sliderText = $('.slider-text');
			var sliderNav = $('.slider-text-navigation');
			var sliderNavLeft = sliderNav.find('.slider-text__arrow_left');
			var sliderNavRight = sliderNav.find('.slider-text__arrow_right');
			var sliderVideo = $('#slider-video');
			var sliderVideoImg = $('#slider-video-img');
			var sliderVideoVolume = $('.video-sound-js');
			var sliderButton = $('.slider-button');
			var indexSlide = $('.slider-text__item_index');
			var videoSlide = $('.slider-background__item_index');
			var videoButton = $('.video-button');
			var videoPgoressPath = videoButton.find('[class*=video-progress]');
			var videoPlayPath = videoButton.find('[class*=video-icon]');
			var videoClosePath = videoButton.find('[class*=video-close]');
			var videoDuration = 0;
			var videoProgress = 10000;
			var sliderDuration = 8000;
			var sliderChangeSpeed = 500;

			// this is the state of the video, hack is used to prevent
			// 'loadedmetadata' event call multiple times when we're on a 'geo' page
			var videoLoadedState = false;

			var sliderVideoHidden = getCookie('showVideo') ? true : true;

			var sliderVideoStatus = sliderVideoHidden;
			var sliderAction = undefined;
			var sliderTimeout = undefined;
			var sliderLength = sliderText.find('.slider-text__item').length;
			var progress = $('.slider-progress');
			var progressLine = $('.slider-progress__line');
			var advantage = $('.section_index .advantages');
			var advantageItems = advantage.find('.advantage');
			var advantageItemsTimeline = new TimelineMax();
			var slideTimeline = new TimelineMax();
			var progressTimeline = new TimelineMax();
			var sectionIndex = $('.section_index');
			var slidersBackground = $('.slider-background__item');

			if (getCookie('music') && sliderVideo.length) {

				if (getCookie('music') * 1 === 0) {
					// $('#slider-video')[0].volume = 0;
					sliderVideo.prop('muted', true);

					if (sliderVideoVolume.length) {
						sliderVideoVolume.addClass('video-sound-js_active');
						sliderVideoVolume.find('.fa').removeClass('fa-volume-up').addClass('fa-volume-off');
						sliderVideoVolume.find('.sidebar-interface__title').text(' ');
					}
				} else {
					// $('#slider-video')[0].volume = 1;
					sliderVideo.removeAttr('muted');

					if (sliderVideoVolume.length) {
						sliderVideoVolume.removeClass('video-sound-js_active');
						sliderVideoVolume.find('.fa').removeClass('fa-volume-off').addClass('fa-volume-up');
						sliderVideoVolume.find('.sidebar-interface__title').text(' ');
					}
				}
			}

			if (sliderVideoVolume.length) {
				sliderVideoVolume.on('click', function (e) {
					var element;
					e.preventDefault();
					element = $(this);
					if (element.hasClass('video-sound-js_active')) {
						// $('#slider-video')[0].volume = 1;
						sliderVideo.prop('muted', false);
						setCookie('music', 1);
						element.removeClass('video-sound-js_active');
						element.find('.fa').removeClass('fa-volume-off').addClass('fa-volume-up');
						element.find('.sidebar-interface__title').text(' ');
					} else {
						// $('#slider-video')[0].volume = 0;
						sliderVideo.prop('muted', true);
						setCookie('music', 0);
						element.addClass('video-sound-js_active');
						element.find('.fa').removeClass('fa-volume-up').addClass('fa-volume-off');
						element.find('.sidebar-interface__title').text(' ');
					}
				});
			}

			// if (!sliderVideo.length){
			sliderButton.addClass('slider-button_hidden');

			window.videoAction = function (type) {

				var cookie = getCookie('showVideo');
				var timer = new Date(new Date().getTime() + 365 * 24 * 3600 * 1000);
				timer = timer.toUTCString();
				var directory = "/";
				var domainName = location.hostname;
				var security = false;
				var settings = { expires: timer, path: directory, domain: domainName };

				if (type == 'hide') {

					if (cookie) {
						setCookie('showVideo', 'hide', settings);
					}
				} else {
					setCookie('showVideo', 'hide', settings);
				}
			};

			if (sliderVideo.length) {
				if (isMobile) {
					videoDuration = 15;
				} else {

					// var pausePromise = sliderVideo[0].pause();

					// var playPromise = sliderVideo[0].play();

					// if (playPromise !== undefined) {
					// 	playPromise.then(function() {
					// 		// console.log('promise')
					// 	}).catch(function(error) {
					// 		// console.log('promise',error)
					// 	});
					// }

					// if (pausePromise !== undefined) {
					// 	pausePromise.then(function() {
					// 		console.log('promise')
					// 	}).catch(function(error) {
					// 		console.log('promise',error)
					// 	});
					// }

					// sliderVideo[0].play().then(function() {
					// 	sliderVideo[0].currentTime = 0;
					// 	sliderVideo[0].play();
					// }, function(error) {
					// 	console.log('promise',error)
					// });

					sliderVideo.load();

					sliderVideo.on("canplay", function () {
						// console.log('canplay')

					}).on("loadedmetadata", function () {
						// if video is already loaded, return from the second event
						if (videoLoadedState) {
							return;
						}

						sliderButton.removeClass('slider-button_hidden');

						videoDuration = sliderVideo[0].duration;
						if (!sliderVideoHidden) {
							indexSliderInit();
						}

						videoLoadedState = true;
					}).on("loadeddata", function () {
						// console.log('loadeddata')

					}).on("play", function () {
						// console.log('play')

						if (videoDuration != 0) {
							progressTimeline.clear();
						}
					}).on("timeupdate", function (e) {
						// console.log('timeupdate')
						// console.log(e,sliderVideo[0].currentTime)

						videoProgress = sliderVideo[0].currentTime;

						percent = videoProgress / videoDuration * 100;
						percent = 100 - percent;
						percent = percent.toFixed(1);

						if (videoProgress != 0 && videoDuration != 0) {

							sliderText.slick('setOption', 'autoplaySpeed', (videoDuration - videoProgress) * 1000, true);
							TweenMax.to(progressLine, 0.5, { width: 100 - percent + "%", ease: Power0.easeNone });
						}

						TweenMax.to(videoPgoressPath, 0.5, { drawSVG: "100% " + percent + "%", ease: Power0.easeNone });

						if (percent == 0) {
							sliderVideoCanPlay();
						}
					});
				}
			}

			sliderNavLeft.on("click", function (e) {
				sliderBackground.slick('slickPrev');
			});

			sliderNavRight.on("click", function (e) {
				sliderBackground.slick('slickNext');
			});

			sliderButton.on("click", function (e) {

				if (sliderVideo.length) {
					if (sliderButton.hasClass('active')) {
						// slidersFilter(false);
						// sliderVideoPause()
						// sliderVideoHide()
						sliderBackground.slick('slickNext');
						// console.log('  , active ')
					} else {
						// sliderButton.addClass('active');
						// slidersFilter(true);
						// console.log('  , active ')
						// sliderVideoPlay() - wtf,   sliderVideoShow    

						sliderVideoStatus = false;
						sliderVideoShow();
					}
				}
			});

			if (sliderBackground.length) {
				slidersInit();
				slidersHeight();

				$(window).on("resize", function () {
					slidersHeight();
				});
			}

			var showIndex = 0;
			var hideIndex = 0;

			$('.most-popular .most-popular__tab').on('show.bs.tab', function (e) {
				var target = $($(this).attr('href'));
				var complexes = target.find('.popular-complex');

				TweenMax.staggerFromTo(complexes, 0.7, { opacity: 0, y: '20px' }, { opacity: 1, y: '0', ease: Back.easeOut.config(1.7) }, 0.1);

				showIndex = $(this).parent().index();

				$(this).parent().removeClass('left right');
				$(this).parent().addClass('shown');

				if (showIndex > hideIndex) {
					$(this).parent().addClass('left');
				} else {
					$(this).parent().addClass('right');
				}
			}).on('shown.bs.tab', function () {
				bLazy.revalidate();
			}).on('hide.bs.tab', function (e) {
				hideIndex = $(this).parent().index();
			}).on('hidden.bs.tab', function (e) {

				$(this).parent().removeClass('shown left right');

				if (showIndex > hideIndex) {
					$(this).parent().addClass('right');
				} else {
					$(this).parent().addClass('left');
				}
			}).parents('.most-popular__tabs').find('li.active').addClass('shown');

			var indexController = new ScrollMagic.Controller({
				globalSceneOptions: {
					triggerHook: "onEnter"
				}
			});

			// if ($("#section-about").length && !isMobile){
			// 	var tween = TweenMax.staggerFromTo(
			// 		$(".advantage__img_big"),
			// 		0.3,
			// 		{y:"20px", opacity:0},
			// 		{
			// 			y:0,
			// 			opacity:1,
			// 			ease: Back.easeOut.config(1.7),
			// 			onStart:function(e){
			// 				// console.log(this);
			// 				animateAdvantage($(this.target).find('.icon-advantage'),$(this.target).data('index'))
			// 			}
			// 		},0.2)

			// 	new ScrollMagic.Scene({triggerElement: "#section-about"})
			// 		.setTween(tween)
			// 		.addTo(indexController);
			// }

			// if ($("#section-aero").length && !isMobile){
			// 	var tween = TweenMax.to("#section-aero .section__background", 0.1, {y: "-25%", ease: Power0.easeNone});

			// 	new ScrollMagic.Scene({triggerElement: "#section-aero", tweenChanges: true, duration: "200%"})
			// 		.setTween(tween)
			// 		.on('start', function () {
			// 			animateAero(aeroTimeline,lineTimeline);
			// 		})
			// 		.addTo(indexController);
			// }

			// if ($("#section-complex").length && !isMobile){
			// 	var tween = TweenMax.to("#section-complex .section__background", 0.1, {y: "-25%", ease: Power0.easeNone});

			// 	new ScrollMagic.Scene({triggerElement: "#section-complex", tweenChanges: true, duration: "200%"})
			// 		.setTween(tween)
			// 		.addTo(indexController);
			// }

			if ($("#section-map").length && !isMobile) {

				$('#section-map .map-apartment__yellow').css({ top: '100%' });
				$('#section-map .map-apartment__blue').css({ top: '-100%' });

				var tween = TweenMax.to("#section-map .map-apartment__yellow", 0.2, { y: "-100%", ease: Power0.easeNone });

				new ScrollMagic.Scene({ triggerElement: "#section-map", tweenChanges: true, duration: "50%" }).setTween(tween).addTo(indexController);

				var tween = TweenMax.to("#section-map .map-apartment__blue", 0.2, { y: "100%", ease: Power0.easeNone });

				new ScrollMagic.Scene({ triggerElement: "#section-map", tweenChanges: true, duration: "50%" }).setTween(tween).addTo(indexController);
			}

			// $.fn.parallax = function ( resistance, mouse ) {
			// 	$el = $( this );
			// 	TweenLite.to( $el, 0.2,
			// 	{
			// 		x : -(( mouse.clientX - (window.innerWidth/2) ) / resistance ),
			// 		y : -(( mouse.clientY - (window.innerHeight/2) ) / resistance ),
			// 		ease:Power4.easeOut
			// 	});
			// };
		};
		if ($('.object-tabs').length) {
			var getPrettyNum = function getPrettyNum(num, round, name, onlyName) {

				var value = ['', '.', '.', '.'];
				var valueKey = 0;
				var number = num;

				if (number > 1000) {
					while (number > 1000) {
						number = number / 1000;
						valueKey++;
					}
				}

				if (onlyName) {
					return value[valueKey];
				}

				if (round) {
					// number = Math.floor(number);
					number = Math.round(number);
				} else {
					number = number.toFixed(1);

					if (number % 1 == 0) number = (number * 1).toFixed(0);
				}

				if (name) {
					return number + ' ' + value[valueKey];
				}

				return number;
			};

			var duplicateRemove = function duplicateRemove(numMin, numMax, round, textStart, textCenter, textEnd) {

				textStart = textStart ? textStart : "";
				textCenter = textCenter ? textCenter : "";
				textEnd = textEnd ? textEnd : "";

				if (getPrettyNum(numMin, round, true) == getPrettyNum(numMax, round, true)) {
					return getPrettyNum(numMin, round, true) + textEnd;
				} else if (getPrettyNum(numMin, round, false, true) == getPrettyNum(numMax, round, false, true)) {
					// console.log('2',getPrettyNum(numMin,round,false))
					return textStart + getPrettyNum(numMin, round, false) + textCenter + getPrettyNum(numMax, round, true) + textEnd;
				} else {
					return textStart + getPrettyNum(numMin, round, true) + textCenter + getPrettyNum(numMax, round, true) + textEnd;
				}
			};

			var createTabs = function createTabs() {
				var tabsData;

				var HintLayout = ymaps.templateLayoutFactory.createClass("<div class='map-hint'>" + "{{ properties.name }}" + "</div>", {
					getShape: function getShape() {
						var el, firstChild, result;
						el = this.getElement();
						result = null;
						if (el) {
							firstChild = el.firstChild;
							result = new ymaps.shape.Rectangle(new ymaps.geometry.pixel.Rectangle([[0, 0], [firstChild.offsetWidth, firstChild.offsetHeight]]));
						}
						return result;
					}
				});

				if (typeof map_items != 'undefined') {

					$.each(map_items, function (i, e) {

						if ($("div#placement-map-" + e.id).length) {
							var element = e;
							var eContent = $("div#placement-map-" + element.id)[0];

							var corpsMap = new ymaps.Map(eContent, {
								center: [55.75, 37.70],
								zoom: 15,
								controls: ["zoomControl"]
							}, {
								searchControlProvider: 'yandex#search',
								maxZoom: 16
							});

							corpsMap.behaviors.disable('scrollZoom');
							if (isMobile) corpsMap.behaviors.disable('drag');

							var myCollection = new ymaps.GeoObjectCollection();

							if (element.map_items.polygon) {

								myPolygon = new ymaps.GeoObject({
									geometry: {
										type: "Polygon",
										coordinates: JSON.parse(element.map_items.polygon)
									},
									properties: {
										name: element.name,
										id: element.id
									}
								}, {
									fillColor: '#6064a0',
									strokeColor: '#fff',
									opacity: 0.5,
									hintLayout: HintLayout
								});

								myCollection.add(myPolygon);
							}

							if (element.map_items.point) {

								points_array = JSON.parse(element.map_items.point);

								$.each(points_array, function (i2, e2) {
									myPoint = new ymaps.GeoObject({
										geometry: {
											type: "Point",
											coordinates: e2
										},
										properties: {
											name: element.name,
											id: element.id
										}
									}, {
										iconLayout: 'default#image',
										iconImageHref: '/local/templates/main/assets/images/maps-baloon.png',
										iconImageSize: [0, 0],
										iconImageOffset: [-30, -73],
										hintLayout: HintLayout
									});

									myCollection.add(myPoint);
								});
							}

							/*
       if(element.map_items.point){
       	myPoint = new ymaps.GeoObject({
                        geometry: {
                            type: "Point",
                            coordinates: JSON.parse(element.map_items.point)
                        },
                        properties: {
                            name: element.name,
                            id: element.id
                        }
                    }, {
                        iconLayout: 'default#image',
                        iconImageHref: '/local/templates/main/assets/images/maps-baloon.png',
                        iconImageSize: [59, 73],
                        iconImageOffset: [-30, -73],
                        hintLayout: HintLayout
                    });
                    myCollection.add(myPoint);
       }*/

							if (myCollection.getLength()) {
								/*
        corpsMap.geoObjects.events.add('click', function (e) {
        	var object = e.get('target');
        	var objectId = object.properties._data.id
        						if(objectId){
        		$('a[href="#corps-'+objectId+'"]').tab('show')
        	}
        });
        */

								corpsMap.geoObjects.add(myCollection);
								corpsMap.setBounds(myCollection.getBounds());
								corpsMap.setZoom(16);

								var mapCenter = corpsMap.getCenter();

								var placeMark = new ymaps.Placemark(mapCenter, {}, {
									iconLayout: 'default#image',
									iconImageHref: '\/local\/templates\/main\/assets\/images\/maps-baloon.png',
									iconImageSize: [32, 43],
									iconImageOffset: [-10, -45],
									zIndex: 9000,
									id: 'zoomMark',
									visible: false
								});

								corpsMap.geoObjects.add(placeMark);

								var markIndex = corpsMap.geoObjects.indexOf(placeMark);

								var markLink = corpsMap.geoObjects.get(markIndex);

								if (!element.map_items.polygon) {
									markLink.options.set("visible", true);
								}

								corpsMap.events.add("boundschange", function (e) {
									var newZoom = e.get('newZoom'),
									    oldZoom = e.get('oldZoom');

									if (element.map_items.polygon) {
										if (newZoom < 15) {
											markLink.options.set("visible", true);
										}
										if (newZoom >= 15) {
											markLink.options.set("visible", false);
										}
									} else {
										markLink.options.set("visible", true);
									}
								});

								/*
        corpsMap.setBounds(myCollection.getBounds(), {
        	checkZoomRange: true,
        	zoomMargin: 15
        });*/
							}
						}
					});
				}

				$('.object-params .object-params__collapse').on('shown.bs.collapse', function () {
					if ($(this).attr("id") != 'collapse-params') {
						$("a[href=#" + $(this).attr('id') + "]").html('<span> <i class="fa fa-circle"></i><i class="fa fa-circle"></i><i class="fa fa-circle"></i></span>');
					}
				});
				$('.object-params .object-params__collapse').on('hidden.bs.collapse.bs.collapse', function () {
					if ($(this).attr("id") != 'collapse-params') {
						$("a[href=#" + $(this).attr('id') + "]").html('<span> <i class="fa fa-circle"></i><i class="fa fa-circle"></i><i class="fa fa-circle"></i></span>');
					}
				});
				$('.object-corps-buttons__item a[role="tab"]').on('click', function () {
					$('.tab-plans').removeClass('active in');
					$($(this).attr("href") + '-plans').addClass('active in').find('.slider-plans').slick('reinit');
				});

				/*
    $(".placement-map").each(function(i,e){
    alert(e.polygon);
    alert(e.attr('polygon'));
        var corpsMap = new ymaps.Map(element, {
            center: [55.75, 37.70],
            zoom: 16,
            controls: ["zoomControl"]
        }, {
            searchControlProvider: 'yandex#search',
            maxZoom: 16
        })
        corpsMap.behaviors.disable('scrollZoom');
    	        var myCollection = new ymaps.GeoObjectCollection();
    	        var myPolygon;
        var myPoint;
        //alert(element.id);
        //var el = $("div#placement-map-"+element.id);
        //alert(el.attr("id"));
        //var mapItems = el.attr('data-map-polygon');
        //alert(mapItems);
    /*
        if (mapItems.length) {
    	            // $.each(generalMapItem.polygon, function(i,e){
            // var generalPolygon = e;
    	            myPolygon = new ymaps.GeoObject({
                geometry: {
                    type: "Polygon",
                    coordinates: mapItems
                },
                properties: {
                    name: element.name,
                    id: element.id
                }
            }, {
                fillColor: '#6064a0',
                strokeColor: '#fff',
                opacity: 0.5,
                hintLayout: HintLayout
            });
    	            myCollection.add(myPolygon);
            // })
        }
    	        /*
        if (generalMapItem.point) {
    	            $.each(generalMapItem.point, function(i,e){
                var generalPoint = e;
    	                myPoint = new ymaps.GeoObject({
                    geometry: {
                        type: "Point",
                        coordinates: generalPoint
                    },
                    properties: {
                        name: generalMapItem.name,
                        id: generalMapItem.id
                    }
                }, {
                    iconLayout: 'default#image',
                    iconImageHref: '../assets/images/maps-baloon.png',
                    iconImageSize: [59, 73],
                    iconImageOffset: [-30, -73],
                    hintLayout: HintLayout
                });
                myCollection.add(myPoint);
            })
        }
    	
    	        if(myCollection.getLength()){
    	            corpsMap.geoObjects.events.add('click', function (e) {
                var object = e.get('target');
                var objectId = object.properties._data.id
    	                if(objectId){
                    $('a[href="#corps-'+objectId+'"]').tab('show')
                }
            });
    	            corpsMap.geoObjects.add(myCollection);
    	            corpsMap.setBounds(myCollection.getBounds(), {
                checkZoomRange: true,
                zoomMargin: 15
            });
    	        }
    	        /*
    });
    		/*if(typeof complex_properties == 'undefined'){
    return false;
    }
    // console.log('heere');
    var tabsData = complex_properties;
    var maxPrice = 0;
    var maxPrice_2 = 0;
    var minPrice = 0;
    var minPrice_2 = 0;
    		var tabsContent = $('.object-tabs-content');
    var tabsHeader = $('.object-tabs-header');
    		objectTabParent = $("<div/>", {
    class: "tab-content animation-block"
    }).appendTo(tabsContent);
    		objectGeneralTab = $("<div/>", {
    class: "tab-pane active fade in",
    id: "corps-general"
    }).appendTo(objectTabParent);
    		if(!tabsData.items){
    tabsContent.css({'margin-top':'24px'})
    }
    		if(tabsData.items){
    			objectButtonsList = $("<ul/>", {
    class: "object-corps-buttons__list animation-block",
    role: "tablist"
    }).appendTo(tabsHeader);
    			objectGeneralButton = $("<li/>", {
    class: "object-corps-buttons__item active",
    role: "presentation"
    }).appendTo(objectButtonsList);
    			objectGeneralLink = $("<a/>", {
    class: "object-corps-buttons__link",
    role: "tab",
    "data-toggle": "tab",
    "aria-controls": "corps-general",
    href: "#corps-general",
    text: ""
    }).appendTo(objectGeneralButton);
    			objectGeneralCorps = $("<div/>", {
    class: "object-corps"
    }).appendTo(objectGeneralTab);
    			objectGeneralPrice = $("<div/>", {
    class: "object-price"
    }).appendTo(objectGeneralCorps);
    			objectGeneralPriceItem = $("<div/>", {
    class: "object-price__item"
    }).appendTo(objectGeneralPrice);
    			objectGeneralPriceBody = $("<div/>", {
    class: "object-price__body"
    }).appendTo(objectGeneralPriceItem);
    			objectGeneralPricePrice = $("<div/>", {
    class: "object-price__price"
    }).appendTo(objectGeneralPriceBody);
    }
    	
    		if(tabsData.items){
    			var minPrice = {
    price: 999979999100,
    price_2: 999979999100
    }
    			var maxPrice = {
    price: 0,
    price_2: 0
    }
    			var current_date = "";
    var generalTypes = [];
    var generalMapData = [];
    // var polygonsData = [];
    // var poinsData = [];
    			$.each(tabsData.items,function(i,e){
    var element = e;
    // console.log(element)
    building_name = element.building_name;
    current_date = element.current_date;
    element.map_items.id = element.id;
    element.map_items.name = element.name;
    generalMapData.push(element.map_items)
    				if(element.items){
    $.each(element.items,function(i,e){
    	var item = JSON.parse(JSON.stringify(e));
    	// Object.assign({}, e);
    						// var item = e;
    	var unique = true;
    	
    	if (item.price_2_min<minPrice.price_2){
    		minPrice.price_2 = item.price_2_min
    	}
    						if (item.price_min<minPrice.price){
    		minPrice.price = item.price_min
    	}
    						if (item.price_2_max>maxPrice.price_2){
    		maxPrice.price_2 = item.price_2_max
    	}
    						if (item.price_max>maxPrice.price){
    		maxPrice.price = item.price_max
    	}
    	
    	$.each(generalTypes, function(i,e){
    		generalType = e;
    							if(generalType.type == item.type){
    			if(generalType.price_2_max < item.price_2_max){
    				generalType.price_2_max = item.price_2_max;
    			}
    			if(generalType.price_max < item.price_max){
    				generalType.price_max = item.price_max;
    			}
    			if(generalType.price_2_min > item.price_2_min){
    				generalType.price_2_min = item.price_2_min;
    			}
    			if(generalType.price_min > item.price_min){
    				generalType.price_min = item.price_min;
    			}
    			if(generalType.space_min > item.space_min){
    				generalType.space_min = item.space_min;
    			}
    			if(generalType.space_max < item.space_max){
    				generalType.space_max = item.space_max;
    			}
    			unique = false;
    		}
    	})
    						if (unique){
    		generalTypes.push(item);
    	}
    					})
    }
    })
    			generalTypes = typesSort(generalTypes)
    			function typesSort(sortObj){
    var list = sortObj;
    				var map = list.map(function(e, i) {
    return { index: i, value: e.type.toLowerCase() };
    });
    				map.sort(function(a, b) {
    if(a.value == ""){
    	return -1;
    }
    return +(a.value > b.value) || +(a.value === b.value) - 1;
    });
    				var result = map.map(function(e) {
    return list[e.index];
    });
    				return result;
    }
    	
    objectGeneralPriceRange = $("<div/>", {
    class: "object-price__price",
    text: duplicateRemove(minPrice.price,maxPrice.price,false,' ','  ',' ')
    }).appendTo(objectGeneralPriceBody);
    			objectGeneralPriceMeta = $("<div/>", {
    class: "object-price__meta",
    text: '('+duplicateRemove(minPrice.price_2,maxPrice.price_2,false,null,'  ',' .  2')+')'
    }).appendTo(objectGeneralPriceBody);
    			objectGeneralPriceDate = $("<div/>", {
    class: "object-price__date",
    // text: '    ' + current_date
    text: building_name ? ('     "' + building_name + '"') : '    ' + current_date
    }).appendTo(objectGeneralPriceBody);
    			objectGeneralPriceTable = $("<table/>", {
    class: "object-price__table"
    }).appendTo(objectGeneralPriceItem);
    			objectGeneralPriceTableHead = $("<tr/>", {
    html: "<th></th><th>, <nobr><sup>2</sup></nobr></th><th>  <sup>2</sup>, .</th><th> </th>"
    }).appendTo(objectGeneralPriceTable);
    	
    // console.log(current_date,generalTypes,generalMapData,polygonsData,poinsData)
    			$.each(generalTypes,function(i,e){
    var tableItem = e;
    				objectGeneralPriceTableRow  = $("<tr/>", {
    }).appendTo(objectGeneralPriceTable);
    				objectGeneralPriceTableCol  = $("<td/>", {
    text: tableItem.type
    }).appendTo(objectGeneralPriceTableRow);
    				objectGeneralPriceTableCol  = $("<td/>", {
    text: duplicateRemove(tableItem.space_min,tableItem.space_max,true,false,' - ',false)
    }).appendTo(objectGeneralPriceTableRow);
    				objectGeneralPriceTableCol  = $("<td/>", {
    text: duplicateRemove(tableItem.price_2_min,tableItem.price_2_max,false,false,' - ',false)
    }).appendTo(objectGeneralPriceTableRow);
    				objectGeneralPriceTableCol  = $("<td/>", {
    text: duplicateRemove(tableItem.price_min,tableItem.price_max,false,false,' - ',false)
    }).appendTo(objectGeneralPriceTableRow);
    			})
    			objectGeneralPlacement = $("<div/>", {
    class: "object-placement placement-map",
    id: "placement-map-general"
    }).appendTo(objectGeneralCorps);
    			var corpsMap = new ymaps.Map(objectGeneralPlacement[0], {
    center: [55.75, 37.70],
    zoom: 16,
    controls: ["zoomControl"]
    }, {
    searchControlProvider: 'yandex#search',
    maxZoom: 16
    })
    corpsMap.behaviors.disable('scrollZoom');
    			// console.log(generalMapData)
    			var myCollection = new ymaps.GeoObjectCollection();
    			$.each(generalMapData, function(i,e){
    generalMapItem = e;
    // console.log(generalMapItem)
    var myPolygon;
    var myPoint;
    				if (generalMapItem.polygon.length) {
    					// $.each(generalMapItem.polygon, function(i,e){
    	// var generalPolygon = e;
    						myPolygon = new ymaps.GeoObject({
    		geometry: {
    			type: "Polygon",
    			coordinates: generalMapItem.polygon
    		},
    		properties: {
    			name: generalMapItem.name,
    			id: generalMapItem.id
    		}
    	}, {
    		fillColor: '#6064a0',
    		strokeColor: '#fff',
    		opacity: 0.5,
    		hintLayout: HintLayout
    	});
    						myCollection.add(myPolygon);
    // })
    }
    				if (generalMapItem.point) {
    					$.each(generalMapItem.point, function(i,e){
    	var generalPoint = e;
    						myPoint = new ymaps.GeoObject({
    		geometry: {
    			type: "Point",
    			coordinates: generalPoint
    		},
    		properties: {
    			name: generalMapItem.name,
    			id: generalMapItem.id
    		}
    	}, {
    		iconLayout: 'default#image',
    		iconImageHref: '../assets/images/maps-baloon.png',
    		iconImageSize: [59, 73],
    		iconImageOffset: [-30, -73],
    		hintLayout: HintLayout
    	});
    	myCollection.add(myPoint);
    })
    }
    			})
    			if(myCollection.getLength()){
    				corpsMap.geoObjects.events.add('click', function (e) {
    var object = e.get('target');
    var objectId = object.properties._data.id
    					if(objectId){
    	$('a[href="#corps-'+objectId+'"]').tab('show')
    }
    });
    				corpsMap.geoObjects.add(myCollection);
    				corpsMap.setBounds(myCollection.getBounds(), {
    checkZoomRange: true,
    zoomMargin: 15
    });
    }
    		}
    	
    		objectGeneralClearfix = $("<div/>", {
    class: "clearfix"
    }).appendTo(objectGeneralTab);
    		objectGeneralParams = $("<div/>", {
    class: "object-params"
    }).appendTo(objectGeneralTab);
    		objectGeneralParamsBody = $("<div/>", {
    class: "object-params__body"
    }).appendTo(objectGeneralParams);
    		// objectGeneralParamsTitle = $("<div/>", {
    objectGeneralParamsTitle = $("<h2/>", {
    class: "object-params__title",
    text: " "
    }).appendTo(objectGeneralParamsBody);
    		objectGeneralRow = $("<div/>", {
    class: "row"
    }).appendTo(objectGeneralParamsBody);
    		objectGeneralCollapse = $("<div/>", {
    class: "object-params__collapse collapse",
    id: "collapse-params-general"
    }).appendTo(objectGeneralParamsBody);
    	
    		var generalHiddenProperties = [];
    		$.each(tabsData.properties, function(i,e){
    var property = e;
    			// console.log(i,tabsData.properties.length)
    			// if(i==tabsData.properties){}
    			if((i+1)==tabsData.properties.length){
    generalHiddenProperties.push(property)
    }else{
    objectGeneralCol = $("<div/>", {
    class: "col-md-6"
    }).appendTo(objectGeneralRow);
    				objectGeneralTable = $("<table/>", {
    }).appendTo(objectGeneralCol);
    				$.each(property, function(i,e){
    					var propertyElem = e;
    var propertyNum = i;
    var randomId = (Math.random()*100000).toFixed(0)
    					// console.log(propertyElem)
    					objectGeneralTr = $("<tr/>", {
    	class: 'object-params__item'
    }).appendTo(objectGeneralTable);
    					objectGeneralTd = $("<td/>", {
    	class: 'object-params__label',
    	text: propertyElem.label + " "
    }).appendTo(objectGeneralTr);
    					if (propertyElem.tooltip){
    						objectGeneralTolltip = $("<i/>", {
    		class: 'fa fa-question-circle js-tooltip',
    		title: propertyElem.tooltip
    	}).tooltipster({
    		contentAsHTML: true,
    		animation: 'fade',
    		trigger: 'hover',
    		maxWidth: 169,
    		position: 'right',
    		interactive: true
    	}).appendTo(objectGeneralTd);
    }
    					objectGeneralTd = $("<td/>", {
    	class: 'object-params__content'
    }).appendTo(objectGeneralTr);
    					// console.log(propertyElem.content.length,'eeee')
    					if(propertyElem.content.length > 3){
    						objectGeneralHidden = $("<div/>",{
    		class: "collapse object-params__collapse",
    		id: "collapse-params-" + randomId
    	}).on('shown.bs.collapse', function(e) {
    		// console.log($('a[href=#'+$(this).attr('id')+']'))
    		TweenLite.to($('a[href=#'+$(this).attr('id')+'] span'), 0.5, {text:'', ease:Linear.easeNone});
    	}).on('hidden.bs.collapse', function(e) {
    		TweenLite.to($('a[href=#'+$(this).attr('id')+'] span'), 0.5, {text:'', ease:Linear.easeNone});
    	}).appendTo(objectGeneralTd);
    						// console.log(i)
    	objectGeneralHiddenButton = $("<a/>",{
    		class: "object-params__more",
    		role: "button",
    		"data-toggle": "collapse",
    		href: "#collapse-params-" + randomId,
    		"aria-expanded": "false",
    		"aria-controls": "collapse-params-" + randomId
    	}).appendTo(objectGeneralTd);
    						for(i=0;i<3;i++){
    		objectGeneralHiddenButtonDots = $("<i/>",{
    			class: "fa fa-circle"
    		}).appendTo(objectGeneralHiddenButton);
    	}
    						objectGeneralHiddenButtonText = $("<span/>",{
    		text: ""
    	}).appendTo(objectGeneralHiddenButton);
    	
    }
    					$.each(propertyElem.content, function(i,e){
    	var content = e;
    	var contentNum = i;
    	// console.log(contentNum, "eee")
    						if(contentNum>2){
    		objectGeneralContent = $("<p/>", {
    			html: content
    		}).appendTo(objectGeneralHidden);
    	}else{
    		if(objectGeneralTd.children('p').length){
    			// console.log(objectGeneralTd.children('p').length)
    			// console.log(objectGeneralTd.children('p').eq(0))
    			objectGeneralContent = $("<p/>", {
    				html: content
    			}).insertAfter(objectGeneralTd.children('p').eq(objectGeneralTd.children('p').length-1));
    		}else{
    			objectGeneralContent = $("<p/>", {
    				html: content
    			}).prependTo(objectGeneralTd);
    		}
    	}
    })
    })
    }
    })
    	
    $.each(generalHiddenProperties,function(i,e){
    var hiddenProperty = e;
    	
    objectGeneralCollapseTable = $("<table/>", {
    }).appendTo(objectGeneralCollapse);
    			$.each(hiddenProperty,function(i,e){
    var hiddenPropertyElem = e;
    var propertyElemNum = i;
    var randomId = (Math.random()*100000).toFixed(0)
    				objectGeneralTr = $("<tr/>", {
    class: 'object-params__item'
    }).appendTo(objectGeneralCollapseTable);
    				objectGeneralTd = $("<td/>", {
    class: 'object-params__label',
    text: hiddenPropertyElem.label
    }).appendTo(objectGeneralTr);
    				objectGeneralTd = $("<td/>", {
    class: 'object-params__content'
    }).appendTo(objectGeneralTr);
    	
    if(hiddenPropertyElem.content.length > 3){
    objectGeneralHidden = $("<div/>",{
    	class: "collapse object-params__collapse",
    	id: "collapse-params-" + randomId
    }).appendTo(objectGeneralTd);
    					// console.log(i)
    objectGeneralHiddenButton = $("<a/>",{
    	class: "object-params__more",
    	role: "button",
    	"data-toggle": "collapse",
    	href: "#collapse-params-" + randomId,
    	"aria-expanded": "false",
    	"aria-controls": "collapse-params-" + randomId
    }).appendTo(objectGeneralTd);
    					for(i=0;i<3;i++){
    	objectGeneralHiddenButtonDots = $("<i/>",{
    		class: "fa fa-circle"
    	}).appendTo(objectGeneralHiddenButton);
    }
    					objectGeneralHiddenButtonText = $("<span/>",{
    	text: ""
    }).appendTo(objectGeneralHiddenButton);
    	
    }
    				$.each(hiddenPropertyElem.content, function(i,e){
    var content = e;
    var contentNum = i;
    // console.log(contentNum)
    if(contentNum>2){
    	objectGeneralContent = $("<p/>", {
    		html: content
    	}).appendTo(objectGeneralHidden);
    }else{
    	if(objectGeneralTd.children('p').length){
    		objectGeneralContent = $("<p/>", {
    			html: content
    		}).insertAfter(objectGeneralTd.children('p').eq(objectGeneralTd.children('p').length-1));
    	}else{
    		objectGeneralContent = $("<p/>", {
    			html: content
    		}).prependTo(objectGeneralTd);
    	}
    }
    })
    				// $.each(hiddenPropertyElem.content, function(i,e){
    // 	var content = e;
    				// 	objectGeneralContent = $("<p/>", {
    // 		html: content
    // 	}).appendTo(objectGeneralTd);
    // })
    })
    		})
    		if(generalHiddenProperties.length){
    			objectGeneralParamsFooter = $("<div/>", {
    class: "object-params__footer"
    }).appendTo(objectGeneralParams);
    			objectGeneralParamsButton = $("<a/>", {
    class: "object-params__show-all",
    href: "#collapse-params-general",
    role: "button",
    "data-toggle": "collapse",
    "aria-expanded": "false",
    "aria-controls":"collapse-params-general",
    text: "+   "
    }).appendTo(objectGeneralParams);
    			$("#collapse-params-general").on('show.bs.collapse', function(e) {
    // objectGeneralParamsButton.text('- C  ');
    				TweenLite.to(objectGeneralParamsButton, 0.5, {text:'- C  ', ease:Linear.easeNone});
    }).on('hidden.bs.collapse', function(e) {
    // objectGeneralParamsButton.text('+   ');
    TweenLite.to(objectGeneralParamsButton, 0.5, {text:'+   ', ease:Linear.easeNone});
    });
    }
    		if(tabsData.items){
    $.each(tabsData.items,function(i,e){
    var element = e;
    				var minPrice = {
    price: 99997999910002,
    price_2: 99997999910002
    }
    				var maxPrice = {
    price: 0,
    price_2: 0
    }
    				objectButtonsItem = $("<li/>", {
    class: "object-corps-buttons__item",
    role: "presentation"
    }).appendTo(objectButtonsList);
    				objectButtonsLink = $("<a/>", {
    class: "object-corps-buttons__link",
    role: "tab",
    "data-toggle": "tab",
    "aria-controls": "corps-"+element.id,
    href: "#corps-"+element.id,
    text: element.name
    }).appendTo(objectButtonsItem);
    				objectTab = $("<div/>", {
    class: "tab-pane fade",
    id: "corps-"+element.id
    }).appendTo(objectTabParent);
    	
    if(element.items){
    					$.each(element.items,function(i,e){
    	var item = e;
    						if (item.price_2_min<minPrice.price_2){
    		minPrice.price_2 = item.price_2_min
    	}
    						if (item.price_min<minPrice.price){
    		minPrice.price = item.price_min
    	}
    						if (item.price_2_max>maxPrice.price_2){
    		maxPrice.price_2 = item.price_2_max
    	}
    						if (item.price_max>maxPrice.price){
    		maxPrice.price = item.price_max
    	}
    });
    					objectCorps = $("<div/>", {
    	class: "object-corps"
    }).appendTo(objectTab);
    					objectPrice = $("<div/>", {
    	class: "object-price"
    }).appendTo(objectCorps);
    					objectPriceItem = $("<div/>", {
    	class: "object-price__item"
    }).appendTo(objectPrice);
    					objectPriceBody = $("<div/>", {
    	class: "object-price__body"
    }).appendTo(objectPriceItem);
    					objectPriceRange = $("<div/>", {
    	class: "object-price__price",
    	text: duplicateRemove(minPrice.price,maxPrice.price,false,' ','  ',' ')
    }).appendTo(objectPriceBody);
    					objectPriceMeta = $("<div/>", {
    	class: "object-price__meta",
    	text: '('+duplicateRemove(minPrice.price_2,maxPrice.price_2,false,null,'  ',' .  2')+')'
    }).appendTo(objectPriceBody);
    					objectPriceDate = $("<div/>", {
    	class: "object-price__date",
    	// text: '    ' + element.current_date
    	text: element.building_name ? ('     "' +element.building_name+ '"') : '    ' + element.current_date
    }).appendTo(objectPriceBody);
    					objectPriceTable = $("<table/>", {
    	class: "object-price__table"
    }).appendTo(objectPriceItem);
    					objectPriceTableHead = $("<tr/>", {
    	html: "<th></th><th>,&nbsp;<nobr><sup>2</sup></nobr></th><th>  <nobr><sup>2</sup>,</nobr> .</th><th> </th>"
    }).appendTo(objectPriceTable);
    	
    $.each(element.items,function(i,e){
    	var tableItem = e;
    						objectPriceTableRow  = $("<tr/>", {
    	}).appendTo(objectPriceTable);
    						objectPriceTableCol  = $("<td/>", {
    		text: tableItem.type
    	}).appendTo(objectPriceTableRow);
    						objectPriceTableCol  = $("<td/>", {
    		text: duplicateRemove(tableItem.space_min,tableItem.space_max,true,false,' - ',false)
    	}).appendTo(objectPriceTableRow);
    						objectPriceTableCol  = $("<td/>", {
    		text: duplicateRemove(tableItem.price_2_min,tableItem.price_2_max,true,false,' - ',false)
    	}).appendTo(objectPriceTableRow);
    						objectPriceTableCol  = $("<td/>", {
    		text: duplicateRemove(tableItem.price_min,tableItem.price_max,true,false,' - ',false)
    	}).appendTo(objectPriceTableRow);
    					})
    					objectPlacement = $("<div/>", {
    	class: "object-placement placement-map",
    	id: "placement-map"+element.id,
    	data: {
    		// 'map-polygon': element.map_items.polygon,
    		// 'map-points': element.map_items.point,
    		// 'map-name': element.name
    	}
    }).appendTo(objectCorps);
    					var corpsMap = new ymaps.Map(objectPlacement[0], {
    	center: [55.75, 37.70],
    	zoom: 16,
    	controls: ["zoomControl"]
    }, {
    	searchControlProvider: 'yandex#search',
    	maxZoom: 16
    })
    					corpsMap.behaviors.disable('scrollZoom');
    	
    var myCollection = new ymaps.GeoObjectCollection();
    					if (element.map_items.polygon.length) {
    	// $.each(element.map_items.polygon,function(i,e){
    		// var polygon = e;
    							var myPolygon = new ymaps.GeoObject({
    			geometry: {
    				type: "Polygon",
    				coordinates: element.map_items.polygon
    			},
    			properties: {
    				name: element.map_items.name
    			}
    		}, {
    			fillColor: '#6064a0',
    			strokeColor: '#fff',
    			opacity: 0.5,
    			hintLayout: HintLayout
    		});
    							myCollection.add(myPolygon);
    	// })
    }
    					if (element.map_items.point) {
    	$.each(element.map_items.polygon,function(i,e){
    		var point = e;
    							var myPoint = new ymaps.GeoObject({
    			geometry: {
    				type: "Point",
    				coordinates: point
    			},
    			properties: {
    				name: element.map_items.name
    			}
    		}, {
    			iconLayout: 'default#image',
    			iconImageHref: '../assets/images/maps-baloon.png',
    			iconImageSize: [59, 73],
    			iconImageOffset: [-30, -73],
    			hintLayout: HintLayout
    		});
    		myCollection.add(myPoint);
    	})
    }
    					if(myCollection.getLength()){
    						corpsMap.geoObjects.add(myCollection);
    						corpsMap.events.add('sizechange',function (e) {
    		corpsMap.setBounds(myCollection.getBounds(), {
    			checkZoomRange: true,
    			zoomMargin: 15
    		});
    	})
    						objectClearfix = $("<div/>", {
    		class: "clearfix"
    	}).appendTo(objectTab);
    }
    				}
    // console.log(minPrice,maxPrice, "2")
    	
    				objectParams = $("<div/>", {
    class: "object-params",
    style: 'margin-top:' + (element.items ? 0 : '24px')
    }).appendTo(objectTab);
    				objectParamsBody = $("<div/>", {
    class: "object-params__body"
    }).appendTo(objectParams);
    				// objectParamsTitle = $("<div/>", {
    objectParamsTitle = $("<h2/>", {
    class: "object-params__title",
    text: " "
    }).appendTo(objectParamsBody);
    				objectTable = $("<table/>", {
    }).appendTo(objectParamsBody);
    				objectCollapse = $("<div/>", {
    class: "object-params__collapse collapse",
    id: "collapse-params"+element.id
    }).appendTo(objectParamsBody);
    				objectCollapseTable = $("<table/>", {
    }).appendTo(objectCollapse);
    				$.each(element.properties, function(i,e){
    var property = e;
    					objectTr = $("<tr/>", {
    	class: 'object-params__item'
    }).appendTo(objectTable);
    					objectTd = $("<td/>", {
    	class: 'object-params__label',
    	text: property.label
    }).appendTo(objectTr);
    					objectTd = $("<td/>", {
    	class: 'object-params__content'
    }).appendTo(objectTr);
    					$.each(property.content, function(i,e){
    	var content = e;
    						objectContent = $("<p/>", {
    		html: content
    	}).appendTo(objectTd);
    })
    })
    })
    }
    */

				toggleMenu(true);
				$(window).resize(function () {
					toggleMenu();
				});
			};

			var toggleMenu = function toggleMenu(init) {
				var menuContainer = $('.object-corps-buttons__list');
				// var debugContainer = $('.object-tabs-header')

				if (init) {
					var menuMore = $("<li/>", {
						class: "object-corps-buttons__item-more object-corps-buttons__item"
					}).appendTo(menuContainer);

					var menuMoreLink = $("<a/>", {
						class: "object-corps-buttons__link",
						href: "#",
						html: " <i class='i fa fa-angle-down'><i/>"
					}).on("click", function (e) {
						e.preventDefault();
					}).appendTo(menuMore);

					var subMenu = $("<ul/>", {
						class: "object-corps-buttons__submenu"
					}).appendTo(menuMore);
				} else {
					var menuMore = $(".object-corps-buttons__item-more");
					var subMenu = $('.object-corps-buttons__submenu');
				}

				var menuItems = $('.object-corps-buttons__item:not(.object-corps-buttons__item-more)');

				menuMore.addClass('object-corps-buttons__item-more_active');

				// var containerWidth = menuContainer.outerWidth(true) - menuMore.outerWidth(true);
				var containerWidth = menuContainer.outerWidth(true) - menuMore.outerWidth(true);

				// debugContainer.append($('<span>',{
				// 	text: menuContainer.outerWidth(true)+' - menuContainer,'+menuMore.outerWidth(true)+' -menuMore',
				// 	style: 'color: #fff'
				// }));

				menuMore.removeClass('object-corps-buttons__item-more_active');

				var itemsWidth = 0;
				var maxItemWidth = 0;

				menuItems.each(function (index, element) {
					var item = $(element);

					// debugContainer.append($('<div>',{
					// 	text: item.width()+' - item.width()',
					// 	style: 'color: #fff'
					// }));

					// if( item.outerWidth() > maxItemWidth ) {
					// 	maxItemWidth = item.outerWidth();
					// }

					item.width(item.outerWidth());
				});

				// debugContainer.append($('<div>',{
				// 	text: maxItemWidth+' - maxItemWidth',
				// 	style: 'color: #fff'
				// }));

				menuItems.each(function (index, element) {
					var item = $(element);

					if (itemsWidth + item.outerWidth() > containerWidth) {
						subMenu.append(item);

						// console.log(itemsWidth + item.outerWidth())
						// console.log(containerWidth)
						menuMore.addClass('object-corps-buttons__item-more_active');
					} else if (itemsWidth + item.outerWidth() < containerWidth) {
						subMenu.children().eq(0).insertBefore(menuMore);
						itemsWidth += item.outerWidth();
						menuMore.removeClass('object-corps-buttons__item-more_active');
					} else {
						itemsWidth += item.outerWidth();
					}
				});

				if (init) {
					toggleMenu();
				}
			};

			// function getPolygonCenter(coords) {
			// 	var n = coords.length, xCoord = 0, yCoord = 0, mult, space = 0;
			// 	for (var i = 0; i < n - 1; i++) {
			// 		mult = (coords[i][0] * coords[i + 1][1] - coords[i + 1][0] * coords[i][1])
			// 		xCoord += (coords[i][0] + coords[i + 1][0]) * mult
			// 		yCoord += (coords[i][1] + coords[i + 1][1]) * mult
			// 		space += mult
			// 	}
			// 	xCoord = xCoord / (space * 3)
			// 	yCoord = yCoord / (space * 3)
			// 	return [xCoord, yCoord]
			// }

			/**
    * Calculates distance to metro
    * 
    * @class Routes
    */


			$(document).ready(function () {
				$('.object-description-new__text img').each(function () {
					var $img = $(this),
					    href = $img.attr('src');
					$img.attr('data-src', href);
				});

				$('.object-description-new__text').lightGallery({
					exThumbImage: 'data-src',
					selector: '.object-description-new__text img'
				});
			});

			;

			var Routes = function () {
				function Routes(options) {
					_classCallCheck(this, Routes);

					this.$pedestrian = $(options.pedestrian);
					this.$masstransit = $(options.masstransit);
					this.$mapContainer = $(options.mapContainer)[0];
					this.traffic = options.traffic;
					this.coords = options.coords;
					this.getPolygonCenter = this.getPolygonCenter.bind(this);
					this.findMetroRoute = this.findMetroRoute.bind(this);
					this.reg = /&#160;/g;
					this.routes = {};
					this.MetroArray = [];
					this.init = this.init.bind(this);
				}

				_createClass(Routes, [{
					key: "getPolygonCenter",
					value: function getPolygonCenter(coords) {
						var n = coords.length,
						    xCoord = 0,
						    yCoord = 0,
						    mult = void 0,
						    space = 0;

						for (var _i2 = 0; _i2 < n - 1; _i2++) {
							mult = coords[_i2][0] * coords[_i2 + 1][1] - coords[_i2 + 1][0] * coords[_i2][1];
							xCoord += (coords[_i2][0] + coords[_i2 + 1][0]) * mult;
							yCoord += (coords[_i2][1] + coords[_i2 + 1][1]) * mult;
							space += mult;
						}

						xCoord = xCoord / (space * 3);
						yCoord = yCoord / (space * 3);
						return [xCoord, yCoord];
					}
				}, {
					key: "findMetroRoute",
					value: function findMetroRoute(points, type) {
						return new ymaps.multiRouter.MultiRoute({
							referencePoints: points,
							params: {
								routingMode: type
							}
						}, {
							editorDrawOver: false,
							wayPointDraggable: false,
							viaPointDraggable: false,
							routeStrokeColor: "252955",
							routeActiveStrokeColor: "ff5500",
							pinIconFillColor: "ff0000",
							boundsAutoApply: true,
							zoomMargin: 30
						});
					}
				}, {
					key: "init",
					value: function init() {
						var _this24 = this;

						var routeMap = void 0;
						var startingPoint = this.getPolygonCenter(this.coords[0]);

						Array.prototype.forEach.call($('#metro-pedestrian').find('.traffic-info'), function (metro, index) {
							var $metroName = $(metro).find('.traffic-info__name a');
							var metroCurrent = void 0;
							metroCurrent = $metroName.text().replace(/\. /g, "");
							_this24.MetroArray.push(metroCurrent);
						});

						Array.prototype.forEach.call(this.MetroArray, function (metroName, indexMetro) {
							var pedestrian = $('#metro-pedestrian a:contains("' + metroName + '")').parents('.traffic-info');
							var masstransit = $('#metro-masstransit a:contains("' + metroName + '")').parents('.traffic-info');
							var destination = ' ' + metroName;
							var routeP = void 0;
							var routeM = void 0;

							routeP = _this24.findMetroRoute([startingPoint, destination], 'pedestrian');
							routeP.model.events.once("requestsuccess", function () {
								if (routeP.getRoutes().get(0)) {
									var properties = routeP.getRoutes().get(0).properties.get(0);
									pedestrian.find('.traffic-info__show a').data('href', 'pedestrian-' + indexMetro);
									routeP.boundedBy = properties.boundedBy;
									_this24.routes['pedestrian-' + indexMetro] = routeP;
								}
								$('#metro-pedestrian').removeClass('loading');
							});

							routeM = _this24.findMetroRoute([startingPoint, destination], 'masstransit');
							routeM.model.events.once("requestsuccess", function () {
								if (routeM.getRoutes().get(0)) {
									var properties = routeM.getRoutes().get(0).properties.get(0);
									masstransit.find('.traffic-info__show a').data('href', 'masstransit-' + indexMetro);
									routeM.boundedBy = properties.boundedBy;
									_this24.routes['masstransit-' + indexMetro] = routeM;
								}
								$('#metro-masstransit').removeClass('loading');
							});
						});

						$('.traffic-info__show a').on('click', function (event) {
							event.preventDefault();
							var href = $(event.currentTarget).data('href');

							if (typeof _this24.routes[href] != 'undefined') {
								$('#modal-route-map').modal();
								$('#modal-route-map').on('shown.bs.modal', function () {
									if (!routeMap) {
										routeMap = new ymaps.Map(_this24.$mapContainer, {
											center: [55.75, 37.70],
											zoom: 16,
											controls: ["zoomControl"]
										}, {
											searchControlProvider: 'yandex#search',
											maxZoom: 16
										});
									}

									routeMap.container.fitToViewport();
									routeMap.geoObjects.removeAll();
									routeMap.geoObjects.add(_this24.routes[href]);

									if (href.indexOf('pedestrian') !== -1 || href.indexOf('masstransit') !== -1) {
										var bounds = _this24.routes[href].boundedBy;
										var _center = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
										routeMap.setCenter(_center, 14, {
											duration: 300
										});
									}
								});

								$('#modal-route-map').on('hide.bs.modal', function () {
									if (routeMap) {
										routeMap.destroy();
										routeMap = null;
									}
								});
							}
						});

						// const reqursiveRequestMetro = (index = 0, type, callback) => {		
						// 	if (this.MetroArray[index]) {
						// 		let pedestrian = $('#metro-pedestrian a:contains("' + this.MetroArray[index] + '")').parents('.traffic-info');
						// 		let masstransit = $('#metro-masstransit a:contains("' + this.MetroArray[index] + '")').parents('.traffic-info');
						// 		let destination = ' ' + this.MetroArray[index];				
						// 		let route = this.findMetroRoute([startingPoint, destination], type);
						// 		let props;

						// 		route.model.events.once("requestsuccess", () => {
						// 			props = route.getRoutes().get(0).properties.get(0);					

						// 			if (type == 'pedestrian') {
						// 				pedestrian.find('.traffic-info__show a').data('href', 'pedestrian-' + index);
						// 				route.boundedBy = props.boundedBy;
						// 				this.routes['pedestrian-' + index] = route;
						// 				$('#metro-pedestrian').removeClass('loading');
						// 			} else if (type == 'masstransit') {
						// 				masstransit.find('.traffic-info__show a').data('href', 'masstransit-' + index);						
						// 				route.boundedBy = props.boundedBy;
						// 				this.routes['masstransit-' + index] = route;
						// 				$('#metro-masstransit').removeClass('loading');
						// 			}

						// 			reqursiveRequestMetro(index + 1, type, callback);
						// 		})
						// 	} else {
						// 		callback()
						// 	}
						// }

						// reqursiveRequestMetro(0, 'pedestrian', () => {			
						// 	reqursiveRequestMetro(0, 'masstransit', () => {});
						// });		
					}
				}]);

				return Routes;
			}();

			ymaps.ready(function () {
				var coords = void 0;

				if (map_items[0].map_items.polygon) {
					coords = JSON.parse(map_items[0].map_items.polygon);
				} else if (map_items[0].map_items.point) {
					coords = JSON.parse(map_items[0].map_items.point);
				}

				var route = new Routes({
					pedestrian: '#metro-pedestrian',
					masstransit: '#metro-masstransit',
					mapContainer: '#modal-yandex-map',
					coords: coords
				});

				route.init();
			});

			if ($('.object-tabs').length) {

				// $(window).load(function(){
				ymaps.ready(function () {
					createTabs();
				});
				// })
			}
		};

		if ($('.filter').length) {
			var setDefaultState = function setDefaultState() {
				if (filter.length) {
					var $checked = bigFilter.find('input[type="checkbox"]:checked,input[type="radio"]:checked');

					$checked.each(function () {
						var $this = $(this);
						var $id = $this.closest('.tag-item').data('tag-id');
						removeTag($id);
					});

					$checked.prop('checked', false);

					filter.get(0).reset();

					bigFilter.find('input[type="text"]').each(function () {
						var $this = $(this);
						var $id = $this.closest('.tag-item').data('tag-id');
						removeTag($id);
					});

					resetSelectedPlace();
					// filter.find('input[type="checkbox"],input[type="radio"]').prop("checked", false);

					filter.find('select').each(function (i, e) {
						var options = $(e).find('option');
						options.prop('selected', false);
					});

					$('.styler').trigger("refresh");

					filter.find('.sumo').each(function (i, e) {
						e.sumo.reload();
					});

					normiePrices();
					filter.submit();
				}
			};

			var resetSelectedPlace = function resetSelectedPlace() {
				$('.filter-item input').prop("checked", false).trigger('change');
				$('.filter-nums').text('');
				$('.big-filter__cnt').text('0');

				// console.log('')
			};

			var locationNumCheck = function locationNumCheck(element) {

				itemsChecked = $('.filter-item input:checked');
				checkedLength = itemsChecked.length;

				buttonNums = element.parents('.tab-pane').find('.filter-nums');
				selectedCnt = $('.big-filter__cnt');

				if (checkedLength) {
					buttonNums.text(checkedLength);
					selectedCnt.text(checkedLength);
				} else {
					buttonNums.text('');
					selectedCnt.text('0');
				}
			};

			var maskify = function maskify() {
				$('.input-mask-money').inputmask("numeric", {
					radixPoint: ".",
					groupSeparator: " ",
					digits: 0,
					autoGroup: true,
					rightAlign: false

					// oncleared: function () { self.Value(''); }
				});

				$('.input-mask-numer').inputmask("numeric", {
					radixPoint: ".",
					groupSeparator: ".",
					autoGroup: true,
					rightAlign: false,
					allowPlus: false,
					allowMinus: false

					// oncleared: function () { self.Value(''); }
				});
			};

			var unmaskify = function unmaskify() {
				$('.input-mask-money, .input-mask-numer').each(function (i, el) {
					var value = $(el).inputmask('unmaskedvalue');
					$(el).inputmask('remove');
					$(el).val(value);
				});
			};

			var tabFill = function tabFill(parent, items) {

				// console.log(parent,items,"parent,items")

				var filterCluster = $("<div/>", {
					class: "big-filter__cluster"
				}).appendTo(parent);

				var filterList = $("<ul/>", {
					class: "big-filter__list"
				}).appendTo(filterCluster);

				var letters = [];

				// $.each(items,function(i,e){
				//  var type = e;
				$.each(items, function (i, e) {
					var object = e;

					var letter = object.label.substr(0, 1);

					if (findElem(letters, letter) == -1) {
						letters.push(letter);
					}
				});
				// })

				letters.sort();
				// console.log(letters)

				$.each(letters, function (i, e) {

					var filterListItem = $("<li/>", {
						'data-letter': e
					}).appendTo(filterList);

					var filterLetter = $("<div/>", {
						class: "filter-letter",
						text: e
					}).appendTo(filterListItem);
				});

				$.each(items, function (i, e) {
					var object = e;
					var letter = object.label.substr(0, 1);
					// console.log(object,"object")

					// console.log(e)

					var filterItem = $("<div/>", {
						class: "filter-item"
					}).appendTo(filterList.find('[data-letter="' + letter + '"]'));

					var filterItemInput = $("<input/>", {
						type: "checkbox",
						id: "input-" + object.id,
						// name:'checkbox-'+object.id,
						name: "f[geo][]",
						value: object.id
					}).on('change', function (e) {
						if ($(this).prop('checked')) {
							createTag(object.label, "input-" + object.id);
						} else {
							removeTag("input-" + object.id);
						}
					}).on('click', function (e) {
						// filter.submit();
					}).appendTo(filterItem);

					if (currentLocation.length) {
						$.each(currentLocation, function (index, element) {
							if (object.id == element) {
								filterItemInput.prop('checked', true).trigger('change');
								locationNumCheck(filterItemInput);
								var currentTab = filterLocation.find('a[href="#' + parent.attr('id') + '"]');
								var currentParentTab = filterLocation.find('a[href="#' + currentTab.parent('.tab-pane').attr('id') + '"]');
								currentParentTab.tab('show');
								currentTab.tab('show');
								// console.log(currentTab)
							}
						});
					}

					var filterItemLabel = $("<label/>", {
						for: "input-" + object.id,
						text: object.label + " "
					}).appendTo(filterItem);

					var filterIcon = $("<i/>", {
						class: "fa fa-check"
					}).appendTo(filterItemLabel);

					if (object.child.length) {
						$.each(object.child, function (i, e) {
							var object = e;
							var letter = object.label.substr(0, 1);

							var filterItem = $("<div/>", {
								class: "filter-item"
							}).appendTo(filterList.find('[data-letter="' + letter + '"]'));

							var filterItemInput = $("<input/>", {
								type: "checkbox",
								id: "input-" + object.id,
								// name:'checkbox-'+object.id,
								name: "f[geo][]",
								value: object.id
							}).on('change', function (e) {
								if ($(this).prop('checked')) {
									createTag(object.label, "input-" + object.id);
								} else {
									removeTag("input-" + object.id);
								}
							}).appendTo(filterItem);

							if (currentLocation.length) {
								$.each(currentLocation, function (index, element) {
									if (object.id == element) {
										filterItemInput.prop('checked', true).trigger('change');
										locationNumCheck(filterItemInput);
										var currentTab = filterLocation.find('a[href="#' + parent.attr('id') + '"]');
										var currentParentTab = filterLocation.find('a[href="#' + currentTab.parent('.tab-pane').attr('id') + '"]');
										currentParentTab.tab('show');
										currentTab.tab('show');
										// console.log(currentTab)
									}
								});
							}

							var filterItemLabel = $("<label/>", {
								for: "input-" + object.id,
								text: object.label + " "
							}).appendTo(filterItem);

							var filterIcon = $("<i/>", {
								class: "fa fa-check"
							}).appendTo(filterItemLabel);
						});
					}
				});
			};

			var tabCreate = function tabCreate(tab, name, title, element, filterRegions, filterButtons) {

				// console.log(tab,name,title,element,filterRegions,filterButtons)

				if (!tab.length) {
					return false;
				}

				var filterTab = $("<div/>", {
					id: 'tab-0-' + name + '-' + element.id,
					class: filterRegions.find('.active').length ? "tab-pane big-filter__cluster-tab" : "active tab-pane big-filter__cluster-tab"
				}).appendTo(filterRegions);

				var filterTabParent = $("<li/>", {
					role: "presentation",
					class: filterButtons.find('.active').length ? "" : "active"
				}).appendTo(filterButtons);

				var filterTabButton = $("<a/>", {
					class: "big-filter__button big-filter__button_tab",
					text: title,
					"data-toggle": 'tab',
					role: 'tab',
					"aria-controls": 'tab-0-' + name + '-' + element.id,
					href: '#tab-0-' + name + '-' + element.id
				}).on('shown.bs.tab', function (e) {
					e.preventDefault();

					// if(!initialFill){
					//  resetSelectedPlace();
					// }
				}).appendTo(filterTabParent);

				// console.log(filterTab,tab,"(filterTab,tab)")
				tabFill(filterTab, tab);
			};

			var tabsCreate = function tabsCreate(types, element, filterRegions, filterButtons) {
				if (element.label == ' ' || element.label == '-') {
					tabCreate(types.district, 'district', '', element, filterRegions, filterButtons);
					tabCreate(types.cityDistrict, 'city_district', '', element, filterRegions, filterButtons);
				} else {
					tabCreate(types.cityDistrict, 'city_district', '', element, filterRegions, filterButtons);
					tabCreate(types.district, 'district', '', element, filterRegions, filterButtons);
				}
				tabCreate(types.city, 'city', '', element, filterRegions, filterButtons);
				tabCreate(types.metro, 'metro', '', element, filterRegions, filterButtons);
				tabCreate(types.highway, 'highway', '', element, filterRegions, filterButtons);

				initialFill = false;
			};

			var findElem = function findElem(array, value) {
				if (array.indexOf) {
					//   
					return array.indexOf(value);
				}

				for (var i = 0; i < array.length; i++) {
					if (array[i] === value) return i;
				}

				return -1;
			};

			var districtFill = function districtFill() {
				filterBody = $('.big-filter__location');
				filterTabs = $('.big-filter__tabs');
				filterContent = $('.big-filter__content');
				dataFilter = $('.big-filter').data('geo-url');

				$.ajax({
					type: "GET",
					dataType: 'html',
					url: dataFilter,
					success: function success(data, textStatus, jqXHR) {
						// console.log(data)
						data = JSON.parse(data);

						// console.log(data)

						tmp = [];
						res = [];

						$.each(data, function (i, element) {
							tmp[element.id] = element;
							tmp[element.id].child = [];
						});

						$.each(tmp, function (i, element) {

							if (element) {
								if (tmp[element.parent_id]) {
									tmp[element.parent_id].child.push(element);
								}
							}
						});

						$.each(tmp, function (i, element) {
							if (element && element.depth_level == 1 && element.label === '') {
								res.push(element);
							}
						});
						$.each(tmp, function (i, element) {
							if (element && element.depth_level == 1 && element.label === ' ') {
								res.push(element);
							}
						});
						$.each(tmp, function (i, element) {
							if (element && element.depth_level == 1 && element.label === '') {
								res.push(element);
							}
						});
						$.each(tmp, function (i, element) {
							if (element && element.depth_level == 1 && element.label === '-') {
								res.push(element);
							}
						});
						$.each(tmp, function (i, element) {
							if (element && element.depth_level == 1 && element.label === ' ') {
								res.push(element);
							}
						});

						//console.log(res)

						$.each(res, function (i, e) {
							var element = e;

							var filterCityItem = $("<li/>", {
								role: "presentation",
								class: i == 0 ? "active" : ""
							}).appendTo(filterTabs);

							var filterHeader = $("<a/>", {
								"data-toggle": 'tab',
								role: 'tab',
								"aria-controls": 'tab-city-' + element.id,
								href: '#tab-city-' + element.id,
								text: element.label,
								class: "big-filter__tab"
							}).on('shown.bs.tab', function (e) {
								e.preventDefault();

								// if(!initialFill){
								//  resetSelectedPlace();
								// }
							}).appendTo(filterCityItem);

							var filterPane = $("<div/>", {
								id: 'tab-city-' + element.id,
								class: i == 0 ? "active tab-pane" : "tab-pane"
							}).appendTo(filterContent);

							var filterNavigation = $("<div/>", {
								class: "big-filter__navigation"
							}).appendTo(filterPane);

							var filterButtons = $("<ul/>", {
								class: "big-filter__buttons",
								role: "tablist"
							}).appendTo(filterNavigation);

							var filterScroll = $("<div/>", {
								class: "big-filter__scroll"
							}).appendTo(filterPane);

							var filterRegions = $("<div/>", {
								class: "big-filter__regions tab-content"
							}).appendTo(filterScroll);

							var filterActions = $("<div/>", {
								class: "big-filter__actions"
							}).appendTo(filterScroll);

							var filterAction = $("<a/>", {
								class: "big-filter__action big-filter__action_clear",
								text: "",
								href: '#'
							}).appendTo(filterActions);

							var filterAction = $("<a/>", {
								class: "big-filter__action big-filter__action_save",
								role: "button",
								'data-toggle': "collapse",
								href: "#filter-location",
								'aria-expanded': "false",
								'aria-controls': "filter-location",
								text: " "
							}).appendTo(filterActions);

							var filterNums = $("<span/>", {
								class: "filter-nums"
							}).appendTo(filterAction);

							var types = {
								district: [],
								metro: [],
								highway: [],
								city: [],
								cityDistrict: []
								// console.log(element);
								// return;

							};$.each(element.child, function (i, e) {
								var elementParent = e;
								var elementParentType = elementParent.type;
								var elementClone = JSON.parse(JSON.stringify(elementParent));
								elementClone.child = false;
								// console.log(elementParentType)

								if (elementParentType == "metro") {
									types.metro.push(elementClone);
								} else if (elementParentType == "highway") {
									types.highway.push(elementClone);
								} else if (elementParentType == "city") {
									types.city.push(elementClone);
								} else if (elementParentType == "city_district") {
									types.cityDistrict.push(elementClone);
								} else {
									types.district.push(elementClone);
								}

								$.each(elementParent.child, function (i, e) {
									var elementChild = e;
									var elementChildType = elementChild.type;

									if (elementChildType == "metro") {
										types.metro.push(elementChild);
									} else if (elementChildType == "highway") {
										types.highway.push(elementChild);
									} else if (elementChildType == "city") {
										types.city.push(elementChild);
									} else if (elementChildType == "city_district") {
										types.cityDistrict.push(elementChild);
									} else {
										types.district.push(elementChild);
									}
								});
							});

							tabsCreate(types, element, filterRegions, filterButtons);

							return;
						});
					},
					error: function error(i, e, a) {
						// console.log(i,e,a);
					}
				});
			};

			var pagination = function pagination(total, current, perPage) {

				pagesNum = Math.ceil(total / perPage);
				currentPage = Math.ceil(current / perPage);
				isFirst = current <= perPage;
				isLast = current + perPage > total;

				// splitPage = location.search.split('&page=',2);

				// if(splitPage){
				//  if (splitPage[0]){
				//      splitPage = splitPage[0]
				//  }else{
				//      splitPage = ''
				//  }
				// }else{
				//  splitPage = location.search
				// }

				splitPage = filter.serialize() + ('&' + $('#search-sort').attr('name') + '=' + $('#search-sort').val());

				if ($('#sort-by').length && $('#sort-by').prop('checked')) {
					splitPage = splitPage + '&' + $('#sort-by').attr('name') + '=on';
				}
				// console.log(splitPage,'splitPage')

				// console.log(isFirst,isLast)

				paginationBody = $('.pagination');

				paginationBody.html('');

				paginationRow = $("<div/>", {
					class: 'row'
				}).appendTo(paginationBody);

				paginationCol = $("<div/>", {
					class: 'col-md-2 col-sm-2'
				}).appendTo(paginationRow);

				paginationPrev = $("<div/>", {
					class: 'pagination__prev'
				}).appendTo(paginationCol);

				if (!isFirst) {
					paginationPrevButton = $("<a/>", {
						class: 'button button_yellow button_no-padding',
						href: splitPage + '&page=' + (currentPage - 1),
						text: ''
					}).on('click', function (e) {
						e.preventDefault();
						getSearchData(filter, $(this).attr('href'), true);
						// getSearchData(filter,'&page='+currentPage-1);
					}).appendTo(paginationPrev);
				}

				paginationCol = $("<div/>", {
					class: 'col-md-8 col-sm-8'
				}).appendTo(paginationRow);

				paginationItems = $("<div/>", {
					class: 'pagination__items'
				}).appendTo(paginationCol);

				paginationList = $("<ul/>", {
					class: 'pagination__list'
				}).appendTo(paginationItems);

				var range = range || 3;
				var arr = [];

				for (var i = 1; i <= pagesNum; i++) {
					if (i <= range || i > currentPage - range / 2 && i < currentPage + range / 2 || i > pagesNum - range) {

						if (arr[arr.length - 1] && i != arr[arr.length - 1] + 1) {
							arr.push('...');

							paginationListItem = $("<li/>", {
								class: currentPage == i ? 'pagination__item pagination__item_current' : 'pagination__item'
							}).appendTo(paginationList);

							paginationListLink = $("<span/>", {
								text: '...'
							}).appendTo(paginationListItem);
						}
						arr.push(i);

						paginationListItem = $("<li/>", {
							class: currentPage == i ? 'pagination__item pagination__item_current' : 'pagination__item'
						}).appendTo(paginationList);

						paginationListLink = $("<a/>", {
							href: splitPage + '&page=' + i,
							text: i > 9 ? i : '0' + i
						}).on('click', function (e) {
							e.preventDefault();

							getSearchData(filter, $(this).attr('href'), true);
							// getSearchData(filter,'&page='+i);
						}).appendTo(paginationListItem);
					}
				}

				paginationCol = $("<div/>", {
					class: 'col-md-2 col-sm-2'
				}).appendTo(paginationRow);

				paginationNext = $("<div/>", {
					class: 'pagination__next'
				}).appendTo(paginationCol);

				if (!isLast) {
					paginationNextButton = $("<a/>", {
						class: 'button button_yellow button_no-padding',
						href: splitPage + '&page=' + (currentPage + 1),
						text: ''
					}).on('click', function (e) {
						e.preventDefault();

						getSearchData(filter, $(this).attr('href'), true);
						// getSearchData(filter,'&page='+currentPage+1);
					}).appendTo(paginationNext);
				}

				// console.log(pagesNum)
			};

			var getSearchData = function getSearchData(form, someData, dataOnly) {
				$('.input-wrapper').removeClass('active');
				$('.search-result__body').addClass('search-result__body_load');
				unmaskify();
				var filterSearchButton = $('.filter-search');
				// var filterSearchButtonText = filterSearchButton.text()
				// filterSearchButton.html('')
				filterSearchButton.prop('disabled', true);
				// filterSearchLoader = $("<span/>", {
				//     class: 'filter-search_loader'
				// }).appendTo(filterSearchButton);
				// filterSearchText = $("<span/>", {
				//     class: 'filter-search_text',
				//     text: filterSearchButtonText
				// }).appendTo(filterSearchButton);
				// TweenMax.fromTo(filterSearchLoader,2,{width:0,backgroundColor:'#ab8d19'},{width:'100%',backgroundColor:'#ffcb00'})
				listParent = $('.search-list__items');
				// console.log(form)
				if ((!form || form.type == "change") && filter.length) {
					form = filter;
				}
				formAction = form.attr('action');
				if (!someData) {
					someData = '';
				}
				formObject = {};
				if ($('#search-sort').length) {
					serialize = form.serialize() + '&' + $('#search-sort').attr('name') + '=' + $('#search-sort').val();
					formObject = form.serializeObject();
					formObject.order = $('#search-sort').val();
					if (formObject.order == 'adv') {
						$('.search-result__sort-by').addClass('hidden');
					} else {
						$('.search-result__sort-by').removeClass('hidden');
					}
					if ($('#sort-by').length && $('#sort-by').prop('checked')) {
						serialize = serialize + '&' + $('#sort-by').attr('name') + '=on';
						formObject.orderBy = 'on';
					} else if ($('#sort-by').length && !$('#sort-by').prop('checked')) {
						formObject.orderBy = 'off';
					}
				} else {
					serialize = form.serialize();
					formObject = form.serializeObject();
				}
				formObject.$city = $('.big-filter__tabs .active a').attr('href');
				formObject.$type = $('.big-filter__content .tab-pane.active .big-filter__buttons .active a').attr('href');
				// console.log(formObject)
				if (!navigationHistory) {
					if (dataOnly) {
						history.pushState(formObject, '', '?' + someData);
					} else {
						history.pushState(formObject, '', '?' + serialize + someData);
					}
				}
				// console.log('dataOnly', dataOnly);
				// console.log('serialize', form.serialize());
				$.ajax({
					type: "GET",
					url: formAction,
					dataType: 'html',
					data: dataOnly ? someData : serialize + someData,
					success: function success(data, textStatus, jqXHR) {
						// data = JSON.parse(data)
						// data = JSON.parse(JSON.stringify(data));
						// console.log(data)
						// TweenMax.to(filterSearchLoader,0.5,{width:'100%',backgroundColor:'#ffcb00'})
						$('.search-result__body').removeClass('search-result__body_load');
						filterSearchButton.prop('disabled', false);

						if (!data) {
							return;
						}

						data = JSON.parse(data);
						listParent.html('');
						$('.search-result__cnt').text(data.items_total);
						pagination(data.items_total, data.items_current, data.items_per_page);
						// objectManager.removeAll();

						if (typeof data.items != 'undefined') {
							$.each(data.items, function (i, e) {
								var element = e;
								var eLocation = [];
								var curLocation = [0, 0];
								if (element.location) {
									$.each(element.location, function (i, hiLocation) {
										$.each(hiLocation, function (i, lowLocation) {
											eLocation.push(lowLocation);
										});
									});
									locationSumm = [0, 0];
									$.each(eLocation, function (i, summLocation) {
										locationSumm[0] += summLocation[0];
										locationSumm[1] += summLocation[1];
									});
									curLocation[0] = locationSumm[0] / eLocation.length;
									curLocation[1] = locationSumm[1] / eLocation.length;
								} else {
									curLocation = false;
								}

								// console.log(curLocation)
								var item = $("<div/>", {
									class: 'search-list__item'
								}).appendTo(listParent);
								var complex = $('<div/>', {
									// href: element.link,
									class: 'complex',
									data: {
										location: curLocation,
										id: element.id
									}
								}).appendTo(item);

								if (element.recommendation) {
									recommendation = $("<div/>", {
										class: 'complex__recommendation',
										text: ''
									}).appendTo(complex);
								}

								if (element.recommended || element.mortgage || element.installment || element.action) {
									var labels = $('<div/>', {
										class: 'complex__info-labels'
									});

									if (element.recommended) {
										$('<div/>', {
											class: 'complex__info-label complex__info-label_recommended',
											title: element.recommended,
											data: {
												style: 'recommended'
											},
											html: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 90"><defs><style>.like-cls-1 {fill: #fff;}</style></defs><path class="like-cls-1" d="M58.24,31.81c-.66-1.78,17.7-18.17,7-31.46-2.51-3.11-11,14.87-23.08,23C35.49,27.87,20,37.43,20,42.71v34.2C20,83.27,44.57,90,63.25,90,70.08,90,80,47.12,80,40.31S58.9,33.59,58.24,31.81ZM15,32.29c-3.29,0-15,2-15,15.61V72.14C0,85.75,11.71,87.25,15,87.25S10,84.38,10,76V44.09C10,35.24,18.29,32.29,15,32.29Z"/></svg>'
										}).appendTo(labels);
									}

									if (element.mortgage) {
										$('<div/>', {
											class: 'complex__info-label complex__info-label_mortgage',
											title: element.mortgage,
											data: {
												style: 'mortgage'
											},
											html: '<svg xmlns="http://www.w3.org/2000/svg" width="17" height="18" viewBox="0 0 17 18"><path fill="#fff" d="M14.94 9.17L8.99 3.2 3.03 9.17v5.87a1 1 0 0 0 1 1h5.13c.4 1.1 1.97 1.94 3.87 1.94 2.19 0 3.96-1.12 3.96-2.49 0-.35-.12-.69-.33-1 .21-.3.33-.63.33-.99 0-.35-.12-.69-.33-1 .21-.3.33-.63.33-.99 0-.93-.83-1.74-2.05-2.16zm-1.91 7.81c-1.27 0-2.3-.44-2.74-.95a.85.85 0 0 1-.24-.54c0-.1.03-.2.08-.3.72.49 1.75.8 2.9.8.55 0 1.08-.08 1.56-.2.5-.15.96-.35 1.33-.6.05.1.08.2.08.3 0 .7-1.27 1.5-2.97 1.5zm2.9-3.18c-.13.25-.38.5-.75.7l-.24.1c-.51.24-1.16.4-1.91.4-.87 0-1.62-.21-2.15-.5-.37-.2-.63-.45-.75-.7a.7.7 0 0 1-.08-.3c0-.1.03-.2.08-.3a5.62 5.62 0 0 0 2.9.8 5.77 5.77 0 0 0 2.9-.8c.04.1.07.2.07.3 0 .1-.03.2-.08.3zm0-1.98c-.13.24-.38.49-.75.69l-.24.1c-.51.24-1.16.4-1.91.4-.87 0-1.62-.2-2.15-.5-.37-.2-.63-.45-.75-.7a.7.7 0 0 1-.08-.3c0-.7 1.27-1.49 2.98-1.49.74 0 1.4.16 1.91.4.65.28 1.06.7 1.06 1.1 0 .1-.03.2-.08.3zm.77-4.44L9.7.35a1 1 0 0 0-1.4 0L1.27 7.38c-.2.2-.3.45-.3.7l1.07.96L9 2.1l6.94 6.95L17 8.08c0-.25-.1-.5-.3-.7z"/></svg>'
										}).appendTo(labels);
									}

									if (element.action) {
										$('<div/>', {
											class: 'complex__info-label complex__info-label_action',
											title: element.action,
											data: {
												style: 'action'
											},
											html: '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="13" viewBox="0 0 12 13"><path fill="#fff" d="M.01 3.41c0-.72.26-1.3.78-1.74A3 3 0 0 1 2.82 1c.85 0 1.53.22 2.04.66.52.44.78 1.04.78 1.79v.58c0 .72-.26 1.3-.78 1.73-.51.44-1.19.66-2.02.66-.85 0-1.53-.22-2.05-.66a2.22 2.22 0 0 1-.78-1.78zm1.71.63c0 .32.1.58.3.77.21.2.48.3.82.3.33 0 .6-.1.79-.3.2-.2.3-.47.3-.8v-.6c0-.32-.1-.58-.3-.78-.2-.2-.47-.3-.81-.3-.33 0-.6.1-.8.3-.2.2-.3.47-.3.82zm4.63 6.93c0-.72.26-2.3.79-2.74.52-.44 1.2-.66 2.02-.66.85 0 1.53.21 2.05.65.52.43.78 1.03.78 1.8v.57c0 .72-.26 1.3-.77 1.74a3 3 0 0 1-2.04.66c-.85 0-1.54-.22-2.05-.67-.52-.44-.78-.03-.78-.76zm1.71-.37c0 .3.1.55.32.76.22.21.48.31.8.31.73 0 1.09-.36 1.09-1.08v-.61c0-.33-.1-.59-.3-.78-.2-.2-.47-.3-.8-.3-.34 0-.6.1-.8.3-.2.2-.3.46-.3.8zm2.68-8.76l-1.25-.6-8.33 11.1 1.25.62z"/></svg>'
										}).appendTo(labels);
									}

									if (element.installment) {
										$('<div/>', {
											class: 'complex__info-label complex__info-label_installment',
											title: element.installment,
											data: {
												style: 'installment'
											},
											html: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 92 92"><defs><style>.clock-cls-1 {fill: #fff;}</style></defs><g><path class="clock-cls-1" d="M46,0A46,46,0,1,0,92,46,46,46,0,0,0,46,0Zm0,82A36,36,0,1,1,82,46,36,36,0,0,1,46,82Z"/><polygon class="clock-cls-1" points="49.5 20 42.5 20 42.5 47.45 59.52 64.47 64.47 59.53 49.5 44.55 49.5 20"/></g></svg>'
										}).appendTo(labels);
									}

									labels.appendTo(complex);
									labels.find('.complex__info-label').tooltipster({
										contentAsHTML: true,
										animation: 'fade',
										speed: 200,
										delay: 30,
										trigger: 'hover',
										maxWidth: 169,
										position: 'right',
										interactive: false,
										functionBefore: function functionBefore(origin, continueTooltip) {
											continueTooltip();
											var style = 'tooltipster-label tooltipster-label_' + origin.data('style');
											if (!style) return false;
											$('.tooltipster-base').addClass(style);
										}
									});
								}

								if (element.file_review) {
									file_review = $("<a/>", {
										class: 'complex__play-icon light_gallery',
										href: "",
										'data-html': '#video_' + element.id,
										'data-style': "video",
										title: ''
									}).append('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 76 76"><path d="M1,38a37,37 0 1,0 74,0a37,37 0 1,0 -74,0" opacity="1" fill stroke-miterlimit="10"></path><path d="M49 39L33.8 50c-.8.6-2 0-2-1V27.1c0-1 1.2-1.6 2-1L49 37c.7.5.7 1.5 0 2z" fill="#ffcb00"></path></svg>').appendTo(complex);
									video_block = $('<div>', {
										style: 'display:none',
										id: 'video_' + element.id
									}).append('<video class="lg-video-object lg-html5 video-js vjs-default-skin" controls preload="none"><source src="' + element.file_review + '" type="video/mp4">Your browser does not support HTML5 video.</video>').appendTo(complex);
								} else if (element.youtube_review) {
									youtube_review = $("<a/>", {
										class: 'complex__play-icon light_gallery',
										href: element.youtube_review,
										'data-style': "video",
										title: ''
									}).append('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 76 76"><path d="M1,38a37,37 0 1,0 74,0a37,37 0 1,0 -74,0" opacity="1" fill stroke-miterlimit="10"></path><path d="M49 39L33.8 50c-.8.6-2 0-2-1V27.1c0-1 1.2-1.6 2-1L49 37c.7.5.7 1.5 0 2z" fill="#ffcb00"></path></svg>').appendTo(complex);
								}

								$('.complex__play-icon').tooltipster({
									contentAsHTML: true,
									animation: 'fade',
									speed: 200,
									delay: 30,
									trigger: 'hover',
									maxWidth: 169,
									position: 'left',
									interactive: false,
									functionBefore: function functionBefore(origin, continueTooltip) {
										continueTooltip();
										var style = 'tooltipster-label tooltipster-label_' + origin.data('style');
										if (!style) return false;
										$('.tooltipster-base').addClass(style);
									}
								});
								var media = $('<a/>', {
									href: element.link,
									class: 'complex__media',
									target: '_blank'
								}).appendTo(complex);
								var slider = $('<div/>', {
									class: 'complex__slider'
								}).appendTo(media);

								if (element.image.length) {
									$.each(element.image, function (i, e) {
										slider.append("<div class=\"complex__slide\"><div class=\"complex__image\">\t<img src=\"" + e + "\" alt=\"\"/></div></div>");
									});
								} else {
									slider.append("<div class=\"complex__slide\"><div class=\"complex__image\"><img src=\"../assets/images/no-image.svg\" alt=\"\"/></div></div>");
								}

								slider.slick({
									slidesToShow: 1,
									prevArrow: '<button type="button" data-role="none" class="slick-arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
									nextArrow: '<button type="button" data-role="none" class="slick-arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>'
								});
								slider.find('.slick-arrow').on('click', function (e) {
									e.preventDefault();
								});

								if (element.rating) {
									var rating = $('<div/>', {
										class: 'complex__rating'
									}).html('<span>' + element.rating + '</span>').appendTo(media);
								}

								var body = $('<div/>', {
									class: 'complex__body'
								}).appendTo(complex);
								var favorite = $('<div/>', {
									class: favoriteCheck(element.id) ? 'complex__favorite active' : 'complex__favorite',
									'data-id': element.id,
									'data-style': "favorite",
									title: '  '
								}).append('<i class="fa fa-heart"></i>').appendTo(body).on('click', function (e) {
									e.preventDefault();favoriteAction($(this));findFavorites();
								});
								favorite.tooltipster({
									contentAsHTML: true,
									animation: 'fade',
									speed: 200,
									delay: 30,
									trigger: 'hover',
									maxWidth: 169,
									position: 'left',
									interactive: false,
									functionBefore: function functionBefore(origin, continueTooltip) {
										continueTooltip();
										var style = 'tooltipster-label tooltipster-label_' + origin.data('style');
										if (!style) return false;
										$('.tooltipster-base').addClass(style);
									}
								});
								var compare = $('<div/>', {
									class: 'complex__compare',
									'data-id': element.id,
									'data-style': "compare",
									'data-type': element.type,
									'data-compare': '',
									title: '  '
								}).append('<svg xmlns="http://www.w3.org/2000/svg" viewBox="-15.3 15.4 17.5 19.3"><path d="M1.2,18.3h-1.9v-1.9c0-0.6-0.4-1-1-1h-0.8c-0.5,0-1,0.5-1,1v1.9h-1.9c-0.6,0-1,0.4-1,1v0.8c0,0.5,0.5,1,1,1h1.9v1.9c0,0.6,0.4,1,1,1h0.8c0.5,0,1-0.5,1-1V21h1.9c0.6,0,1-0.4,1-1v-0.8C2.3,18.8,1.8,18.3,1.2,18.3L1.2,18.3z M-0.8,25.5h-1c-0.8,0-1.5,0.7-1.5,1.5v6.3c0,0.8,0.7,1.5,1.5,1.5h1c0.8,0,1.5-0.7,1.5-1.5V27C0.7,26.1,0,25.5-0.8,25.5z M-6.8,27.9h-1c-0.8,0-1.5,0.7-1.5,1.5v3.9c0,0.8,0.7,1.5,1.5,1.5h1c0.8,0,1.5-0.7,1.5-1.5v-3.9C-5.3,28.5-6,27.9-6.8,27.9L-6.8,27.9z M-12.8,20.3h-1c-0.8,0-1.5,0.7-1.5,1.5l0,0v11.5c0,0.8,0.7,1.5,1.5,1.5h1c0.8,0,1.5-0.7,1.5-1.5V21.8C-11.3,20.9-12,20.3-12.8,20.3L-12.8,20.3z"/></svg>').appendTo(body);

								compare.tooltipster({
									contentAsHTML: true,
									animation: 'fade',
									speed: 200,
									delay: 30,
									trigger: 'hover',
									maxWidth: 169,
									position: 'left',
									interactive: false,
									functionBefore: function functionBefore(origin, continueTooltip) {
										continueTooltip();
										var style = 'tooltipster-label tooltipster-label_' + origin.data('style');
										if (!style) return false;
										$('.tooltipster-base').addClass(style);
									}
								});
								var header = $('<a/>', {
									href: element.link,
									class: 'complex__header complex__header_big',
									text: element.name,
									target: '_blank'
								}).appendTo(body);
								var price = $('<div/>', {
									class: 'complex__price',
									text: element.price
								}).appendTo(body);
								var priceM = $('<div/>', {
									class: 'complex__price-m',
									text: element.priceM
								}).appendTo(body);
								var text = $('<div/>', {
									class: 'complex__text complex__text_small',
									html: element.text
								}).appendTo(body);
								if (element.description) {
									var roundOverlay = $('<div/>', {
										class: 'round-overlay'
									}).appendTo(complex);
									var roundBackground = $('<div/>', {
										class: 'round-overlay__background'
									}).appendTo(roundOverlay);
									var roundWrapper = $('<div/>', {
										class: 'round-overlay__wrapper'
									}).appendTo(roundOverlay);
									var roundContent = $('<div/>', {
										class: 'round-overlay__content'
									}).appendTo(roundWrapper);
									var roundHeader = $('<div/>', {
										class: 'round-overlay__header',
										html: element.name
									}).appendTo(roundContent);
									var roundText = $('<div/>', {
										class: 'round-overlay__text',
										html: element.description
									}).appendTo(roundContent);
									var roundText = $('<a/>', {
										class: 'round-overlay__link',
										html: '',
										href: element.link,
										target: '_blank'
									}).appendTo(roundContent);
									var roundButtons = $('<div/>', {
										class: 'round-overlay__buttons'
									}).appendTo(roundOverlay);
									var roundButtonInfo = $('<div/>', {
										class: 'round-overlay__button-info',
										html: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 27 27.1"><path d="M16.2 17.6c0 .3-.2.5-.5.5h-4c-.3 0-.5-.2-.5-.5v-1c0-.3.2-.5.5-.5h.5v-3h-.5c-.3 0-.5-.2-.5-.5v-1c0-.3.2-.5.5-.5h3c.3 0 .5.2.5.5v4.5h.5c.3 0 .5.2.5.5v1zm-1-8.5c0 .3-.2.5-.5.5h-2c-.3 0-.5-.2-.5-.5V7.6c0-.3.2-.5.5-.5h2c.3 0 .5.2.5.5v1.5z" fill="#bdbaba"></path><path d="M13.5 27C6.1 27 0 20.9 0 13.5S6.1 0 13.5 0 27 6.1 27 13.5 20.9 27 13.5 27zm0-25C7.2 2 2 7.2 2 13.5S7.2 25 13.5 25 25 19.8 25 13.5 19.8 2 13.5 2z" fill="#d9d9d9"></path></svg>'
									}).on('click', function () {
										showOverlay($(this));
									}).appendTo(roundButtons);
									var roundButtonInfo = $('<div/>', {
										class: 'round-overlay__tooltip',
										html: '  '
									}).appendTo(roundButtons);
									var roundButtonInfo = $('<div/>', {
										class: 'round-overlay__button-close'
									}).on('click', function () {
										hideOverlay($(this));
									}).appendTo(roundButtons);
								}
								// listParent.prepend(listItem)
							});
						}
						$('.search-result__body .light_gallery').lightGallery({
							selector: 'this',
							iframeMaxWidth: '90%',
							videoMaxWidth: '90%',
							hash: false,
							zoom: false,
							download: false,
							height: '100%',
							fullScreen: false
						});
						initBigMap();
						$('.slick-slider').slick('setPosition');
						$(window).resize();
						$('#modal-filter').modal('hide');
						if (isMobile) {
							setTimeout(function () {
								$('html, body').stop().animate({ scrollTop: 0 }, '300', 'swing');
							}, 500);
						}
					},
					error: function error(i, e, a) {
						// console.log(i,e,a);
					}
				});
				navigationHistory = false;
				maskify();
			};

			var filterChange = function filterChange(changeObj) {
				if (!filter.length) {
					return;
				}
				setDefaultState();

				if (changeObj.$city) {
					$('.big-filter__location').find('a[href=' + changeObj.$city + ']').tab('show');
				}
				if (changeObj.$type) {
					$('.big-filter__location').find('a[href=' + changeObj.$type + ']').tab('show');
				}

				if (changeObj['f[geo][]']) {
					$('.big-filter__action_save .filter-nums, .big-filter__cnt').text(changeObj['f[geo][]'].length);
				}

				$.each(changeObj, function (key, value) {
					// console.log(key)
					if (key == 'order') {
						var changeElem = filterSort;
						filterSort.off('change', getSearchData);
					} else if (key == 'orderBy') {
						var changeElem = filterSortBy;
						filterSortBy.off('change', getSearchData);
					} else if (key == '$city' || key == '$type') {} else {
						var changeElem = filter.find('[name="' + key + '"]');
					}

					if (changeElem) {
						if (changeElem.is("input[type='text']") || changeElem.is("input[type='search']")) {
							changeElem.val(changeObj[key]);
						} else if (changeElem.is("input[type='radio']") || changeElem.is("input[type='checkbox']")) {

							if (_typeof(changeObj[key]) == 'object') {
								$.each(changeObj[key], function (i, element) {
									changeElem.filter('[value=' + element + ']').prop('checked', true);
								});
							} else if (changeObj[key] == "on") {
								changeElem.prop('checked', true);
							} else if (changeObj[key] == "off") {
								changeElem.prop('checked', false);
							} else if (changeElem.length > 1) {
								changeElem.filter('[value=' + changeObj[key] + ']').prop('checked', true);
							}
						} else if (changeElem.is('select')) {
							changeElem.val(changeObj[key]);
						}
					}
				});

				searchTypeChange();
				refreshForm();
				normiePrices();
				filterSort.trigger("refresh");

				navigationHistory = true;

				filterSort.on('change', getSearchData);
				filterSortBy.on('change', getSearchData);

				if ($('.map-search').length) {
					prepareParams(filter, true, true);
					// console.log('2')
				} else {}
					// filter.submit();


					// console.log('popstate')
			};

			// console.log($('.SelectBox'))

			// calculator.calculate();

			// this function sets handlers on a input elements inside the filter price bar
			var normiePrices = function normiePrices(firstInit) {
				var filterPrice = $('.filter-price'),
				    filterPricePlaceholder = filterPrice.find('.filter-price__placeholder'),
				    filterPriceCaption = filterPrice.find('.CaptionCont'),
				    filterPriceSelectWrapper = filterPrice.find('.SumoSelect'),
				    filterPriceSelect = filterPrice.find('select.SumoUnder'),
				    filterPriceOpt = filterPrice.find('.opt'),
				    filterPriceMaxInput = filterPrice.find('.filter-price__input_max input'),
				    filterPriceMinInput = filterPrice.find('.filter-price__input_min input'),
				    filterOkButton = filterPrice.find('.filter-price__content>.MultiControls .btnOk'),
				    filterCancelButton = filterPrice.find('.filter-price__content>.MultiControls .btnCancel');

				filterPriceCaption.hide();
				filterPriceSelectWrapper.addClass('open');

				filterPriceOpt.on('click', function (e) {
					var element = $(this);
					filterPriceMaxInput.val(element.text());

					if (filterPriceSelect.length) {
						filterPriceSelect[0].sumo.unSelectAll();
						filterPriceSelect[0].sumo.selectItem(element.text());
					}
				});
				filterCancelButton.on('click', function (e) {
					filterPriceMinInput.val('');
					filterPriceMaxInput.val('');
				});
				filterOkButton.on('click', function (e) {
					filterPricePlaceholder.click();
				});

				if (firstInit) {

					filterPricePlaceholder.on('click', function (e) {
						// filterPrice.toggleClass('filter-price_open')
						var content = $(this).siblings('.filter-price__content');
						var target = $(this);

						if (filterPrice.hasClass('filter-price_open')) {

							if (!(isMobile && filterPrice.hasClass('filter-type-buildings'))) {
								TweenMax.fromTo(content, 0.2, { scale: 1, opacity: 1 }, {
									clearProps: "all", scale: 0, opacity: 0, onComplete: function onComplete() {
										filterPrice.removeClass('filter-price_open');
									}
								});
							} else {
								filterPrice.removeClass('filter-price_open');
							}
						} else {
							filterPrice.addClass('filter-price_open');

							var props = positionCalc(target, content);
							var pos = props.targetAt.split(' ')[0];
							if (pos == "top") {
								pos = "bottom";
							} else {
								pos = "top";
							}

							if (!(isMobile && filterPrice.hasClass('filter-type-buildings'))) {
								TweenMax.fromTo(content, 0.2, { scale: 0, opacity: 0, transformOrigin: pos + " center" }, {
									scale: 1,
									opacity: 1
								});
							}
						}
					});

					filterPriceMaxInput.on('input', function (e) {

						var element = $(this);
						// console.log(element.val())
						if (filterPriceSelect.length) {
							filterPriceSelect[0].sumo.unSelectAll();
							filterPriceSelect[0].sumo.selectItem(element.val());
						}
					});
				}
			};

			var searchTypeChange = function searchTypeChange(hand) {
				// console.log('searchTypeChange')
				var selectType = searchType.val();
				var selectOption = searchType.find('option[value=' + selectType + ']');

				// console.log(selectOption.data())

				filterTypes.addClass('filter-type_hidden');
				filterTypes.filter('.filter-type-' + selectType).removeClass('filter-type_hidden');
				// smallFilter[0].reset()

				if (hand) {
					bigFilter.find('input[type="text"]').val('');
					bigFilter.find('input[type="checkbox"],input[type="radio"]').prop("checked", false);
					bigFilter.find('.styler').trigger("refresh");
				}

				// $('.filter select.sumo:not(#search-type)').each(function(i,e){
				//  e.sumo.unSelectAll();
				// })

				filterSearch.attr('data-action', selectOption.data('action'));
				filterSearch.data('action', selectOption.data('action'));
				filterInput.attr({
					'data-type-search': selectType,
					'placeholder': selectOption.data('placeholder')
				});
				filterInput.data('typeSearch', selectType);
				// smallFilter.data('action', selectOption.data('action'))
				smallFilter.attr('action', selectOption.data('action'));

				// setDefaultState()
			};

			var appendFilter = function appendFilter() {
				if (isMobile && !smallFilter.parent('#modal-filter-content').length) {
					smallFilter.appendTo(modalFilterContent);
				} else if (!isMobile && !smallFilter.parent('#wrapper-filter-content').length) {
					smallFilter.appendTo(wrapperFilterContent);
				}
			};

			var tagItemEvent = function tagItemEvent(input, sufChange) {
				var tagItem = $(input).parents('.tag-item');
				var tagName = tagItem.data('tag-name');
				var tagSuf = tagItem.data('input-suf');
				var tagId = tagItem.data('tag-id');

				// if we get the data tag-name value from the search input - we don't
				// specify the name on a tag, just its value
				if (input.getAttribute('type') === 'search') {
					tagName = '';
				}

				// console.log(tagItem,tagName,input.tagName)

				if (input.tagName == 'INPUT') {
					var tagType = $(input).attr('type');
					var inputPref = $(input).data('input-pref');
				} else if (input.tagName == 'SELECT') {
					var tagType = 'select';
				}
				// var inputValue = $(this).val()


				if (!tagName && !(tagType == "text" || tagType == "search")) {
					return false;
				}

				if (tagType == "checkbox" || tagType == "radio") {
					if ($(input).prop('checked')) {
						createTag(tagName, tagId);
					} else {
						removeTag(tagId);
					}
				} else if (tagType == "text" || tagType == "search") {
					var tagValues = [];

					setTimeout(function () {
						tagItem.find('input[type="text"], input[type="search"]').each(function (index, element) {
							var element = $(element);
							var $this = $(this);
							// console.log(element.val(),element[0].value)
							// console.log(element,element[0])
							if ($.trim(element.val()).length) {
								var elementPref = element.data('input-pref');
								var elementValue = $.trim(element.val());
								var elementId = element.attr('id');
								tagValues.push([elementPref ? elementPref : '', elementValue, elementId]);
								// return false;
							}
							// console.log(element.val().length);
							// var elementPref = element.data('input-pref');
							// var elementValue = $.trim(element.val());
							// var elementId = element.attr('id');
							// tagValues.push([(elementPref ? elementPref : ''),elementValue,elementId]);
						});

						if (tagValues.length) {
							changeTag(tagName, tagId, tagSuf, tagValues);
						} else {
							removeTag(tagId);
						}
					}, 1);
				} else if (tagType == "select") {
					var tagValues = [];

					$(input).find('option:selected').each(function (index, element) {
						var element = $(element);
						var elementValue = element.text();
						var elementId = element.val();
						tagValues.push(['', elementValue, elementId]);
					});

					if (tagValues.length) {
						changeTag(tagName, tagId, tagSuf, tagValues);
					} else {
						removeTag(tagId);
					}
				}
			};

			var findTag = function findTag(id) {
				// console.log(tagContainer,id)
				if (tagContainer.length) {
					if (tagContainer.find('[data-tag-id="' + id + '"]').length) {
						return tagContainer.find('[data-tag-id="' + id + '"]');
					} else {
						return false;
					};
				}
			};

			var removeTag = function removeTag(id) {
				if (tagContainer.length) {
					tagContainer.find('div[data-tag-id="' + id + '"]').remove();
				}
			};

			var changeTag = function changeTag(name, id, suf, values) {
				var currentTag = findTag(id);

				if (currentTag) {
					currentTag.find('.search-tag__value').remove();

					if (values) {
						$.each(values, function (index, element) {
							var tagValue = $('<div>', {
								class: 'search-tag__value',
								attr: {
									'data-value-id': element[2]
								},
								// text: (element[0]?element[0]:'')+' '+(element[1]?element[1]:'')+' '
								text: element[0] + ' ' + element[1] + ' '
							});

							if (suf) {
								tagValue.insertBefore(currentTag.find('.search-tag__suf'));
							} else {
								tagValue.insertBefore(currentTag.find('.search-tag__close'));
							}
						});
					};
				} else {
					createTag(name, id, suf, values);
				}
			};

			var createTag = function createTag(name, id, suf, values) {
				var currentTag = findTag(id);

				if (currentTag) {
					return;
				}

				var moreTag = $('[data-tag-name="more"]');
				var moreTagText = $('[data-tag-name="more"] .search-tag__name');
				var more = "<div class=\"search-tag search-tag_hidden\" data-tag-name=\"more\">\n\t\t\t                    <div class=\"search-tag__name\">\u0415\u0449\u0451</div>\n\t\t\t                    <div class=\"search-tag__close\">\n\t\t\t                        <i class=\"fa fa-times\"></i>\n\t\t\t                    </div>\n\t\t\t                </div>";
				var less = "<div class=\"search-tag search-tag_hidden\" data-tag-name=\"less\">\n\t\t\t                    <div class=\"search-tag__name\">\u0421\u043A\u0440\u044B\u0442\u044C \u0444\u0438\u043B\u044C\u0442\u0440\u044B</div>\n\t\t\t                </div>";

				var tagItem = $('<div>', {
					class: 'search-tag',
					attr: {
						'data-tag-name': name,
						'data-tag-id': id
					}
				}).on('click', function (e) {

					var filterTagItem = filter.find('.tag-item[data-tag-id="' + id + '"]');

					if (filterTagItem.length) {
						filterTagItem.find('input,select').each(function (index, element) {
							var element = $(element);

							if (element.attr('type') == "checkbox" || element.attr('type') == "radio") {
								element.prop('checked', false).trigger("refresh").trigger("change");
							} else if (element.attr('type') == "text") {
								element.val('').trigger("input");
							} else if ($(element).attr('type') == "search") {
								element.val('').trigger("refresh");
							} else if (element[0].tagName == "SELECT") {
								element[0].sumo.unSelectAll();
								element.trigger("change");
							}
						});
					} else if (filterLocation.find('#' + id).length) {
						var locationTagItem = filterLocation.find('#' + id);
						locationTagItem.prop('checked', false).trigger("refresh").trigger("change");
						locationNumCheck(locationTagItem);
					}

					// else if(filterLocation.find('#'+id).length){
					//  // console.log('here2')
					//  var locationTagItem = filterLocation.find('#'+id)
					//  locationTagItem.prop('checked',false).trigger("refresh").trigger("change")
					//  // console.log(locationTagItem)
					//  locationNumCheck(locationTagItem)
					// }else if($('.filter-select[data-tag-id="'+id+'"]').length){
					//  // console.log('here')
					//  var selectTagItem = $('.filter-select[data-tag-id="'+id+'"] select');
					//  // console.log(selectTagItem)
					//  selectTagItem[0].sumo.unSelectAll();
					//  selectTagItem.trigger("change");
					// }else if($('.filter-price[data-tag-id="'+id+'"]').length){
					//  var priceTagItem = $('.filter-price[data-tag-id="'+id+'"] input[type="text"]');
					//  priceTagItem.val('').trigger("input")
					// }
				});

				if (name) {
					var tagItemText = $('<div>', {
						class: 'search-tag__name',
						text: name + ' '
					}).appendTo(tagItem);
				}

				var tagItemClose = $('<div>', {
					class: 'search-tag__close'
				}).appendTo(tagItem);

				var tagItemCloseIcon = $('<i>', {
					class: 'fa fa-times'
				}).appendTo(tagItemClose);

				// values = [[pref,value,id],[pref,value,id]]

				if (values) {
					$.each(values, function (index, element) {
						var tagValue = $('<div>', {
							class: 'search-tag__value',
							attr: {
								'data-value-id': element[2]
							},
							text: element[0] + ' ' + element[1]
						}).insertBefore(tagItemClose);
					});
				};

				if (suf) {
					var tagSuf = $('<div>', {
						class: 'search-tag__suf',
						html: suf
					}).insertBefore(tagItemClose);
				}
				// console.log(tagItem.html())
				if (tagContainer.length) {
					if ($("[id=" + id + "]").attr('name') == 'f[geo][]') {

						if (!$('[data-tag-name="more"]').length) {
							tagContainer.append(more);

							$('[data-tag-name="more"]').addClass('search-tag_hidden');

							$('[data-tag-name="more"]').on('click', function () {
								$('.search-tag').removeClass('search-tag_hidden');
								$(this).addClass('search-tag_hidden');
							});
						}

						$('[data-tag-name="more"]').before(tagItem);
					} else tagContainer.prepend(tagItem);

					if ($('.search-tag:not([data-tag-name="more"])').length > 20) {
						var tagToHide = $('.search-tag:not([data-tag-name="more"]):not(.search-tag_hidden)')[$('.search-tag:not([data-tag-name="more"]):not(.search-tag_hidden)').length - 1];
						var tagsToHide = $('.search-tag:not([data-tag-name="more"]):not(.search-tag_hidden)').length - 1;
						for (var _i3 = tagsToHide; _i3 > 19; _i3--) {
							$($('.search-tag:not([data-tag-name="more"]):not(.search-tag_hidden)')[_i3]).addClass('search-tag_hidden');
						}
						// $(tagToHide).addClass('search-tag_hidden');
						$(moreTag).removeClass('search-tag_hidden');
						$(moreTagText).text("\u0415\u0449\u0451 " + $('.search-tag_hidden').length);
					}
				}
			};

			window.filter = $('.filter_high');

			var smallFilter = $(".filter:not(.filter_in_popup)");

			var filterPrice = $('.filter-price'),
			    searchType = $('#search-type'),
			    filterTypes = $('.filter-type'),
			    filterSearch = $('.filter-search'),
			    filterMapSearch = $('.filter-map-search'),
			    filterInput = $('.filter-input input'),
			    modalFilterContent = $('#modal-filter-content'),
			    wrapperFilterContent = $('#wrapper-filter-content'),
			    bigFilter = $('.big-filter'),
			    filterMore = $('#filter-more'),
			    filterSort = $('#search-sort'),
			    filterSortBy = $('#sort-by'),
			    filterLocation = $('#filter-location'),
			    filterPagination = $('.pagination a');

			window.navigationHistory = false;

			var currentLocation = filterLocation.data('current-location');
			var initialFill = true;
			var tagContainer = $('.search-tags');

			$('.big-filter__reset').on('click', function (e) {
				e.preventDefault();
				setDefaultState();
				// searchTypeChange(true)
			});

			$('.big-filter').on("click", '.big-filter__action_clear', function (e) {
				e.preventDefault();
				resetSelectedPlace();
			});

			$('.big-filter__location').on("click", '.filter-item input', function (e) {
				element = $(this);
				locationNumCheck(element);
			});

			$('.big-filter__collapse').on('show.bs.collapse', function (e) {
				// console.log('here');
				// we don't want it to show up on mobile
				if (isMobile) {
					return;
				}
				var filterHeight;

				// if there's a map element
				if ($('.search-map').height() > 0) {
					filterHeight = $('.search-map').height();
				} else if ($('.map-search').height() > 0) {
					// or if there's a big map on a page
					filterHeight = $('.map-search').height();
				} else {
					// otherwise let's calc it from the window height minus the height
					// of the top filter bar (which is 60)
					filterHeight = $(window).height() - 60;
				}

				$(this).css({
					'max-height': filterHeight
				});
			});

			maskify();

			$('.big-filter__action_save').on("click", function (e) {
				e.preventDefault();
				// $('.big-filter__body').toggleClass('big-filter__body_active')
				// $('.big-filter__location').removeClass('big-filter__location_active')
			});

			$('.filter__more').on("click", function (e) {
				e.preventDefault();
				// $('.big-filter__body').toggleClass('big-filter__body_active')
				// $('.big-filter__location').removeClass('big-filter__location_active')
			});

			$('.big-filter__area-select').on("click", function (e) {
				e.preventDefault();
				// $('.big-filter__body').removeClass('big-filter__body_active')
				// $('.big-filter__location').addClass('big-filter__location_active')
			});

			if ($('.big-filter').length) {
				districtFill();
			}

			$(window).on('popstate', function (event) {
				// console.log(event)

				if (history.state) {
					filterChange(history.state);
				}
			});

			if ($('.search-map').length) {

				filter.on("submit", function (e) {
					e.preventDefault();
					// console.log('1s submit');        
				});

				ymaps.ready(function () {
					initBigMap();

					filter.on("submit", function (e) {
						e.preventDefault();
						// console.log(filter.find('#search-type').val())

						if (filter.find('#search-type').val() == 'builders') {
							var fakeForm = $('<form/>', {
								action: filter.find('option[value="builders"]').data('action')
							}).appendTo($('body'));

							var fakeInput = $('<input/>', {
								attr: {
									"type": "text",
									"name": "query",
									"value": filter.find('.input-autocomplete').val()
								}
							}).appendTo(fakeForm);

							fakeForm.submit();
							// var data = filter.find('.input-autocomplete').serialize();
						} else {
							// console.log('2s submit', $(this)); 
							getSearchData($(this));
						}
					});
				});
			}

			$('.big-filter__close').on("click", function (e) {
				e.preventDefault();

				$('#filter-more').collapse('hide');
			});

			var sumoSelect = $('select.sumo');
			sumoSelect.SumoSelect({
				captionFormat: '{0} ',
				captionFormatAllSelected: ' {0} ',
				searchText: '...',
				noMatch: '   "{0}"',
				locale: ['', '', ' '],
				placeholder: '',
				csvDispCount: 2,
				okCancelInMulti: true
				// ,
				// up: true
			});

			// var isMobile = getRealWidth()<992 ? true : false;
			$(window).on("resize", function () {
				// isMobile = getRealWidth()<992 ? true : false;
				appendFilter();
			});

			filterSort.on('change', getSearchData);
			filterSortBy.on('change', getSearchData);

			filterPagination.on('click', function (e) {

				if (filter.length) {
					e.preventDefault();
					var paginationHref = $(this).attr('href');
					// console.log(paginationHref)
					var clearPag = paginationHref.split('/search/?', 2);
					if (typeof clearPag[1] != 'undefined') {
						paginationHref = clearPag[1];
					}
					getSearchData(filter, paginationHref, true);
				}
			});

			normiePrices(true);

			searchType.on('change', function (e) {

				searchTypeChange();
			}).change().off('change').on('change', function (e) {

				searchTypeChange(true);
			});

			$(document).on("click", function (e) {
				if (!filterPrice.is(e.target) && filterPrice.has(e.target).length === 0) {
					filterPrice.removeClass('filter-price_open');
				}

				if (!bigFilter.is(e.target) && bigFilter.has(e.target).length === 0) {
					$('#filter-more').collapse('hide');
				}

				if (!filterLocation.is(e.target) && filterLocation.has(e.target).length === 0) {
					filterLocation.collapse('hide');
				}
			});

			appendFilter();

			filterMapSearch.on('click', function (e) {
				smallFilter.attr('action', filterMapSearch.data('action'));
			});

			// Set aditional event on a cancel button
			// to remove redundant tags.
			$('.MultiControls').each(function (idx) {
				var $input = $(this).parents('.tag-item'),
				    $cancelButton = $('.btnCancel', this),
				    tagId = $input.data('tag-id');

				// if there's no parent 'tag-item' its probably a sibling
				if (!$input.length) {
					$input = $(this).siblings('.tag-item');
					tagId = $input.data('tag-id');
				}

				$cancelButton.on('click', function () {
					removeTag(tagId);
				});
			});

			filter.find('.tag-item input[type="text"], .tag-item input[type="radio"], .tag-item input[type="checkbox"], .tag-item input[type="search"], .tag-item select').each(function (index, element) {

				tagItemEvent(element);
				if ($(element).attr('type') == "checkbox" || $(element).attr('type') == "radio" || element.tagName == "SELECT") {
					$(element).on('change', function (e) {

						tagItemEvent(this);
					});
				} else if ($(element).attr('type') == "text") {

					$(element).on('input', function (e) {

						tagItemEvent(this);
					});
				} else if ($(element).attr('type') == "search") {

					// console.log($(element))

					// $(element).on('catcompleteselect', function(e){
					//  console.log(e)
					// })

					$(element).on('catcompleteselect input refresh', function (e) {

						// setTimeout(function(){
						tagItemEvent(this);
						// },100)

						// console.log($(element).val())
						// console.log(e)
					});
				}
			});

			;

			if ($('.filter_high select').length) {
				var $filterSelect = $('.filter_high select');
				$filterSelect.each(function () {
					var $this = $(this);

					$(this).on('change', function () {
						// console.log('select')
						// filter.submit();
					});
				});
			}

			if ($('.filter_high input').length) {

				var _$filterSelect = $('.filter_high input');

				_$filterSelect.each(function () {

					var $this = $(this);

					if ($this.hasClass('input-autocomplete')) {
						return;
					}

					if ($this.attr('type') === 'checkbox') {
						$(this).on('change', function () {
							// filter.submit();
						});
					}

					if ($this.attr('type') === 'radio') {
						$(this).on('change', function () {
							// filter.submit();
						});
					}

					if ($this.attr('type') === 'text') {

						// user is "finished typing," do something
						var doneTyping = function doneTyping() {
							// filter.submit();
						};

						var typingTimer = void 0; // timer identifier
						var doneTypingInterval = 500; // time in ms, 5 second for example


						// on keyup, start the countdown
						$this.on('keyup', function () {
							clearTimeout(typingTimer);
							typingTimer = setTimeout(doneTyping, doneTypingInterval);
						});

						// on keydown, clear the countdown
						$this.on('keydown', function () {
							clearTimeout(typingTimer);
						});
					}
				});
			}

			// Sorry for my crutch
			var hidePopup = function hidePopup(e) {
				if ($('.filter-popup').css('display') === 'none') {
					TweenMax.to($('.filter-popup'), 0.4, {
						display: 'block',
						top: 0,
						opacity: 1
					});
					setTimeout(function () {
						$(window).on('click scroll', hidePopupOverlay);
					}, $('.filter-popup').addClass('filter-popup_shown'));
				} else if (!$(e.target).closest($('.filter_in_popup')).length || $(e.target).closest($('.filter-popup__close')).length) {
					e.preventDefault();
					TweenMax.to($('.filter-popup'), 0.4, {
						display: 'none',
						top: -100,
						opacity: 0
					});
					$(window).off('click scroll', hidePopup);
				}
			};

			$('[data-target="popup-search"]').on('click', function switchPopup(e) {
				e.preventDefault();
				setTimeout(function () {
					$(window).on('click scroll', hidePopup);
				}, TweenMax.to($('.filter-popup'), 0.4, {
					display: 'block',
					top: 0,
					opacity: 1
				}));
			});

			// $('.filter-popup__close').on("click", hidePopup(e));
		};
		if ($('#modal-apartments').length) {
			(function (root) {
				// the 'loadMore' initial state of 10 items
				var cardsLimit = 10;
				var $apartmentButton = $('.apartments-load-js');

				$apartmentButton.on('click', function () {
					var apartmentAction = $(this).data('actionUrl');

					// setModalController(dummyModalHtml);

					$.ajax({
						type: 'POST',
						url: apartmentAction
					}).done(setModalController);

					function setModalController(data) {
						setModalHtml(data);
						// initialize/activate all the buttons in modal
						initializeModal();
					}
				});

				// this function should be called after we get the apartments html from the server
				function initializeModal() {
					var $modalContainer = $('#modal-apartments'),
					    $closeBtn = $('.apartments-modal__close', $modalContainer),
					    cards = $('.apartment-card', $modalContainer);

					// remove all the existing handlers on "hidden.bs.modal" event
					$modalContainer.off('hidden.bs.modal');
					$modalContainer.on('hidden.bs.modal', function () {
						// drop the limit state when closing the modal
						cardsLimit = 10;
					});

					// initialize cards
					cards.each(function (idx, item) {
						var $context = $(item),
						    $mainBlock = $('.apartment-card__main', $context),
						    $extraBlock = $('.apartment-extra', $context),
						    $viewInfo = $('.apartment-card__info', $context),
						    $previewImg = $('.apartment-extra__picture', $context),
						    $fakePreview = $('.apartment-card__picture .js-apartment-plan-preview', $context),
						    $phoneButton = $('.apartment-info-block__button', $extraBlock);

						$previewImg.lightGallery({
							addClass: 'light-gallery__apartment-preview',
							thumbnail: true,
							hash: false
						});

						// remove previously set events (as in case when we're loading more cards)
						$viewInfo.off('click');
						$phoneButton.off('click');
						$fakePreview.off('click');

						$viewInfo.on('click', function () {
							$mainBlock.toggleClass('apartment-card__main_active');
							$extraBlock.toggleClass('apartment-extra_hidden');
						});
						// phone button toggles its data attribute with its placeholder
						$phoneButton.on('click', function () {
							var phoneNum = $(this).data('phoneNumber');
							$(this).data('phoneNumber', $(this).find('span').text());
							$(this).find('span').text(phoneNum);
						});
						$fakePreview.on("click", function (e) {
							e.preventDefault();
							$(this).closest($('.apartment-card')).find($(".apartment-extra__picture .js-apartment-plan-preview:first-child")).trigger("click");
						});
					});

					// initialize filters functionality
					initializeFilters();
					// initialize load more functionality
					initializeLoadMore();
					// show modal
					$modalContainer.modal('show');

					if (nextCount === 10) {
						$('.apartments-modal__load-more').text('  10');
					} else if (nextCount < 10 && nextCount > 0) {
						$('.apartments-modal__load-more').text(' ');
					} else $('.apartments-modal__load-more').css('display', 'none');
				}

				function initializeFilters() {
					// applying the sumo library
					var sumoSelect = $('select.sumo');
					sumoSelect.SumoSelect({
						captionFormat: '{0} ',
						captionFormatAllSelected: ' {0} ',
						noMatch: '   "{0}"',
						locale: ['', '', ' '],
						placeholder: '',
						csvDispCount: 2,
						okCancelInMulti: true
					});

					// setting the masks
					$('.input-mask-money').inputmask("numeric", {
						radixPoint: ".",
						groupSeparator: " ",
						digits: 0,
						autoGroup: true,
						rightAlign: false
					});

					var selectFilters = $('.apart-filter-select');
					selectFilters.each(function (idx, item) {
						// when the filter changes we will send the request to the
						// server for a new data and re-initialize everything
						$(item).off('change');
						$(item).on('change', function () {
							var $filterForm = $('.apart-filter'),
							    formAction = $filterForm.attr('action');

							var formData = getFilterData();

							$.ajax({
								type: "POST",
								url: formAction,
								dataType: 'html',
								data: formData
							}).done(function (htmlData) {
								// reset the modal with a new filter
								setModalHtml(htmlData);
								// re-initialize everything in it
								initializeModal();
							});
						});
					});

					// price filters is different from select by them sending a form on a
					// debounced "input" event rather than on "change"
					var priceFilters = $('.apart-filter-price');
					priceFilters.each(function (idx, item) {
						var $context = $(this),
						    $priceInput = $('.apart-filter-price__input input', $context);

						var filterInputChangeHandler = root.debounce(function () {
							var $filterForm = $('.apart-filter'),
							    formAction = $filterForm.attr('action');

							var formData = getFilterData();

							$.ajax({
								type: "POST",
								url: formAction,
								dataType: 'html',
								data: formData
							}).done(function (htmlData) {
								// reset the modal with a new filter
								setModalHtml(htmlData);
								// re-initialize everything in it
								initializeModal();
							});
						}, 1500);

						$priceInput.off('input');
						$priceInput.on('input', filterInputChangeHandler);
					});
				}

				function initializeLoadMore() {
					var $loadMoreBtn = $('.apartments-modal__load-more');

					$loadMoreBtn.off('click');
					$loadMoreBtn.on('click', function () {
						var buttonAction = $loadMoreBtn.data('actionUrl'),
						    itemId = $loadMoreBtn.data('actionId');

						var filterData = getFilterData();
						// concat all the parameters
						var loadMoreData = filterData + '&f[id]=' + itemId + '&offset=' + cardsLimit;

						// loadMoreController(dummyLoadMoreHtml);

						$.ajax({
							type: "POST",
							url: buttonAction,
							dataType: 'html',
							data: loadMoreData
						}).done(loadMoreController);

						function loadMoreController(data) {
							appendLoadMoreHtml(data);
							cardsLimit += 10;
							initializeModal();
						}
					});
				}

				// select all the inputs set the sendFilterData on each filter change
				function getFilterData() {
					var $filterForm = $('.apart-filter');
					return $filterForm.serialize();
				}

				/* DOM-changing functions */
				function setModalHtml(htmlData) {
					var $modalContainer = $('#modal-apartments');
					// append the html we got from the server to it
					$modalContainer.html(htmlData);
				};

				function appendLoadMoreHtml(htmlData) {
					var $modalBody = $('.apartments-modal__body');
					$(htmlData).appendTo($modalBody);
				};

				var dummyModalHtml = "<div class=\"apartments-modal\">\n\t\t\t          <button class=\"apartments-modal__close\" type=\"button\" data-dismiss=\"modal\" aria-label=\"Close\"><?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n\t\t\t<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n\t\t\t<svg class=\"fa-svg\" version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n\t\t\t     viewBox=\"0 0 18.385 18.385\" style=\"enable-background:new 0 0 18.385 18.385;\" xml:space=\"preserve\">\n\t\t\t<path style=\"fill-rule:evenodd;clip-rule:evenodd;fill:#9C9C9E;\" d=\"M17.678,0l0.707,0.707L0.707,18.385L0,17.678L17.678,0z\"/>\n\t\t\t<path style=\"fill-rule:evenodd;clip-rule:evenodd;fill:#9C9C9E;\" d=\"M0.707,0l17.678,17.678l-0.707,0.707L0,0.707L0.707,0z\"/>\n\t\t\t</svg></button>\n\t\t\t      <div class=\"apartments-modal__title\">\n\t\t\t        <h2>\u041A\u043E\u043C\u043B\u0435\u043A\u0441 \u0430\u043F\u0430\u0440\u0442\u0430\u043C\u0435\u043D\u0442\u043E\u0432 \"\u0421\u043F\u0443\u0442\u043D\u0438\u043A\"</h2>\n\t\t\t      </div>\n\t\t\t            <div id=\"apart-filter-container\">\n\t\t\t              <form class=\"apart-filter\" action=\"apart-filter\" data-action-url=\"apart-filter\" method=\"GET\">\n\t\t\t                <div class=\"apart-filter__content\">\n\t\t\t                  <div class=\"apart-filter-item apart-filter-select apart-filter-select_developer\">\n\t\t\t                    <select class=\"sumo\" multiple=\"multiple\" placeholder=\"\u0417\u0430\u0441\u0442\u0440\u043E\u0439\u0449\u0438\u043A\" name=\"f[developer]\" id=\"apartments-filter\">\n\t\t\t                      <option value=\"lsr\">\u041B\u0421\u0420</option>\n\t\t\t                      <option value=\"kortos\">\u041A\u041E\u0420\u0422\u0420\u041E\u0421</option>\n\t\t\t                      <option value=\"morton\">\u041C\u043E\u0440\u0442\u043E\u043D</option>\n\t\t\t                      <option value=\"pik\">\u041F\u0418\u041A</option>\n\t\t\t                    </select>\n\t\t\t                  </div>\n\t\t\t                  <div class=\"apart-filter-item apart-filter-select apart-filter-select_rooms\">\n\t\t\t                    <select class=\"sumo\" name=\"f[room]\" id=\"apartments-filter\">\n\t\t\t                      <option value=\"rooms-all\">1-4+ \u043A\u043E\u043C\u043D\u0430\u0442\u044B</option>\n\t\t\t                      <option value=\"1\">1 \u043A\u043E\u043C\u043D\u0430\u0442\u0430</option>\n\t\t\t                      <option value=\"2\">2 \u043A\u043E\u043C\u043D\u0430\u0442\u044B</option>\n\t\t\t                      <option value=\"3\">3 \u043A\u043E\u043C\u043D\u0430\u0442\u044B</option>\n\t\t\t                      <option value=\"4\">4 \u0438 \u0431\u043E\u043B\u0435\u0435</option>\n\t\t\t                    </select>\n\t\t\t                  </div>\n\t\t\t                  <div class=\"apart-filter-item apart-filter-price\">\n\t\t\t                    <div class=\"apart-filter-price__container\">\n\t\t\t                      <div class=\"apart-filter-price__input apart-filter-price__input_min\">\n\t\t\t                        <input class=\"input-mask-money\" name=\"price-range-from\" data-input=\"from\"/>\n\t\t\t                      </div>\n\t\t\t                      <div class=\"apart-filter-price__input apart-filter-price__input_max\">\n\t\t\t                        <input class=\"input-mask-money\" name=\"price-range-to\" data-input=\"to\"/>\n\t\t\t                      </div>\n\t\t\t                    </div>\n\t\t\t                  </div>\n\t\t\t                  <div class=\"apart-filter-item apart-filter-select apart-filter-select_sort\">\n\t\t\t                    <select class=\"sumo\" name=\"f[sort]\" id=\"apartments-filter\">\n\t\t\t                      <option value=\"price-asc\">\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u043A\u0430: \u0441\u043D\u0430\u0447\u0430\u043B\u043E \u0434\u0435\u0448\u0435\u0432\u043B\u0435</option>\n\t\t\t                      <option value=\"price-desc\">\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u043A\u0430: \u0441\u043D\u0430\u0447\u0430\u043B\u043E \u0434\u043E\u0440\u043E\u0436\u0435</option>\n\t\t\t                    </select>\n\t\t\t                  </div>\n\t\t\t                </div>\n\t\t\t              </form>\n\t\t\t            </div>\n\t\t\t      <div class=\"apartments-modal__body\">\n\t\t\t        <div class=\"apartment-card\">\n\t\t\t          <div class=\"apartment-card__main\"><a class=\"apartment-card__picture js-apartment-plan-preview\" href=\"../assets/images/plans-img-big.jpg\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/></a><a class=\"apartment-card__info\">87,6 \u043C, 3-\u043A\u043E\u043C\u043D\u0430\u0442\u043D\u0430\u044F</a><span class=\"apartment-card__floor\">17 \u044D\u0442\u0430\u0436<span class=\"apartment-card__floor-total\">\u0438\u0437 25</span></span><span class=\"apartment-card__price\">6 630 000 \u0420</span>\n\t\t\t          </div>\n\t\t\t          <div class=\"apartment-extra apartment-extra apartment-extra_hidden\">\n\t\t\t            <div class=\"apartment-extra__picture\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/>\n\t\t\t            </div>\n\t\t\t            <div class=\"apartment-info-block\">\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041F\u043B\u043E\u0449\u0430\u0434\u044C</span>88,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0416\u0438\u043B\u0430\u044F</span>40,1 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041A\u0443\u0445\u043D\u044F</span>14,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0430\u043D\u0443\u0437\u0435\u043B</span>\u0421\u043E\u0432\u043C\u0435\u0449\u0451\u043D\u043D\u044B\u0439\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0440\u043E\u043A \u0441\u0434\u0430\u0447\u0438</span>3-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B 2019-\u0433\u043E\n\t\t\t              </div>\n\t\t\t              <button class=\"apartment-info-block__button button button_yellow button button_block phone-number\" data-phone-number=\"+7 (495) 123 4567\">\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0442\u0435\u043B\u0435\u0444\u043E\u043D <span>+7 (\u0425\u0425\u0425) \u0425\u0425\u0425 \u0425\u0425-\u0425\u0425</span>\n\t\t\t              </button>\n\t\t\t            </div>\n\t\t\t          </div>\n\t\t\t        </div>\n\t\t\t        <div class=\"apartment-card\">\n\t\t\t          <div class=\"apartment-card__main\"><a class=\"apartment-card__picture js-apartment-plan-preview\" href=\"../assets/images/plans-img-big.jpg\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/></a><a class=\"apartment-card__info\">87,6 \u043C, 3-\u043A\u043E\u043C\u043D\u0430\u0442\u043D\u0430\u044F</a><span class=\"apartment-card__floor\">17 \u044D\u0442\u0430\u0436<span class=\"apartment-card__floor-total\">\u0438\u0437 25</span></span><span class=\"apartment-card__price\">6 630 000 \u0420</span>\n\t\t\t          </div>\n\t\t\t          <div class=\"apartment-extra apartment-extra apartment-extra_hidden\">\n\t\t\t            <div class=\"apartment-extra__picture\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/>\n\t\t\t            </div>\n\t\t\t            <div class=\"apartment-info-block\">\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041F\u043B\u043E\u0449\u0430\u0434\u044C</span>88,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0416\u0438\u043B\u0430\u044F</span>40,1 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041A\u0443\u0445\u043D\u044F</span>14,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0430\u043D\u0443\u0437\u0435\u043B</span>\u0421\u043E\u0432\u043C\u0435\u0449\u0451\u043D\u043D\u044B\u0439\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0440\u043E\u043A \u0441\u0434\u0430\u0447\u0438</span>3-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B 2019-\u0433\u043E\n\t\t\t              </div>\n\t\t\t              <button class=\"apartment-info-block__button button button_yellow button button_block phone-number\" data-phone-number=\"+7 (495) 123 4567\">\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0442\u0435\u043B\u0435\u0444\u043E\u043D <span>+7 (\u0425\u0425\u0425) \u0425\u0425\u0425 \u0425\u0425-\u0425\u0425</span>\n\t\t\t              </button>\n\t\t\t            </div>\n\t\t\t          </div>\n\t\t\t        </div>\n\t\t\t        <div class=\"apartment-card\">\n\t\t\t          <div class=\"apartment-card__main\"><a class=\"apartment-card__picture js-apartment-plan-preview\" href=\"../assets/images/plans-img-big.jpg\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/></a><a class=\"apartment-card__info\">87,6 \u043C, 3-\u043A\u043E\u043C\u043D\u0430\u0442\u043D\u0430\u044F</a><span class=\"apartment-card__floor\">17 \u044D\u0442\u0430\u0436<span class=\"apartment-card__floor-total\">\u0438\u0437 25</span></span><span class=\"apartment-card__price\">6 630 000 \u0420</span>\n\t\t\t          </div>\n\t\t\t          <div class=\"apartment-extra apartment-extra apartment-extra_hidden\">\n\t\t\t            <div class=\"apartment-extra__picture\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/>\n\t\t\t            </div>\n\t\t\t            <div class=\"apartment-info-block\">\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041F\u043B\u043E\u0449\u0430\u0434\u044C</span>88,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0416\u0438\u043B\u0430\u044F</span>40,1 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041A\u0443\u0445\u043D\u044F</span>14,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0430\u043D\u0443\u0437\u0435\u043B</span>\u0421\u043E\u0432\u043C\u0435\u0449\u0451\u043D\u043D\u044B\u0439\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0440\u043E\u043A \u0441\u0434\u0430\u0447\u0438</span>3-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B 2019-\u0433\u043E\n\t\t\t              </div>\n\t\t\t              <button class=\"apartment-info-block__button button button_yellow button button_block phone-number\" data-phone-number=\"+7 (495) 123 4567\">\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0442\u0435\u043B\u0435\u0444\u043E\u043D <span>+7 (\u0425\u0425\u0425) \u0425\u0425\u0425 \u0425\u0425-\u0425\u0425</span>\n\t\t\t              </button>\n\t\t\t            </div>\n\t\t\t          </div>\n\t\t\t        </div>\n\t\t\t        <div class=\"apartment-card\">\n\t\t\t          <div class=\"apartment-card__main\"><a class=\"apartment-card__picture js-apartment-plan-preview\" href=\"../assets/images/plans-img-big.jpg\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/></a><a class=\"apartment-card__info\">87,6 \u043C, 3-\u043A\u043E\u043C\u043D\u0430\u0442\u043D\u0430\u044F</a><span class=\"apartment-card__floor\">17 \u044D\u0442\u0430\u0436<span class=\"apartment-card__floor-total\">\u0438\u0437 25</span></span><span class=\"apartment-card__price\">6 630 000 \u0420</span>\n\t\t\t          </div>\n\t\t\t          <div class=\"apartment-extra apartment-extra apartment-extra_hidden\">\n\t\t\t            <div class=\"apartment-extra__picture\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/>\n\t\t\t            </div>\n\t\t\t            <div class=\"apartment-info-block\">\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041F\u043B\u043E\u0449\u0430\u0434\u044C</span>88,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0416\u0438\u043B\u0430\u044F</span>40,1 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041A\u0443\u0445\u043D\u044F</span>14,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0430\u043D\u0443\u0437\u0435\u043B</span>\u0421\u043E\u0432\u043C\u0435\u0449\u0451\u043D\u043D\u044B\u0439\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0440\u043E\u043A \u0441\u0434\u0430\u0447\u0438</span>3-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B 2019-\u0433\u043E\n\t\t\t              </div>\n\t\t\t              <button class=\"apartment-info-block__button button button_yellow button button_block phone-number\" data-phone-number=\"+7 (495) 123 4567\">\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0442\u0435\u043B\u0435\u0444\u043E\u043D <span>+7 (\u0425\u0425\u0425) \u0425\u0425\u0425 \u0425\u0425-\u0425\u0425</span>\n\t\t\t              </button>\n\t\t\t            </div>\n\t\t\t          </div>\n\t\t\t        </div>\n\t\t\t        <div class=\"apartment-card\">\n\t\t\t          <div class=\"apartment-card__main\"><a class=\"apartment-card__picture js-apartment-plan-preview\" href=\"../assets/images/plans-img-big.jpg\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/></a><a class=\"apartment-card__info\">87,6 \u043C, 3-\u043A\u043E\u043C\u043D\u0430\u0442\u043D\u0430\u044F</a><span class=\"apartment-card__floor\">17 \u044D\u0442\u0430\u0436<span class=\"apartment-card__floor-total\">\u0438\u0437 25</span></span><span class=\"apartment-card__price\">6 630 000 \u0420</span>\n\t\t\t          </div>\n\t\t\t          <div class=\"apartment-extra apartment-extra apartment-extra_hidden\">\n\t\t\t            <div class=\"apartment-extra__picture\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/>\n\t\t\t            </div>\n\t\t\t            <div class=\"apartment-info-block\">\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041F\u043B\u043E\u0449\u0430\u0434\u044C</span>88,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0416\u0438\u043B\u0430\u044F</span>40,1 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041A\u0443\u0445\u043D\u044F</span>14,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0430\u043D\u0443\u0437\u0435\u043B</span>\u0421\u043E\u0432\u043C\u0435\u0449\u0451\u043D\u043D\u044B\u0439\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0440\u043E\u043A \u0441\u0434\u0430\u0447\u0438</span>3-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B 2019-\u0433\u043E\n\t\t\t              </div>\n\t\t\t              <button class=\"apartment-info-block__button button button_yellow button button_block phone-number\" data-phone-number=\"+7 (495) 123 4567\">\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0442\u0435\u043B\u0435\u0444\u043E\u043D <span>+7 (\u0425\u0425\u0425) \u0425\u0425\u0425 \u0425\u0425-\u0425\u0425</span>\n\t\t\t              </button>\n\t\t\t            </div>\n\t\t\t          </div>\n\t\t\t        </div>\n\t\t\t        <div class=\"apartment-card\">\n\t\t\t          <div class=\"apartment-card__main\"><a class=\"apartment-card__picture js-apartment-plan-preview\" href=\"../assets/images/plans-img-big.jpg\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/></a><a class=\"apartment-card__info\">87,6 \u043C, 3-\u043A\u043E\u043C\u043D\u0430\u0442\u043D\u0430\u044F</a><span class=\"apartment-card__floor\">17 \u044D\u0442\u0430\u0436<span class=\"apartment-card__floor-total\">\u0438\u0437 25</span></span><span class=\"apartment-card__price\">6 630 000 \u0420</span>\n\t\t\t          </div>\n\t\t\t          <div class=\"apartment-extra apartment-extra apartment-extra_hidden\">\n\t\t\t            <div class=\"apartment-extra__picture\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/>\n\t\t\t            </div>\n\t\t\t            <div class=\"apartment-info-block\">\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041F\u043B\u043E\u0449\u0430\u0434\u044C</span>88,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0416\u0438\u043B\u0430\u044F</span>40,1 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041A\u0443\u0445\u043D\u044F</span>14,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0430\u043D\u0443\u0437\u0435\u043B</span>\u0421\u043E\u0432\u043C\u0435\u0449\u0451\u043D\u043D\u044B\u0439\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0440\u043E\u043A \u0441\u0434\u0430\u0447\u0438</span>3-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B 2019-\u0433\u043E\n\t\t\t              </div>\n\t\t\t              <button class=\"apartment-info-block__button button button_yellow button button_block phone-number\" data-phone-number=\"+7 (495) 123 4567\">\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0442\u0435\u043B\u0435\u0444\u043E\u043D <span>+7 (\u0425\u0425\u0425) \u0425\u0425\u0425 \u0425\u0425-\u0425\u0425</span>\n\t\t\t              </button>\n\t\t\t            </div>\n\t\t\t          </div>\n\t\t\t        </div>\n\t\t\t        <div class=\"apartment-card\">\n\t\t\t          <div class=\"apartment-card__main\"><a class=\"apartment-card__picture js-apartment-plan-preview\" href=\"../assets/images/plans-img-big.jpg\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/></a><a class=\"apartment-card__info\">87,6 \u043C, 3-\u043A\u043E\u043C\u043D\u0430\u0442\u043D\u0430\u044F</a><span class=\"apartment-card__floor\">17 \u044D\u0442\u0430\u0436<span class=\"apartment-card__floor-total\">\u0438\u0437 25</span></span><span class=\"apartment-card__price\">6 630 000 \u0420</span>\n\t\t\t          </div>\n\t\t\t          <div class=\"apartment-extra apartment-extra apartment-extra_hidden\">\n\t\t\t            <div class=\"apartment-extra__picture\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/>\n\t\t\t            </div>\n\t\t\t            <div class=\"apartment-info-block\">\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041F\u043B\u043E\u0449\u0430\u0434\u044C</span>88,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0416\u0438\u043B\u0430\u044F</span>40,1 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041A\u0443\u0445\u043D\u044F</span>14,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0430\u043D\u0443\u0437\u0435\u043B</span>\u0421\u043E\u0432\u043C\u0435\u0449\u0451\u043D\u043D\u044B\u0439\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0440\u043E\u043A \u0441\u0434\u0430\u0447\u0438</span>3-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B 2019-\u0433\u043E\n\t\t\t              </div>\n\t\t\t              <button class=\"apartment-info-block__button button button_yellow button button_block phone-number\" data-phone-number=\"+7 (495) 123 4567\">\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0442\u0435\u043B\u0435\u0444\u043E\u043D <span>+7 (\u0425\u0425\u0425) \u0425\u0425\u0425 \u0425\u0425-\u0425\u0425</span>\n\t\t\t              </button>\n\t\t\t            </div>\n\t\t\t          </div>\n\t\t\t        </div>\n\t\t\t        <div class=\"apartment-card\">\n\t\t\t          <div class=\"apartment-card__main\"><a class=\"apartment-card__picture js-apartment-plan-preview\" href=\"../assets/images/plans-img-big.jpg\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/></a><a class=\"apartment-card__info\">87,6 \u043C, 3-\u043A\u043E\u043C\u043D\u0430\u0442\u043D\u0430\u044F</a><span class=\"apartment-card__floor\">17 \u044D\u0442\u0430\u0436<span class=\"apartment-card__floor-total\">\u0438\u0437 25</span></span><span class=\"apartment-card__price\">6 630 000 \u0420</span>\n\t\t\t          </div>\n\t\t\t          <div class=\"apartment-extra apartment-extra apartment-extra_hidden\">\n\t\t\t            <div class=\"apartment-extra__picture\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/>\n\t\t\t            </div>\n\t\t\t            <div class=\"apartment-info-block\">\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041F\u043B\u043E\u0449\u0430\u0434\u044C</span>88,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0416\u0438\u043B\u0430\u044F</span>40,1 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041A\u0443\u0445\u043D\u044F</span>14,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0430\u043D\u0443\u0437\u0435\u043B</span>\u0421\u043E\u0432\u043C\u0435\u0449\u0451\u043D\u043D\u044B\u0439\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0440\u043E\u043A \u0441\u0434\u0430\u0447\u0438</span>3-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B 2019-\u0433\u043E\n\t\t\t              </div>\n\t\t\t              <button class=\"apartment-info-block__button button button_yellow button button_block phone-number\" data-phone-number=\"+7 (495) 123 4567\">\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0442\u0435\u043B\u0435\u0444\u043E\u043D <span>+7 (\u0425\u0425\u0425) \u0425\u0425\u0425 \u0425\u0425-\u0425\u0425</span>\n\t\t\t              </button>\n\t\t\t            </div>\n\t\t\t          </div>\n\t\t\t        </div>\n\t\t\t        <div class=\"apartment-card\">\n\t\t\t          <div class=\"apartment-card__main\"><a class=\"apartment-card__picture js-apartment-plan-preview\" href=\"../assets/images/plans-img-big.jpg\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/></a><a class=\"apartment-card__info\">87,6 \u043C, 3-\u043A\u043E\u043C\u043D\u0430\u0442\u043D\u0430\u044F</a><span class=\"apartment-card__floor\">17 \u044D\u0442\u0430\u0436<span class=\"apartment-card__floor-total\">\u0438\u0437 25</span></span><span class=\"apartment-card__price\">6 630 000 \u0420</span>\n\t\t\t          </div>\n\t\t\t          <div class=\"apartment-extra apartment-extra apartment-extra_hidden\">\n\t\t\t            <div class=\"apartment-extra__picture\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/>\n\t\t\t            </div>\n\t\t\t            <div class=\"apartment-info-block\">\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041F\u043B\u043E\u0449\u0430\u0434\u044C</span>88,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0416\u0438\u043B\u0430\u044F</span>40,1 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041A\u0443\u0445\u043D\u044F</span>14,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0430\u043D\u0443\u0437\u0435\u043B</span>\u0421\u043E\u0432\u043C\u0435\u0449\u0451\u043D\u043D\u044B\u0439\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0440\u043E\u043A \u0441\u0434\u0430\u0447\u0438</span>3-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B 2019-\u0433\u043E\n\t\t\t              </div>\n\t\t\t              <button class=\"apartment-info-block__button button button_yellow button button_block phone-number\" data-phone-number=\"+7 (495) 123 4567\">\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0442\u0435\u043B\u0435\u0444\u043E\u043D <span>+7 (\u0425\u0425\u0425) \u0425\u0425\u0425 \u0425\u0425-\u0425\u0425</span>\n\t\t\t              </button>\n\t\t\t            </div>\n\t\t\t          </div>\n\t\t\t        </div>\n\t\t\t        <div class=\"apartment-card\">\n\t\t\t          <div class=\"apartment-card__main\"><a class=\"apartment-card__picture js-apartment-plan-preview\" href=\"../assets/images/plans-img-big.jpg\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/></a><a class=\"apartment-card__info\">87,6 \u043C, 3-\u043A\u043E\u043C\u043D\u0430\u0442\u043D\u0430\u044F</a><span class=\"apartment-card__floor\">17 \u044D\u0442\u0430\u0436<span class=\"apartment-card__floor-total\">\u0438\u0437 25</span></span><span class=\"apartment-card__price\">6 630 000 \u0420</span>\n\t\t\t          </div>\n\t\t\t          <div class=\"apartment-extra apartment-extra apartment-extra_hidden\">\n\t\t\t            <div class=\"apartment-extra__picture\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/>\n\t\t\t            </div>\n\t\t\t            <div class=\"apartment-info-block\">\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041F\u043B\u043E\u0449\u0430\u0434\u044C</span>88,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0416\u0438\u043B\u0430\u044F</span>40,1 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041A\u0443\u0445\u043D\u044F</span>14,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0430\u043D\u0443\u0437\u0435\u043B</span>\u0421\u043E\u0432\u043C\u0435\u0449\u0451\u043D\u043D\u044B\u0439\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0440\u043E\u043A \u0441\u0434\u0430\u0447\u0438</span>3-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B 2019-\u0433\u043E\n\t\t\t              </div>\n\t\t\t              <button class=\"apartment-info-block__button button button_yellow button button_block phone-number\" data-phone-number=\"+7 (495) 123 4567\">\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0442\u0435\u043B\u0435\u0444\u043E\u043D <span>+7 (\u0425\u0425\u0425) \u0425\u0425\u0425 \u0425\u0425-\u0425\u0425</span>\n\t\t\t              </button>\n\t\t\t            </div>\n\t\t\t          </div>\n\t\t\t        </div>\n\t\t\t      </div>\n\t\t\t      <div class=\"apartments-modal__load-more\">\n\t\t\t        <button class=\"button button_yellow button_block\" data-action-url=\"apartments-load-more\">\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0435\u0449\u0451 10</button>\n\t\t\t      </div>\n\t\t\t    </div>";

				var dummyLoadMoreHtml = '';

				for (var i = 0; i < 9; i++) {
					dummyLoadMoreHtml += "<div class=\"apartment-card\">\n\t\t\t          <div class=\"apartment-card__main\">\n\t\t\t            <div class=\"apartment-card__picture\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/>\n\t\t\t            </div><a class=\"apartment-card__info\">87,6 \u043C, 3-\u043A\u043E\u043C\u043D\u0430\u0442\u043D\u0430\u044F</a><span class=\"apartment-card__floor\">17 \u044D\u0442\u0430\u0436<span class=\"apartment-card__floor-total\">\u0438\u0437 25</span></span><span class=\"apartment-card__price\">6 630 000 \u0420</span>\n\t\t\t          </div>\n\t\t\t          <div class=\"apartment-extra apartment-extra apartment-extra_hidden\">\n\t\t\t            <div class=\"apartment-extra__picture\"><img src=\"../assets/images/plans-img2.jpg\" alt=\"\"/>\n\t\t\t            </div>\n\t\t\t            <div class=\"apartment-info-block\">\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041F\u043B\u043E\u0449\u0430\u0434\u044C</span>88,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0416\u0438\u043B\u0430\u044F</span>40,1 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u041A\u0443\u0445\u043D\u044F</span>14,4 \u043C\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0430\u043D\u0443\u0437\u0435\u043B</span>\u0421\u043E\u0432\u043C\u0435\u0449\u0451\u043D\u043D\u044B\u0439\n\t\t\t              </div>\n\t\t\t              <div class=\"apartment-info-block__point\"><span>\u0421\u0440\u043E\u043A \u0441\u0434\u0430\u0447\u0438</span>3-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B 2019-\u0433\u043E\n\t\t\t              </div>\n\t\t\t              <button class=\"apartment-info-block__button button button_yellow button button_block phone-number\" data-phone-number=\"+7 (495) 123 4567\">\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0442\u0435\u043B\u0435\u0444\u043E\u043D <span>+7 (\u0425\u0425\u0425) \u0425\u0425\u0425 \u0425\u0425-\u0425\u0425</span>\n\t\t\t              </button>\n\t\t\t            </div>\n\t\t\t          </div>\n\t\t\t        </div>";
				}
			})(window);
		};
		if ($('#map-block').length) {

			//clusters on big map
			window.bigMap = undefined;
			window.bigObjectManager = undefined;

			var imageHref = imageLink + 'maps-baloon.png';
			var imageHrefHover = imageLink + 'maps-baloon-hover.png';

			var clusterHref = imageLink + 'baloon-cluster.png';
			var clusterHrefHover = imageLink + 'baloon-cluster-hover.png';
			var clusterBigHref = imageLink + 'baloon-cluster-big.png';
			var clusterBigHrefHover = imageLink + 'baloon-cluster-big-hover.png';

			window.initBigMap = function () {
				var $mapWrap = $('.search-list'),
				    $mapObjects = $mapWrap;

				var city_location = [50, 50];
				var collection = {
					type: 'FeatureCollection',
					features: []
				};

				if (typeof bigMap == 'undefined') {
					window.bigMap = new ymaps.Map('map-block', {
						center: city_location,
						zoom: 15,
						controls: ['zoomControl']
					}, {
						maxZoom: 17,
						minZoom: 3
					});
				} else {
					bigObjectManager.removeAll();
				}

				balloonContentLayout = ymaps.templateLayoutFactory.createClass(['<div class="complex-close"><i class="fa fa-times"></i></div>', '<div class="complex complex_map" data-id="{{properties.myObject.id}}" target="_blank">', '{% if properties.myObject.recommended || properties.myObject.mortgage || properties.myObject.installment %}', '<div class="complex__info-labels">', '{% if properties.myObject.recommended %}', '<div class="complex__info-label complex__info-label_recommended" data-style="recommended" title="{{ properties.myObject.recommended }}">', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 90"><defs><style>.like-cls-1 {fill: #fff;}</style></defs><path class="like-cls-1" d="M58.24,31.81c-.66-1.78,17.7-18.17,7-31.46-2.51-3.11-11,14.87-23.08,23C35.49,27.87,20,37.43,20,42.71v34.2C20,83.27,44.57,90,63.25,90,70.08,90,80,47.12,80,40.31S58.9,33.59,58.24,31.81ZM15,32.29c-3.29,0-15,2-15,15.61V72.14C0,85.75,11.71,87.25,15,87.25S10,84.38,10,76V44.09C10,35.24,18.29,32.29,15,32.29Z"/></svg>', '</div>', '{% endif %}', '{% if properties.myObject.mortgage %}', '<div class="complex__info-label complex__info-label_mortgage" data-style="mortgage" title="{{ properties.myObject.mortgage }}">', '<svg xmlns="http://www.w3.org/2000/svg" width="17" height="18" viewBox="0 0 17 18"><path fill="#fff" d="M14.94 9.17L8.99 3.2 3.03 9.17v5.87a1 1 0 0 0 1 1h5.13c.4 1.1 1.97 1.94 3.87 1.94 2.19 0 3.96-1.12 3.96-2.49 0-.35-.12-.69-.33-1 .21-.3.33-.63.33-.99 0-.35-.12-.69-.33-1 .21-.3.33-.63.33-.99 0-.93-.83-1.74-2.05-2.16zm-1.91 7.81c-1.27 0-2.3-.44-2.74-.95a.85.85 0 0 1-.24-.54c0-.1.03-.2.08-.3.72.49 1.75.8 2.9.8.55 0 1.08-.08 1.56-.2.5-.15.96-.35 1.33-.6.05.1.08.2.08.3 0 .7-1.27 1.5-2.97 1.5zm2.9-3.18c-.13.25-.38.5-.75.7l-.24.1c-.51.24-1.16.4-1.91.4-.87 0-1.62-.21-2.15-.5-.37-.2-.63-.45-.75-.7a.7.7 0 0 1-.08-.3c0-.1.03-.2.08-.3a5.62 5.62 0 0 0 2.9.8 5.77 5.77 0 0 0 2.9-.8c.04.1.07.2.07.3 0 .1-.03.2-.08.3zm0-1.98c-.13.24-.38.49-.75.69l-.24.1c-.51.24-1.16.4-1.91.4-.87 0-1.62-.2-2.15-.5-.37-.2-.63-.45-.75-.7a.7.7 0 0 1-.08-.3c0-.7 1.27-1.49 2.98-1.49.74 0 1.4.16 1.91.4.65.28 1.06.7 1.06 1.1 0 .1-.03.2-.08.3zm.77-4.44L9.7.35a1 1 0 0 0-1.4 0L1.27 7.38c-.2.2-.3.45-.3.7l1.07.96L9 2.1l6.94 6.95L17 8.08c0-.25-.1-.5-.3-.7z"/></svg>', '</div>', '{% endif %}', '{% if properties.myObject.installment %}', '<div class="complex__info-label complex__info-label_installment" data-style="installment" title="{{ properties.myObject.installment }}">', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 92 92"><defs><style>.clock-cls-1 {fill: #fff;}</style></defs><g><path class="clock-cls-1" d="M46,0A46,46,0,1,0,92,46,46,46,0,0,0,46,0Zm0,82A36,36,0,1,1,82,46,36,36,0,0,1,46,82Z"/><polygon class="clock-cls-1" points="49.5 20 42.5 20 42.5 47.45 59.52 64.47 64.47 59.53 49.5 44.55 49.5 20"/></g></svg>', '</div>', '{% endif %}', '{% if properties.myObject.action %}', '<div class="complex__info-label complex__info-label_action" data-style="action" title="{{ properties.myObject.action }}">', '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="13" viewBox="0 0 12 13"><path fill="#fff" d="M.01 3.41c0-.72.26-1.3.78-1.74A3 3 0 0 1 2.82 1c.85 0 1.53.22 2.04.66.52.44.78 1.04.78 1.79v.58c0 .72-.26 1.3-.78 1.73-.51.44-1.19.66-2.02.66-.85 0-1.53-.22-2.05-.66a2.22 2.22 0 0 1-.78-1.78zm1.71.63c0 .32.1.58.3.77.21.2.48.3.82.3.33 0 .6-.1.79-.3.2-.2.3-.47.3-.8v-.6c0-.32-.1-.58-.3-.78-.2-.2-.47-.3-.81-.3-.33 0-.6.1-.8.3-.2.2-.3.47-.3.82zm4.63 6.93c0-.72.26-2.3.79-2.74.52-.44 1.2-.66 2.02-.66.85 0 1.53.21 2.05.65.52.43.78 1.03.78 1.8v.57c0 .72-.26 1.3-.77 1.74a3 3 0 0 1-2.04.66c-.85 0-1.54-.22-2.05-.67-.52-.44-.78-.03-.78-.76zm1.71-.37c0 .3.1.55.32.76.22.21.48.31.8.31.73 0 1.09-.36 1.09-1.08v-.61c0-.33-.1-.59-.3-.78-.2-.2-.47-.3-.8-.3-.34 0-.6.1-.8.3-.2.2-.3.46-.3.8zm2.68-8.76l-1.25-.6-8.33 11.1 1.25.62z"/></svg>', '</div>', '{% endif %}', '</div>', '{% endif %}', '{% if properties.myObject.recommendation %}', '<div class="complex__recommendation"></div>', '{% endif %}', '<a href="{{ properties.myObject.url }}" target="_blank" class="complex__media">', '<div class="complex__slider">', '{% for image in properties.myObject.image %}', '<div class="complex__slide">', '<div class="complex__image">', '<img src="{{ image }}" alt=""/>', '</div>', '</div>', '{% endfor %}', '</div>', '<div class="complex__rating"><span>{{ properties.myObject.rating }}</span></div>', '</a>', '<div class="complex__body">', '{% if properties.myObject.favorites %}', '<div class="complex__favorite" data-id="{{ properties.myObject.id }}"><i class="fa fa-heart"></i></div>', '{% endif %}', '<a href="{{ properties.myObject.url }}" target="_blank" class="complex__header complex__header_big">{{ properties.myObject.title }}</a>', '<div class="complex__price">{{ properties.myObject.price }}</div>', '<div class="complex__text complex__text_small"> {{properties.myObject.info }} </div>', '</div>', '{% if properties.myObject.description %}', '<div class="round-overlay">', '<div class="round-overlay__background"></div>', '<div class="round-overlay__wrapper">', '<div class="round-overlay__content">', '<div class="round-overlay__header">{{ properties.myObject.title }}</div>', '<div class="round-overlay__text">{{properties.myObject.description }}</div>', '</div>', '<a class="round-overlay__link" href="{{ properties.myObject.url }}"></a>', '</div>', '<div class="round-overlay__buttons">', '<div class="round-overlay__button-info">', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 27 27.1">', '<path d="M16.2 17.6c0 .3-.2.5-.5.5h-4c-.3 0-.5-.2-.5-.5v-1c0-.3.2-.5.5-.5h.5v-3h-.5c-.3 0-.5-.2-.5-.5v-1c0-.3.2-.5.5-.5h3c.3 0 .5.2.5.5v4.5h.5c.3 0 .5.2.5.5v1zm-1-8.5c0 .3-.2.5-.5.5h-2c-.3 0-.5-.2-.5-.5V7.6c0-.3.2-.5.5-.5h2c.3 0 .5.2.5.5v1.5z" fill="#bdbaba" />', '<path d="M13.5 27C6.1 27 0 20.9 0 13.5S6.1 0 13.5 0 27 6.1 27 13.5 20.9 27 13.5 27zm0-25C7.2 2 2 7.2 2 13.5S7.2 25 13.5 25 25 19.8 25 13.5 19.8 2 13.5 2z" fill="#d9d9d9" />', '</svg>', '</div>', '<div class="round-overlay__button-close round-overlay__button-close_hidden"></div>', '<div class="round-overlay__tooltip">  </div>', '</div>', '</div>', '{% endif %}', '</div>'].join(''), {
					build: function build() {
						balloonContentLayout.superclass.build.call(this);
						$('.complex_map .complex__favorite').on('click', function (e) {
							e.preventDefault();

							favoriteAction($(this));
							findFavorites();
						});
						findFavorites();

						$('.complex-close').on('click', function (e) {
							e.preventDefault();
							bigMap.balloon.close();
						});

						$('.complex_map .complex__text').html($('.complex_map .complex__text').text());

						$('.complex_map .round-overlay__button-info').on('click', function () {
							showOverlay($(this));
						});

						$('.complex_map .round-overlay__button-close').on('click', function () {
							hideOverlay($(this));
						});

						// console.log($('.complex_map'))

						$('.complex_map .complex__slider').slick({
							slidesToShow: 1,
							swipe: false,
							prevArrow: '<button type="button" data-role="none" class="slick-arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
							nextArrow: '<button type="button" data-role="none" class="slick-arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>',
							lazyLoad: 'ondemand'
						});

						$('.complex_map .slick-arrow').on('click', function (e) {
							return e.preventDefault();
						});

						setTimeout(function () {
							$('.complex_map .complex__slider').slick('setPosition');
						}, 1);
					},
					onCounterClick: function onCounterClick() {
						// console.log('here')
					}
				});

				clusterContentLayout = ymaps.templateLayoutFactory.createClass('<div style="color: #FFFFFF; font-weight: bold;">$[properties.geoObjects.length]</div>');

				if (typeof bigObjectManager == 'undefined') {
					bigObjectManager = new ymaps.ObjectManager({
						clusterize: true,
						gridSize: 16,
						viewportMargin: 0
					});

					bigObjectManager.objects.options.set({
						// balloonLayout: balloonContentLayout,
						balloonContentLayout: balloonContentLayout,
						balloonPanelMaxMapArea: 0,
						balloonMaxWidth: 300,
						balloonMinWidth: 300,
						balloonMaxHeight: 467,
						balloonMinHeight: 467,
						balloonCloseButton: false
					});

					bigObjectManager.clusters.options.set({
						preset: 'islands#yellowClusterIcons',
						clusterIcons: [{
							href: clusterHref,
							color: '#fff',
							size: [40, 40],
							offset: [-20, -20]
						}, {
							href: clusterBigHref,
							color: '#fff',
							size: [60, 60],
							offset: [-30, -30]
						}],
						clusterNumbers: 500,
						clusterIconContentLayout: clusterContentLayout
					});
				} else {

					bigObjectManager.objects.options.set({
						// balloonLayout: balloonContentLayout,
						balloonContentLayout: balloonContentLayout,
						balloonPanelMaxMapArea: 0,
						balloonMaxWidth: 300,
						balloonMinWidth: 300,
						balloonMaxHeight: 467,
						balloonMinHeight: 467,
						balloonCloseButton: false
					});

					bigObjectManager.clusters.options.set({
						preset: 'islands#yellowClusterIcons',
						clusterIcons: [{
							href: clusterHref,
							color: '#fff',
							size: [40, 40],
							offset: [-20, -20]
						}, {
							href: clusterBigHref,
							color: '#fff',
							size: [60, 60],
							offset: [-30, -30]
						}],
						clusterNumbers: 500,
						clusterIconContentLayout: clusterContentLayout
					});
				}

				$mapObjects.find('.search-list__item .complex').each(function (i) {
					var $this = $(this);
					// console.log($this)
					if ($this.data('location')) {

						var objectImages = [];

						$this.find('.complex__media img').each(function (i, element) {
							if ($(element).attr('src')) {
								objectImages.push($(element).attr('src'));
							} else if ($(element).attr('data-lazy')) {
								objectImages.push($(element).attr('data-lazy'));
							}
						});

						// console.log($this.data('id'))
						var mapItemInfo;
						var complexHtml;

						for (var i = 0; i < $this.find('.complex__text').length; i++) {

							if ($($this.find('.complex__text')[i]).find('p').length != 0) {
								complexHtml = $($this.find('.complex__text')[i]).html();
							} else {
								complexHtml = ['<p>', $($this.find('.complex__text')[i]).html(), '</p>'].join('');
							}

							mapItemInfo ? mapItemInfo += complexHtml : mapItemInfo = complexHtml;
						}

						// $this.find('.complex__text').forEach(function(item, i, arr) {
						//  	console.log( i + ": " + item + " (:" + arr + ")" );
						// });

						collection.features.push({
							type: 'Feature',
							id: $this.data('id'),
							geometry: {
								type: 'Point',
								coordinates: $this.data('location')
							},
							properties: {
								balloonContentHeader: $this.find('.complex__header').text(),
								myObject: {
									title: $this.find('.complex__header').text(),
									price: $this.find('.complex__price').text(),
									info: mapItemInfo,
									image: objectImages,
									url: $this.find('.complex__header').attr('href'),
									id: $this.data('id'),
									rating: $this.find('.complex__rating').text(),
									recommendation: $this.find('.complex__recommendation').text(),
									description: $this.find('.round-overlay__text').html(),
									favorites: true
								}
							},
							options: {
								iconLayout: 'default#image',
								iconImageHref: imageHref
							}
						});
					}
				}).on('mouseenter', function () {
					var $this = $(this),
					    id = $this.data('id');

					var oSt = bigObjectManager.getObjectState(id);

					if (oSt.isClustered) {
						bigObjectManager.clusters.setClusterOptions(oSt.cluster.id, {
							preset: 'islands#yellowClusterIcons',
							clusterIcons: [{
								href: clusterHrefHover,
								color: '#fff',
								size: [40, 40],
								offset: [-20, -20]
							}, {
								href: clusterBigHrefHover,
								color: '#fff',
								size: [60, 60],
								offset: [-30, -30]
							}],
							clusterNumbers: 500,
							clusterIconContentLayout: clusterContentLayout
						});
					} else {
						bigObjectManager.objects.setObjectOptions(id, {
							iconLayout: 'default#image',
							iconImageHref: imageHrefHover
						});
					}
				}).on('mouseleave', function () {
					var $this = $(this),
					    id = $this.data('id');

					var oSt = bigObjectManager.getObjectState(id);

					if (oSt.isClustered) {
						bigObjectManager.clusters.setClusterOptions(oSt.cluster.id, {
							preset: 'islands#yellowClusterIcons',
							clusterIcons: [{
								href: clusterHref,
								color: '#fff',
								size: [40, 40],
								offset: [-20, -20]
							}, {
								href: clusterBigHref,
								color: '#fff',
								size: [60, 60],
								offset: [-30, -30]
							}],
							clusterNumbers: 500,
							clusterIconContentLayout: clusterContentLayout
						});
					} else {
						bigObjectManager.objects.setObjectOptions(id, {
							iconLayout: 'default#image',
							iconImageHref: imageHref
						});
					}
				});

				function onObjectEvent(e) {
					var objectId = e.get('objectId');
					if (e.get('type') == 'mouseenter') {
						bigObjectManager.objects.setObjectOptions(objectId, {
							iconLayout: 'default#image',
							iconImageHref: imageHrefHover
						});
					} else {
						bigObjectManager.objects.setObjectOptions(objectId, {
							iconLayout: 'default#image',
							iconImageHref: imageHref
						});
					}
				}

				function onClusterEvent(e) {
					var objectId = e.get('objectId');
					if (e.get('type') == 'mouseenter') {
						bigObjectManager.clusters.setClusterOptions(objectId, {
							preset: 'islands#yellowClusterIcons',
							clusterIcons: [{
								href: clusterHrefHover,
								color: '#fff',
								size: [40, 40],
								offset: [-20, -20]
							}, {
								href: clusterBigHrefHover,
								color: '#fff',
								size: [60, 60],
								offset: [-30, -30]
							}],
							clusterNumbers: 500,
							clusterIconContentLayout: clusterContentLayout
						});
					} else {
						bigObjectManager.clusters.setClusterOptions(objectId, {
							preset: 'islands#yellowClusterIcons',
							clusterIcons: [{
								href: clusterHref,
								color: '#fff',
								size: [40, 40],
								offset: [-20, -20]
							}, {
								href: clusterBigHref,
								color: '#fff',
								size: [60, 60],
								offset: [-30, -30]
							}],
							clusterNumbers: 500,
							clusterIconContentLayout: clusterContentLayout
						});
					}
				}

				bigObjectManager.objects.events.add(['mouseenter', 'mouseleave'], onObjectEvent);
				bigObjectManager.clusters.events.add(['mouseenter', 'mouseleave'], onClusterEvent);

				if (collection.features.length) {

					bigObjectManager.add(collection);
					// console.log('add collection')
					// console.log(collection)
					bigMap.geoObjects.add(bigObjectManager);
					// console.log('add manager')
					bigMap.setBounds(bigMap.geoObjects.getBounds(), {
						checkZoomRange: true,
						zoomMargin: 15
					});
				}

				bigMap.events.add('click', function (e) {
					bigMap.balloon.close();
				});
			};
		};
		if ($('.map-search-wrapper').length) {
			var setMapHeight = function setMapHeight() {
				mapSearchFilter = $('.filter');
				mapSearchContainer.height($(window).height() - mapSearchFilter.outerHeight());
			};

			var renderMap = function renderMap(params, callback) {
				var defaultParams = {
					// center: [55.75494, 37.62062],
					// zoom: 7,
					controls: ['searchControl', 'zoomControl', 'typeSelector', 'fullscreenControl'],
					geo: ''
				},
				    defaultOpts = {
					suppressMapOpenBlock: true
				};
				params = $.extend(defaultParams, params);

				if ($.isFunction(callback)) onMapInit(callback);

				ymaps.ready(function () {

					clusterContentLayout = ymaps.templateLayoutFactory.createClass('<div style="color: #FFFFFF; font-weight: bold;">$[properties.geoObjects.length]</div>');

					balloonContentLayout = ymaps.templateLayoutFactory.createClass(['<div class="complex-close"><i class="fa fa-times"></i></div>', '<div class="complex complex_map" data-id="{{properties.myObject.id}}" target="_blank">', '{% if properties.myObject.recommended || properties.myObject.mortgage || properties.myObject.installment %}', '<div class="complex__info-labels">', '{% if properties.myObject.recommended %}', '<div class="complex__info-label complex__info-label_recommended" data-style="recommended" title="{{ properties.myObject.recommended }}">', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 90"><defs><style>.like-cls-1 {fill: #fff;}</style></defs><path class="like-cls-1" d="M58.24,31.81c-.66-1.78,17.7-18.17,7-31.46-2.51-3.11-11,14.87-23.08,23C35.49,27.87,20,37.43,20,42.71v34.2C20,83.27,44.57,90,63.25,90,70.08,90,80,47.12,80,40.31S58.9,33.59,58.24,31.81ZM15,32.29c-3.29,0-15,2-15,15.61V72.14C0,85.75,11.71,87.25,15,87.25S10,84.38,10,76V44.09C10,35.24,18.29,32.29,15,32.29Z"/></svg>', '</div>', '{% endif %}', '{% if properties.myObject.mortgage %}', '<div class="complex__info-label complex__info-label_mortgage" data-style="mortgage" title="{{ properties.myObject.mortgage }}">', '<svg xmlns="http://www.w3.org/2000/svg" width="17" height="18" viewBox="0 0 17 18"><path fill="#fff" d="M14.94 9.17L8.99 3.2 3.03 9.17v5.87a1 1 0 0 0 1 1h5.13c.4 1.1 1.97 1.94 3.87 1.94 2.19 0 3.96-1.12 3.96-2.49 0-.35-.12-.69-.33-1 .21-.3.33-.63.33-.99 0-.35-.12-.69-.33-1 .21-.3.33-.63.33-.99 0-.93-.83-1.74-2.05-2.16zm-1.91 7.81c-1.27 0-2.3-.44-2.74-.95a.85.85 0 0 1-.24-.54c0-.1.03-.2.08-.3.72.49 1.75.8 2.9.8.55 0 1.08-.08 1.56-.2.5-.15.96-.35 1.33-.6.05.1.08.2.08.3 0 .7-1.27 1.5-2.97 1.5zm2.9-3.18c-.13.25-.38.5-.75.7l-.24.1c-.51.24-1.16.4-1.91.4-.87 0-1.62-.21-2.15-.5-.37-.2-.63-.45-.75-.7a.7.7 0 0 1-.08-.3c0-.1.03-.2.08-.3a5.62 5.62 0 0 0 2.9.8 5.77 5.77 0 0 0 2.9-.8c.04.1.07.2.07.3 0 .1-.03.2-.08.3zm0-1.98c-.13.24-.38.49-.75.69l-.24.1c-.51.24-1.16.4-1.91.4-.87 0-1.62-.2-2.15-.5-.37-.2-.63-.45-.75-.7a.7.7 0 0 1-.08-.3c0-.7 1.27-1.49 2.98-1.49.74 0 1.4.16 1.91.4.65.28 1.06.7 1.06 1.1 0 .1-.03.2-.08.3zm.77-4.44L9.7.35a1 1 0 0 0-1.4 0L1.27 7.38c-.2.2-.3.45-.3.7l1.07.96L9 2.1l6.94 6.95L17 8.08c0-.25-.1-.5-.3-.7z"/></svg>', '</div>', '{% endif %}', '{% if properties.myObject.installment %}', '<div class="complex__info-label complex__info-label_installment" data-style="installment" title="{{ properties.myObject.installment }}">', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 92 92"><defs><style>.clock-cls-1 {fill: #fff;}</style></defs><g><path class="clock-cls-1" d="M46,0A46,46,0,1,0,92,46,46,46,0,0,0,46,0Zm0,82A36,36,0,1,1,82,46,36,36,0,0,1,46,82Z"/><polygon class="clock-cls-1" points="49.5 20 42.5 20 42.5 47.45 59.52 64.47 64.47 59.53 49.5 44.55 49.5 20"/></g></svg>', '</div>', '{% endif %}', '{% if properties.myObject.action %}', '<div class="complex__info-label complex__info-label_action" data-style="action" title="{{ properties.myObject.action }}">', '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="13" viewBox="0 0 12 13"><path fill="#fff" d="M.01 3.41c0-.72.26-1.3.78-1.74A3 3 0 0 1 2.82 1c.85 0 1.53.22 2.04.66.52.44.78 1.04.78 1.79v.58c0 .72-.26 1.3-.78 1.73-.51.44-1.19.66-2.02.66-.85 0-1.53-.22-2.05-.66a2.22 2.22 0 0 1-.78-1.78zm1.71.63c0 .32.1.58.3.77.21.2.48.3.82.3.33 0 .6-.1.79-.3.2-.2.3-.47.3-.8v-.6c0-.32-.1-.58-.3-.78-.2-.2-.47-.3-.81-.3-.33 0-.6.1-.8.3-.2.2-.3.47-.3.82zm4.63 6.93c0-.72.26-2.3.79-2.74.52-.44 1.2-.66 2.02-.66.85 0 1.53.21 2.05.65.52.43.78 1.03.78 1.8v.57c0 .72-.26 1.3-.77 1.74a3 3 0 0 1-2.04.66c-.85 0-1.54-.22-2.05-.67-.52-.44-.78-.03-.78-.76zm1.71-.37c0 .3.1.55.32.76.22.21.48.31.8.31.73 0 1.09-.36 1.09-1.08v-.61c0-.33-.1-.59-.3-.78-.2-.2-.47-.3-.8-.3-.34 0-.6.1-.8.3-.2.2-.3.46-.3.8zm2.68-8.76l-1.25-.6-8.33 11.1 1.25.62z"/></svg>', '</div>', '{% endif %}', '</div>', '{% endif %}', '{% if properties.myObject.recommendation %}', '<div class="complex__recommendation"></div>', '{% endif %}', '<a href="{{ properties.myObject.url }}" target="_blank" class="complex__media">', '<div class="complex__slider">', '{% for image in properties.myObject.image %}', '<div class="complex__slide">', '<div class="complex__image">', '<img src="{{ image }}" alt=""/>', '</div>', '</div>', '{% endfor %}', '</div>', '<div class="complex__rating"><span>{{ properties.myObject.rating }}</span></div>', '</a>', '<div class="complex__body">', '<div class="complex__favorite" data-id="{{ properties.myObject.id }}"><i class="fa fa-heart"></i></div>', '<a href="{{ properties.myObject.url }}" target="_blank" class="complex__header complex__header_big">{{ properties.myObject.title }}</a>', '<div class="complex__price">{{ properties.myObject.price }}</div>', '<div class="complex__price-m">{{ properties.myObject.priceM }}</div>', '<div class="complex__text complex__text_small"> {{properties.myObject.info }} </div>', '</div>', '{% if properties.myObject.description %}', '<div class="round-overlay">', '<div class="round-overlay__background"></div>', '<div class="round-overlay__wrapper">', '<div class="round-overlay__content">', '<div class="round-overlay__header">{{ properties.myObject.title }}</div>', '<div class="round-overlay__text">{{properties.myObject.description }}</div>', '</div>', '<a class="round-overlay__link" href="{{ properties.myObject.url }}"></a>', '</div>', '<div class="round-overlay__buttons">', '<div class="round-overlay__button-info">', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 27 27.1">', '<path d="M16.2 17.6c0 .3-.2.5-.5.5h-4c-.3 0-.5-.2-.5-.5v-1c0-.3.2-.5.5-.5h.5v-3h-.5c-.3 0-.5-.2-.5-.5v-1c0-.3.2-.5.5-.5h3c.3 0 .5.2.5.5v4.5h.5c.3 0 .5.2.5.5v1zm-1-8.5c0 .3-.2.5-.5.5h-2c-.3 0-.5-.2-.5-.5V7.6c0-.3.2-.5.5-.5h2c.3 0 .5.2.5.5v1.5z" fill="#bdbaba" />', '<path d="M13.5 27C6.1 27 0 20.9 0 13.5S6.1 0 13.5 0 27 6.1 27 13.5 20.9 27 13.5 27zm0-25C7.2 2 2 7.2 2 13.5S7.2 25 13.5 25 25 19.8 25 13.5 19.8 2 13.5 2z" fill="#d9d9d9" />', '</svg>', '</div>', '<div class="round-overlay__button-close round-overlay__button-close_hidden"></div>', '<div class="round-overlay__tooltip">  </div>', '</div>', '</div>', '{% endif %}', '</div>'].join(''), {
						build: function build() {
							balloonContentLayout.superclass.build.call(this);
							$('.complex_map .complex__favorite').on('click', function (e) {
								e.preventDefault();

								favoriteAction($(this));
								findFavorites();
							});
							findFavorites();

							$('.complex-close').on('click', function (e) {
								e.preventDefault();
								map.balloon.close();
							});

							$('.complex_map .complex__text').html($('.complex_map .complex__text').text());

							$('.complex_map .round-overlay__button-info').on('click', function () {
								showOverlay($(this));
							});

							$('.complex_map .round-overlay__button-close').on('click', function () {
								hideOverlay($(this));
							});

							// console.log($('.complex_map'))
							$('.complex_map .complex__slider').slick({
								slidesToShow: 1,
								swipe: false,
								prevArrow: '<button type="button" data-role="none" class="slick-arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
								nextArrow: '<button type="button" data-role="none" class="slick-arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>',
								lazyLoad: 'ondemand'
							});

							$('.complex_map .slick-arrow').on('click', function (e) {
								return e.preventDefault();
							});

							setTimeout(function () {
								$('.complex_map .complex__slider').slick('setPosition');
							}, 1);
						},
						onCounterClick: function onCounterClick() {
							// console.log('here')
						}
					});

					var afterInit = function afterInit() {
						ymaps.modules.require(['PieChartClusterer'], function (PieChartClusterer) {
							clusterer = new PieChartClusterer();
							clusterer.createCluster = function (center, geoObjects) {
								var cluster = PieChartClusterer.prototype.createCluster.call(this, center, geoObjects);
								cluster.events.add('click', function () {
									if (map.getZoom() === map.zoomRange.getCurrent()[1]) {
										$.each(cluster.getGeoObjects(), function (k, v) {
											getLotInfo(v);
										});
									}
								});
								return cluster;
							};
							map.geoObjects.add(clusterer);
							searchInitFlg = true;
						});
					};

					if (!!params.geo) {
						ymaps.geocode(params.geo).then(function (res) {
							geoCoord = res.geoObjects.get(0).geometry.getCoordinates();
							mapSearchContainer.empty();
							params.center = geoCoord;

							map = new ymaps.Map(mapSearchContainer[0], params, defaultOpts);
							afterInit();
						});
					} else {
						mapSearchContainer.empty();
						map = new ymaps.Map(mapSearchContainer[0], params, defaultOpts);
						afterInit();
					}
				});
			};

			var getLotInfo = function getLotInfo(o) {
				// console.log('getLotInfo')
				if (!!o.properties.get('ballonGetted')) return;

				var id = o.properties.get('objId');

				$.get(searchAjaxUrlItem, { id: id }, function (data) {

					o.options.set({
						ballonGetted: true,
						balloonContentLayout: balloonContentLayout,
						balloonPanelMaxMapArea: 0,
						balloonMaxWidth: 300,
						balloonMinWidth: 300,
						balloonMaxHeight: 467,
						balloonMinHeight: 467,
						balloonCloseButton: false
					});

					o.properties.set({
						myObject: {
							title: data.name,
							price: data.price,
							priceM: data.priceM,
							info: data.text,
							image: data.image,
							url: data.link,
							id: data.id,
							rating: data.rating,
							recommendation: data.recommendation,
							description: data.description
						}
					});

					if (!clusterer.getObjectState(o).isClustered) o.balloon.open();
				}, 'json');
			};

			/**
    * When map was loaded
    */


			var onMapInit = function onMapInit(func) {
				if (!searchInitFlg) setTimeout(function () {
					onMapInit(func);
				}, 500);else func();
			};

			/**
    * When all objects was loaded
    */


			var onMapLoad = function onMapLoad(func) {
				if (searchLoadFlg) setTimeout(function () {
					onMapLoad(func);
				}, 500);else func();
			};

			var addToCluster = function addToCluster(objs, setCenter, popstate) {
				var adds = [];

				if (setCenter) {
					clearMap();
				}

				for (var i in objs) {
					var o,
					    v = objs[i],
					    id = v['id'].toString();
					icn = customIcon;

					if (!!placeMarks[id]) continue;

					if (v.hasOwnProperty('text')) {
						// if((parseFloat(v['location'][0][0][0] != 0) && (parseFloat(v['location'][0][0][0] != 0)){

						// }
						o = new ymaps.Placemark([parseFloat(v['location'][0][0][0]), parseFloat(v['location'][0][0][1])], {
							id: v['id']
						}, icn);

						o.properties.set({
							balloonContentBody: v['text'],
							balloonContentHeader: v['name'],
							clusterCaption: v['name']
						});

						o.events.add('click', function (e) {
							$('#map-info-popup').hide();
						});
					} else {
						o = new ymaps.Placemark([parseFloat(v['location'][0][0][0]), parseFloat(v['location'][0][0][1])], {
							objId: id,
							ballonGetted: false
						}, icn);

						o.events.add('click', function (e) {
							$('#map-info-popup').hide();

							var o = e.originalEvent.target;
							// do not show baloon on current object
							//if (o.options.get('iconImageHref') === redIconUrl)
							//	return;

							getLotInfo(o);
						});
					}

					placeMarks[id] = o;
					adds.push(placeMarks[id]);
				}

				// console.log(setCenter,adds,adds.length,'setCenter && adds.length')
				// console.log(placeMarks,placeMarks.length,'placeMarks')

				// console.log(Object.keys(clusterer._objects).length,'clusterer.length after')
				// console.log(placeMarks,'placeMarks before')

				if (setCenter) {

					// map.geoObjects.removeAll()
					// clusterer.removeAll();
					// placeMarks={};
					// clearMap()
					map.events.remove('boundschange', boundsChange);
					clusterer.add(adds);
					map.setBounds(map.geoObjects.getBounds(), {
						checkZoomRange: true
					});

					setTimeout(function () {
						map.events.add('boundschange', boundsChange);
					}, 100);
				} else {
					clusterer.add(adds);
				}

				// console.log(Object.keys(clusterer._objects).length,'clusterer.length after')
				// console.log(placeMarks,'placeMarks after')
			};

			var loadObj = function loadObj(params, setCenter, callback) {
				// console.log('loadObj')
				if (typeof params === 'undefined') {
					if ($.isPlainObject(console)) {
						// console.log('  ');
					}
					return;
				}

				// console.log(params)

				//clusterer.removeAll();
				//placeMarks = {};
				searchLoadFlg = true;

				$.get(searchAjaxUrl, params, function (data) {

					// console.log(data,'data')

					if ($.isArray(data.items) && data.items.length) {
						addToCluster(data.items, setCenter);
					}

					searchLoadFlg = false;
					if ($.isFunction(callback)) {
						callback(data);
					}
				}, 'json');
			};

			// function checkObjVisibility(id, callback, prevZoom) {
			// 	if (!placeMarks[id]) {
			// 		return;
			// 	}

			// 	if (typeof prevZoom === 'undefined') {
			// 		prevZoom = 0;
			// 	}

			// 	var curZoom = map.getZoom(),
			// 		mapC = map.getCenter(),
			// 		placeMark = placeMarks[id].geometry.getCoordinates();

			// 	if (mapC[0].toFixed(9) != parseFloat(placeMark[0]).toFixed(9)
			// 		|| mapC[1].toFixed(9) != parseFloat(placeMark[1]).toFixed(9)
			// 	) {
			// 		map.setCenter(placeMark, curZoom, {
			// 			//duration: 250,
			// 			checkZoomRange: true,
			// 			callback: function() {
			// 				checkObjVisibility(id, callback);
			// 			}
			// 		});
			// 		return;
			// 	}

			// 	var state = clusterer.getObjectState(placeMarks[id]);

			// 	if (state.isClustered && prevZoom < curZoom && curZoom + 1 <= map.options.get('maxZoom')) {
			// 		map.setZoom(curZoom + 1, {
			// 			checkZoomRange: true,
			// 			callback: function() {checkObjVisibility(id, callback, curZoom)}
			// 		});
			// 	}
			// 	else if ($.isFunction(callback)) {
			// 		callback();
			// 	}
			// }


			var clearMap = function clearMap() {
				clusterer.removeAll();
				placeMarks = {};
			};

			var _prepareParams = function _prepareParams(filter, setCenter, popstate) {
				// console.log('here')

				// console.log(filter,setCenter,popstate,initialRequest,'prepareParams');

				if (setCenter && initialRequest && !popstate) {
					initialRequest = false;
					setCenter = false;
				}

				if (setCenter) {
					serialize = filter.serialize();
				} else {
					serialize = filter.serialize() + getCoords(true);
				}

				formObject = filter.serializeObject();

				formObject.$city = $('.big-filter__tabs .active a').attr('href');
				formObject.$type = $('.big-filter__content .tab-pane.active .big-filter__buttons .active a').attr('href');

				// console.log(formObject)

				if (!navigationHistory) {
					history.pushState(formObject, '', '?' + serialize);
				}

				// serialize = filter.serialize() + getCoords(true)

				// var filterSearchButton = $('.filter-search')
				// var filterSearchButtonText = filterSearchButton.text()
				// filterSearchButton.html('')

				// filterSearchLoader = $("<span/>", {
				// 	class: 'filter-search_loader'
				// }).appendTo(filterSearchButton);

				// filterSearchText = $("<span/>", {
				// 	class: 'filter-search_text',
				// 	text: filterSearchButtonText
				// }).appendTo(filterSearchButton);

				// TweenMax.fromTo(filterSearchLoader,2,{width:0,backgroundColor:'#ab8d19'},{width:'100%',backgroundColor:'#ffcb00'})

				// filterSearchButton.prop('disabled', true);

				loadObj(serialize, setCenter, function (res) {

					// filterSearchButton.prop('disabled', false);
					// TweenMax.to(filterSearchLoader,0.5,{width:'100%',backgroundColor:'#ffcb00'})

					navigationHistory = false;
				});
			};

			// $(window).on('popstate', function(event){
			// 	// console.log(event)
			// 	if(history.state){
			// 		filterChange(history.state)
			// 	}
			// })


			var getCoords = function getCoords(name) {
				var tmp = map.getBounds();
				tmp[0][0] = parseFloat(tmp[0][0]).toFixed(4);
				tmp[0][1] = parseFloat(tmp[0][1]).toFixed(4);
				tmp[1][0] = parseFloat(tmp[1][0]).toFixed(4);
				tmp[1][1] = parseFloat(tmp[1][1]).toFixed(4);

				if (name) {
					return '&coords=[[' + tmp[0][0] + ',' + tmp[0][1] + '],[' + tmp[1][0] + ',' + tmp[1][1] + ']]';
				} else {
					return tmp;
				}
			};

			var boundsChange = function boundsChange() {
				var tmp = getCoords();

				if (tmp[0][0] !== mapBnds[0][0] || tmp[0][1] !== mapBnds[0][1] || tmp[1][0] !== mapBnds[1][0] || tmp[1][1] !== mapBnds[1][1]) {
					navigationHistory = true;
					_prepareParams(filter);
					mapBnds = tmp;
				}
			};

			mapSearchContainer = $('#map-search');
			mapSearchWrapper = $('.map-search-wrapper');

			setMapHeight();

			$(window).on('resize', function (e) {
				setMapHeight();
			});

			if (typeof filter == 'undefined') {
				window.filter = $('.filter_high');
			}

			var inf = [],
			    map = false,
			    searchAjaxUrl = "./",
			    searchAjaxUrlItem = mapSearchWrapper.data('request-url'),
			    placeMarks = {},
			    clusterer = false,
			    searchInitFlg = false,
			    searchLoadFlg = false,
			    initialRequest = true,
			    imageHref = '/local/templates/main/assets/images/maps-baloon.png',
			    balloonContentLayout = false;

			// var locationCoords = location.search

			// if(locationCoords.length){
			// 	var center = false;
			// 	var zoom = false;
			// }else{
			var center = [55.741075, 37.624988];
			var zoom = 11;
			// }


			var mapBnds = [[0, 0], [0, 0]],
			    mapSet = {
				center: center ? center : undefined,
				zoom: zoom ? zoom : undefined,
				behaviors: ["drag", "dblClickZoom", "rightMouseButtonMagnifier", "multiTouch", "scrollZoom"],
				controls: ["zoomControl"]
			};

			if (location.hostname == "localhost") {
				searchAjaxUrl = '../assets/javascripts/request4.json';
			}

			var imageHref = imageLink + 'maps-baloon.png';
			var clusterHref = imageLink + 'baloon-cluster.png';
			var clusterBigHref = imageLink + 'baloon-cluster-big.png';

			customIcon = {
				iconLayout: 'default#image',
				iconImageHref: imageHref,
				iconImageSize: [34, 39],
				iconImageOffset: [-17, -19]
			};

			ymaps.modules.define('PieChartClusterer.icon.colors', [], function (provide) {
				var colors = {
					red: '#ED4543',
					yellow: '#ffcb00'
				};

				provide(colors);
			});

			ymaps.modules.define('PieChartClusterer.icon.params', ['shape.Circle', 'geometry.pixel.Circle'], function (provide, CircleShape, PixelCircleGeometry) {
				provide({
					icons: {
						small: {
							size: [46, 46],
							offset: [-23, -23],
							shape: new CircleShape(new PixelCircleGeometry([0, 2], 21.5))
						},
						medium: {
							size: [58, 58],
							offset: [-29, -29],
							shape: new CircleShape(new PixelCircleGeometry([0, 2], 27.5))
						},
						large: {
							size: [71, 71],
							offset: [-35.5, -35.5],
							shape: new CircleShape(new PixelCircleGeometry([0, 2], 34))
						}
					},
					numbers: [10, 100]
				});
			});

			ymaps.modules.define('PieChartClusterer.component.Canvas', ['option.Manager', 'PieChartClusterer.icon.colors'], function (provide, OptionManager, iconColors) {
				var DEFAULT_OPTIONS = {
					canvasIconStrokeStyle: 'white',
					canvasIconLineWidth: 2,
					canvasIconCoreRadius: 23,
					canvasIconCoreFillStyle: 'white'
				};

				var Canvas = function Canvas(size) {
					this._canvas = document.createElement('canvas');
					this._canvas.width = size[0];
					this._canvas.height = size[1];

					this._context = this._canvas.getContext('2d');
					this.options = new OptionManager({});
				};

				Canvas.prototype.generateIconDataURL = function (styleGroups, total) {
					this._drawIcon(styleGroups, total);

					return this._canvas.toDataURL();
				};

				Canvas.prototype._drawIcon = function (styleGroups, total) {
					var startAt = 0;
					var endAt = 360;
					var ctx = this._context;
					var x = this._canvas.width / 2;
					var y = this._canvas.height / 2;
					var lineWidth = this.options.get('canvasIconLineWidth', DEFAULT_OPTIONS.canvasIconLineWidth);
					var strokeStyle = this.options.get('canvasIconStrokeStyle', DEFAULT_OPTIONS.canvasIconStrokeStyle);
					var radius = Math.floor((x + y - lineWidth) / 2);

					ctx.strokeStyle = strokeStyle;
					ctx.lineWidth = lineWidth;

					Object.keys(styleGroups).forEach(function (style) {
						var num = styleGroups[style];

						endAt = startAt + num * 360 / total;
						ctx.fillStyle = this._getStyleColor(style);

						if (total > num) {
							startAt = this._drawSector(x, y, radius, startAt, endAt);
						} else {
							this._drawCircle(x, y, radius);
						}
					}, this);

					this._drawCore(x, y);
				};

				Canvas.prototype._drawCore = function (x, y) {
					var ctx = this._context;
					var fillStyle = this.options.get('canvasIconCoreFillStyle', DEFAULT_OPTIONS.canvasIconCoreFillStyle);
					var radius = this.options.get('canvasIconCoreRadius', DEFAULT_OPTIONS.canvasIconCoreRadius);

					ctx.fillStyle = fillStyle;
					this._drawCircle(x, y, radius);
				};

				Canvas.prototype._drawCircle = function (x, y, radius) {
					var ctx = this._context;

					ctx.beginPath();
					ctx.arc(x, y, radius, 0, 2 * Math.PI);
					ctx.fill();
					ctx.stroke();
				};

				Canvas.prototype._drawSector = function (x, y, radius, startAt, endAt) {
					var ctx = this._context;

					ctx.beginPath();
					ctx.moveTo(x, y);
					ctx.arc(x, y, radius, this._toRadians(startAt), this._toRadians(endAt));
					ctx.lineTo(x, y);
					ctx.closePath();
					ctx.fill();
					ctx.stroke();

					return endAt;
				};

				Canvas.prototype._toRadians = function (deg) {
					return deg * Math.PI / 180;
				};

				Canvas.prototype._getStyleColor = function (style) {
					return iconColors[style];
				};

				provide(Canvas);
			});

			var clusterContentLayout;

			ymaps.modules.define('PieChartClusterer', ['Clusterer', 'util.defineClass', 'util.extend', 'PieChartClusterer.icon.params', 'PieChartClusterer.component.Canvas'], function (provide, Clusterer, defineClass, extend, iconParams, PieChartClustererCanvas) {

				var STYLE_REG_EXP = /#(.+?)(?=Icon|DotIcon|StretchyIcon|CircleIcon|CircleDotIcon)/;

				var PieChartClusterer = defineClass(function (options) {
					PieChartClusterer.superclass.constructor.call(this, options);

					this._canvas = new PieChartClustererCanvas(iconParams.icons.large.size);
					this._canvas.options.setParent(this.options);
				}, Clusterer, {
					createCluster: function createCluster(center, geoObjects) {
						//  -     .
						var clusterPlacemark = PieChartClusterer.superclass.createCluster.call(this, center, geoObjects);
						var styleGroups = geoObjects.reduce(function (groups, geoObject) {
							var style = getIconStyle(geoObject.options.get('preset', 'islands#yellowIcon'));

							groups[style] = ++groups[style] || 1;

							return groups;
						}, {});
						var iconUrl = this._canvas.generateIconDataURL(styleGroups, geoObjects.length);
						var clusterOptions = {
							clusterIcons: [extend({ href: clusterHref }, iconParams.icons.small), extend({ href: clusterBigHref }, iconParams.icons.medium)],
							clusterNumbers: 500,
							clusterIconContentLayout: clusterContentLayout
						};

						clusterPlacemark.options.set(clusterOptions);

						return clusterPlacemark;
					}
				});

				function getIconStyle(preset) {
					if ($.isArray(preset)) {
						preset = preset[0];
					}

					return preset.match(STYLE_REG_EXP)[1];
				}

				provide(PieChartClusterer);
			});

			renderMap(mapSet, function () {
				map.events.add('boundschange', boundsChange);

				if (!location.search.length) {
					_prepareParams(filter, true);
				} else {
					navigationHistory = true;
					_prepareParams(filter, true, true);
				}

				// console.log('1')
			});

			filter.on("submit", function (e) {
				e.preventDefault();
				_prepareParams($(this), true);
			});
		};
		if ($('#map-complex').length) {
			var removeArray = function removeArray(base, remover) {

				$.each(remover, function (i, element) {
					if (arrayFind(base, element) !== -1) {
						base.splice(arrayFind(base, element), 1);
					}
				});
			};

			var appendArray = function appendArray(base, appender) {

				if (!(appender.length && (typeof appender === "undefined" ? "undefined" : _typeof(appender)) === 'object')) {
					return;
				}
				$.each(appender, function (index, val) {
					if (base.find(function (el) {
						return val.id === el.id;
					}) === undefined) {
						base.push(val);
					}
				});
			};

			var _getCoords = function _getCoords() {
				return complexMap.getBounds().reduce(function (prev, current, i) {
					return "" + prev + (i > 0 ? ',' : '') + current[0] + "," + current[1];
				}, '');
			};

			// function infRequest() {

			//   const url = $('#map-complex').data('infrastructure-url'),
			//         coords = getCoords();
			//   return $.get(url,{coords}).done(({ features }) => {
			//     $.each(features,(key,val)=>{
			//       if (!infraObjects[key]) infraObjects[key] = [];
			//       appendArray(infraObjects[key],val)
			//     })
			//   })

			// };


			var ecoRequest = function ecoRequest() {

				var url = $('#map-complex').data('eco-url'),
				    coords = _getCoords();

				return $.get(url, { coords: coords }).done(function (_ref) {
					var features = _ref.features;

					$.each(features, function (key, val) {
						if (!ecoObjects[key]) ecoObjects[key] = [];
						appendArray(ecoObjects[key], val);
					});
				});
			};

			var addMapPoints = function addMapPoints(type) {
				if (infraObjects[type] && infraObjects[type].length) {
					$.each(infraObjects[type], function (ind, el) {
						el.options.hintLayout = HintLayoutInfra;
					});

					infrastructureManager.add(infraObjects[type]);
					complexMap.geoObjects.add(infrastructureManager);
				}
			};

			var removeMapPoints = function removeMapPoints(type) {

				infrastructureManager.remove(infraObjects[type]);
				complexMap.geoObjects.add(infrastructureManager);
			};

			var getPolygonCenter = function getPolygonCenter(coords) {

				var n = coords.length,
				    xCoord = 0,
				    yCoord = 0,
				    mult = void 0,
				    space = 0;

				for (var _i4 = 0; _i4 < n - 1; _i4++) {
					mult = coords[_i4][0] * coords[_i4 + 1][1] - coords[_i4 + 1][0] * coords[_i4][1];
					xCoord += (coords[_i4][0] + coords[_i4 + 1][0]) * mult;
					yCoord += (coords[_i4][1] + coords[_i4 + 1][1]) * mult;
					space += mult;
				}

				xCoord = xCoord / (space * 3);
				yCoord = yCoord / (space * 3);

				return [xCoord, yCoord];
			};

			var addMapPolygons = function addMapPolygons(type) {

				if (ecoObjects[type] && ecoObjects[type].length) {
					$.each(ecoObjects[type], function (ind, el) {
						el.options.hintLayout = HintLayoutEco;
						if (el.geometry.type === 'Polygon') {
							ecoPointsManager.add({
								'type': 'Feature',
								'id': el.id,
								'options': {
									'iconLayout': 'default#image',
									"iconImageSize": [30, 40],
									"iconImageOffset": [-12, -25],
									'iconImageHref': el.options.iconImageHref
								},
								'geometry': {
									'type': 'Point',
									'coordinates': getPolygonCenter(el.geometry.coordinates[0])
								},
								'properties': {
									'name': el.properties.name,
									'description': el.properties.description
								}
							});
						}
					});

					ecoManager.add(ecoObjects[type]);

					complexMap.geoObjects.add(ecoManager);
					complexMap.geoObjects.add(ecoPointsManager);
				}
			};

			var removeMapPolygons = function removeMapPolygons(type) {

				// complexMap.geoObjects.removeAll();
				ecoPointsManager.removeAll();
				ecoManager.removeAll();
				if (window.infrastructureManager) {
					complexMap.geoObjects.add(window.infrastructureManager);
				}
				var selected = $('#filter-content-ecological .map-filter__item_active');
				$.each(selected, function (ind, el) {
					addMapPolygons($(el).data('map-type'));
				});
			};

			var updateInfrastructure = function updateInfrastructure() {

				infRequest().done(function () {

					var selected = $('#filter-content-infrastructure .map-filter__item_active');

					$.each(selected, function (ind, el) {
						addMapPoints($(el).data('map-type'));
					});
				});
			};

			var updateEcological = function updateEcological() {

				ecoRequest().done(function () {

					var selected = $('#filter-content-ecological .map-filter__item_active');

					$.each(selected, function (ind, el) {
						addMapPolygons($(el).data('map-type'));
					});
				});
			};

			var updateMap = function updateMap() {

				updateInfrastructure();
				updateEcological();
			};

			var infrastructureSetUp = function infrastructureSetUp() {

				$('.map-filter__item').on('click', function (event) {
					event.preventDefault();

					var selected = $(event.currentTarget),
					    currentType = selected.data('map-type');

					if (selected.parent('#filter-content-infrastructure').length) {
						/*
            if (!$.isEmptyObject(infraObjects)) {
      
              if (selected.hasClass('map-filter__item_active')) {
                addMapPoints(currentType)
              } else {
                removeMapPoints(currentType)
              }
            }
      */
					} else if (selected.parent('#filter-content-ecological').length) {
						selected.toggleClass('map-filter__item_active');

						if (selected.hasClass('map-filter__item_active')) {
							updateEcological();
						} else {
							removeMapPolygons(currentType);
						}
					}
				});

				// infraObjects = {
				//   "medicine" : [
				//     {
				//       "type": "Feature",
				//       "id": 25924,
				//       "options": {
				//         "iconLayout": "default#image",
				//         "iconImageHref": '/assets/images/map-icon_medicine.svg',
				//         "iconImageSize": [
				//           51,
				//           60
				//         ],
				//         "iconImageOffset": [
				//           -12,
				//           -25
				//         ],
				//         "hintLayout": true
				//       },
				//       "geometry": {
				//         "type": "Point",
				//         "coordinates": [
				//           55.872162182165,
				//           37.261772884687
				//         ]
				//       },
				//       "properties": {
				//         "type": "medicine",
				//         "name": "\u041f\u0440\u043e\u043c\u0437\u043e\u043d\u0430"
				//       }
				//     }
				//   ]
				// }

				// ecoObjects = {
				//   "industzones" : [
				//     {
				//       "type":"Feature",
				//       "id":25927,
				//       "options":{
				//         "iconLayout":"default#image",
				//         "iconImageHref":"\/assets\/images\/map-icon_powerlines.svg",
				//         "iconImageSize":[51,60],1][1] - coords[i+1][0]*coords[i][1])
				//         "iconImageOffset":[-25,-50],
				//         "hintLayout":true
				//       },
				//       "geometry":{
				//         "type":"Polygon",
				//         "coordinates":[
				//           [
				//             [
				//               55.758959459323,
				//               37.633605613708
				//             ], [
				//               55.757870491555,
				//               37.636824264526
				//             ], [
				//               55.760169387696,
				//               37.64111579895
				//             ], [
				//               55.76210519468,
				//               37.635579719543
				//             ], [
				//               55.758959459323,
				//               37.633605613708
				//             ]
				//           ]
				//         ]
				//       },
				//       "properties":{
				//         "type":null,
				//         "name":"\u041f\u0440\u043e\u043c\u0437\u043e\u043d\u0430",
				//         "fillColor":"#ff4a4a",
				//         "strokeColor": '#fff',
				//         "opacity": 0.3
				//       },
				//     }
				//   ],
				//   "dump": [
				//     {
				//       "type":"Feature",
				//       "id":25928,
				//       "options":{
				//         "iconLayout":"default#image",
				//         "iconImageHref":"\/assets\/images\/map-icon_powerlines.svg",
				//         "iconImageSize":[51,60],
				//         "iconImageOffset":[-25,-50],
				//         "hintLayout":true
				//       },
				//       "geometry":{
				//         "type":"Polygon",
				//         "coordinates":[
				//           [
				//             [
				//               55.754824730363,
				//               37.649919337411
				//             ],[
				//               55.755090946181,
				//               37.655240840096
				//             ],[
				//               55.757414206779,
				//               37.659918612618
				//             ],[
				//               55.75869678069,
				//               37.65112096705
				//             ],[
				//               55.754824730363,
				//               37.649919337411
				//             ]
				//           ]
				//         ]
				//       },
				//       "properties":{
				//         "type":null,
				//         "name":"\u041f\u0440\u043e\u043c\u0437\u043e\u043d\u0430 2",
				//         "fillColor": '#83adef',
				//         "strokeColor": '#fff',
				//         "opacity": 0.3
				//       },
				//     }
				//   ],
				//   "powerlines":[
				//     {
				//       "type":"Feature",
				//       "id":25930,
				//       "options":{
				//         "iconLayout":"default#image",
				//         "iconImageHref":"\/assets\/images\/map-icon_powerlines.svg",
				//         "iconImageSize":[51,60],"iconImageOffset":[-25,-50],
				//         "hintLayout":true,
				//         "fillColor":"#83adef",
				//         "strokeColor":"#fff",
				//         "opacity":0.5
				//       },
				//       "geometry":{
				//         "type":"Polygon",
				//         "coordinates":
				//           [
				//             [
				//               [
				//                 55.872162182165,
				//                 37.261772884687
				//               ],[
				//                 55.872693002338,
				//                 37.266708149275
				//               ],[
				//                 55.873923511988,
				//                 37.26666523393
				//               ],[
				//                 55.872982537543,
				//                 37.262802852949
				//               ],[
				//                 55.872162182165,
				//                 37.261772884687
				//               ]
				//             ]
				//           ]
				//       },
				//       "properties":{
				//         "type":"powerlines",
				//         "name":"\u041b\u042d\u041f \u041b\u0430\u0441\u0442\u043e\u0447\u043a\u0430",
				//       }
				//     }
				//   ]
				// }


				// complexMap.events.add('boundschange', function (e) {
				//   if (!resizing) {
				//     updateMap()
				//   }
				//   // if (init) {
				//   //     infRequest()

				//   //     ecoRequest().done(() => {
				//   //       // const complexBounds = complexCollection.getBounds();
				//   //       // const complexCenter = [
				//   //       //   complexBounds[0][0] + (complexBounds[1][0] - complexBounds[0][0]) / 2,
				//   //       //   (complexBounds[1][1] - complexBounds[0][1]) / 2 + complexBounds[0][1]
				//   //       // ];
				//   //       // const radius = 10000
				//   //       // const viewRadius = new ymaps.geometry.Circle(complexCenter, radius)
				//   //       // viewRadius.setMap(complexMap)
				//   //       // viewRadius.options.setParent(complexMap.options);
				//   //       //
				//   //       // const types = ['industzones', 'thermalstations', 'industenterprises', 'incinerations', 'treatmentfacil', 'powerlines', 'dump']
				//   //       //
				//   //       // for (let i = 0; i < types.length; i++) {
				//   //       //   const type = types[i]
				//   //       //   if (ecoObjects[type]) {
				//   //       //     $.each(ecoObjects[type], (ind,el) => {
				//   //       //       const elCoords = el.geometry.coordinates[0]
				//   //       //       let coords
				//   //       //
				//   //       //       if (elCoords.length > 2) {
				//   //       //         coords = getPolygonCenter(el.geometry.coordinates[0])
				//   //       //       } else {
				//   //       //         coords = el.geometry.coordinates
				//   //       //       }
				//   //       //
				//   //       //       if (viewRadius.contains(coords)) {
				//   //       //         $('[data-target="#filter-content-ecological"]').removeClass('_hidden')
				//   //       //         return false
				//   //       //       }
				//   //       //
				//   //       //     })
				//   //       //   }
				//   //       // }
				//   //     })

				//   //     init = false;
				//   // }
				// });
			};

			var getInfRequest = function getInfRequest(type) {
				switch (type) {
					case 'kindergarten':
						return ' ';
						break;
					case 'school':
						return '';
						break;
					case 'medicine':
						return '';
						break;
					case 'shopping':
						return '';
						break;
					case 'banks':
						return '';
						break;
					case 'pharmacy':
						return '';
						break;
					case 'park':
						return '';
						break;
				}
			};

			var removeArray = function removeArray(base, remover) {

				$.each(remover, function (i, element) {
					if (arrayFind(base, element) !== -1) {
						base.splice(arrayFind(base, element), 1);
					}
				});
			};

			var appendArray = function appendArray(base, appender) {

				if (!(appender.length && (typeof appender === "undefined" ? "undefined" : _typeof(appender)) === 'object')) {
					return;
				}

				var q = [];

				$.each(appender, function (index, val) {
					var sum = val.geometry.coordinates[0] + val.geometry.coordinates[1];

					if (q[sum] === undefined) {
						q[sum] = val;
						base.push(q[sum]);
					}
				});
			};

			var infRequest = function infRequest(dataTypes) {
				// var spn = [0.015 * 2 * radius, 0.002 * radius * 2 * 3.3];

				lat = myCoords[1];
				lng = myCoords[0];

				// console.log(lat, lng);

				return $.ajax({
					type: 'GET',
					url: '/ajax/get_infrastructure.php',
					async: true,
					data: {
						apikey: yandexFirmsKey,
						lang: 'ru_RU',
						ll: lat + ',' + lng,
						results: 20,
						rspn: 1,
						text: dataTypes,
						//spn: spn.join(','),
						type: 'biz'
					}
				}).done(function (_ref2) {
					var features = _ref2.features;

					$.each(features, function (key, val) {
						if (!infraObjects[key]) infraObjects[key] = [];
						appendArray(infraObjects[key], val);
					});
				});
			};

			var infrastructureIcon,
			    HintLayout,
			    HintLayoutInfra,
			    Points = [],
			    Polygons = [],
			    infraObjects = {},
			    init = true,
			    resizing = false;
			window.ecoObjects = {};

			// if(location.hostname == "localhost"){
			//   infrastructureIcon = {
			//       banks: {
			//           iconImageHref: '../assets/images/map-icon_bank.svg',
			//       },

			//       school: {
			//           iconImageHref: '../assets/images/map-icon_edu.svg',
			//       },

			//       kindergarten: {
			//           iconImageHref: '../assets/images/map-icon_garden.svg',
			//       },

			//       shopping: {
			//           iconImageHref: '../assets/images/map-icon_shop.svg',
			//       },

			//       pharmacy: {
			//           iconImageHref: '../assets/images/map-icon_pharmacy.svg',
			//       },

			//       park: {
			//           iconImageHref: '../assets/images/map-icon_park.svg',
			//       },

			//       medicine: {
			//           iconImageHref: '../assets/images/map-icon_hospital.svg',
			//       }
			//   }
			// } else {
			//   infrastructureIcon = {
			//       banks: {
			//           iconImageHref: '/local/templates/main/assets/images/map-icon_bank.svg',
			//       },

			//       school: {
			//           iconImageHref: '/local/templates/main/assets/images/map-icon_edu.svg',
			//       },

			//       kindergarten: {
			//           iconImageHref: '/local/templates/main/assets/images/map-icon_garden.svg',
			//       },

			//       shopping: {
			//           iconImageHref: '/local/templates/main/assets/images/map-icon_shop.svg',
			//       },

			//       pharmacy: {
			//           iconImageHref: '/local/templates/main/assets/images/map-icon_pharmacy.svg',
			//       },

			//       park: {
			//           iconImageHref: '/local/templates/main/assets/images/map-icon_park.svg',
			//       },

			//       medicine: {
			//           iconImageHref: '/local/templates/main/assets/images/map-icon_hospital.svg',
			//       }
			//   }
			// }

			window.complexMap = window.complexMap || undefined;

			var ecoInit = function ecoInit() {

				var mapWrapper = $('#map-complex');

				HintLayout = ymaps.templateLayoutFactory.createClass("<div class='map-hint'>" + mapWrapper.data('complex-name') + "</div>", {
					getShape: function getShape() {
						var el = this.getElement(),
						    result = null;
						if (el) {
							var firstChild = el.firstChild;
							result = new ymaps.shape.Rectangle(new ymaps.geometry.pixel.Rectangle([[0, 0], [firstChild.offsetWidth, firstChild.offsetHeight]]));
						}
						return result;
					}
				});

				HintLayoutInfra = ymaps.templateLayoutFactory.createClass("<div class='map-hint map-hint_width'>" + "<div>{{ properties.name }}</div>" +
				// "<div>{{ properties.description }}</div>" +
				"</div>", {
					getShape: function getShape() {
						var el = this.getElement(),
						    result = null;
						if (el) {
							var firstChild = el.firstChild;
							result = new ymaps.shape.Rectangle(new ymaps.geometry.pixel.Rectangle([[0, 0], [firstChild.offsetWidth, firstChild.offsetHeight]]));
						}
						return result;
					}
				});

				HintLayoutEco = ymaps.templateLayoutFactory.createClass("<div class='map-hint map-hint_width'>" + "<div>{{ properties.description }}</div>" + "<div>{{ properties.name }}</div>" + "</div>", {
					getShape: function getShape() {
						var el = this.getElement(),
						    result = null;
						if (el) {
							var firstChild = el.firstChild;
							result = new ymaps.shape.Rectangle(new ymaps.geometry.pixel.Rectangle([[0, 0], [firstChild.offsetWidth, firstChild.offsetHeight]]));
						}
						return result;
					}
				});

				if (typeof complexMap == 'undefined') {

					window.complexMap = new ymaps.Map('map-complex', {
						center: [50, 50],
						zoom: 16,
						controls: ['zoomControl']
					}, {
						maxZoom: 16,
						minZoom: 10
					});

					window.complexMap.behaviors.disable('scrollZoom');
					if (isMobile) {
						window.complexMap.behaviors.disable('drag');
					}
				}

				if (typeof infrastructureManager == 'undefined') {
					infrastructureManager = new ymaps.ObjectManager({
						clusterize: false,
						gridSize: 32,
						viewportMargin: 0
					});
				};

				if (typeof complexManager == 'undefined') {
					complexManager = new ymaps.ObjectManager({
						clusterize: false,
						gridSize: 64,
						viewportMargin: 0
					});
				};

				if (typeof polygonManager == 'undefined') {
					polygonManager = new ymaps.ObjectManager();
				}

				if (typeof ecoPointsManager == 'undefined') {
					window.ecoPointsManager = new ymaps.ObjectManager({
						clusterize: false,
						gridSize: 32,
						viewportMargin: 0
					});
				};

				window.ecoManager = new ymaps.ObjectManager();

				function initialData() {

					complexCollection = new ymaps.GeoObjectCollection();

					if (mapWrapper.data('map-polygon')) {

						myPolygon = new ymaps.GeoObject({
							geometry: {
								type: "Polygon",
								coordinates: mapWrapper.data('map-polygon')
							}
						}, {
							fillColor: '#6064a0',
							strokeColor: '#fff',
							opacity: 0.5,
							hintLayout: HintLayoutEco
						});

						complexCollection.add(myPolygon);

						complexMap.geoObjects.add(complexCollection);

						complexMap.setBounds(complexCollection.getBounds(), {
							checkZoomRange: true,
							zoomMargin: 10,
							zoom: 16
						});
					}
				};

				initialData();

				$('.map-more__button').on('click', function (e) {
					button = $(this);

					button.toggleClass('map-more__button_active');

					if (button.hasClass('map-more__button_active')) {
						button.text('');

						TweenLite.to(window, 0.5, { scrollTo: { y: $('#map-complex').offset().top }, ease: Power2.easeOut });

						TweenMax.to($('#map-complex'), 0.5, {
							height: $(window).height(),
							onStart: function onStart() {
								button.addClass('map-more__button_disabled');
								resizing = true;
							},
							onUpdate: function onUpdate() {
								complexMap.container.fitToViewport();
							},
							onComplete: function onComplete() {
								button.removeClass('map-more__button_disabled');
								resizing = false;
								updateMap();
							}

						});
					} else {
						button.text('');
						TweenLite.to(window, 0.5, { scrollTo: { y: $('#map-complex').offset().top }, ease: Power2.easeOut });
						TweenMax.to($('#map-complex'), 0.5, {
							height: 510,
							onStart: function onStart() {
								button.addClass('map-more__button_disabled');
								resizing = true;
							},
							onUpdate: function onUpdate() {
								complexMap.container.fitToViewport();
							},
							onComplete: function onComplete() {
								button.removeClass('map-more__button_disabled');
								resizing = false;
								updateMap();
							}
						});
					}
				});

				infrastructureSetUp();

				setTimeout(function () {
					var mapCenter = complexMap.getCenter();

					var placeMark = new ymaps.Placemark(mapCenter, {}, {
						iconLayout: 'default#image',
						iconImageHref: '/local/templates/main/assets/images/maps-baloon.png',
						iconImageSize: [32, 43],
						iconImageOffset: [-15, -45],
						zIndex: 9000,
						id: 'zoomMark',
						visible: false
					});

					complexMap.geoObjects.add(placeMark);

					var markIndex = complexMap.geoObjects.indexOf(placeMark);

					var markLink = complexMap.geoObjects.get(markIndex);

					if (!map_items[0].map_items.polygon) {
						markLink.options.set("visible", true);
					}

					complexMap.events.add("boundschange", function (e) {
						var newZoom = e.get('newZoom');
						var oldZoom = e.get('oldZoom');

						if (map_items[0].map_items.polygon) {
							if (newZoom < 15) {
								markLink.options.set("visible", true);
							}

							if (newZoom >= 15) {
								markLink.options.set("visible", false);
							}
						} else {
							markLink.options.set("visible", true);
						}
					});
				}, 9000);
			};

			var infrastructureInit = function infrastructureInit() {
				// if ( typeof infrastructureManager == 'undefined' ) {
				//   infrastructureManager = new ymaps.ObjectManager({
				//     clusterize: false,
				//     gridSize: 32,
				//     viewportMargin: 0
				//   });
				// };

				var Objects = {};

				Objects['school'] = [];
				Objects['kindergarten'] = [];
				Objects['medicine'] = [];
				Objects['shopping'] = [];
				Objects['pharmacy'] = [];
				Objects['park'] = [];
				Objects['banks'] = [];
				Objects['industzones'] = [];
				Objects['thermalstations'] = [];
				Objects['industenterprises'] = [];
				Objects['incinerations'] = [];
				Objects['treatmentfacil'] = [];
				Objects['dump'] = [];

				$('#filter-content-infrastructure .map-filter__item').on('click', function (e) {
					e.preventDefault();

					$(this).toggleClass('map-filter__item_active');

					dataTypes = [];

					dataTypes = $(e.currentTarget).data('map-type');

					infrastructureManager.removeAll();

					if (dataTypes.length) {
						if (Objects[dataTypes].length === 0) {
							infRequest(getInfRequest(dataTypes)).done(function (data) {
								if (data.properties.ResponseMetaData.SearchResponse.found > 0) {
									var type = data.features;

									$.each(type, function (i, e) {
										obj = e;
										Objects[dataTypes].push({
											type: 'Feature',
											id: obj.properties.CompanyMetaData.id,
											geometry: {
												type: 'Point',
												coordinates: [obj.geometry.coordinates[1], obj.geometry.coordinates[0]]
											},
											options: {
												iconLayout: 'default#image',
												iconImageSize: [26, 30],
												iconImageOffset: [-15, -40],
												iconImageHref: infrastructureIcon[dataTypes].iconImageHref,
												hintLayout: HintLayoutInfra
											},
											properties: {
												name: obj.properties.name
											},
											fillColor: '#6064a0',
											strokeColor: '#fff',
											opacity: 0.5
										});
									});
								}

								if ($(e.currentTarget).hasClass('map-filter__item_active')) {
									appendArray(Points, Objects[dataTypes]);
								} else {
									removeArray(Points, Objects[dataTypes]);
								}

								infrastructureManager.add(Points);

								complexMap.geoObjects.add(infrastructureManager);
							});
						} else {
							if ($(e.currentTarget).hasClass('map-filter__item_active')) {
								appendArray(Points, Objects[dataTypes]);
							} else {
								removeArray(Points, Objects[dataTypes]);
							}

							infrastructureManager.add(Points);

							complexMap.geoObjects.add(infrastructureManager);
						}
					}
				});
			};

			if ($('#map-complex').length > 0) {
				ymaps.ready(ecoInit);
			}
			var yandexFirmsKey,
			    infrastructureIcon,
			    myCoords,
			    dataTypes,
			    HintLayout,
			    HintLayoutInfra,
			    Points = [];

			window.infrastructureManager;

			yandexFirmsKey = 'd6f2d66e-5972-4aad-a1e7-2f4a9567001f';

			myCoords = [];

			window.complexMap = undefined;

			var complexInit = function complexInit() {
				var complexPlacemarks;
				var complexManager;
				var polygonManager;
				var groups;

				var mapWrapper = $('#map-complex');

				var dataLink = mapWrapper.data('infrastructure-url');

				// var Polygons = {
				//   "type": "FeatureCollection",
				//   "features": []
				// };

				// HintLayout = ymaps.templateLayoutFactory.createClass(
				//     "<div class='map-hint'>" +
				//     mapWrapper.data('complex-name') +
				//     "</div>", {
				//         getShape: function () {
				//             var el = this.getElement(),
				//                 result = null;
				//             if (el) {
				//                 var firstChild = el.firstChild;
				//                 result = new ymaps.shape.Rectangle(
				//                     new ymaps.geometry.pixel.Rectangle([
				//                         [0, 0],
				//                         [firstChild.offsetWidth, firstChild.offsetHeight]
				//                     ])
				//                 );
				//             }
				//             return result;
				//         }
				//     }
				// );

				// HintLayoutInfra = ymaps.templateLayoutFactory.createClass(
				//     "<div class='map-hint map-hint_width'>" +
				//     "{{ properties.name }}" +
				//     "</div>", {
				//         getShape: function () {
				//             var el = this.getElement(),
				//                 result = null;
				//             if (el) {
				//                 var firstChild = el.firstChild;
				//                 result = new ymaps.shape.Rectangle(
				//                     new ymaps.geometry.pixel.Rectangle([
				//                         [0, 0],
				//                         [firstChild.offsetWidth, firstChild.offsetHeight]
				//                     ])
				//                 );
				//             }
				//             return result;
				//         }
				//     }
				// );

				infrastructureInit();

				// if (typeof complexMap == 'undefined') {
				//
				//   window.complexMap = new ymaps.Map('map-complex', {
				//     center: [50, 50],
				//     zoom: 16,
				//     controls: ['zoomControl']
				//   },{
				//     maxZoom: 16,
				//     minZoom: 10
				//   });
				//
				//   window.complexMap.behaviors.disable('scrollZoom');
				//   if ( isMobile ) {
				//     window.complexMap.behaviors.disable('drag');
				//   }
				// } else {
				//   // complexManager.removeAll();
				// }
				//
				// if ( typeof complexManager == 'undefined' ) {
				//   complexManager = new ymaps.ObjectManager({
				//     clusterize: false,
				//     gridSize: 64,
				//     viewportMargin: 0
				//   });
				// };

				// if ( typeof polygonManager == 'undefined' ) {
				//   polygonManager = new ymaps.ObjectManager();
				// }

				// complexCollection = new ymaps.GeoObjectCollection();

				// reqursion = false;

				function setCenter() {
					complexMap.setBounds(complexManager.getBounds(), {
						checkZoomRange: true,
						zoomMargin: 15
					}).then(function () {
						//console.log('setComplete');
					});
				};

				function addedElems(data) {
					//console.dir(data);
					// $.each(data, function (i,e) {
					//  console.log(e)
					//  obj = e;
					//  obj.options.hintLayout = HintLayout;

					//  if ( e.geometry.type == "Point" ) {
					//    Points.features.push(obj);
					//  } else {
					//    Polygons.features.push(obj);
					//  }
					// });

					// complexManager.add(Points);
					// polygonManager.add(Polygons);

					// complexMap.geoObjects.add(complexManager);
					// complexMap.geoObjects.add(polygonManager);
				};

				function initialData() {

					complexCollection = new ymaps.GeoObjectCollection();

					if (mapWrapper.data('map-polygon')) {
						myCoords = mapWrapper.data('map-polygon')[0][0];

						// $.each(mapWrapper.data('map-polygon'), function (index, element) {
						myPolygon = new ymaps.GeoObject({
							geometry: {
								type: "Polygon",
								coordinates: mapWrapper.data('map-polygon')
							},
							properties: {
								// name: map.data('map-name')
							}
						}, {
							fillColor: '#6064a0',
							strokeColor: '#fff',
							opacity: 0.5,
							hintLayout: HintLayout
						});
						complexCollection.add(myPolygon);
						// });

						//console.dir(complexMap)

						complexMap.geoObjects.add(complexCollection);

						complexMap.setBounds(complexCollection.getBounds(), {
							checkZoomRange: true,
							zoomMargin: 10
						});
					}
				};

				initialData();
			};

			if (location.hostname == "localhost") {
				infrastructureIcon = {
					banks: {
						iconImageHref: '../assets/images/map-icon_banks.svg'
					},

					school: {
						iconImageHref: '../assets/images/map-icon_edu.svg'
					},

					kindergarten: {
						iconImageHref: '../assets/images/map-icon_garden.svg'
					},

					shopping: {
						iconImageHref: '../assets/images/map-icon_shop.svg'
					},

					pharmacy: {
						iconImageHref: '../assets/images/map-icon_pharmacy.svg'
					},

					park: {
						iconImageHref: '../assets/images/map-icon_park.svg'
					},

					medicine: {
						iconImageHref: '../assets/images/map-icon_hospital.svg'
					}
				};
			} else {
				infrastructureIcon = {
					banks: {
						iconImageHref: '/local/templates/main/assets/images/map-icon_banks.svg'
					},

					school: {
						iconImageHref: '/local/templates/main/assets/images/map-icon_school.svg'
					},

					kindergarten: {
						iconImageHref: '/local/templates/main/assets/images/map-icon_kindergarten.svg'
					},

					shopping: {
						iconImageHref: '/local/templates/main/assets/images/map-icon_shopping.svg'
					},

					pharmacy: {
						iconImageHref: '/local/templates/main/assets/images/map-icon_pharmacy.svg'
					},

					park: {
						iconImageHref: '/local/templates/main/assets/images/map-icon_park.svg'
					},

					medicine: {
						iconImageHref: '/local/templates/main/assets/images/map-icon_medicine.svg'
					}
				};
			}

			var myCoords = $('#map-complex').data('map-polygon')[0][0];

			var lat, lng;

			;

			if ($('#map-complex').length > 0) {
				ymaps.ready(complexInit);
			}
		};
		if ($('.map-container').length) {
			var mapInit = function mapInit() {

				var mapContainer = $('.map-container');
				var i = 1;

				mapContainer.each(function (i, elem) {

					if (!$(elem).attr('id')) {
						$(elem).attr('id', 'map_' + i++);
					}

					var MapHint = ymaps.templateLayoutFactory.createClass("<div class='map-hint'>" + $(elem).data('complex-name') + "</div>", {
						getShape: function getShape() {
							var el = this.getElement(),
							    result = null;
							if (el) {
								var firstChild = el.firstChild;
								result = new ymaps.shape.Rectangle(new ymaps.geometry.pixel.Rectangle([[0, 0], [firstChild.offsetWidth, firstChild.offsetHeight]]));
							}
							return result;
						}
					});

					var map = new ymaps.Map($(elem).attr('id'), {
						center: [50, 50],
						zoom: 15,
						controls: ['zoomControl']
					}, {
						maxZoom: 16
					});

					map.behaviors.disable('scrollZoom');

					if ($(elem).data('map-polygon')) {

						var _myPolygon = new ymaps.GeoObject({
							geometry: {
								type: "Polygon",
								coordinates: $(elem).data('map-polygon')
							}
						}, {
							fillColor: '#6064a0',
							strokeColor: '#fff',
							opacity: 0.7,
							hintLayout: MapHint
						});

						var mapCollection = new ymaps.GeoObjectCollection();

						mapCollection.add(_myPolygon);

						map.geoObjects.add(mapCollection);

						map.setBounds(mapCollection.getBounds(), {
							checkZoomRange: true,
							zoomMargin: 10,
							zoom: 15
						});

						var mapCenter = map.getCenter();

						var placeMark = new ymaps.Placemark(mapCenter, {}, {
							iconLayout: 'default#image',
							iconImageHref: '/local/templates/main/assets/images/maps-baloon.png',
							iconImageSize: [32, 43],
							iconImageOffset: [-15, -45],
							zIndex: 9000,
							id: 'zoomMark',
							visible: false
						});

						map.geoObjects.add(placeMark);

						var markIndex = map.geoObjects.indexOf(placeMark);

						var markLink = map.geoObjects.get(markIndex);

						map.events.add("boundschange", function (e) {
							var newZoom = e.get('newZoom'),
							    oldZoom = e.get('oldZoom');

							if (newZoom < 15) {
								markLink.options.set("visible", true);
							}
							if (newZoom == 15) {
								markLink.options.set("visible", false);
							}
						});
					}
				});
			};

			if ($('.map-container').length) {
				ymaps.ready(mapInit);
			}
		};
		if ($('.building-corps').length) {
			var CLASSES = {
				B_CORPS: '.building-corps', //  
				B_MONTHS_CORPS: '.building-months-corps', //  
				B_MONTHS: '.building-months', //   
				B_CONTENT_CORPS: '.building-content-corps', //   
				B_CONTENT_MONTHS: '.building-content-months', //    
				B_CONTENT_MONTH: '.building-content-month' //   
			};

			var $corpsNav = $(CLASSES.B_CORPS); //  
			var $monthsCorpsNav = $(CLASSES.B_MONTHS_CORPS); //  
			var $monthsNav = $(CLASSES.B_MONTHS); //   

			var $corpsContent = $(CLASSES.B_CONTENT_CORPS); //   
			var $monthsContent = $(CLASSES.B_CONTENT_MONTHS); //    
			var $monthContent = $(CLASSES.B_CONTENT_MONTH); //   

			var prevArrowSrc = '<button type="button" data-role="none" class="slick-arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>';
			var nextArrowSrc = '<button type="button" data-role="none" class="slick-arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>';

			var prevArrowBigSrc = '<button class="slick-arrow slick-arrow-big slick-prev" type="button" data-role="none" aria-label="Next" role="button"><img src="' + imageLink + 'icon-left.png"></button>';
			var nextArrowBigSrc = '<button class="slick-arrow slick-arrow-big slick-next" type="button" data-role="none" aria-label="Next" role="button"><img src="' + imageLink + 'icon-right.png"></button>';

			$corpsNav.slick({
				infinite: false,
				swipe: false,
				draggable: false,
				prevArrow: prevArrowSrc,
				nextArrow: nextArrowSrc,
				asNavFor: CLASSES.B_MONTHS_CORPS + ', ' + CLASSES.B_CONTENT_CORPS
			}).on('beforeChange', function (event, slick, currentSlide, nextSlide) {
				$monthsNav.slick('slickGoTo', 0);
				$monthsContent.slick('slickGoTo', 0);
			});

			$monthsCorpsNav.slick({
				infinite: false,
				swipe: false,
				draggable: false,
				arrows: false
				// asNavFor: CLASSES.B_CORPS,
			});

			$monthsNav.slick({
				infinite: true,
				swipe: false,
				draggable: false,
				prevArrow: prevArrowSrc,
				nextArrow: nextArrowSrc,
				asNavFor: CLASSES.B_CONTENT_MONTHS
			}).on('beforeChange', function (event, slick, currentSlide, nextSlide) {
				$monthContent.slick('slickGoTo', 0);
			});

			// $('.building-months-corp .slick-prev, .building-months-corp .slick-next').on('click', function(){
			//   var $monthsNav = $(this).parents('.building-months-corp').find(CLASSES.B_MONTHS);
			//   var slick = $monthsNav.slick('getSlick');

			//   if (slick.currentSlide === 0) {
			//     console.log('if worked');
			//     $monthsNav.slick('slickGoTo', slick.slideCount);
			//   } else if (slick.currentSlide + 1 === slick.slideCount) {
			//     console.log('else if worked');
			//     $monthsNav.slick('slickGoTo', 0);
			//   }
			// });

			$corpsContent.slick({
				infinite: false,
				swipe: false,
				draggable: false,
				lazyLoad: 'progressive',
				arrows: false
			});

			$monthsContent.slick({
				infinite: true,
				swipe: false,
				draggable: false,
				arrows: false,
				lazyLoad: 'progressive'
				// asNavFor: CLASSES.B_MONTHS,
			}).on('beforeChange', function (event, slick, currentSlide, nextSlide) {
				$monthContent.slick('slickGoTo', 0);
			});

			$monthContent.slick({
				infinite: true,
				swipe: false,
				draggable: false,
				lazyLoad: 'progressive',
				prevArrow: prevArrowBigSrc,
				nextArrow: nextArrowBigSrc
			});

			$('.building-content-month.slick-cloned').slick({
				infinite: true,
				swipe: false,
				draggable: false,
				arrows: false,
				lazyLoad: 'progressive'
				// asNavFor: CLASSES.B_MONTHS,
			}).on('beforeChange', function (event, slick, currentSlide, nextSlide) {
				$monthContent.slick('slickGoTo', 0);
			});
		};
		if ($('.social-button').length) {
			$(document).ready(function () {
				(function ($, w, d, undefined) {

					function getParam(key) {
						if (key) {
							var pairs = top.location.search.replace(/^\?/, '').split('&');

							for (var i in pairs) {
								var current = pairs[i];
								var match = current.match(/([^=]*)=(\w*)/);

								if (match[1] === key) {
									return decodeURIComponent(match[2]);
								}
							}
						}
						return false;
					}

					var ButtonConfiguration = function ButtonConfiguration(params) {
						if (params) {
							return $.extend(true, {}, ButtonConfiguration.defaults, params);
						}

						return ButtonConfiguration.defaults;
					};

					ButtonConfiguration.defaults = {
						selectors: {
							facebookButton: '.social-button_facebook',
							twitterButton: false,
							vkontakteButton: '.social-button_vk',

							count: '.social-button__counter',
							ico: false,

							shareTitle: "title",
							shareSumary: "description",
							shareImages: "image"
						},

						buttonDepth: 2,
						// alternativeImage: typeof $('meta[itemprop="image"]') !== 'undefined' ? $('meta[itemprop="image"]')[0].content : false,
						alternativeSummary: $('meta[property="og:description"]').length ? $('meta[property="og:description"]')[0].content : false,
						alternativeTitle: $('meta[property="og:title"]').length ? $('meta[property="og:title"]')[0].content : false,
						alternativeImage: $('meta[property="og:image"]').length ? $('meta[property="og:image"]')[0].content : false,
						// alternativeSummary: " ",
						// alternativeTitle: " ",
						forceAlternativeImage: true,
						forceAlternativeSummary: true,
						forceAlternativeTitle: true,

						classes: {
							countVisibleClass: 'like-not-empty'
						},

						keys: {
							shareLinkParam: 'href'
						},

						popupWindowOptions: ['left=0', 'top=0', 'width=500', 'height=250', 'personalbar=0', 'toolbar=0', 'scrollbars=1', 'resizable=1']
					};

					var Button = function Button() {};
					Button.lastIndex = 0;

					Button.prototype = {
						/*@methods*/
						init: function init($context, conf, index) {
							this.config = conf;
							this.index = index;

							this.$context = $context;
							this.$count = $(this.config.selectors.count, this.$context);
							this.$ico = $(this.config.selectors.ico, this.$context);

							this.collectShareInfo();
							this.bindEvents();
							this.ajaxRequest = this.countLikes();
						},

						bindEvents: function bindEvents() {
							this.$context.bind('click', this, this.openShareWindow);

							this.$ico.bind('click', Button.returnFalse);
						},

						setCountValue: function setCountValue(count) {
							this.$context.addClass(this.config.classes.countVisibleClass);

							this.$count.text(count);
						},

						getCountLink: function getCountLink(url) {
							return this.countServiceUrl + encodeURIComponent(url);
						},

						collectShareInfo: function collectShareInfo() {
							var $parent = this.$context,
							    button = this;

							for (var i = 0; i < this.config.buttonDepth; i++) {
								$parent = $parent.parent();
							}

							var href = this.$context.attr(this.config.keys.shareLinkParam),
							    origin = w.location.origin || w.location.href.replace(new RegExp(w.location.pathname + w.location.search + '$'), '');

							this.linkToShare = href;

							if (!href) {
								href = w.location.origin + w.location.pathname;
							} else if (href.indexOf('http://') == -1 & href.indexOf('https://') == -1) {
								this.linkToShare = href[0] == '/' ? origin + href : origin + w.location.pathname + href;
							}

							var $title = $(this.$context).data(this.config.selectors.shareTitle),
							    $summary = $(this.$context).data(this.config.selectors.shareSumary),
							    $images = $(this.$context).data(this.config.selectors.shareImages);

							this.title = $title;
							if (this.config.forceAlternativeTitle) {
								this.title = this.config.alternativeTitle;
							} else if (typeof $title != 'undefined' && $title.length == 0 && this.config.alternativeTitle) {
								this.title = this.config.alternativeTitle;
							} else {
								this.title = d.title;
							}

							if (typeof $summary != 'undefined' && !this.config.forceAlternativeSummary) {
								this.summary = $summary;
							} else {
								this.summary = this.config.alternativeSummary ? this.config.alternativeSummary : undefined;
							}

							this.images = [];

							if (typeof $images != 'undefined' && $images.length > 0 && !this.config.forceAlternativeImage) {
								$images.each(function (index, element) {
									button.images[index] = element;
								});
							} else {
								this.images[0] = this.config.alternativeImage ? this.config.alternativeImage : undefined;
							}
						},

						getPopupOptions: function getPopupOptions() {
							return this.config.popupWindowOptions.join(',');
						},

						openShareWindow: function openShareWindow(e) {
							e.preventDefault();
							var button = e.data,
							    shareUri = button.getShareLink(),
							    windowOptions = button.getPopupOptions();
							var newWindow = w.open(shareUri, '', windowOptions);

							if (w.focus) {
								newWindow.focus();
							}
						},

						/*@properties*/
						linkToShare: null,
						title: d.title,
						summary: null,
						images: [],

						countServiceUrl: null,
						$context: null,
						$count: null,
						$ico: null
					};

					Button = $.extend(Button, {
						/*@methods*/
						returnFalse: function returnFalse(e) {
							return false;
						}
						/*@properties*/
					});

					var FacebookButton = function FacebookButton($context, conf, index) {
						this.init($context, conf, index);
						this.type = 'facebook';
					};

					FacebookButton.prototype = new Button();
					FacebookButton.prototype = $.extend(FacebookButton.prototype, {
						/*@methods*/
						countLikes: function countLikes() {
							var serviceURI = this.getCountLink(this.linkToShare),
							    execContext = this;

							return $.ajax({
								url: serviceURI,
								dataType: 'jsonp',
								success: function success(data, status, jqXHR) {
									if (status == 'success' && data[0]) {
										if (data[0].share_count > 0) {
											execContext.setCountValue(data[0].share_count);
										}
									}
								}
							});
						},

						getCountLink: function getCountLink(url) {
							var fql = 'SELECT share_count FROM link_stat WHERE url="' + url + '"';
							return this.countServiceUrl + encodeURIComponent(fql);
						},

						getShareLink: function getShareLink() {
							var images = '';

							for (var i in this.images) {
								if (typeof this.images[i] != "undefined") {
									images += '&picture=' + encodeURIComponent(this.images[i]);
								}
							}

							return 'http://www.facebook.com/sharer/sharer.php?' + 's=' + 100 + '&u=' + encodeURIComponent(this.linkToShare) + (this.summary ? '&description=' + encodeURIComponent(this.summary) : '') + '&caption=' + encodeURIComponent(this.title) + (images ? images : '');
						},

						/*@properties*/
						countServiceUrl: 'https://api.facebook.com/method/fql.query?format=json&query='
					});

					// var TwitterButton = function($context, conf, index) {
					// 	this.init($context, conf, index);
					// 	this.type = 'twitter';
					// };

					// TwitterButton.prototype = new Button;
					// TwitterButton.prototype = $.extend(TwitterButton.prototype,{
					// 	/*@methods*/
					// 	countLikes: function() {
					// 		var serviceURI = this.getCountLink(this.linkToShare),
					// 		execContext = this;

					// 		return $.ajax({
					// 			url: serviceURI,
					// 			dataType: 'jsonp',
					// 			success: function(data, status, jqXHR) {
					// 				if(status == 'success' & data.count > 0) {
					// 					execContext.setCountValue(data.count)
					// 				}
					// 			}
					// 		});
					// 	},

					// 	getShareLink: function() {
					// 		return 'https://twitter.com/share'
					// 			+ '?url=' + encodeURIComponent(this.linkToShare)
					// 			+ (this.title ? '&text=' + encodeURIComponent(this.title) : '');
					// 	},

					// 	/*@properties*/
					// 	countServiceUrl: 'http://urls.api.twitter.com/1/urls/count.json?url='
					// });


					var VkontakteButton = function VkontakteButton($context, conf, index) {
						this.init($context, conf, index);
						this.type = 'vkontakte';
					};

					VkontakteButton.prototype = new Button();
					VkontakteButton.prototype = $.extend(VkontakteButton.prototype, {
						/*@methods*/
						countLikes: function countLikes() {
							var serviceURI = this.getCountLink(this.linkToShare) + '&index=' + this.index;

							w.socialButtonCountObjects[this.index] = this;

							return $.ajax({
								url: serviceURI,
								dataType: 'jsonp'
							});
						},

						getShareLink: function getShareLink() {
							return 'http://vk.com/share.php?' + 'url=' + encodeURIComponent(this.linkToShare) + (this.summary ? '&description=' + encodeURIComponent(this.summary) : '') + '&title=' + encodeURIComponent(this.title) + '&image=' + encodeURIComponent(this.images[0]);
						},

						/*@properties*/
						countServiceUrl: 'http://vk.com/share.php?act=count&url='
					});

					//   
					w.socialButtonCountObjects = {};

					function vkShare(index, count) {
						var button = w.socialButtonCountObjects[index];
						if (count > 0) {
							button.setCountValue(count);
						}
						delete w.socialButtonCountObjects[index];
					}

					if (!w.VK) {
						w.VK = {
							Share: {
								count: function count(index, _count) {
									vkShare(index, _count);
								}
							}
						};
					} else {
						var originalVkCount = w.VK.Share.count;

						w.VK.Share.count = function (index, count) {
							vkShare(index, count);
							originalVkCount.call(w.VK.Share, index, count);
						};
					}

					$.fn.socialButton = function (config) {
						this.each(function (index, element) {
							setTimeout(function () {
								var $element = $(element),
								    conf = new ButtonConfiguration(config),
								    b = false;

								Button.lastIndex++;

								if ($element.is(conf.selectors.facebookButton)) {
									b = new FacebookButton($element, conf, Button.lastIndex);
								} else if ($element.is(conf.selectors.vkontakteButton)) {
									b = new VkontakteButton($element, conf, Button.lastIndex);
								} else if ($element.is(conf.selectors.twitterButton)) {
									b = new TwitterButton($element, conf, Button.lastIndex);
								}

								$.when(b.ajaxRequest).then(function () {
									$element.trigger('socialButton.done', [b.type]);
								}, function () {
									$element.trigger('socialButton.done', [b.type]);
								});
							}, 0);
						});

						return this;
					};
					$('.social-button_vk').socialButton();
				})(jQuery, window, document);
			});
		};
		if ($('.bank-liked').length) {
			var getBankData = function getBankData(page) {
				var bankWrapper = $('.bank-liked');
				var bankId = bankWrapper.data('bank-id');
				var bankAction = bankWrapper.attr('action');
				var bankType = bankWrapper.attr('type');

				var bankSort = $('#bank-sort');
				var bankSortBy = $('#bank-sort-by');

				if (page) var bankData = 'bank=' + bankId + '&' + bankWrapper.serialize() + '&' + page;else var bankData = 'bank=' + bankId + '&' + bankWrapper.serialize();

				var accreditedList = $('.accredited-list');

				// console.log(bankData)
				// return

				$.ajax({
					type: bankType,
					url: bankAction,
					dataType: 'html',
					data: bankData,
					success: function success(data, textStatus, jqXHR) {
						data = JSON.parse(data);

						bankPagination(data.items_total, data.items_current, data.items_per_page);

						accreditedList.html('');

						$.each(data.items, function (index, element) {

							var accreditedListItem = $('<div>', {
								class: 'accredited-list__item'
							});

							var complexAccredited = $('<a>', {
								class: 'complex-accredited',
								href: element.href
							}).appendTo(accreditedListItem);

							var complexAccreditedMedia = $('<div>', {
								class: 'complex-accredited__media'
							}).appendTo(complexAccredited);

							var complexAccreditedImage = $('<img>', {
								src: element.image
							}).appendTo(complexAccreditedMedia);

							var complexAccreditedContent = $('<div>', {
								class: 'complex-accredited__content'
							}).appendTo(complexAccredited);

							var complexAccreditedTitle = $('<div>', {
								class: 'complex-accredited__title',
								text: element.title
							}).appendTo(complexAccreditedContent);

							var complexAccreditedPrice = $('<div>', {
								class: 'complex-accredited__price',
								text: element.price
							}).appendTo(complexAccreditedContent);

							accreditedListItem.appendTo(accreditedList);
						});

						accreditedList.append($('<div>', { class: 'clearfix' }));
					}
				});
			};

			var bankPagination = function bankPagination(total, current, perPage) {

				pagesNum = Math.ceil(total / perPage);
				currentPage = Math.ceil(current / perPage);
				isFirst = current <= perPage;
				isLast = current + perPage > total;

				paginationBody = $('.pagination');

				paginationBody.html('');

				paginationRow = $("<div/>", {
					class: 'row'
				}).appendTo(paginationBody);

				paginationCol = $("<div/>", {
					class: 'col-md-2 col-sm-2'
				}).appendTo(paginationRow);

				paginationPrev = $("<div/>", {
					class: 'pagination__prev'
				}).appendTo(paginationCol);

				if (!isFirst) {
					paginationPrevButton = $("<a/>", {
						class: 'button button_yellow button_no-padding',
						href: 'page=' + (currentPage - 1),
						text: ''
					}).on('click', function (e) {
						e.preventDefault();
						getBankData($(this).attr('href'));
						// getSearchData(filter,$(this).attr('href'),true);
					}).appendTo(paginationPrev);
				}

				paginationCol = $("<div/>", {
					class: 'col-md-8 col-sm-8'
				}).appendTo(paginationRow);

				paginationItems = $("<div/>", {
					class: 'pagination__items'
				}).appendTo(paginationCol);

				paginationList = $("<ul/>", {
					class: 'pagination__list'
				}).appendTo(paginationItems);

				var range = range || 3;
				var arr = [];

				for (var i = 1; i <= pagesNum; i++) {
					if (i <= range || i > currentPage - range / 2 && i < currentPage + range / 2 || i > pagesNum - range) {

						if (arr[arr.length - 1] && i != arr[arr.length - 1] + 1) {
							arr.push('...');

							paginationListItem = $("<li/>", {
								class: currentPage == i ? 'pagination__item pagination__item_current' : 'pagination__item'
							}).appendTo(paginationList);

							paginationListLink = $("<span/>", {
								text: '...'
							}).appendTo(paginationListItem);
						}
						arr.push(i);

						paginationListItem = $("<li/>", {
							class: currentPage == i ? 'pagination__item pagination__item_current' : 'pagination__item'
						}).appendTo(paginationList);

						paginationListLink = $("<a/>", {
							href: 'page=' + i,
							text: i > 9 ? i : '0' + i
						}).on('click', function (e) {
							e.preventDefault();
							getBankData($(this).attr('href'));
							// getSearchData(filter,$(this).attr('href'),true);
						}).appendTo(paginationListItem);
					}
				}

				paginationCol = $("<div/>", {
					class: 'col-md-2 col-sm-2'
				}).appendTo(paginationRow);

				paginationNext = $("<div/>", {
					class: 'pagination__next'
				}).appendTo(paginationCol);

				if (!isLast) {
					paginationNextButton = $("<a/>", {
						class: 'button button_yellow button_no-padding',
						href: 'page=' + (currentPage + 1),
						text: ''
					}).on('click', function (e) {
						e.preventDefault();
						getBankData($(this).attr('href'));
						// getSearchData(filter,$(this).attr('href'),true);
					}).appendTo(paginationNext);
				}
			};

			$('.bank-liked .pagination a').on('click', function (e) {
				e.preventDefault();
				getBankData($(this).attr('href'));
			});

			$('#bank-sort, #bank-sort-by').on('change', function (e) {
				e.preventDefault();
				getBankData();
			});
		};
		if ($('.tgb-block').length) {
			var initTgb = function initTgb(start, showed_tgb, showed_tgb_element) {
				startid = start - 1;
				if (start <= tgbLength) {
					var tgbBlock = $(".tgb-block").eq(startid);
					tgbBlock.hide();
					var tgbParams = {
						'type': tgbBlock.data('type'),
						'promo': tgbBlock.data('promo'),
						'geocode': tgbBlock.data('geocode'),
						'sort': tgbBlock.data('sort'),
						'limit': tgbBlock.data('limit'),
						'orientation': tgbBlock.data('orientation'),
						'finder': tgbBlock.data('finder'),
						'metrika_goal': tgbBlock.data('metrika-goal'),
						'showed': showed_tgb,
						'showed_element': showed_tgb_element
					};
					$.ajax({
						url: '/ajax/tgb.php',
						data: tgbParams,
						success: function success(json) {
							start = start + 1;
							tgb_list = JSON.parse(json);
							tgb_id = Math.ceil(Math.random() * 10000);

							if (tgb_list.tgb) {
								if (start <= tgbLength) {
									if (tgb_list.showed) $.merge(showed_tgb, tgb_list.showed);
									if (tgb_list.showed_element) $.merge(showed_tgb_element, tgb_list.showed_element);
									initTgb(start, showed_tgb, showed_tgb_element);
								}
								tgb_id.toString();
								if (tgbBlock.data('orientation') != 'vertical') {
									tgbBLockListSlider = $("<div/>", {
										class: "full-slider animation-block full-slider-tgb-" + tgb_id
									}).appendTo(tgbBlock);
								}

								$.each(tgb_list.tgb, function (index, el) {

									metrikaAction = '';

									if (tgbBlock.data('metrika-goal')) {
										metrikaAction = 'yaCounter39897405.reachGoal(\'tgb_goal\',{\'tgb_name\' : \'' + el.name + '\'});';
									}

									if (tgbBlock.data('orientation') == 'vertical') {

										tgbBlockComplex = $("<a/>", {
											class: "complex animation-block article-banners__item",
											href: el.link,
											target: "_blank",
											onclick: metrikaAction
										}).appendTo(tgbBlock);

										tgbBLockComplexImage = $("<div/>", {
											class: "complex__image"
										}).appendTo(tgbBlockComplex);

										tgbBLockComplexImg = $("<img/>", {
											//class: "b-lazy",
											alt: el.name,
											src: el.image
										}).appendTo(tgbBLockComplexImage); //.attr('width',276).attr('height',200);

										tgbBlockComplexBody = $("<div/>", {
											class: "complex__body complex__body_auto-height"
										}).appendTo(tgbBlockComplex);

										tgbBlockComplexBodyHeader = $("<div/>", {
											class: "complex__header"
										}).append(el.name).appendTo(tgbBlockComplexBody);

										tgbBlockComplexBodyText = $("<div/>", {
											class: "complex__tgb__text"
										}).append(el.text).appendTo(tgbBlockComplexBody);
									} else {

										tgbBlockItem = $("<div/>", {
											class: "full-slider__item",
											id: el.id
										}).appendTo(tgbBLockListSlider);

										tgbBlockComplex = $("<div/>", {
											class: "complex"
										}).appendTo(tgbBlockItem);

										tgbBLockComplexMedia = $("<div/>", {
											class: "complex__media"
										}).appendTo(tgbBlockComplex);

										if (el.phone && el.newton) {

											tgbBlockCallback = $("<a/>", {
												class: "complex-callback",
												href: "#modal-callback-right",
												type: "button",
												"data-toggle": "modal",
												"data-form": "developer",
												"data-form-adv": el.id,
												"data-form-title": '     ' + el.building_name,
												"data-target": "#modal-callback-right"
											}).appendTo(tgbBLockComplexMedia);

											tgbBlockCallbackContainer = $("<div/>", {
												class: "complex-callback__container"
											}).appendTo(tgbBlockCallback);

											tgbBlockCallbackIcon = $("<div/>", {
												class: "complex-callback__icon"
											}).appendTo(tgbBlockCallbackContainer);

											tgbBlockCallbackIconSvg = $("<div/>", {
												class: "callback-icon"
											}).append('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 25.2 25.8" style="enable-background:new 0 0 25.2 25.8;" xml:space="preserve"><path style="fill:none;stroke:#000000;stroke-width:2;stroke-miterlimit:10;" d="M9.1,8.5L5.6,5c-0.4-0.4-1-0.4-1.4,0L1.7,7.6c-0.5,0.5-0.7,1.3-0.5,2c0.7,1.9,2.4,5.8,5.8,9.1s7.2,5.1,9.1,5.8c0.7,0.3,1.5,0.1,2-0.5l2.6-2.6c0.4-0.4,0.4-1,0-1.4l-3.4-3.4c-0.4-0.4-1-0.4-1.4,0l-2.1,2.1c0,0-2.3-1-4.1-2.8C8,14.3,7,11.9,7,11.9l2.1-2.1C9.5,9.5,9.5,8.8,9.1,8.5z"/><path style="fill:none;stroke:#000000;stroke-width:2;stroke-miterlimit:10;" d="M18.1,8.7 14.1,4.7 18.1,0.7 "/><path style="fill:none;stroke:#000000;stroke-width:2;stroke-miterlimit:10;" d="M14.1,4.7h6c2.2,0,4,1.8,4,4l0,0c0,2.2-1.8,4-4,4h-1"/></svg>').appendTo(tgbBlockCallbackIcon);

											tgbBlockCallbackButton = $("<div/>", {
												class: "complex-callback__text"
											}).append(' ').appendTo(tgbBlockCallbackContainer);
										}

										tgbBLockComplexImage = $("<div/>", {
											class: "complex__image"
										}).appendTo(tgbBLockComplexMedia);

										tgbBLockComplexImg = $("<img/>", {
											//class: "b-lazy",
											alt: el.name,
											src: el.image
										}).appendTo(tgbBLockComplexImage).attr('width', 276).attr('height', 200);

										tgbBLockComplexBody = $("<a/>", {
											class: "complex__body",
											target: "_blank",
											href: el.link,
											onclick: metrikaAction
										}).appendTo(tgbBlockComplex);

										tgbBLockComplexBodyHeader = $("<div/>", {
											class: "complex__header"
										}).appendTo(tgbBLockComplexBody);
										tgbBLockComplexBodyHeader.html(el.name);

										tgbBLockComplexBodyText = $("<div/>", {
											class: "complex__tgb__text"
										}).appendTo(tgbBLockComplexBody);
										tgbBLockComplexBodyText.html(el.text);
									}
								});

								if (tgbBlock.data('orientation') != 'vertical') {

									tgbSliderContainer = $("<div/>", {
										class: "container"
									}).appendTo(tgbBlock);
									tgbSliderNavigation = $("<div/>", {
										class: "slider-navigation"
									}).appendTo(tgbSliderContainer);

									$('.full-slider-tgb-' + tgb_id).each(function (_this) {

										return function (index, element) {

											var appender = $(element).siblings('.container').children('.slider-navigation');
											var slickSlider = $(element).slick({
												cssEase: 'ease-out',
												infinite: true,
												// infinite: false,
												speed: 1000,
												// autoplay: true,
												// autoplaySpeed: 8000,
												centerMode: true,
												slidesToShow: 7,
												slidesToScroll: 7,
												variableWidth: true,
												arrows: false,
												lazyLoad: 'ondemand',
												// appendArrows: appender,
												// prevArrow: fullSliderNavLeft,
												// nextArrow: fullSliderNavRight,
												responsive: [{
													breakpoint: 1980,
													settings: {
														slidesToShow: 5,
														slidesToScroll: 5,
														speed: 600
													}
												}, {
													breakpoint: 1460,
													settings: {
														slidesToShow: 3,
														speed: 450
													}
												}, {
													breakpoint: 860,
													settings: {
														slidesToShow: 1,
														speed: 300
													}
												}]
											}).on('afterChange', function () {
												bLazy.revalidate();
											});;

											slickSlider.slick('slickGoTo', 0);

											var changeInterval = setInterval(function () {
												slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').currentSlide + slickSlider.slick('getSlick').options.slidesToShow);
											}, 8000);

											var fullSliderNavLeft = $('<button>', {
												"type": "button",
												"data-role": "none",
												"class": "full-slider__arrow slick-prev",
												"aria-label": "Previous",
												"role": "button"
											}).append($('<i>', {
												"class": "fa fa-angle-left"
											})).on('click', function (e) {
												if (slickSlider.slick('getSlick').currentSlide < slickSlider.slick('getSlick').options.slidesToShow) {
													slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').slideCount - slickSlider.slick('getSlick').options.slidesToShow);
												} else {
													slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').currentSlide - slickSlider.slick('getSlick').options.slidesToShow);
												}
												clearInterval(changeInterval);
												changeInterval = setInterval(function () {
													slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').currentSlide + slickSlider.slick('getSlick').options.slidesToShow);
												}, 8000);
											});

											var fullSliderNavRight = $('<button>', {
												"type": "button",
												"data-role": "none",
												"class": "full-slider__arrow slick-next",
												"aria-label": "Previous",
												"role": "button"
											}).append($('<i>', {
												"class": "fa fa-angle-right"
											})).on('click', function (e) {
												slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').currentSlide + slickSlider.slick('getSlick').options.slidesToShow);
												clearInterval(changeInterval);
												changeInterval = setInterval(function () {
													slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').currentSlide + slickSlider.slick('getSlick').options.slidesToShow);
												}, 8000);
											});

											$(element).hover(function () {
												clearInterval(changeInterval);
											}, function () {
												changeInterval = setInterval(function () {
													slickSlider.slick('slickGoTo', slickSlider.slick('getSlick').currentSlide + slickSlider.slick('getSlick').options.slidesToShow);
												}, 8000);
											});

											appender.append([fullSliderNavLeft, fullSliderNavRight]);
										};
									}(this));
								}

								tgbBlock.show();

								if ('.articles__item'.length) {
									$('.articles__item').each(function (index, article) {
										hideBanners($(article));
									});
								}
							}
						}
					});
				}
			};

			tgbLength = $(".tgb-block").length;

			if (tgbLength > 0) {
				js_slider_showed = [];
				if (typeof slider_showed != "undefined") {
					js_slider_showed = slider_showed;
				}
				initTgb(1, js_slider_showed, []);
			}
		};
		if ($('#modal-competition').length) {
			var modalCompetition = $('#modal-competition');

			modalCompetition.modal('show');
			modalCompetition.on('hidden.bs.modal', function () {
				$('.button_competition').removeClass('button_unvisible');
			});
		}
		if ($('.js-comments').length) {
			//
			// // collapse
			// var collapse_target = $('.js-comments-collapse'),
			//     collapseGroup = $('.comments__collapse-group');
			//
			// collapse_target.on('click', function(e){
			//         var th            = $(this),
			//             body          = th.closest('.comments__body'),
			//             collapseGroup = body.find('.comments__collapse-group');
			//
			//         collapseGroup.collapse('toggle');
			//
			//     e.preventDefault();
			// });
			// collapseGroup.on('show.bs.collapse', function(){
			//     var th            = $(this),
			//         body          = th.closest('.comments__body'),
			//         collapseGroup = body.find('.js-comments-collapse');
			//
			//     collapseGroup.text(' ');
			//
			// }).on('hide.bs.collapse', function(){
			//     var th            = $(this),
			//         body          = th.closest('.comments__body'),
			//         collapseGroup = body.find('.js-comments-collapse');
			//
			//     collapseGroup.text('  ');
			// });
			// // like trigger
			// /*
			// $('.comments__likes__btn').on('click', function(e){
			//     var th = $(this),
			//         pa = th.closest('.comments__likes'),
			//         voted = parseInt(pa.attr('data-voted'));
			//
			//     if(!pa.hasClass('is-voted')){
			//         if(th.index() == 0){
			//             voted--;
			//         }else{
			//             voted++;
			//         };
			//         pa.addClass('is-voted');
			//         pa.attr('data-voted', parseInt(voted));
			//         th.children('span').text(parseInt(th.children('span').text()) + voted);
			//     };
			//     e.preventDefault();
			// });
			// */
			//
			// // star-form
			// var starForm = $('.js-star-form');
			// starForm.each(function(){
			//     var th = $(this),
			//         input = th.children('input'),
			//         emptyItems = th.find('.stars__empty i'),
			//         full = th.children('.stars__full'),
			//         currentWidth = full.css('width'),
			//         estimate__form = th.closest('.estimate__form');
			//
			//     emptyItems.on('mouseenter', function(){
			//         var item = $(this);
			//         full.css({
			//             width: ((item.index() + 1) * 20 + '%')
			//         });
			//     }).on('click', function(){
			//         var item = $(this);
			//
			//         currentWidth = ((item.index() + 1) * 20 + '%');
			//         input.val(item.index() + 1);
			//     });
			//     th.on('mouseout', function(){
			//         full.css({
			//             width: currentWidth
			//         });
			//     });
			//     if(estimate__form.length > 0){
			//         starFormReset_trigger = $('.js-estimat-form-reset');
			//
			//         starFormReset_trigger.on('click', function(e){
			//             e.preventDefault();
			//             full.css({
			//                 width: '0%'
			//             });
			//             input.val('0');
			//         });
			//     }
			// });
			//
			// // avatar-form
			// var avatarForm = $('.avatar-form');
			// $('.avatar-form').each(function(){
			//     var th = $(this),
			//         img = th.children('.avatar-form__img'),
			//         input = th.find('input[name="my-image"]'),
			//         items = th.find('.avatar-form__group').children();
			//
			//     img.on('click', function(){
			//         th.toggleClass('is-active');
			//     });
			//     items.on('click', function(){
			//         var item = $(this);
			//             style = item.attr('data-style');
			//
			//         item.addClass('is-checked').siblings('.is-checked').removeClass('is-checked');
			//         $(".sendfile2").val(style);
			//         clearAvatar();
			//         img.attr('data-style', style);
			//
			//     });
			//     input.on('change', function(){
			//         var th = this;
			//         if (th.files && th.files[0]) {
			//             var reader = new FileReader();
			//             reader.onload = function (e) {
			//
			//                 var newImg = document.createElement("img");
			//                 newImg.setAttribute("src", e.target.result);
			//                 $(".sendfile2").val(e.target.result);
			//
			//                 clearAvatar();
			//                 items.removeClass('is-checked');
			//                 img.attr('data-style', '').append(newImg);
			//             };
			//             reader.readAsDataURL(th.files[0]);
			//         }
			//     });
			//     function clearAvatar(){
			//         img.html('');
			//     }
			// });
			//
			// $('.avatar-form').fileupload({
			//   add: (e, data) => {
			//     console.log('add');
			//     data.submit()
			//   }
			// })
			//
			//
			// $('body').on('click', function(e){
			//     var th = $(e.target);
			//
			//     if(th.closest('.avatar-form').length == 0){
			//         avatarForm.removeClass('is-active');
			//     };
			// });
			//
			// /*$('.comments-send').fileupload({
			//   add: (e, data) => {
			//     alert("add");
			//     var file_extension = data.files[0]['name'].split('.').pop().toLowerCase();
			//     /*var reader = new FileReader();
			//     reader.readAsDataURL(data.files[0]);
			//
			//
			//     const view = $('.js-upload-wrap').find('.js-upload-file-target')
			//
			//     $('.js-upload-wrap').on('click', '.attached-file__close', function(){
			//
			//         const th = $(this)
			//         const item = th.parent('.attached-file');
			//         item.remove();
			//     });
			//
			//     if(file_extension == 'jpg' || file_extension == 'png'){
			//             // Closure to capture the file information.
			//       reader.onload = (function(theFile) {
			//                 return function(e) {
			//                     // Render thumbnail.
			//                     var newImg = ['<img class="thumb" src="', e.target.result, '"/>'].join('');
			//       // var input2 = document.createElement('input');
			//       // input2.setAttribute("name","files_array[]");
			//       // input2.setAttribute("type","hidden");
			//       // input2.setAttribute("class","sendfile");
			//       // input2.setAttribute("value",e.target.result);
			//       // input2.setAttribute("data-input-count-delete", inputCount);
			//       // container.prepend(input2);
			//                     view.append(createViewItem(file_extension, newImg));
			//                     // filecollection.push(theFile);
			//                 };
			//             })(data.files[0]);
			//
			//     }else{
			//         var newImg = false;
			//         reader.onload = (function(theFile) {
			//             return function(e) {
			//               // var input2 = document.createElement('input');
			//       // input2.setAttribute("name","files_array[]");
			//       // input2.setAttribute("type","hidden");
			//       // input2.setAttribute("class","sendfile");
			//       // input2.setAttribute("value",e.target.result);
			//       // input2.setAttribute("data-input-count-delete", inputCount);
			//       // container.prepend(input2);
			//                 // Render thumbnail.
			//                 view.append(createViewItem(file_extension, newImg));
			//                 // filecollection.push(theFile);
			//             };
			//         })(data.files[0]);
			//     };
			//
			//
			//     data.submit()
			// 	alert("add2");
			//     // createViewItem(file_extension: ?, newImg: string|bool, inputCount: ?)
			//
			//     alert("add2");
			//   }
			// })
			// */
			//
			// // uploding files
			//  $('.js-upload-wrap').each(function(){
			//      var pa = $(this),
			//          trigger = pa.find('.js-upload-file-trigger'),
			//          view = pa.find('.js-upload-file-target'),
			//          container = pa.find('.js-upload-inputs');
			//          var filecollection = [];
			//      	var uploadInputCount = 0;
			//
			//      trigger.on('click', function(e){
			//          uploadInputBtn(container, view, filecollection, uploadInputCount++);
			//           e.preventDefault();
			//      });
			//      pa.on('click', '.attached-file__close', function(){
			//          var th = $(this),
			//          	inputCount = th.attr('data-input-count'),
			//              item = th.parent('.attached-file');
			//              $("input[data-input-count-delete="+inputCount+"]").remove();
			//          var input = container.children('input').filter(function(){
			//              return parseInt($(this).attr('data-input-count')) == inputCount;
			//          });
			//          // console.log(input)
			//          var inputCurrentCount = parseInt(input.attr('data-input-current-count'));
			//
			//          if(inputCurrentCount > 1){
			//              input.attr('data-input-current-count', --inputCurrentCount);
			//          }else{
			//              input.remove();
			//          }
			//          item.remove();
			//          filecollection.splice(item.index(), 1);
			//      });
			//  });
			//
			//
			// function uploadInputBtn(container, view, filecollection, uploadInputCount){
			//     'use strict';
			//     var input = document.createElement('input');
			//     input.setAttribute("type", "file");
			//     input.setAttribute('accept', 'image/jpeg, image/png, image/gif, image/bmp, .xlsx, .xls, .doc, .docx, .txt, .pdf');
			//     input.setAttribute("name","files[]");
			//     input.setAttribute("multiple", "multiple");
			//     input.setAttribute("data-input-count", uploadInputCount);
			//     input.setAttribute("data-url", "/ajax/comments_file.php");
			//     input.setAttribute("multiple", "true");
			//     var $input = $(input);
			//
			//
			//
			//     //$(".sendfile").remove();
			//
			//     container.find('input[type="file"]').not($input).each(function() {
			//         var th = $(this);
			//         if(th.val().length === 0){
			//             th.remove();
			//         };
			//     });
			//
			//     $input.on('change', function(e){
			//         var th = $(this);
			//         var inputCount = th.attr('data-input-count');
			//         var inputCountCurrentFiles = 0;
			//         var files = e.target.files;
			// 		$.each( files, function(i, file){
			//             var file_extension = files[i]['name'].split('.').pop().toLowerCase();
			//             var reader = new FileReader();
			//
			//             reader.readAsDataURL(files[i]);
			//
			//             if(file_extension == 'jpg' || file_extension == 'png'){
			//                     // Closure to capture the file information.
			//                     reader.onload = (function(theFile) {
			//                         return function(e) {
			//                             // Render thumbnail.
			//                             var newImg = ['<img class="thumb" src="', e.target.result, '"/>'].join('');
			// 							//var input2 = document.createElement('input');
			// 							//input2.setAttribute("name","files_array[]");
			// 							//input2.setAttribute("type","hidden");
			// 							//input2.setAttribute("class","sendfile");
			// 							//input2.setAttribute("value",e.target.result);
			// 							//input2.setAttribute("data-input-count-delete", inputCount);
			// 							//container.prepend(input2);
			//                             view.append(createViewItem(file_extension, newImg, inputCount));
			//                             filecollection.push(theFile);
			//                         };
			//                     })(files[i]);
			//
			//             }else{
			//                 var newImg = false;
			//                 reader.onload = (function(theFile) {
			//                     return function(e) {
			// 	                    //var input2 = document.createElement('input');
			// 							//input2.setAttribute("name","files_array[]");
			// 							//input2.setAttribute("type","hidden");
			// 							//input2.setAttribute("class","sendfile");
			// 							//input2.setAttribute("value",e.target.result);
			// 							//input2.setAttribute("data-input-count-delete", inputCount);
			// 							//container.prepend(input2);
			//                         // Render thumbnail.
			//                         view.append(createViewItem(file_extension, newImg, inputCount));
			//                         filecollection.push(theFile);
			//                     };
			//                 })(files[i]);
			//             };
			//             th.attr('data-input-current-count', ++inputCountCurrentFiles);
			//         });
			//
			//     });
			//
			//     container.prepend(input);
			//
			//     $input.fileupload({
			//         add: function (e, data) {
			//             data.submit();
			//         },
			//         done: function (e, data) {
			// 	        var th = $(this);
			// 			var inputCount = th.attr('data-input-count');
			// 	    	if(JSON.parse(data.result)) {
			// 		    	$.each(JSON.parse(data.result), function(index, value) {
			// 							var input2 = document.createElement('input');
			// 							input2.setAttribute("name","files_array[]");
			// 							input2.setAttribute("type","hidden");
			// 							input2.setAttribute("value",value);
			// 							input2.setAttribute("data-input-count-delete", inputCount);
			// 							container.prepend(input2);
			// 				});
			// 	    	}
			//         },
			// 	});
			//
			//     setTimeout(function(){
			//         $input.click();
			//
			//     }, 300);
			// };
			// function filterTitle(file_extension){
			//     if(file_extension == 'jpg' || file_extension == 'png'){
			//         return '';
			//     }else if(file_extension == 'txt' || file_extension == 'docx' || file_extension == 'doc'){
			//         return '';
			//     }else if(file_extension == 'xlsx' || file_extension == 'xls'){
			//         return '';
			//     }else if(file_extension == 'ppt' || file_extension == 'pps' || file_extension == 'pptx'){
			//         return '';
			//     }
			// }
			// function createViewItem(file_extension, newImg){
			//     var template = '';
			//
			//     template += '<div class="attached-file" title="">';
			//     template +=     '<div class="attached-file__close"><svg class="icon icon-close-xs"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#icon-close-xs"></use></svg></div>';
			//     template +=     '<div class="attached-file__img">';
			//     if(newImg){
			//
			//         template +=         newImg;
			//     }else{
			//         template +=         '<svg class="icon icon-attached-file"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#icon-attached-file"></use></svg>';
			//     }
			//     template +=         '<div class="attached-file__tag">' + file_extension + '</div>';
			//     template +=     '</div>';
			//     template +=     '<div class="attached-file__ttl">' + filterTitle(file_extension) + '</div>';
			//     template += '</div>';
			//
			//     return template;
			// }
			// //
			// // $('.js-send-trigger').on('click', function(e){
			// //   console.log('clock');
			// //     e.preventDefault();
			// //     var th = $(this),
			// //         pa = th.closest('.modal-form-js'),
			// //         message = pa.next('.js-message-target');
			// //
			// //     pa.collapse('hide');
			// //     pa.on('hidden.bs.collapse', function(){
			// //         message.collapse('show');
			// //     });
			// // });
			// $('[data-target="#modal-feedback"]').on('click',function(){
			// 	var el = $(this);
			// 	$("#comments-type").val(el.data('type'));
			// 	$("#comments-element-id").val(el.data('element-id'));
			// 	$("#comments-review").val(el.data('review'));
			// 	$("#comments-review-top").val(el.data('review-top'));
			// 	if(el.data('review') > 0) {
			// 		$("#modal-feedback .hide-for-comment").addClass('hide');
			// 	} else {
			// 		$("#modal-feedback .hide-for-comment").removeClass('hide');
			// 	}
			//     if (el.data('type') == 'news') {
			//         $("#modal-feedback .hide-for-news").addClass('hide');
			//     } else if (el.data('type') == 'articles') {
			// 		$("#modal-feedback .hide-for-articles").addClass('hide');
			// 	}
			//   if (el.data('type') == 'interview') {
			//     $("#modal-feedback .hide-for-interview").addClass('hide');
			//   }
			// });
			// $('#modal-feedback').on('hidden.bs.modal', function(){
			//     var th = $(this);
			//     th.find('.modal-form-js').collapse('show');
			//     th.find('.js-message-target').collapse('hide');
			//     th.find('.error-msg').empty();
			// });
			// /*$('#modal-feedback-error').on('hidden.bs.modal', function(){
			//     $('#modal-feedback').modal("show");
			// });*/
			// $('body').on('click', '.js-add-commets', function(e){
			//     var th = $(this),
			//         pa = th.closest('.comments__item__inner'),
			//         form;
			//
			//     if (pa.length) {
			//       form = pa.next('.comments__item__form');
			//     }
			//     else{
			//       pa = th.closest('.comments__item')
			//       form = pa.children('.comments__item__form');
			//     }
			//
			//     // console.log(inner)
			//     form.collapse('toggle');
			//     e.preventDefault();
			// });
			// $('.comments-auth').on('click',function(){
			// var el = $(this);
			// provider = el.data('provider');
			// w = 600;
			// h = 400;
			// var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;
			// var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;
			// var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
			// var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;
			// var left = ((width / 2) - (w / 2)) + dualScreenLeft;
			// var top = ((height / 2) - (h / 2)) + dualScreenTop;
			// var newWindow = window.open('/ajax/social_auth.php?auth_via='+provider+'&social=entry', '', 'scrollbars=yes, width=' + w + ', height=' + h + ', top=' + top + ', left=' + left);
			// if (window.focus) {
			//     newWindow.focus();
			// }
			// var timer = setInterval(function () {
			//        if (newWindow.document.getElementsByClassName('game-account-user__name').length > 0){
			// 	     newWindow.close();
			//          $('.comments-logged').removeClass('hide');
			// 		 $('.comments-not-logged').addClass('hide');
			// 		 $('.comments-send input[name="auth-type"]').val('social');
			//          setTimeout(function(){
			//          clearInterval(timer);
			//        } , 100);
			//      }
			//    }, 200);
			// });
			// /*
			// $('.comments-email-register').on('click',function(){
			// var el = $(this);
			// el.attr("disabled","disabled");
			// newEmail = $('#comments-email-register').val();
			// newName = $('#comments-name-register').val();
			// newPassword = $('#comments-password-register').val();
			// $.ajax({
			//   url: '/ajax/comments_user.php',
			//   data: 'name='+newName+'&email='+newEmail+'&password='+newPassword,
			//   success: function(data){
			//     req = JSON.parse(data);
			//     if(req.error){
			// 	    alert(req.error);
			//     } else if(req.success){
			// 	    $(".comments-hide-after-auth").addClass('hide');
			// 	    $(".comments-hide-after-logout").removeClass('hide');
			//     }
			//     el.removeAttr('disabled');
			//   }
			// });
			// return false;
			// });
			//
			// $('.comments-email-auth').on('click',function(){
			// var el = $(this);
			// el.attr("disabled","disabled");
			// newEmail = $('#comments-email-auth').val();
			// newPassword = $('#comments-password-auth').val();
			// $.ajax({
			//   url: '/ajax/comments_user.php',
			//   data: 'email='+newEmail+'&password='+newPassword,
			//   success: function(data){
			//     req = JSON.parse(data);
			//     if(req.error){
			// 	    alert(req.error);
			//     } else if(req.success){
			// 	    $(".comments-hide-after-auth").addClass('hide');
			// 	    $(".comments-hide-after-logout").removeClass('hide');
			//     }
			//     if(req.name){
			//     	$("#comments-name").val(req.name);
			//     }
			//     el.removeAttr('disabled');
			//   }
			// });
			// return false;
			// });
			//
			//
			// $('.comments-send').on('click',function(){
			//
			//
			// 	var el = $(this);
			// 	el.attr("disabled","disabled");
			// 	$.ajax({
			// 	  url: '/ajax/comments_send.php',
			// 	  data: $('#comments-form').serialize(),
			// 	  type: 'POST',
			// 	  success: function(data){
			// 	    req = JSON.parse(data);
			// 	    if(req.error){
			// 		    alert(req.error);
			// 	    } else if(req.success){
			// 			    $("#comments-text").val("");
			// 	    		$("#modal-feedback").find('.modal-form-js2').collapse('hide');
			// 	    		$("#modal-feedback").find('.js-message-target').collapse('show');
			// 	    		$("#modal-feedback").on('hidden.bs.modal', function() {
			// 				$("#modal-feedback").find('.modal-form-js2').collapse('show');
			// 				$("#modal-feedback").find('.js-message-target').collapse('hide');
			// 				});
			//
			// 	    }
			// 	    el.removeAttr('disabled');
			// 	  }
			// 	});
			// 	return false;
			// });
			// */
			// let prevTab;
			//
			// function makeRequired() {
			//   $activeTab = $('.tab-pane.active')
			//   prevTab = $activeTab
			//   $activeTab.find('[data-required]').attr('required', true)
			// }
			//
			// makeRequired()
			//
			// $('.js-required').on('click', (e) => {
			//   $target = $(e.target)
			//   $thisHref = $target.attr('href')
			//   if (prevTab) {
			//     prevTab.find('[data-required]').attr('required', false)
			//   }
			//   prevtab = $($thisHref)
			//   $($thisHref).find('[data-required]').attr('required', true)
			// })
			//
			//
			//
			// $('.set-auth-type').on('click',function (){
			// 	el = $(this);
			// 	el.closest('form').find('input[name="auth-type"]').val(el.data("auth-type"));
			// 	if (el.data("auth-type") == 'guest') {
			// 		$(".hide-for-guest").addClass('hide');
			// 	} else {
			// 		$(".hide-for-guest").removeClass('hide');
			// 	}
			// })
			//
			// $('.comments-logout').on('click',function(e){
			// 	e.preventDefault();
			// 	el = $(this);
			// 	form = el.closest('form');
			// 	form.find('.js-upload-file-target').html("");
			// 	form.find('.js-upload-inputs').html("");
			// 	$.ajax({
			// 	  url: '/ajax/comments_logout.php',
			// 	  success: function(data){
			// 	    req = JSON.parse(data);
			// 	    if(req.success){
			// 		    $(".comments-not-logged").removeClass('hide');
			// 		    $(".comments-logged").addClass('hide');
			// 		    //$('.comments-send input[name="auth-type"]').val('register');
			// 	    }
			// 	  }
			// 	});
			// });
			// $('.comments-send-mes').on('submit',function(e){
			// 	e.preventDefault();
			// 	var el = $(this);
			// 	button = el.find('button[type="submit"]');
			// 	button.attr("disabled","disabled");
			// 	$.ajax({
			// 	  url: '/ajax/comments_send.php',
			// 	  data: el.serialize(),
			// 	  type: 'POST',
			// 	  success: function(data){
			// 	    req = JSON.parse(data);
			// 	    if(req.user_auth == 'no') {
			// 		    $("#comments-type").val(el.find('[name="type"]').val());
			// 			$("#comments-element-id").val(el.find('[name="element-id"]').val());
			// 			$("#comments-review").val(el.find('[name="review"]').val());
			// 			$("#comments-review-top").val(el.find('[name="review-top"]').val());
			// 			$("#fd-id-1").val(el.find('[name="text"]').val());
			// 			$("#modal-feedback .hide-for-comment").addClass('hide');
			// 			$("#modal-feedback").modal('show');
			// 	    } else {
			// 		    if(req.error){
			// 			    messageHtml = '';
			// 			    $.each(req.error, function (e, t) {
			// 	                messageHtml += '<p>' + t + '</p>';
			// 	            });
			// 			    $("#modal-feedback-comment-error-text").html(messageHtml);
			// 			    $("#modal-feedback-comment-error").modal("show");
			// 		    } else if(req.success){
			// 			    el.find('textarea[name="text"]').val("");
			// 			    $(this).find('textarea[name="text"]').val("");
			// 			    $("#modal-feedback-comment").modal('show');
			// 		    }
			// 	    }
			//
			// 	    button.removeAttr('disabled');
			// 	  }
			// 	});
			// });
			//
			// // $("#modal-feedback").find('button[type="submit"]').on('click', (e) => {
			// //   // console.log($("#modal-feedback").find("input:invalid")[0]);
			// //   $("#modal-feedback").find("input:invalid").focus()
			// // })
			//
			// let error = 0
			//
			// function validateField(context, name) {
			//
			//   const $authType = $('input[name="auth-type"]').val()
			//
			//   function validateEmail(email) {
			//     var regExp = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
			//     return regExp.test(email);
			//   }
			//
			//   switch (name) {
			//     case 'name':
			//       if (context.val() === '') {
			//         context.next('.error-msg').empty()
			//         context.next('.error-msg').html(' ')
			//         context.addClass('_has-error')
			//         // context.focus()
			//         error = 1
			//       } else {
			//         context.next('.error-msg').empty()
			//         context.removeClass('_has-error')
			//         error = 0
			//       }
			//       break;
			//
			//     case 'register-email':
			//       if ($authType === 'register') {
			//         if (!validateEmail(context.val())) {
			//           context.next('.error-msg').empty()
			//           context.next('.error-msg').html('  e-mail')
			//           context.addClass('_has-error')
			//         //   context.focus()
			//           error = 1
			//         } else {
			//           context.next('.error-msg').empty()
			//           context.removeClass('_has-error')
			//           error = 0
			//         }
			//       }
			//
			//       break;
			//
			//     case 'auth-email':
			//       if ($authType === 'auth') {
			//         if (!validateEmail(context.val())) {
			//           context.next('.error-msg').empty()
			//           context.next('.error-msg').html('  e-mail')
			//           context.addClass('_has-error')
			//         //   context.focus()
			//           error = 1
			//         } else {
			//           context.next('.error-msg').empty()
			//           context.removeClass('_has-error')
			//           error = 0
			//         }
			//       }
			//       break;
			//
			//     case 'auth-password':
			//       if ($authType === 'auth') {
			//         if (context.val() === '' || context.val().length < 8 ) {
			//           context.next('.error-msg').empty()
			//           context.next('.error-msg').html('  8 ')
			//           context.addClass('_has-error')
			//         //   context.focus()
			//           error = 1
			//         } else {
			//           context.next('.error-msg').empty()
			//           context.removeClass('_has-error')
			//           error = 0
			//         }
			//
			//       }
			//
			//       break;
			//
			//     case 'register-password':
			//       if ($authType === 'register') {
			//         if (context.val() === '' || context.val().length < 8 ) {
			//           context.next('.error-msg').empty()
			//           context.next('.error-msg').html('  8 ')
			//           context.addClass('_has-error')
			//         //   context.focus()
			//           error = 1
			//         } else {
			//           context.next('.error-msg').empty()
			//           context.removeClass('_has-error')
			//           error = 0
			//         }
			//
			//       }
			//       break;
			//
			//     case 'text':
			//       if (context.val().length < 10) {
			//         context.next('.error-msg').empty()
			//         context.next('.error-msg').html('  10 ')
			//         context.addClass('_has-error')
			//         // context.focus()
			//         error = 1
			//       } else {
			//         context.next('.error-msg').empty()
			//         context.removeClass('_has-error')
			//         error = 0
			//       }
			//       break;
			//
			//     // case 'dignity':
			//     //   if (!$.trim(context.val())) {
			//     //     context.next('.error-msg').empty()
			//     //     context.next('.error-msg').html(' ')
			//     //     context.addClass('_has-error')
			//     //     context.focus()
			//     //     error = 1
			//     //   } else {
			//     //     context.next('.error-msg').empty()
			//     //     context.removeClass('_has-error')
			//     //     error = 0
			//     //   }
			//     //   break;
			//     //
			//     // case 'fault':
			//     //   if (!$.trim(context.val())) {
			//     //     context.next('.error-msg').empty()
			//     //     context.next('.error-msg').html(' ')
			//     //     context.addClass('_has-error')
			//     //     context.focus()
			//     //     error = 1
			//     //   } else {
			//     //     context.next('.error-msg').empty()
			//     //     context.removeClass('_has-error')
			//     //     error = 0
			//     //   }
			//     //   break;
			//   }
			// }
			//
			// $('.comments-send .form-control').on('blur', (e) => {
			//   const $this = $(e.target)
			//   const $name = $this.attr('name')
			//
			//   validateField($this, $name)
			// })
			//
			// $('.comments-send').on('submit',function (e){
			// 	e.preventDefault();
			// 	$("#modal-feedback").find('.info-messages').empty();
			// 	var el = $(this);
			// 	button = el.find('button[type="submit"]');
			//   const $inputs = el.find('.form-control')
			//
			//   $inputs.each(function() {
			//     const $this = $(this)
			//     const $name = $this.attr('name')
			//     validateField($this, $name)
			//   })
			//
			//   if (error) return false;
			//
			// 	button.attr("disabled","disabled");
			//
			// 	$.ajax({
			// 	  url: '/ajax/comments_send.php',
			// 	  data: el.serialize(),
			// 	  type: 'POST',
			// 	  success: function(data){
			// 	    req = JSON.parse(data);
			// 	    if(req.error){
			// 		    messageHtml = '';
			// 		    $.each(req.error, function (e, t) {
			//                 messageHtml += '<p>' + t + '</p>';
			//             });
			// 		    // $("#modal-feedback-error-text").html(messageHtml);
			// 		    $("#modal-feedback").find('.info-messages').html(messageHtml)
			// 		    // $("#modal-feedback-error").modal("show");
			// 	    } else if(req.success){
			// 			    el.find('textarea[name="text"]').val("");
			// 			    el.find('.js-upload-file-target').html("");
			// 			    el.find('.js-upload-inputs').html("");
			// 			    el.find('.error-msg').empty();
			// 	    		$("#modal-feedback").find('.modal-form-js2').collapse('hide');
			// 	    		$("#modal-feedback").find('.js-message-target').collapse('show');
			// 	    		$("#modal-feedback").on('hidden.bs.modal', function() {
			// 				$("#modal-feedback").find('.modal-form-js2').collapse('show');
			// 				$("#modal-feedback").find('.js-message-target').collapse('hide');
			// 				});
			//
			// 	    }
			// 	    if(req.action == 'afterRegister' || req.action == 'afterAuth'){
			// 		    $('.comments-logged').removeClass('hide');
			// 		    $('.comments-not-logged').addClass('hide');
			// 	    }
			// 	    button.removeAttr('disabled');
			// 	  }
			// 	});
			// })
			// $('.comments-likes-btn').on('click',function(e){
			// 	e.preventDefault();
			// 	var el = $(this);
			// 	$.ajax({
			// 	  url: '/ajax/comments_likes.php',
			// 	  data: {comment: el.data('comment'), like: el.data('like')},
			// 	  type: 'POST',
			// 	  success: function(data){
			// 	    req = JSON.parse(data);
			// 	    if(req.count || req.count == 0){
			// 		    el.find('span').html(req.count);
			// 	    }
			// 	    if(req.count2 || req.count2 == 0){
			// 		    el.siblings().find('span').html(req.count2)
			// 	    }
			// 	  }
			// 	});
			// })
		};
		if ($('.gh-header').length) {
			//============================================================
			//
			// The MIT License
			//
			// Copyright (C) 2014 Matthew Wagerfield - @wagerfield
			//
			// Permission is hereby granted, free of charge, to any
			// person obtaining a copy of this software and associated
			// documentation files (the "Software"), to deal in the
			// Software without restriction, including without limitation
			// the rights to use, copy, modify, merge, publish, distribute,
			// sublicense, and/or sell copies of the Software, and to
			// permit persons to whom the Software is furnished to do
			// so, subject to the following conditions:
			//
			// The above copyright notice and this permission notice
			// shall be included in all copies or substantial portions
			// of the Software.
			//
			// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY
			// OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
			// LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
			// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
			// EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
			// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
			// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
			// OR OTHER DEALINGS IN THE SOFTWARE.
			//
			//============================================================

			/**
    * jQuery || Zepto Parallax Plugin
    * @author Matthew Wagerfield - @wagerfield
    * @description Creates a parallax effect between an array of layers,
    *              driving the motion from the gyroscope output of a smartdevice.
    *              If no gyroscope is available, the cursor position is used.
    */
			;(function ($, window, document, undefined) {

				// Strict Mode
				'use strict';

				// Constants

				var NAME = 'parallax';
				var MAGIC_NUMBER = 30;
				var DEFAULTS = {
					relativeInput: false,
					clipRelativeInput: false,
					calibrationThreshold: 500,
					calibrationDelay: 500,
					supportDelay: 500,
					calibrateX: false,
					calibrateY: true,
					invertX: true,
					invertY: true,
					limitX: false,
					limitY: false,
					scalarX: 10.0,
					scalarY: 10.0,
					frictionX: 0.1,
					frictionY: 0.1,
					originX: 0.5,
					originY: 0.5
				};

				function Plugin(element, options) {

					// DOM Context
					this.element = element;

					// Selections
					this.$context = $(element).data('api', this);
					this.$layers = this.$context.find('.layer');

					// Data Extraction
					var data = {
						calibrateX: this.$context.data('calibrate-x') || null,
						calibrateY: this.$context.data('calibrate-y') || null,
						invertX: this.$context.data('invert-x') || null,
						invertY: this.$context.data('invert-y') || null,
						limitX: parseFloat(this.$context.data('limit-x')) || null,
						limitY: parseFloat(this.$context.data('limit-y')) || null,
						scalarX: parseFloat(this.$context.data('scalar-x')) || null,
						scalarY: parseFloat(this.$context.data('scalar-y')) || null,
						frictionX: parseFloat(this.$context.data('friction-x')) || null,
						frictionY: parseFloat(this.$context.data('friction-y')) || null,
						originX: parseFloat(this.$context.data('origin-x')) || null,
						originY: parseFloat(this.$context.data('origin-y')) || null
					};

					// Delete Null Data Values
					for (var key in data) {
						if (data[key] === null) delete data[key];
					}

					// Compose Settings Object
					$.extend(this, DEFAULTS, options, data);

					// States
					this.calibrationTimer = null;
					this.calibrationFlag = true;
					this.enabled = false;
					this.depths = [];
					this.raf = null;

					// Element Bounds
					this.bounds = null;
					this.ex = 0;
					this.ey = 0;
					this.ew = 0;
					this.eh = 0;

					// Element Center
					this.ecx = 0;
					this.ecy = 0;

					// Element Range
					this.erx = 0;
					this.ery = 0;

					// Calibration
					this.cx = 0;
					this.cy = 0;

					// Input
					this.ix = 0;
					this.iy = 0;

					// Motion
					this.mx = 0;
					this.my = 0;

					// Velocity
					this.vx = 0;
					this.vy = 0;

					// Callbacks
					this.onMouseMove = this.onMouseMove.bind(this);
					this.onDeviceOrientation = this.onDeviceOrientation.bind(this);
					this.onOrientationTimer = this.onOrientationTimer.bind(this);
					this.onCalibrationTimer = this.onCalibrationTimer.bind(this);
					this.onAnimationFrame = this.onAnimationFrame.bind(this);
					this.onWindowResize = this.onWindowResize.bind(this);

					// Initialise
					this.initialise();
				}

				Plugin.prototype.transformSupport = function (value) {
					var element = document.createElement('div');
					var propertySupport = false;
					var propertyValue = null;
					var featureSupport = false;
					var cssProperty = null;
					var jsProperty = null;
					for (var i = 0, l = this.vendors.length; i < l; i++) {
						if (this.vendors[i] !== null) {
							cssProperty = this.vendors[i][0] + 'transform';
							jsProperty = this.vendors[i][1] + 'Transform';
						} else {
							cssProperty = 'transform';
							jsProperty = 'transform';
						}
						if (element.style[jsProperty] !== undefined) {
							propertySupport = true;
							break;
						}
					}
					switch (value) {
						case '2D':
							featureSupport = propertySupport;
							break;
						case '3D':
							if (propertySupport) {
								var body = document.body || document.createElement('body');
								var documentElement = document.documentElement;
								var documentOverflow = documentElement.style.overflow;
								if (!document.body) {
									documentElement.style.overflow = 'hidden';
									documentElement.appendChild(body);
									body.style.overflow = 'hidden';
									body.style.background = '';
								}
								body.appendChild(element);
								element.style[jsProperty] = 'translate3d(1px,1px,1px)';
								propertyValue = window.getComputedStyle(element).getPropertyValue(cssProperty);
								featureSupport = propertyValue !== undefined && propertyValue.length > 0 && propertyValue !== "none";
								documentElement.style.overflow = documentOverflow;
								body.removeChild(element);
							}
							break;
					}
					return featureSupport;
				};

				Plugin.prototype.ww = null;
				Plugin.prototype.wh = null;
				Plugin.prototype.wcx = null;
				Plugin.prototype.wcy = null;
				Plugin.prototype.wrx = null;
				Plugin.prototype.wry = null;
				Plugin.prototype.portrait = null;
				Plugin.prototype.desktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);
				Plugin.prototype.vendors = [null, ['-webkit-', 'webkit'], ['-moz-', 'Moz'], ['-o-', 'O'], ['-ms-', 'ms']];
				Plugin.prototype.motionSupport = !!window.DeviceMotionEvent;
				Plugin.prototype.orientationSupport = !!window.DeviceOrientationEvent;
				Plugin.prototype.orientationStatus = 0;
				Plugin.prototype.transform2DSupport = Plugin.prototype.transformSupport('2D');
				Plugin.prototype.transform3DSupport = Plugin.prototype.transformSupport('3D');
				Plugin.prototype.propertyCache = {};

				Plugin.prototype.initialise = function () {

					// Configure Styles
					if (this.$context.css('position') === 'static') {
						this.$context.css({
							position: 'relative'
						});
					}

					// Hardware Accelerate Context
					this.accelerate(this.$context);

					// Setup
					this.updateLayers();
					this.updateDimensions();
					this.enable();
					this.queueCalibration(this.calibrationDelay);
				};

				Plugin.prototype.updateLayers = function () {

					// Cache Layer Elements
					this.$layers = this.$context.find('.layer');
					this.depths = [];

					// Configure Layer Styles
					this.$layers.css({
						position: 'absolute',
						display: 'block',
						left: 0,
						top: 0
					});
					this.$layers.first().css({
						position: 'relative'
					});

					// Hardware Accelerate Layers
					this.accelerate(this.$layers);

					// Cache Depths
					this.$layers.each($.proxy(function (index, element) {
						this.depths.push($(element).data('depth') || 0);
					}, this));
				};

				Plugin.prototype.updateDimensions = function () {
					this.ww = window.innerWidth;
					this.wh = window.innerHeight;
					this.wcx = this.ww * this.originX;
					this.wcy = this.wh * this.originY;
					this.wrx = Math.max(this.wcx, this.ww - this.wcx);
					this.wry = Math.max(this.wcy, this.wh - this.wcy);
				};

				Plugin.prototype.updateBounds = function () {
					this.bounds = this.element.getBoundingClientRect();
					this.ex = this.bounds.left;
					this.ey = this.bounds.top;
					this.ew = this.bounds.width;
					this.eh = this.bounds.height;
					this.ecx = this.ew * this.originX;
					this.ecy = this.eh * this.originY;
					this.erx = Math.max(this.ecx, this.ew - this.ecx);
					this.ery = Math.max(this.ecy, this.eh - this.ecy);
				};

				Plugin.prototype.queueCalibration = function (delay) {
					clearTimeout(this.calibrationTimer);
					this.calibrationTimer = setTimeout(this.onCalibrationTimer, delay);
				};

				Plugin.prototype.enable = function () {
					if (!this.enabled) {
						this.enabled = true;
						if (this.orientationSupport) {
							this.portrait = null;
							window.addEventListener('deviceorientation', this.onDeviceOrientation);
							setTimeout(this.onOrientationTimer, this.supportDelay);
						} else {
							this.cx = 0;
							this.cy = 0;
							this.portrait = false;
							window.addEventListener('mousemove', this.onMouseMove);
						}
						window.addEventListener('resize', this.onWindowResize);
						this.raf = requestAnimationFrame(this.onAnimationFrame);
					}
				};

				Plugin.prototype.disable = function () {
					if (this.enabled) {
						this.enabled = false;
						if (this.orientationSupport) {
							window.removeEventListener('deviceorientation', this.onDeviceOrientation);
						} else {
							window.removeEventListener('mousemove', this.onMouseMove);
						}
						window.removeEventListener('resize', this.onWindowResize);
						cancelAnimationFrame(this.raf);
					}
				};

				Plugin.prototype.calibrate = function (x, y) {
					this.calibrateX = x === undefined ? this.calibrateX : x;
					this.calibrateY = y === undefined ? this.calibrateY : y;
				};

				Plugin.prototype.invert = function (x, y) {
					this.invertX = x === undefined ? this.invertX : x;
					this.invertY = y === undefined ? this.invertY : y;
				};

				Plugin.prototype.friction = function (x, y) {
					this.frictionX = x === undefined ? this.frictionX : x;
					this.frictionY = y === undefined ? this.frictionY : y;
				};

				Plugin.prototype.scalar = function (x, y) {
					this.scalarX = x === undefined ? this.scalarX : x;
					this.scalarY = y === undefined ? this.scalarY : y;
				};

				Plugin.prototype.limit = function (x, y) {
					this.limitX = x === undefined ? this.limitX : x;
					this.limitY = y === undefined ? this.limitY : y;
				};

				Plugin.prototype.origin = function (x, y) {
					this.originX = x === undefined ? this.originX : x;
					this.originY = y === undefined ? this.originY : y;
				};

				Plugin.prototype.clamp = function (value, min, max) {
					value = Math.max(value, min);
					value = Math.min(value, max);
					return value;
				};

				Plugin.prototype.css = function (element, property, value) {
					var jsProperty = this.propertyCache[property];
					if (!jsProperty) {
						for (var i = 0, l = this.vendors.length; i < l; i++) {
							if (this.vendors[i] !== null) {
								jsProperty = $.camelCase(this.vendors[i][1] + '-' + property);
							} else {
								jsProperty = property;
							}
							if (element.style[jsProperty] !== undefined) {
								this.propertyCache[property] = jsProperty;
								break;
							}
						}
					}
					element.style[jsProperty] = value;
				};

				Plugin.prototype.accelerate = function ($element) {
					for (var i = 0, l = $element.length; i < l; i++) {
						var element = $element[i];
						this.css(element, 'transform', 'translate3d(0,0,0)');
						this.css(element, 'transform-style', 'preserve-3d');
						this.css(element, 'backface-visibility', 'hidden');
					}
				};

				Plugin.prototype.setPosition = function (element, x, y) {
					x += 'px';
					y += 'px';
					if (this.transform3DSupport) {
						this.css(element, 'transform', 'translate3d(' + x + ',' + y + ',0)');
					} else if (this.transform2DSupport) {
						this.css(element, 'transform', 'translate(' + x + ',' + y + ')');
					} else {
						element.style.left = x;
						element.style.top = y;
					}
				};

				Plugin.prototype.onOrientationTimer = function (event) {
					if (this.orientationSupport && this.orientationStatus === 0) {
						this.disable();
						this.orientationSupport = false;
						this.enable();
					}
				};

				Plugin.prototype.onCalibrationTimer = function (event) {
					this.calibrationFlag = true;
				};

				Plugin.prototype.onWindowResize = function (event) {
					this.updateDimensions();
				};

				Plugin.prototype.onAnimationFrame = function () {
					this.updateBounds();
					var dx = this.ix - this.cx;
					var dy = this.iy - this.cy;
					if (Math.abs(dx) > this.calibrationThreshold || Math.abs(dy) > this.calibrationThreshold) {
						this.queueCalibration(0);
					}
					if (this.portrait) {
						this.mx = this.calibrateX ? dy : this.iy;
						this.my = this.calibrateY ? dx : this.ix;
					} else {
						this.mx = this.calibrateX ? dx : this.ix;
						this.my = this.calibrateY ? dy : this.iy;
					}
					this.mx *= this.ew * (this.scalarX / 100);
					this.my *= this.eh * (this.scalarY / 100);
					if (!isNaN(parseFloat(this.limitX))) {
						this.mx = this.clamp(this.mx, -this.limitX, this.limitX);
					}
					if (!isNaN(parseFloat(this.limitY))) {
						this.my = this.clamp(this.my, -this.limitY, this.limitY);
					}
					this.vx += (this.mx - this.vx) * this.frictionX;
					this.vy += (this.my - this.vy) * this.frictionY;
					for (var i = 0, l = this.$layers.length; i < l; i++) {
						var depth = this.depths[i];
						var layer = this.$layers[i];
						var xOffset = this.vx * depth * (this.invertX ? -1 : 1);
						var yOffset = this.vy * depth * (this.invertY ? -1 : 1);
						this.setPosition(layer, xOffset, yOffset);
					}
					this.raf = requestAnimationFrame(this.onAnimationFrame);
				};

				Plugin.prototype.onDeviceOrientation = function (event) {

					// Validate environment and event properties.
					if (!this.desktop && event.beta !== null && event.gamma !== null) {

						// Set orientation status.
						this.orientationStatus = 1;

						// Extract Rotation
						var x = (event.beta || 0) / MAGIC_NUMBER; //  -90 :: 90
						var y = (event.gamma || 0) / MAGIC_NUMBER; // -180 :: 180

						// Detect Orientation Change
						var portrait = window.innerHeight > window.innerWidth;
						if (this.portrait !== portrait) {
							this.portrait = portrait;
							this.calibrationFlag = true;
						}

						// Set Calibration
						if (this.calibrationFlag) {
							this.calibrationFlag = false;
							this.cx = x;
							this.cy = y;
						}

						// Set Input
						this.ix = x;
						this.iy = y;
					}
				};

				Plugin.prototype.onMouseMove = function (event) {

					// Cache mouse coordinates.
					var clientX = event.clientX;
					var clientY = event.clientY;

					// Calculate Mouse Input
					if (!this.orientationSupport && this.relativeInput) {

						// Clip mouse coordinates inside element bounds.
						if (this.clipRelativeInput) {
							clientX = Math.max(clientX, this.ex);
							clientX = Math.min(clientX, this.ex + this.ew);
							clientY = Math.max(clientY, this.ey);
							clientY = Math.min(clientY, this.ey + this.eh);
						}

						// Calculate input relative to the element.
						this.ix = (clientX - this.ex - this.ecx) / this.erx;
						this.iy = (clientY - this.ey - this.ecy) / this.ery;
					} else {

						// Calculate input relative to the window.
						this.ix = (clientX - this.wcx) / this.wrx;
						this.iy = (clientY - this.wcy) / this.wry;
					}
				};

				var API = {
					enable: Plugin.prototype.enable,
					disable: Plugin.prototype.disable,
					updateLayers: Plugin.prototype.updateLayers,
					calibrate: Plugin.prototype.calibrate,
					friction: Plugin.prototype.friction,
					invert: Plugin.prototype.invert,
					scalar: Plugin.prototype.scalar,
					limit: Plugin.prototype.limit,
					origin: Plugin.prototype.origin
				};

				$.fn[NAME] = function (value) {
					var args = arguments;
					return this.each(function () {
						var $this = $(this);
						var plugin = $this.data(NAME);
						if (!plugin) {
							plugin = new Plugin(this, value);
							$this.data(NAME, plugin);
						}
						if (API[value]) {
							plugin[value].apply(plugin, Array.prototype.slice.call(args, 1));
						}
					});
				};
			})(window.jQuery || window.Zepto, window, document);

			/**
    * Request Animation Frame Polyfill.
    * @author Tino Zijdel
    * @author Paul Irish
    * @see https://gist.github.com/paulirish/1579671
    */
			;(function () {

				var lastTime = 0;
				var vendors = ['ms', 'moz', 'webkit', 'o'];

				for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
					window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
					window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
				}

				if (!window.requestAnimationFrame) {
					window.requestAnimationFrame = function (callback, element) {
						var currTime = new Date().getTime();
						var timeToCall = Math.max(0, 16 - (currTime - lastTime));
						var id = window.setTimeout(function () {
							callback(currTime + timeToCall);
						}, timeToCall);
						lastTime = currTime + timeToCall;
						return id;
					};
				}

				if (!window.cancelAnimationFrame) {
					window.cancelAnimationFrame = function (id) {
						clearTimeout(id);
					};
				}
			})();
			$(function () {
				var $container = $('.container'),
				    rootPath = '/zolotayakaska/';

				function setLocation(currentLocation) {
					try {
						history.pushState(null, null, rootPath + currentLocation);
						return;
					} catch (e) {}
					location.pathname = rootPath + currentLocation;
				}
				function getCurrentTabs() {
					var path = window.location.pathname.replace(rootPath, '').replace(/\/$/g, ''),
					    arr = path.split('/');

					switch (arr.length) {
						case 1:
							return [arr[0]];
						case 2:
							return [arr[0], path];
					}
					return [];
				}

				//========== ...:
				(function () {
					$('.gh-header-parallax').parallax({
						scalarY: 0,
						frictionY: 0,
						originY: 0
					});

					$('[data-dropdown-target]').on('click', function () {
						$('[data-dropdown=' + $(this).data('dropdown-target') + ']').toggleClass('opened');
					});

					$('select.gh-form__field.sumo').SumoSelect({
						placeholder: ''
					});
				})();
				//========== ...;


				//========== ...:
				var toggleTargetBox = function toggleTargetBox() {
					$('[data-active-show-target]').on('change', function () {
						var $target = $('[data-active-show-box=' + $(this).data('active-show-target') + ']');

						if ($(this).prop('checked') && $target.length) {
							$target.slideDown();
						}
					});
					$('[data-active-hide-target]').on('change', function () {
						var $target = $('[data-active-hide-box=' + $(this).data('active-hide-target') + ']');

						if ($(this).prop('checked') && $target.length) {
							$target.slideUp();
						}
					});
				};
				toggleTargetBox();
				//========== ...;


				//========== js-select-btn-list:
				(function () {
					var $selectList = $('select.js-select-btn-list');

					if ($selectList.length) {
						$selectList.styler();
						$selectList.siblings('.jq-selectbox__dropdown').find('li').on('click', function () {
							var code = $(this).data('code'),
							    $target = $('.gh-tabs__btn[data-code="' + code + '"], .gh-tags-tabs__btn[data-code="' + code + '"]');

							if ($target.length) {
								$target.click();
							}
						});
					}
				})();
				//========== js-select-btn-list;


				//========== gh-fixed-header:
				(function () {
					var $headLine = $('.gh-fixed-header');
					var toggleClass = 'gh-fixed-header_scrolled';

					$(window).on('scroll', function () {
						if ($(window).scrollTop() > 0) {
							$headLine.addClass(toggleClass);
						} else {
							$headLine.removeClass(toggleClass);
						}
					});
				})();
				//========== gh-fixed-header;


				//========== tabs:
				(function () {
					var $tabList = $('[data-tabs-parent]');
					var toggleClassBtn = 'current';
					var toggleClassBody = 'opened';

					if ($tabList.length) {
						$tabList.each(function () {
							var $parent = $(this),
							    parent = $parent.data('tabs-parent'),
							    $btns = $('[data-tabs-btn="' + parent + '"]', $parent),
							    $bodys = $('[data-tabs-body="' + parent + '"]', $parent);

							$btns.on('click', function (e) {
								e.preventDefault();
								var $btn = $(this),
								    code = $btn.data('code');

								if (typeof code !== 'undefined' && code.length) {
									setLocation(code);
								}

								$btns.filter('.' + toggleClassBtn).removeClass(toggleClassBtn);
								$bodys.filter('.' + toggleClassBody).removeClass(toggleClassBody);
								$btn.addClass(toggleClassBtn);
								$bodys.eq($btn.index()).addClass(toggleClassBody);
							});
						});
					}
				})();
				//========== tabs;


				$container.on('click', '.js-request', function (e) {
					e.preventDefault();
					if (typeof $(this).data('href') == 'undefined') {
						throw new Error('href must defined');
					}
					if (typeof this.canRequest == 'undefined' || this.canRequest) {
						this.canRequest = false;
						var self = this,
						    code = $(this).data('code');

						$('.js-request.active').removeClass('active');
						$(this).addClass('active');

						if (typeof code !== 'undefined' && code.length) {
							setLocation(code);
						}
						$('.js-poll').prepend('<div class="goldenhelmet-outer-loader text-center"><span class="goldenhelmet-loader"><span class="goldenhelmet-loader-inner"></span></span></div>');
						$.ajax({
							url: $(this).data('href')
						}).done(function (data) {
							self.canRequest = true;
							jsPollRender(data).then(function () {
								renderSlick($('.gh-card__slider'));
							});
						});
					}
				});

				//========== url tabs:
				(function () {
					var currentTabs = getCurrentTabs(),
					    $tabs1 = $('.gh-tabs__btn'),
					    $tabs2 = $('.gh-tags-tabs__btn');

					if (currentTabs.length) {
						$tabs1.each(function () {
							var $btn = $(this),
							    code = $btn.data('code');
							if (code === currentTabs[0] && location.hostname !== 'localhost') {
								$btn.click();
							}
						});

						if (currentTabs.length > 1) {
							$tabs2.each(function () {
								var $btn = $(this),
								    code = $btn.data('code');
								if (code === currentTabs[1] && location.hostname !== 'localhost') {
									$btn.click();
								}
							});
						}
					}
				})();
				//========== url tabs;


				//========== sliders:
				var renderSlick = function renderSlick($object) {
					if (typeof $object !== 'undefined' && $object !== null && $object.length) {
						$object.slick({
							slidesToShow: 1,
							swipe: false,
							prevArrow: '<button type="button" data-role="none" class="slick-arrow slick-prev" aria-label="Previous" role="button"><i class="fa fa-angle-left"></i></button>',
							nextArrow: '<button type="button" data-role="none" class="slick-arrow slick-next" aria-label="Next" role="button"><i class="fa fa-angle-right"></i></button>',
							lazyLoad: 'ondemand'
						});
						$object.find('.slick-arrow').on('click', function (e) {
							e.stopPropagation();
							e.preventDefault();
						});
					}
				};
				renderSlick($('.gh-card__slider'));
				//========== sliders;


				//========== share:
				$(document).on('click', '.btn-share', function (e) {
					var cardCode = $(this).data('code'),
					    title = $(this).data('title'),
					    description = $(this).data('description'),
					    image = $(this).data('image'),
					    url = window.location.href,
					    $modal = $('#modal-share');

					$('.social-button_vk', $modal).attr('href', cardCode);
					$('.social-button_vk', $modal).attr('data-title', title + '. ' + description);
					$('.social-button_vk', $modal).attr('data-image', image);
					$('.social-button_vk').unbind();
					$('.social-button_vk').socialButton({
						alternativeSummary: description,
						alternativeTitle: title,
						alternativeImage: typeof image == "undefined" || image == "" ? false : image,
						forceAlternativeSummary: true,
						forceAlternativeTitle: true,
						forceAlternativeImage: typeof image == "undefined" || image == "" ? false : true
					});

					$('.social-button_facebook', $modal).attr('href', cardCode);
					$('.social-button_facebook', $modal).attr('data-description', description);
				});
				//========== share;


				//========== modals:
				$(document).on('click', '[data-modal]', function (e) {
					e.preventDefault();

					var $btn = $(this),
					    selector = $btn.data('modal'),
					    href = $btn.data('href');

					if ($btn.hasClass('btn-not-auth')) {
						$('.modal').modal('hide');
						$('#modal-auth').modal('show');
						if (typeof $btn.data('id') !== 'undefined' && $btn.data('id') !== null) {
							setCookie('show.modal', $btn.data('id'), { path: '/', domain: location.hostname });
						}
					} else if (typeof href !== 'undefined') {
						$.ajax({
							url: href,
							method: 'GET'
						}).always(function (data, jqXHR) {
							jsPollRender(data, selector).then(function () {
								$('.modal').modal('hide');
								$(selector).modal('show');
								var timeoutId = setTimeout(function () {
									clearTimeout(timeoutId);
									renderSlick($('.gh-card__slider', $(selector)));
								}, 300);
							});
						});
					} else {
						$('.modal').modal('hide');
						$(selector).modal('show');
					}
				});

				(function () {
					if (getCookie('show.modal')) {
						var id = getCookie('show.modal');
						var $link = $('[data-id=' + id + '] .gh-card__title');

						setCookie('show.modal', null, { path: '/', domain: location.hostname });

						if ($link.length) {
							$link.click();
						}
					}
				})();
				//========== modals;


				//========== forms:
				$container.on('submit', '.js-feedback-goldenhelmet', function (e) {
					e.preventDefault();

					var data = $(this).serialize();

					if (typeof data !== 'undefined' && (typeof this.canRequest == 'undefined' || this.canRequest)) {
						this.canRequest = false;
						var self = this;
						$.ajax({
							data: data,
							url: $(this).attr('action'),
							method: $(this).attr('method')
						}).done(function (data) {
							self.canRequest = true;
						}).always(function (data, jqXHR) {
							jsPollRender(data, '.js-feedback-goldenhelmet-status').then(function () {
								toggleTargetBox();
								if ($('#modal-goldenhelmet-feedback').length) {
									$('.modal').modal('hide');
									$('#modal-goldenhelmet-feedback').modal('show');
								}
							});
						});
					}
				});
				//========== forms:

				$container.on('submit', '.js-form-request', function (e) {
					e.preventDefault();
				});

				$(document).on('click', '.js-vote', function (e) {
					e.preventDefault();
					var form = $(this).closest('form'),
					    vote = form.find('input[name=vote]'),
					    voteId = form.find('input[name=VOTE_ID]'),
					    sessid = form.find('input[name=sessid]'),
					    answer = $(this).find('input.js-vote-input');
					if (!form.length || !vote.length || !voteId.length || !answer.length || !sessid.length) {
						throw new Error('Params must be set');
					}
					if (typeof this.canRequest == 'undefined' || this.canRequest) {
						var data = {
							vote: vote.val(),
							PUBLIC_VOTE_ID: voteId.val(),
							VOTE_ID: voteId.val(),
							sessid: sessid.val(),
							ans: answer.val()
						};
						data[answer.attr('name')] = answer.val();
						this.canRequest = true;
						var self = this;
						$.ajax({
							method: 'POST',
							url: form.attr('action'),
							data: data
						}).done(function (data) {
							self.canRequest = true;
						}).always(function (data) {
							jsPollRender(data).then(function () {
								var $modalVoted = $('#modal-voted');
								var description = $('.social-button_vk', $modalVoted).attr('data-description'),
								    title = $('.social-button_vk', $modalVoted).attr('data-title'),
								    image = $('.social-button_vk', $modalVoted).attr('data-image'),
								    cardCode = $('.social-button_vk', $modalVoted).attr('data-code');
								$('.social-button_vk', $modalVoted).unbind();
								$('.social-button_vk', $modalVoted).attr('href', cardCode);
								$('.social-button_vk', $modalVoted).socialButton({
									alternativeSummary: description,
									alternativeTitle: title,
									alternativeImage: typeof image == "undefined" || image == "" ? false : image,
									forceAlternativeSummary: true,
									forceAlternativeTitle: true,
									forceAlternativeImage: typeof image == "undefined" || image == "" ? false : true
								});

								$('.social-button_facebook', $modalVoted).attr('href', cardCode);
								$('.social-button_facebook', $modalVoted).attr('data-description', description);
								if ($modalVoted.length) {
									$('.modal').modal('hide');
									$modalVoted.modal('show');
								}
							});
						});
					}
				});

				var jsPollRender = function jsPollRender(data, selector) {
					return new Promise(function (resolve, reject) {
						selector = selector || '.js-poll';
						resolve(typeof $(selector) !== 'undefined' && $(selector).length ? $(selector).html(data) : null);
					});
				};
			});
		};
		if ($('.ajax-tags-tgb').length) {
			tgbTagsLength = $(".ajax-tags-tgb").length;
			if (tgbTagsLength > 0) {
				var initTgbTags = function initTgbTags() {
					activeTags = [];
					selectedCities = [];

					$.each($(".ajax-tags-button"), function () {
						el2 = $(this);
						if (el2.hasClass('btn-tag_active')) {
							if (el2.data('tag') == 'moskva' || el2.data('tag') == 'novaya-moskva' || el2.data('tag') == 'podmoskove') {
								selectedCities.push(el2.data('tag'));
							} else {
								activeTags.push(el2.data('tag'));
							}
						}
					});

					$(".ajax-tags-tgb").removeClass("hide");

					if (activeTags.length == 0 && selectedCities.length == 0) {
						$(".ajax-tags-button-all").addClass("btn-tag_active");
					} else {
						$(".ajax-tags-button-all").removeClass("btn-tag_active");
						$.each($(".ajax-tags-tgb"), function () {
							el3 = $(this);

							activeCity = false;

							notActiveTag = false;
							$.each(selectedCities, function (key, value) {
								if (el3.hasClass("tag-" + value)) {
									activeCity = true;
								}
							});
							$.each(activeTags, function (key, value) {
								if (!el3.hasClass("tag-" + value)) {
									notActiveTag = true;
								}
							});
							if (!activeCity && selectedCities.length > 0) {
								el3.addClass("hide");
							} else if (activeTags.length > 0 && notActiveTag) {
								el3.addClass("hide");
							}
						});
					}
				};

				$(".ajax-tags-button-all").on('click', function (e) {
					e.preventDefault();
					el = $(this);
					el.addClass("btn-tag_active");
					$(".ajax-tags-button").removeClass("btn-tag_active");
					$(".ajax-tags-tgb").removeClass("hide");
				});

				$(".ajax-tags-button").on('click', function (e) {
					e.preventDefault();
					el = $(this);
					if (el.hasClass('btn-tag_active')) {
						el.removeClass('btn-tag_active');
					} else {
						el.addClass('btn-tag_active');
					}
					initTgbTags();
				});
				initTgbTags();
			}
		};
		if ($('.lider_invest').length) {
			$(document).ready(function () {
				var win_w = $(window).width();
				// var win_w = window.matchMedia;
				var win_scroll = $(window).scrollTop();
				var win_h = $(window).height();

				var li = {
					pages: {},
					anchors: {},
					scroll_items_interval: false,
					scroll_item: -1,
					scroll_top: 0,
					scroll_anchor: 0,
					scroll_elems: '.scrollable',
					slide: 0,
					anchor_link: '.lider_invest__header__nav a ',
					container_li: '.lider_invest',
					review_slider: '.lider_invest__video_review__slider',
					main_slider: '.lider_invest__slider',
					main_slider_nav: '.lider_invest__slider__nav',
					main_slider_item: '.lider_invest__slider__item',
					main_slider_tab: '.lider_invest__slider__map_item',
					main_slider__prev_arr: '<div class="lider_invest__slider__arr--prev lider_invest__slider__arr"><div class="lider_invest__slider__arr_icon">&nbsp;</div> </div>',
					main_slider__next_arr: '<div class="lider_invest__slider__arr--next lider_invest__slider__arr"> <div class="lider_invest__slider__arr_icon">&nbsp;</div></div>'
				};

				/*      */
				$(li.anchor_link).on('click', function () {
					var to_href = $(this).attr('href');
					$('html, body').stop().animate({ scrollTop: $(to_href).offset().top }, 500);

					return false;
				});

				/*    */
				$(li.main_slider).slick({
					fade: true,
					slidesToShow: 1,
					slidesToScroll: 1,
					appendArrows: li.main_slider_nav,
					prevArrow: li.main_slider__prev_arr,
					nextArrow: li.main_slider__next_arr,
					dots: false
				});

				/*    */
				$(li.review_slider).slick({
					slidesToShow: 6,
					slidesToScroll: 1,
					// centerPadding: '13px',
					// appendArrows: li.main_slider_nav,
					prevArrow: '<button type="button" class="full-slider__arrow slick-prev" ><i class="fa fa-angle-left"></i></button>',
					nextArrow: '<button type="button" class="full-slider__arrow slick-next" ><i class="fa fa-angle-right"></i></button>',
					dots: false,
					centerMode: true,

					responsive: [{
						breakpoint: 1800,
						settings: {
							slidesToShow: 5
						}
					}, {
						breakpoint: 1600,
						settings: {
							slidesToShow: 4
						}
					}, {
						breakpoint: 1366,
						settings: {
							slidesToShow: 3
						}
					}, {
						breakpoint: 910,
						settings: {
							slidesToShow: 2
						}
					}, {
						breakpoint: 640,
						settings: {
							slidesToShow: 1
						}
					}]
				});

				/*        */
				$(li.main_slider).on('afterChange', function () {
					$(li.main_slider_tab + '.active').removeClass('active');
					var this_slide = $(li.main_slider_item + '.slick-active').attr('id');
					$(li.main_slider_tab + '[href="#' + this_slide + '"]').addClass('active');
				});

				// $(li.main_slider_tab).on('click', function () {
				//     $(li.main_slider_tab + '.active').removeClass('active');
				//     $(this).addClass('active');
				//     var to_slide = $(this).attr('href');
				//     var to_slide__num = $(to_slide).index();
				//     $(li.main_slider).slick('slickGoTo', to_slide__num);
				//     return false;
				// });

				/*   */
				$('body').lightGallery({
					selector: '[data-src]'
				});

				/*   */
				var lider_invest__text_block__animation = function lider_invest__text_block__animation(duration) {
					var lider_invest__text_block__of_top = $('.lider_invest__text_block').offset().top;
					var lider_invest__text_block__hieght = $('.lider_invest__text_block').height();
					if (win_scroll > lider_invest__text_block__of_top - win_h / 2 && win_scroll < lider_invest__text_block__of_top + lider_invest__text_block__hieght) {
						$('.lider_invest__text_block').addClass('active');
					} else {
						$('.lider_invest__text_block').removeClass('active');
					}
				};

				lider_invest__text_block__animation();

				if ($('#line-block').length) {
					var place_banner = $('#line-block').offset().top + $('#line-block').height() - 50;
					var show_banner = place_banner + $('.lider_invest__sale').height() - win_h - 100;
					$('.lider_invest__sale').css('top', place_banner);
					if (win_scroll > show_banner) {
						$('.lider_invest__sale').addClass('show');
					}
				}

				$('.lider_invest__sale__minimize').on('click', function (e) {
					e.preventDefault();

					if ($('.lider_invest__sale').hasClass('_toggled')) {
						$('.lider_invest__sale').removeClass('_minimized _toggled');
						$('.lider_invest__sale__text').show();
						$('.lider_invest__sale__title').show();
						return;
					}
					$('.lider_invest__sale').addClass('_minimized _toggled');
					$('.lider_invest__sale__text').hide();
					$('.lider_invest__sale__title').hide();
				});

				$(window).scroll(function () {
					win_scroll = $(window).scrollTop();
					if (win_scroll > 60) {
						$(li.container_li).addClass('fix');
					} else {
						$(li.container_li).removeClass('fix');
					}

					if ($('#line-block').length) {
						place_banner = $('#line-block').offset().top + $('#line-block').height() - 50;
						show_banner = place_banner + $('.lider_invest__sale').height() - win_h - 100;
						$('.lider_invest__sale').css('top', place_banner);
					}
					if (win_scroll > show_banner) {
						$('.lider_invest__sale').addClass('show');
					}

					lider_invest__text_block__animation();
				});

				ymaps.ready(function () {
					function makeCollection(style) {
						return new ymaps.GeoObjectCollection({}, style);
					}

					var iconStyle = {
						iconLayout: 'default#image',
						iconImageHref: "/local/templates/main/assets/images/lider-invest/lider_invest__slider__map_item.png",
						iconImageSize: [32, 38],
						iconImageOffset: [-16, -19]
					};

					if ($('#map_bottom').length) {
						var mapBottom = new ymaps.Map('map_bottom', {
							center: [55.751574, 37.573856],
							zoom: 11
						}, {
							searchControlProvider: 'yandex#search'
						});

						// const iconStyle = {
						//   iconLayout: 'default#image',
						//   iconImageHref: "/local/templates/main/assets/images/lider-invest/placemark0.png",
						//   iconImageSize: [47, 54],
						//   iconImageOffset: [-23, -27]
						// }

						var offices = makeCollection(iconStyle);

						if (window.devOffices && window.devOffices.length) {
							for (var _i5 = 0; _i5 < window.devOffices.length; _i5++) {
								var item = window.devOffices[_i5];
								var officeCoords = item['coords'];
								var officeAddr = item['addr'] || '  ';
								var placeMark = new ymaps.Placemark(officeCoords);

								placeMark.properties.set('hintContent', officeAddr);
								offices.add(placeMark);
							}
						}

						mapBottom.geoObjects.add(offices);
						mapBottom.behaviors.disable('scrollZoom');
					}

					if ($('#slider-map').length) {
						var sliderMap = new ymaps.Map('slider-map', {
							center: [55.751574, 37.573856],
							zoom: 11
						}, {
							maxZoom: 16
						});

						var buildings = makeCollection(iconStyle);
						var prevSelected = void 0;

						buildings.events.add('click', function (e) {
							e.preventDefault();
							var target = e.get('target');

							if (typeof prevSelected !== 'undefined') {
								prevSelected.options.set({
									iconImageHref: "/local/templates/main/assets/images/lider-invest/lider_invest__slider__map_item.png"
								});
							}

							target.options.set({
								iconImageHref: "/local/templates/main/assets/images/lider-invest/lider_invest__slider__map_item_selected.png"
							});

							var id = target.properties.get('id');
							var slideNum = $('#' + id).index();
							$(li.main_slider).slick('slickGoTo', slideNum);

							prevSelected = target;
						});

						if (window.devLanding && window.devLanding.length) {
							for (var _i6 = 0; _i6 < window.devLanding.length; _i6++) {
								var _item = window.devLanding[_i6];
								var buildingCoords = _item['coords'];
								var buildingId = _item['id'];
								var _placeMark = new ymaps.Placemark(buildingCoords);
								_placeMark.properties.set({ id: buildingId });
								buildings.add(_placeMark);
							}
						}

						sliderMap.geoObjects.add(buildings);
						sliderMap.setBounds(buildings.getBounds());
					}
				});

				if ($('.lider_invest__object').length) {
					$('.lider_invest__object').on('click', function (e) {
						var $target = $(e.target);
						var $loadMore = $target.closest('.js-load-more-objects');

						if (!$loadMore.length) {
							return false;
						}

						if ($loadMore.hasClass('_toggled')) {
							return false;
						}

						e.preventDefault();
						$loadMore.addClass('_toggled');

						var $href = $loadMore.data('href');
						var $loadMoreParent = $loadMore.closest('.lider_invest__object__btn');
						var $container = $loadMoreParent.parent();

						$.get($href, function (getData) {
							$loadMoreParent.remove();
							$container.append(getData);
							$('body').lightGallery({
								selector: '[data-src]'
							});
						});

						setTimeout(function () {
							$loadMore.removeClass('_toggled');
						}, 1000);
					});
				}
				if ($('#form.lider_invest__container').length) {
					var $form = $('#form.lider_invest__container').find('form');
					var $input = $form.find('.form-control');
					var error = void 0;

					$input.on('blur', function (e) {
						var $this = $(this);
						//
						// console.log($this.val());
						// console.log($this.val().trim().length);

						if ($this.val() === '' || $this.val().trim().length <= 0) {
							$this.next('.error-msg').empty().html(' ');
							$this.addClass('_has-error');
							error = 1;
						} else {
							$this.next('.error-msg').empty();
							$this.removeClass('_has-error');
							error = 0;
						}
					});

					$form.on('submit', function (e) {
						e.preventDefault();
						var $this = $(this);
						var $btn = $this.find('button[type="submit"]');
						var $action = $this.attr('action');
						var $method = $this.attr('method');
						var $controls = $form.find('.form-control');

						$controls.each(function (i, element) {
							var e = $(element);
							if (e.val() === '' || e.val().trim().length <= 0) {
								e.next('.error-msg').empty().html(' ');
								e.addClass('_has-error');
								error = 1;
							} else {
								e.next('.error-msg').empty();
								e.removeClass('_has-error');
								error = 0;
							}
						});

						if (error) {
							return false;
						}

						$btn.attr("disabled", "disabled");

						$.ajax({
							url: $action,
							data: $this.serialize(),
							type: $method
						}).done(function (data) {
							var req = JSON.parse(data);
							messageHtml = '';
							$.each(req.messages, function (key, val) {
								messageHtml += '<p>' + val + '</p>';
							});
							if (req.status) {
								$("#modal-msg .modal-body").empty().append('<div class="h3">' + req.header[0] + '</div>').append(messageHtml);
								$("#modal-msg").modal('show');
								return;
							}

							$("#info").empty().html(messageHtml);
							$btn.removeAttr('disabled');
						});
					});
				}
			});
		};
		if ($('.interview__background').length) {
			var interviews = $('.interview-item:nth-child(1) .interview__background img, .interview-item:nth-child(9n+4) .interview__background img, .interview-item:nth-child(9n+6) .interview__background img, .interview-item:nth-child(9n+11) .interview__background img');
			var isTablet = getRealWidth() < 768 ? true : false;

			if (!isTablet) {
				interviews.each(function (index, img) {
					if ($(img).data('horizontal-img')) {
						$(img).attr('src', $(img).data('horizontal-img'));
					}
				});
			}
		};
		if ($('.rating_block').length) {
			/** Class which generates svg circle chart and animates it. */
			var CircleChart = function () {

				/**
     * Get all options.
     * @param {string}  wrapper - Chart wrapper.
     * @param {string}  data - Data-attribute of wrapper with value.
     * @param {number}  maxValue - Max chart value.
     * @param {array}   colorRange - Range of possible colors of chart: from first to last.
     *                               Use: https://gka.github.io/palettes
     * @param {string}  background - Default background color of chart.
     * @param {number}  thickness - Thickness of chart.
     * @param {boolean} backwards - Animate chart counterclockwise.
     * @param {number}  speed - Animation speed. By default = item value / max value (%).
     * @param {string}  ease - Animation easing. https://greensock.com/ease-visualizer
     */
				function CircleChart(options) {
					_classCallCheck(this, CircleChart);

					this.wrapper = $(options.wrapper);
					this.data = options.data;
					this.maxValue = options.maxValue;
					this.colorRange = options.colorRange;
					this.background = options.circle.background;
					this.thickness = options.circle.thickness || 2;
					this.backwards = options.circle.backwards || false;
					this.speed = options.circle.speed || 1;
					this.ease = options.circle.ease || 'Power0.easeNone';
					this.animate = this.animate.bind(this);
					this.render = this.render.bind(this);
				}

				/**
     * Create svg tag as DOM element
     */


				_createClass(CircleChart, [{
					key: "makeSVG",
					value: function makeSVG(tag, attrs) {
						var el = document.createElementNS('http://www.w3.org/2000/svg', tag);
						for (var key in attrs) {
							el.setAttribute(key, attrs[key]);
						}
						return el;
					}

					/**
      * Render chart and append in to wrapper
      */

				}, {
					key: "render",
					value: function render() {
						var _this25 = this;

						this.wrapper.each(function (i, el) {
							var parent = el;
							var svg = _this25.makeSVG('svg', {
								'xmlns': 'http://www.w3.org/2000/svg',
								'viewbox': "0 0 " + (32 + _this25.thickness) + " " + (32 + _this25.thickness),
								'style': _this25.backwards ? 'transform: rotate(270deg) scale(-1, 1)' : 'transform: rotate(270deg)'
							});
							parent.appendChild(svg);
							var bgCircle = _this25.makeSVG('circle', {
								'cx': '50%',
								'cy': '50%',
								'r': '16',
								'fill': 'none',
								'stroke': _this25.background,
								'stroke-width': _this25.thickness + 'px'
							});
							svg.appendChild(bgCircle);
							var fillingCircle = _this25.makeSVG('circle', {
								'class': 'chart-circle',
								'cx': '50%',
								'cy': '50%',
								'r': '16',
								'fill': 'none',
								'stroke': _this25.colorRange[0],
								'stroke-width': _this25.thickness + 'px',
								'stroke-dasharray': '100',
								'stroke-dashoffset': '100'
							});
							svg.appendChild(fillingCircle);
							// Hack for SVG correct display
							$(el).html($(el).html());
						});
					}

					/**
      * Animate chart if it's in viewport
      */

				}, {
					key: "animate",
					value: function animate() {
						var _this26 = this;

						this.wrapper.each(function (i, el) {
							var itemBottom = $(el).offset().top + $(el).height();
							var windowBottom = window.pageYOffset + window.innerHeight;
							if (windowBottom > itemBottom) {
								var rating = $(el).closest($("[data-" + _this26.data + "]")).data(_this26.data);
								var circle = $(el).find($('.chart-circle'));
								var color = _this26.colorRange[Math.round(rating) - 1] || _this26.colorRange[0];
								var value = void 0;
								if (rating <= 0) {
									value = 0;
									color = '#e8e8e8';
								} else if (rating < 3) {
									value = 25;
									color = _this26.colorRange[0];
								} else if (rating < 4) {
									value = 50;
									color = _this26.colorRange[1];
								} else if (rating < 4.5) {
									value = 75;
									color = _this26.colorRange[2];
								} else {
									value = 100;
									color = _this26.colorRange[3];
								}
								var valueBlock = $(el).siblings('.rating_block__i_num');
								valueBlock.css('background-color', color);
								TweenLite.to(circle, 1.5, { drawSVG: value + "%", stroke: color, ease: _this26.ease });
							}
						});
					}
				}, {
					key: "init",
					value: function init() {
						$(window).on("load", this.render);
						$(document).on("scroll", this.animate);
						$(document).on("ready", this.animate);
					}
				}]);

				return CircleChart;
			}();

			var ratingAnimation = new CircleChart({
				wrapper: '.rating_block__circle',
				data: 'ranking',
				colorRange: ['#fa0000', '#ff7200', '#ffa800', '#ffc63e'],
				maxValue: 5,
				circle: {
					background: '#e8e8e8',
					thickness: 2,
					backwards: true,
					ease: 'Bounce.easeOut',
					speed: 2
				}
			});

			ratingAnimation.init();

			$('.developer-header__rating, .rating-medal').on("click", function (e) {
				if ($('.rating_block').length) {
					$("html, body").animate({
						scrollTop: $('.rating_block').offset().top - 65
					}, 500);
				}
			});

			// Sorry for this
			$('.rating_block__i_text a[href="#reviews"]').on('click', function (e) {
				$('#reviews').addClass('in').height('auto');
				$('html, body').scrollTop($('#reviews').offset().top);
			});

			$('.rating_block__item, .rating_block__medal').tooltipster({
				contentAsHTML: true,
				animation: 'fade',
				trigger: 'hover',
				speed: 200,
				maxWidth: 250,
				position: 'bottom',
				interactive: false,
				functionBefore: function functionBefore(origin, continueTooltip) {
					continueTooltip();

					var style = 'tooltipster-label tooltipster-label_' + origin.data('style');
					if (!style) return false;

					$('.tooltipster-base').addClass(style);
				}
			});
		}
		if ($('.zhk-rating-filter').length) {
			var RatingFilter = function () {
				function RatingFilter(options) {
					_classCallCheck(this, RatingFilter);

					this.$form = $(options.form);
					this.$input = $(options.input);
					this.$wrapper = $(options.wrapper);
					this.$searchForm = $(options.searchForm);
					this.$autocomplete = $(options.autocomplete);
					this.paginators = options.paginators;
					this.request = this.request.bind(this);
					this.pagination = this.pagination.bind(this);
					this.popstate = this.popstate.bind(this);
					this.search = this.search.bind(this);
					this.init = this.init.bind(this);
					this.path = ~window.location.pathname.indexOf("novostroyki") ? "/novostroyki/rating/" : "/zastroyshchiki/rating/";
					this.popping = false;
				}

				_createClass(RatingFilter, [{
					key: "init",
					value: function init() {
						var _this27 = this;

						this.$input.on("change", function () {
							return _this27.request();
						});

						$("body").on("click", this.paginators, function (e) {
							e.preventDefault();
							_this27.pagination(e.currentTarget);
						});

						$(window).on("popstate", this.popstate);

						this.$searchForm.on("submit", function (e) {
							e.preventDefault();
							if (_this27.$autocomplete.data('rating-id-item')) {
								_this27.search(_this27.$autocomplete.data('rating-id-item'));
							}
						});

						this.$autocomplete.catcomplete("option", "source", function (request, response) {

							if (_this27.$autocomplete.val() !== '') {
								$.ajax({
									dataType: 'html',
									url: _this27.$autocomplete.data('search-url'),
									data: {
										rating_geo: $('.zhk-rating-filter-geo option:selected').data('value'),
										q: request.term
									},
									success: function success(data) {
										data = JSON.parse(data);
										response(data.length === 1 && data[0].length === 0 ? [] : data);
										if (data.length === 1) {
											_this27.$autocomplete.attr('data-rating-id-item', data[0].id);
										} else _this27.$autocomplete.attr('data-rating-id-item', '');
									}
								});
							} else if (_this27.$autocomplete.data('search-empty-url')) {
								$.ajax({
									dataType: 'html',
									url: _this27.$autocomplete.data('search-empty-url'),
									data: {
										rating_geo: $('.zhk-rating-filter-geo option:selected').data('value')
									},
									success: function success(data) {
										data = JSON.parse(data);
										response(data.length === 1 && data[0].length === 0 ? [] : data);
									}
								});
							}
						});

						this.$autocomplete.catcomplete("option", "select", function (event, ui) {
							_this27.$autocomplete.attr("data-rating-id-item", ui.item.id);
							_this27.search(ui.item.id);
						});
					}
				}, {
					key: "request",
					value: function request() {
						var _this28 = this;

						var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.$form.serialize() + '&' + $('.zhk-rating-filter-geo select').serialize();
						var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';


						$(".section__content_rating").addClass("section__content_rating_is_loading");

						var nextTab = document.querySelector('.zhk-rating-filter__input:checked');
						var nextTabValue = nextTab.value;
						var nextTabDataValue = nextTab.getAttribute('data-value') || '';

						var currentGeo = document.querySelector('.zhk-rating-filter-geo option:checked');
						var currentGeoValue = currentGeo.value;
						var currentGeoDataValue = currentGeo.getAttribute('data-value');
						var currentGeoText = currentGeo.innerText;

						var nextUrl = "" + this.path + currentGeoDataValue + "/" + nextTabDataValue;

						return $.ajax({
							type: "GET",
							dataType: "HTML",
							url: this.$form.attr('action'),
							data: headers + ("&next_url=" + nextUrl)
						}).then(function (data, textStatus, jqXHR) {
							var geoHeader = '&' + $('.zhk-rating-filter-geo select').serialize();
							_this28.$wrapper.html(data);

							if (!_this28.popping) {
								history.pushState({
									form: _this28.$form.serializeObject(),
									geoHeader: geoHeader,
									page: page,
									geo: currentGeoValue,
									param: nextTabValue
								}, 'Rating-filter', "" + _this28.path + currentGeoDataValue + "/" + nextTabDataValue + (page ? "?" + page.replace('&', '') : ''));
							}

							$(".section__content_rating").removeClass("section__content_rating_is_loading");
							var pathMain = ~window.location.pathname.indexOf("novostroyki") ? "/novostroyki/" : "/zastroyshchiki/";
							$('.crumbs__item:nth-child(2)').find('a').attr('href', "" + pathMain + currentGeoDataValue + "/");
							$('.crumbs__item:nth-child(2)').find('span').html(currentGeoText);

							var nameZHK = void 0;

							switch (currentGeoDataValue) {
								case 'moskva':
									nameZHK = '';
									break;
								case 'sankt-peterburg':
									nameZHK = '-';
									break;
								case 'moskovskaya-oblast':
									nameZHK = '';
									break;
								case 'leningradskaya-oblast':
									nameZHK = ' ';
									break;
								case 'novaya-moskva':
									nameZHK = ' ';
									break;
								default:
									console.error('no geoData');
							}

							var nameParamDescr = void 0;
							var nameParamTitle = void 0;

							switch (nextTabValue) {
								case 'reviews_rating':
									nameParamDescr = '';
									nameParamTitle = '';
									break;
								case 'rating_price':
									nameParamDescr = '';
									nameParamTitle = '';
									break;
								case 'rating_quality':
									nameParamDescr = '';
									nameParamTitle = '';
									break;
								case 'rating_reliability':
									nameParamDescr = '';
									nameParamTitle = '';
									break;
								case 'rating_infrastructure':
									nameParamDescr = '';
									nameParamTitle = 'e';
									break;
								case 'rating_transport':
									nameParamDescr = ' ';
									nameParamTitle = ' ';
									break;
								case 'rating_subway':
									nameParamDescr = '  ';
									nameParamTitle = '  ';
									break;
								default:
									nameParamDescr = '';
									nameParamTitle = '';
									console.error('no param');
							}

							var titleText = nextTabDataValue ? " \u043F\u043E " + nameParamTitle : ':     , ,    ';

							$('head > title').html("\u0420\u0435\u0439\u0442\u0438\u043D\u0433 \u043D\u043E\u0432\u043E\u0441\u0442\u0440\u043E\u0435\u043A " + nameZHK + titleText);

							var descrText = nextTabDataValue ? " \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043C\u043E\u0441\u0442\u0438 \u043E\u0442 " + nameParamDescr : '.      : , , ,    .';

							$('meta[name="description"]').attr('content', "\u041D\u0430 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0435 \u043F\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u044B \u043B\u0443\u0447\u0448\u0438\u0435 \u0416\u041A " + nameZHK + descrText);

							var keywordsText = nextTabDataValue ? ", " + nextTab.nextSibling.innerText : '';

							$('meta[name="keywords"]').attr('content', "\u043D\u043E\u0432\u043E\u0441\u0442\u0440\u043E\u0439\u043A\u0430, \u0440\u0435\u0439\u0442\u0438\u043D\u0433, \u0436\u043A, \u043B\u0443\u0447\u0448\u0438\u0439, " + currentGeoText + keywordsText);

							if ($('.crumbs__item:nth-child(4)').length) {
								$('.crumbs__item:nth-child(4)').remove();
							}

							if (nextTabDataValue) {
								$('.crumbs__list').append("<li class=\"crumbs__item\" itemprop=\"itemListElement\" itemscope=\"\" itemtype=\"http://schema.org/ListItem\">\n                                                        <span itemprop=\"name\">" + nextTab.nextSibling.innerText + "</span>\n                                                        <meta itemprop=\"position\" content=\"4\">\n                                                    </li>");
							}
						});
					}
				}, {
					key: "search",
					value: function search(id) {
						var _this29 = this;

						$.ajax({
							type: 'GET',
							dataType: 'HTML',
							url: this.$searchForm.attr('action'),
							data: this.$form.serialize() + '&' + $('.zhk-rating-filter-geo select').serialize() + '&id=' + id
						}).then(function (data, textStatus, jqXHR) {
							var parsedData = JSON.parse(data);
							var page = '&PAGEN_1=' + parsedData["page"];
							_this29.request(_this29.$form.serialize() + '&' + $('.zhk-rating-filter-geo select').serialize() + page, page).then(function (data) {
								if ($("[data-rating-id=\"" + id + "\"]").length) {
									var item = $("[data-rating-id=\"" + id + "\"]");
									var itemHeight = item.height();
									var itemOffset = item.offset().top;
									var windowHeight = $(window).height();
									item.find('.zhk_rating__item').addClass('zhk_rating__item_is_found');
									$("html, body").animate({
										scrollTop: itemOffset - (windowHeight / 2 - itemHeight / 2)
									}, 500);
								}
							});
						});
					}
				}, {
					key: "pagination",
					value: function pagination(button) {

						var geoHeader = '&' + $('.zhk-rating-filter-geo select').serialize();
						var href = $(button).attr('href');
						var page = '&' + href.slice(href.lastIndexOf('PAGE'));

						this.request(this.$form.serialize() + geoHeader + page, page).then(function () {
							$("html, body").animate({
								scrollTop: $('.zhk-rating-filter').offset().top
							}, 500);
						});
					}
				}, {
					key: "popstate",
					value: function popstate() {
						var _this30 = this;

						this.popping = true;
						$('.zhk-rating-filter-geo .sumo')[0].sumo.selectItem(history.state.geo);
						$("[value=" + history.state.param + "]").prop('checked', true);
						this.request($.param(history.state.form) + history.state.geoHeader + history.state.page).then(function () {
							_this30.popping = false;
						});
					}
				}]);

				return RatingFilter;
			}();

			var complexFilter = new RatingFilter({
				form: '.zhk-rating-filter',
				input: '[data-zhk-input]',
				wrapper: '.zhk_rating_content',
				paginators: '.pagination-n-2 a',
				searchForm: '.js-rating-search',
				autocomplete: '.input-autocomplete.js-rating-autocomplete'
			});

			complexFilter.init();
		}
		if ($('.library').length) {
			$('.library-search').find('button').on('click', function (event) {
				event.preventDefault();
				var inputLibrary = $('.library-search').find('input');
				var formAction = inputLibrary.data('search-url');
				var formSerialize = $('.library-search').serialize();

				$('.library').addClass('library_load');

				$.ajax({
					type: "GET",
					datatype: "JSON",
					url: formAction,
					data: formSerialize,
					success: function success(data, textStatus, jqXHR) {
						$('.library').empty();

						if (data.length) {
							data.forEach(function (book, i, arr) {
								var bookContent = "<div class=\"library__item\">\n\t\t\t                                        <a class=\"library__cover\" href=\"#\">\n\t\t\t                                            <img src=\"" + book.book_cover + "\" alt=\"\">\n\t\t\t                                        </a>\n\t\t\t                                        <a class=\"library__book-name\" href=\"#\">" + book.book_name + "</a>\n\t\t\t                                        <div class=\"library__book-author\">" + book.book_author + "</div>\n\t\t\t                                        <a class=\"library__read-btn\" href=\"" + book.book_url + "\">\u0427\u0438\u0442\u0430\u0442\u044C</a>\n\t\t\t                    </div>";

								$('.library').append(bookContent);
							});
						} else {
							$('.library').append('  ');
						}

						$('.library').removeClass('library_load');
					}
				});
			});
		}
		if ($('.book').length) {
			/*Sliding on desktop */
			EPUBJS.Render.Iframe.prototype.setLeft = function (leftPos) {
				this.docEl.style[this.transform] = 'translate(' + -leftPos + 'px, 0)';
			};
			/*Smooth sliding*/
			// EPUBJS.Hooks.register('beforeChapterDisplay').pageAnimation = function (callback, renderer) {
			//   var style = renderer.doc.createElement("style");
			//   style.innerHTML = "*{-webkit-transition: transform {t} ease;-moz-transition: tranform {t} ease;-o-transition: transform {t} ease;-ms-transition: transform {t} ease;transition: transform {t} ease;}";
			//   style.innerHTML = style.innerHTML.split("{t}").join("0.5s");
			//   renderer.doc.head.appendChild(style);
			//   if (callback) {
			//     callback();
			//   }
			// };
			/*Swipe and animation of divider sliding*/
			EPUBJS.Hooks.register('beforeChapterDisplay').swipeDetection = function (callback, renderer) {
				var script = renderer.doc.createElement('script');
				script.text = "!function(a,b,c){function f(a){d=a.touches[0].clientX,e=a.touches[0].clientY}function g(f){if(d&&e){var g=f.touches[0].clientX,h=f.touches[0].clientY,i=d-g,j=e-h;Math.abs(i)>Math.abs(j)&&(i>a?b():i<0-a&&c()),d=null,e=null}}var d=null,e=null;document.addEventListener('touchstart',f,!1),document.addEventListener('touchmove',g,!1)}";
				script.text += "(10,function() {\n                    // parent.$('.book__divider').removeClass('goRight');\n                    // parent.$('.book__divider').addClass('goRight');\n                    // setTimeout(() => {\n                    //   parent.$('.book__divider').removeClass('goRight');\n                    // }, 550);\n                    parent.reader.book.nextPage();\n                  }, function() {\n                    // parent.$('.book__divider').removeClass('goLeft');\n                    // parent.$('.book__divider').addClass('goLeft');\n                    // setTimeout(() => {\n                    //   parent.$('.book__divider').removeClass('goLeft');\n                    // }, 550);\n                    parent.reader.book.prevPage();\n                  });";
				renderer.doc.head.appendChild(script);
				if (callback) {
					callback();
				}
			};

			/* Block changing document title */
			EPUBJS.reader.MetaController = function (meta) {
				return;
			};

			/**
    * Creates bookmark element
    * @param {string} cfi special link of page location in book
    */
			var createBookmarkItem = function createBookmarkItem(cfi) {

				var bookmarkNumber = reader.settings.bookmarks.indexOf(cfi) + 1;
				var pageNumber = $('.js-current-page').text();

				var bookmarkElement = $("\n                <li id=\"bookmark-" + bookmarkNumber + "\" class=\"list_item\">\n                  <a href=\"" + cfi + "\"\n                    class=\"book-reader__bookmark\">\n                      \u0421\u0442\u0440\u0430\u043D\u0438\u0446\u0430 \u043D\u043E\u043C\u0435\u0440 \u2116" + pageNumber + "\n                  </a>\n                </li>\n              ");

				bookmarkElement.appendTo($('#bookmarks'));
			};

			/**
    * Removes bookmark element
    * @param {string | number} number of bookmark
    */
			var removeBookmarkItem = function removeBookmarkItem(number) {
				$("#bookmark-" + number).remove();
			};

			var bookUrl = $('.book-reader').data('book-src') || '../assets/1984book.epub';

			window.reader = ePubReader(bookUrl, {
				styles: { 'background-color': '#fff', 'max-width': 'none' },
				// restore: true, 
				// storage: true,
				history: false
			});

			EPUBJS.reader.hashChanged = function () {
				return;
			};

			/**
    * Creates bookmark item and stores it in array
    * @param {string} cfi special link of page location in book
    */
			reader.addBookmark = function (cfi) {
				var bookmarkIndex = this.isBookmarked(cfi);
				if (bookmarkIndex > -1) return;
				this.settings.bookmarks.push(cfi);
				createBookmarkItem(cfi);
			};

			/**
    * Removes bookmark item
    * @param {string} cfi special link of page location in book
    */
			reader.removeBookmark = function (cfi) {
				var bookmarkIndex = this.isBookmarked(cfi);
				if (bookmarkIndex === -1) return;
				this.settings.bookmarks.splice(bookmarkIndex, 1);
				removeBookmarkItem(bookmarkIndex + 1);
				$('[data-add-bookmark]').removeClass('active');
			};

			/**
    * Toggles bookmark icon fill depending if page is bookmarked
    * @param {string} cfi special link of page location in book
    */
			reader.book.on('renderer:locationChanged', function (location) {
				var bookmarked = ~reader.isBookmarked(location);
				if (bookmarked) {
					$('[data-add-bookmark]').addClass('active');
				} else {
					$('[data-add-bookmark]').removeClass('active');
				}
			});

			/**
    * Event for bookmark button 
    */
			var toggleBookmark = function toggleBookmark() {
				var cfi = reader.book.getCurrentLocationCfi();
				var bookmarked = ~reader.isBookmarked(cfi);

				if (!bookmarked) {
					//-- Add bookmark
					reader.addBookmark(cfi);
					$('[data-add-bookmark]').addClass('active');
				} else {
					//-- Remove Bookmark
					reader.removeBookmark(cfi);
					$('[data-add-bookmark]').removeClass('active');
				}
			};

			$('[data-add-bookmark]').on('click', toggleBookmark);

			var rememberBookmarks = function rememberBookmarks() {
				$('#bookmarks').html('');
				reader.settings.bookmarks.forEach(function (cfi) {
					createBookmarkItem(cfi);
				});
			};

			/**
    * Puts current page number and pages amount to the page counter
    */
			reader.book.generatePagination().then(function () {
				var pagesAmount = reader.book.pageList.length;
				$('.js-all-pages').text(pagesAmount);
				var currentpage = reader.book.pagination.pageFromCfi(reader.book.getCurrentLocationCfi());
				$('.js-current-page').text(currentpage);
				rememberBookmarks();
			});

			/**
    * Animates divider on page change
    * @param {string} side where should divider move
    */
			// const animateDivider = (side) => {
			//   $('.book__divider').addClass(`go${side}`);
			//   setTimeout(() => {
			//     $('.book__divider').removeClass(`go${side}`);
			//   }, 500);
			// }

			// $('.book__arrow').on('click', (event) => {
			//   event.preventDefault();
			//   const $this = $(event.currentTarget);
			//   const side = $this.hasClass('book__arrow_prev') ? 'Left' : 'Right';
			//   animateDivider(side);
			// });

			/**
    * Change current page number in page counter after page change
    */
			reader.book.on('book:pageChanged', function (location) {
				var currentpage = location.pageRange[1];
				$('.js-current-page').text(currentpage);
			});

			/**
    * Alignes sidebar by Y
    */
			var alignSidebar = function alignSidebar() {
				$('.book-reader__sidebar').css({
					top: $('.book-reader__book')[0].offsetTop
				});
			};

			/**
    * If chapters wasn't generated by plugin generates them
    */
			var generateChapters = function generateChapters() {
				var chaptersGenerated = reader.book.getToc()._result.length;
				if (!chaptersGenerated) {
					var counter = 1;
					var chapterName = void 0;
					reader.book.contents.spine.forEach(function (element, index) {
						if (index === 0) {
							chapterName = ' ';
						} else if (index === 1) {
							chapterName = '';
						} else if (index === reader.book.contents.spine.length - 1) {
							chapterName = ' ';
						} else {
							chapterName = "\u0427\u0430\u0441\u0442\u044C " + counter;
							counter++;
						}
						$('#tocView ul').append("\n                    <li>\n                      <a class=\"book-reader__chapter\" href=\"" + element.cfi + "\">" + chapterName + "</a>\n                    </li>\n                  ");
					});
				}
			};

			reader.book.on('book:ready', function () {
				alignSidebar();
				generateChapters();
			});

			var closeSidebar = function closeSidebar() {
				$('.book-reader__sidebar').removeClass('open');
				reader.sidebarOpen = false;
			};

			var gotoChapter = function gotoChapter(chapter) {
				var url = chapter.attr('href');
				reader.book.goto(url);
				closeSidebar();
			};

			$('#tocView').on('click', '.book-reader__chapter, .list_item a', function (event) {
				event.preventDefault();
				var currentChapter = $(event.currentTarget);
				gotoChapter(currentChapter);
			});

			var gotoBookmark = function gotoBookmark(bookmark) {
				var url = bookmark.attr('href');
				reader.book.gotoCfi(url);
				closeSidebar();
			};

			$('#bookmarks').on('click', '.book-reader__bookmark', function (event) {
				event.preventDefault();
				var currentBookmark = $(event.currentTarget);
				gotoBookmark(currentBookmark);
			});

			$('.js-close-reader-sidebar').on('click', function (event) {
				event.preventDefault();
				closeSidebar();
			});
		}
		if ($('.articles__wrap').length) {
			var _initTgb = function _initTgb(start, showed_tgb, showed_tgb_element) {
				startid = start - 1;
				tgbLength = start;
				if (start <= tgbLength) {
					var tgbBlock = $('.articles__wrap').find(".tgb-block").eq(startid);
					tgbBlock.hide();
					var tgbParams = {
						'type': tgbBlock.data('type'),
						'promo': tgbBlock.data('promo'),
						'geocode': tgbBlock.data('geocode'),
						'sort': tgbBlock.data('sort'),
						'limit': tgbBlock.data('limit'),
						'orientation': tgbBlock.data('orientation'),
						'finder': tgbBlock.data('finder'),
						'metrika_goal': tgbBlock.data('metrika-goal'),
						'showed': showed_tgb,
						'showed_element': showed_tgb_element
					};
					$.ajax({
						url: '/ajax/tgb.php',
						data: tgbParams,
						success: function success(json) {
							start = start + 1;
							tgb_list = JSON.parse(json);
							tgb_id = Math.ceil(Math.random() * 10000);

							if (tgb_list.tgb) {
								if (start <= tgbLength) {
									if (tgb_list.showed) $.merge(showed_tgb, tgb_list.showed);
									if (tgb_list.showed_element) $.merge(showed_tgb_element, tgb_list.showed_element);
									_initTgb(start, showed_tgb, showed_tgb_element);
								}
								tgb_id.toString();
								if (tgbBlock.data('orientation') != 'vertical') {
									tgbBLockListSlider = $("<div/>", {
										class: "full-slider animation-block full-slider-tgb-" + tgb_id
									}).appendTo(tgbBlock);
								}

								$.each(tgb_list.tgb, function (index, el) {

									metrikaAction = '';

									if (tgbBlock.data('metrika-goal')) {
										metrikaAction = 'yaCounter39897405.reachGoal(\'tgb_goal\',{\'tgb_name\' : \'' + el.name + '\'});';
									}

									if (tgbBlock.data('orientation') == 'vertical') {

										tgbBlockComplex = $("<a/>", {
											class: "complex animation-block article-banners__item",
											href: el.link,
											target: "_blank",
											onclick: metrikaAction
										}).appendTo(tgbBlock);

										tgbBLockComplexImage = $("<div/>", {
											class: "complex__image"
										}).appendTo(tgbBlockComplex);

										tgbBLockComplexImg = $("<img/>", {
											//class: "b-lazy",
											alt: el.name,
											src: el.image
										}).appendTo(tgbBLockComplexImage); //.attr('width',276).attr('height',200);

										tgbBlockComplexBody = $("<div/>", {
											class: "complex__body complex__body_auto-height"
										}).appendTo(tgbBlockComplex);

										tgbBlockComplexBodyHeader = $("<div/>", {
											class: "complex__header"
										}).append(el.name).appendTo(tgbBlockComplexBody);

										tgbBlockComplexBodyText = $("<div/>", {
											class: "complex__tgb__text"
										}).append(el.text).appendTo(tgbBlockComplexBody);
									}
								});

								tgbBlock.show();

								if ('.articles__item'.length) {
									$('.articles__item').each(function (index, article) {
										hideBanners($(article));
									});
								}
							}
						}
					});
				}
			};

			var _getUrlVars = function _getUrlVars() {
				var vars = [],
				    hash = void 0;
				var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
				for (var i = 0; i < hashes.length; i++) {
					hash = hashes[i].split('=');
					vars.push(hash[0]);
					vars[hash[0]] = hash[1];
				}
				return vars;
			};

			$(window).on('load', function () {
				var windowHeight = $(window).height();
				var windowScroll = $(window).scrollTop();
				var activeElement = $('.articles__item:first');
				// activeElement.css('margin-bottom', windowHeight);
				var activeOffset = activeElement.offset().top;
				var nextElement = activeElement.next();
				var art_number = activeElement.index();
				//     
				var art_num = $(".articles__item").length - 1;
				var nextId;
				var dataId;
				var addedNews;
				var tgbLength;
				// --------------------------------------------
				$('.articles__item').each(function (index, article) {
					hideBanners($(article));
				});

				activeElement.addClass('articles__item--active').removeClass('articles__item--next');
				nextElement.addClass('articles__item--next');

				var activeElementHeight = activeElement[0].clientHeight;

				$(window).on('scroll', function () {
					windowScroll = $(window).scrollTop();
					art_num = $(".articles__item").length - 1;
					art_number = activeElement.index();
					if (windowScroll >= activeOffset + activeElementHeight && art_number != art_num) {
						activeElement.removeClass('articles__item--active');
						activeElement.next().removeClass('articles__item--next').addClass('articles__item--active');

						activeElement = activeElement.next();
						activeElement.next().addClass('articles__item--next');
						// if (art_number + 1 != art_num) {
						//   activeElement.css('margin-bottom', windowHeight);
						// }

						// activeElement.removeClass('articles__item--next').addClass('articles__item--active');
						activeElementHeight = activeElement[0].clientHeight;
						activeOffset = activeElement.offset().top;

						nextElement = activeElement.next();

						// nextElement.addClass('articles__item--next');

						if (!_getUrlVars()['loadAllEquals'] && $(equalNewsIds).length && art_number + 2 == art_num) {

							nextId = equalNewsIds.shift();
							dataId = "id=" + nextId;
							$.ajax({
								type: "GET",
								dataType: 'html',
								url: '/ajax/getNextArticle.php',
								data: dataId,
								success: function success(response, textStatus, jqXHR) {
									$('.articles__wrap').append(response);
									tgbLength = $(".tgb-block").length;
									if (tgbLength > 0) {
										js_slider_showed = [];
										if (typeof slider_showed != "undefined") {
											js_slider_showed = slider_showed;
										}
										_initTgb(tgbLength - 1, js_slider_showed, []);
									}
									// hideBanners($('.articles__item:last'));              
								}
							});
						}
					} else if (windowScroll < activeOffset && art_number > 0) {

						nextElement.removeClass('articles__item--next');
						activeElement.removeClass('articles__item--active').addClass('articles__item--next');
						activeElement.prev().addClass('articles__item--active');

						nextElement = activeElement;
						// nextElement.addClass('articles__item--next');        
						activeElement = activeElement.prev();
						// activeElement.css('margin-bottom', windowHeight);
						// activeElement.removeClass('articles__item--next').addClass('articles__item--active');

						activeElementHeight = activeElement[0].clientHeight;
						activeOffset = activeElement.offset().top;
					}
				});
			});

			var goToNextArticle = function goToNextArticle() {
				var articleVisibleHeight = $('.articles__item--active').height() + $('.articles__item--active')[0].getBoundingClientRect().top;
				$(window).scrollTop($(window).scrollTop() + articleVisibleHeight);
			};

			$('.articles__wrap').on('click', '.js-next-article', goToNextArticle);
		}
	});
})(jQuery);